
/*
*
* THIS FILE IS GENERATED BY genswigi.py
*
* vulkanmitts SWIG interface description file
*
* Copyright (C) 2016 by VLAM3D Software inc. https://www.vlam3d.com
*
* This code is licensed under the MIT license (MIT) (http://opensource.org/licenses/MIT)
*/

/*
** Copyright (c) 2015-2016 The Khronos Group Inc.
**
** Permission is hereby granted, free of charge, to any person obtaining a
** copy of this software and/or associated documentation files (the
** "Materials"), to deal in the Materials without restriction, including
** without limitation the rights to use, copy, modify, merge, publish,
** distribute, sublicense, and/or sell copies of the Materials, and to
** permit persons to whom the Materials are furnished to do so, subject to
** the following conditions:
**
** The above copyright notice and this permission notice shall be included
** in all copies or substantial portions of the Materials.
**
** THE MATERIALS ARE PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
** MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
** TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
** MATERIALS OR THE USE OR OTHER DEALINGS IN THE MATERIALS.
*/

// Begin content generated by genswigi.py
const char* vkGetErrorString(VkResult retval);



#define VK_VERSION_1_0 1
#include "vk_platform.h"
#define VK_MAKE_VERSION(major, minor, patch) \
    (((major) << 22) | ((minor) << 12) | (patch))

// DEPRECATED: This define has been removed. Specific version defines (e.g. VK_API_VERSION_1_0), or the VK_MAKE_VERSION macro, should be used instead.
//#define VK_API_VERSION VK_MAKE_VERSION(1, 0, 0) // Patch version should always be set to 0

// Vulkan 1.0 version number
#define VK_API_VERSION_1_0 VK_MAKE_VERSION(1, 0, 0)// Patch version should always be set to 0

#define VK_VERSION_MAJOR(version) ((uint32_t)(version) >> 22)
#define VK_VERSION_MINOR(version) (((uint32_t)(version) >> 12) & 0x3ff)
#define VK_VERSION_PATCH(version) ((uint32_t)(version) & 0xfff)
// Version of this file
#define VK_HEADER_VERSION 121


#define VK_NULL_HANDLE 0


#define VK_DEFINE_HANDLE(object) typedef struct object##_T* object;


#if !defined(VK_DEFINE_NON_DISPATCHABLE_HANDLE)
#if defined(__LP64__) || defined(_WIN64) || (defined(__x86_64__) && !defined(__ILP32__) ) || defined(_M_X64) || defined(__ia64) || defined (_M_IA64) || defined(__aarch64__) || defined(__powerpc64__)
        #define VK_DEFINE_NON_DISPATCHABLE_HANDLE(object) typedef struct object##_T *object;
#else
        #define VK_DEFINE_NON_DISPATCHABLE_HANDLE(object) typedef uint64_t object;
#endif
#endif

typedef uint32_t VkFlags;
typedef uint32_t VkBool32;
typedef uint64_t VkDeviceSize;
typedef uint32_t VkSampleMask;
VK_DEFINE_HANDLE(VkInstance)
VK_DEFINE_HANDLE(VkPhysicalDevice)
VK_DEFINE_HANDLE(VkDevice)
VK_DEFINE_HANDLE(VkQueue)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkSemaphore)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkFence)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkDeviceMemory)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkBuffer)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkImage)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkEvent)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkQueryPool)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkBufferView)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkImageView)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkShaderModule)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkPipelineCache)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkPipelineLayout)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkRenderPass)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkPipeline)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkDescriptorSetLayout)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkSampler)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkDescriptorPool)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkFramebuffer)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkCommandPool)
#define VK_LOD_CLAMP_NONE                 1000.0f
#define VK_REMAINING_MIP_LEVELS           (~0U)
#define VK_REMAINING_ARRAY_LAYERS         (~0U)
#define VK_WHOLE_SIZE                     (~0ULL)
#define VK_ATTACHMENT_UNUSED              (~0U)
#define VK_TRUE                           1
#define VK_FALSE                          0
#define VK_QUEUE_FAMILY_IGNORED           (~0U)
#define VK_SUBPASS_EXTERNAL               (~0U)
#define VK_MAX_PHYSICAL_DEVICE_NAME_SIZE  256
#define VK_UUID_SIZE                      16
#define VK_MAX_MEMORY_TYPES               32
#define VK_MAX_MEMORY_HEAPS               16
#define VK_MAX_EXTENSION_NAME_SIZE        256
#define VK_MAX_DESCRIPTION_SIZE           256

typedef enum VkPipelineCacheHeaderVersion {
    VK_PIPELINE_CACHE_HEADER_VERSION_ONE = 1,
    VK_PIPELINE_CACHE_HEADER_VERSION_MAX_ENUM = 0x7FFFFFFF
} VkPipelineCacheHeaderVersion;

typedef enum VkResult {
    VK_SUCCESS = 0,
    VK_NOT_READY = 1,
    VK_TIMEOUT = 2,
    VK_EVENT_SET = 3,
    VK_EVENT_RESET = 4,
    VK_INCOMPLETE = 5,
    VK_ERROR_OUT_OF_HOST_MEMORY = -1,
    VK_ERROR_OUT_OF_DEVICE_MEMORY = -2,
    VK_ERROR_INITIALIZATION_FAILED = -3,
    VK_ERROR_DEVICE_LOST = -4,
    VK_ERROR_MEMORY_MAP_FAILED = -5,
    VK_ERROR_LAYER_NOT_PRESENT = -6,
    VK_ERROR_EXTENSION_NOT_PRESENT = -7,
    VK_ERROR_FEATURE_NOT_PRESENT = -8,
    VK_ERROR_INCOMPATIBLE_DRIVER = -9,
    VK_ERROR_TOO_MANY_OBJECTS = -10,
    VK_ERROR_FORMAT_NOT_SUPPORTED = -11,
    VK_ERROR_FRAGMENTED_POOL = -12,
    VK_ERROR_OUT_OF_POOL_MEMORY = -1000069000,
    VK_ERROR_INVALID_EXTERNAL_HANDLE = -1000072003,
    VK_ERROR_SURFACE_LOST_KHR = -1000000000,
    VK_ERROR_NATIVE_WINDOW_IN_USE_KHR = -1000000001,
    VK_SUBOPTIMAL_KHR = 1000001003,
    VK_ERROR_OUT_OF_DATE_KHR = -1000001004,
    VK_ERROR_INCOMPATIBLE_DISPLAY_KHR = -1000003001,
    VK_ERROR_VALIDATION_FAILED_EXT = -1000011001,
    VK_ERROR_INVALID_SHADER_NV = -1000012000,
    VK_ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT = -1000158000,
    VK_ERROR_FRAGMENTATION_EXT = -1000161000,
    VK_ERROR_NOT_PERMITTED_EXT = -1000174001,
    VK_ERROR_INVALID_DEVICE_ADDRESS_EXT = -1000244000,
    VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT = -1000255000,
    VK_ERROR_OUT_OF_POOL_MEMORY_KHR = VK_ERROR_OUT_OF_POOL_MEMORY,
    VK_ERROR_INVALID_EXTERNAL_HANDLE_KHR = VK_ERROR_INVALID_EXTERNAL_HANDLE,
    VK_RESULT_MAX_ENUM = 0x7FFFFFFF
} VkResult;

typedef enum VkStructureType {
    VK_STRUCTURE_TYPE_APPLICATION_INFO = 0,
    VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO = 1,
    VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO = 2,
    VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO = 3,
    VK_STRUCTURE_TYPE_SUBMIT_INFO = 4,
    VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO = 5,
    VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE = 6,
    VK_STRUCTURE_TYPE_BIND_SPARSE_INFO = 7,
    VK_STRUCTURE_TYPE_FENCE_CREATE_INFO = 8,
    VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO = 9,
    VK_STRUCTURE_TYPE_EVENT_CREATE_INFO = 10,
    VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO = 11,
    VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO = 12,
    VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO = 13,
    VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO = 14,
    VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO = 15,
    VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO = 16,
    VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO = 17,
    VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO = 18,
    VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO = 19,
    VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO = 20,
    VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO = 21,
    VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO = 22,
    VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO = 23,
    VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO = 24,
    VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO = 25,
    VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO = 26,
    VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO = 27,
    VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO = 28,
    VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO = 29,
    VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO = 30,
    VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO = 31,
    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO = 32,
    VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO = 33,
    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO = 34,
    VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET = 35,
    VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET = 36,
    VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO = 37,
    VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO = 38,
    VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO = 39,
    VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO = 40,
    VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO = 41,
    VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO = 42,
    VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO = 43,
    VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER = 44,
    VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER = 45,
    VK_STRUCTURE_TYPE_MEMORY_BARRIER = 46,
    VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO = 47,
    VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO = 48,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES = 1000094000,
    VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO = 1000157000,
    VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO = 1000157001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES = 1000083000,
    VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS = 1000127000,
    VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO = 1000127001,
    VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO = 1000060000,
    VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO = 1000060003,
    VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO = 1000060004,
    VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO = 1000060005,
    VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO = 1000060006,
    VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO = 1000060013,
    VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO = 1000060014,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES = 1000070000,
    VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO = 1000070001,
    VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2 = 1000146000,
    VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2 = 1000146001,
    VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2 = 1000146002,
    VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2 = 1000146003,
    VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2 = 1000146004,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2 = 1000059000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2 = 1000059001,
    VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2 = 1000059002,
    VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2 = 1000059003,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2 = 1000059004,
    VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2 = 1000059005,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2 = 1000059006,
    VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2 = 1000059007,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2 = 1000059008,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES = 1000117000,
    VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO = 1000117001,
    VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO = 1000117002,
    VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO = 1000117003,
    VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO = 1000053000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES = 1000053001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES = 1000053002,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES = 1000120000,
    VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO = 1000145000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES = 1000145001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES = 1000145002,
    VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2 = 1000145003,
    VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO = 1000156000,
    VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO = 1000156001,
    VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO = 1000156002,
    VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO = 1000156003,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES = 1000156004,
    VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES = 1000156005,
    VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO = 1000085000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO = 1000071000,
    VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES = 1000071001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO = 1000071002,
    VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES = 1000071003,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES = 1000071004,
    VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO = 1000072000,
    VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO = 1000072001,
    VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO = 1000072002,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO = 1000112000,
    VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES = 1000112001,
    VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO = 1000113000,
    VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO = 1000077000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO = 1000076000,
    VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES = 1000076001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES = 1000168000,
    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT = 1000168001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES = 1000063000,
    VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR = 1000001000,
    VK_STRUCTURE_TYPE_PRESENT_INFO_KHR = 1000001001,
    VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR = 1000060007,
    VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR = 1000060008,
    VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR = 1000060009,
    VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR = 1000060010,
    VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR = 1000060011,
    VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR = 1000060012,
    VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR = 1000002000,
    VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR = 1000002001,
    VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR = 1000003000,
    VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR = 1000004000,
    VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR = 1000005000,
    VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR = 1000006000,
    VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR = 1000008000,
    VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR = 1000009000,
    VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT = 1000011000,
    VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD = 1000018000,
    VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT = 1000022000,
    VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT = 1000022001,
    VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT = 1000022002,
    VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV = 1000026000,
    VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV = 1000026001,
    VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV = 1000026002,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT = 1000028000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT = 1000028001,
    VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT = 1000028002,
    VK_STRUCTURE_TYPE_IMAGE_VIEW_HANDLE_INFO_NVX = 1000030000,
    VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD = 1000041000,
    VK_STRUCTURE_TYPE_STREAM_DESCRIPTOR_SURFACE_CREATE_INFO_GGP = 1000049000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV = 1000050000,
    VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV = 1000056000,
    VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV = 1000056001,
    VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV = 1000057000,
    VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV = 1000057001,
    VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV = 1000058000,
    VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT = 1000061000,
    VK_STRUCTURE_TYPE_VI_SURFACE_CREATE_INFO_NN = 1000062000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES_EXT = 1000066000,
    VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT = 1000067000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT = 1000067001,
    VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR = 1000073000,
    VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR = 1000073001,
    VK_STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR = 1000073002,
    VK_STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR = 1000073003,
    VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR = 1000074000,
    VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR = 1000074001,
    VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR = 1000074002,
    VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR = 1000075000,
    VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR = 1000078000,
    VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR = 1000078001,
    VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR = 1000078002,
    VK_STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR = 1000078003,
    VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR = 1000079000,
    VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR = 1000079001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR = 1000080000,
    VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT = 1000081000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT = 1000081001,
    VK_STRUCTURE_TYPE_CONDITIONAL_RENDERING_BEGIN_INFO_EXT = 1000081002,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES_KHR = 1000082000,
    VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR = 1000084000,
    VK_STRUCTURE_TYPE_OBJECT_TABLE_CREATE_INFO_NVX = 1000086000,
    VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NVX = 1000086001,
    VK_STRUCTURE_TYPE_CMD_PROCESS_COMMANDS_INFO_NVX = 1000086002,
    VK_STRUCTURE_TYPE_CMD_RESERVE_SPACE_FOR_COMMANDS_INFO_NVX = 1000086003,
    VK_STRUCTURE_TYPE_DEVICE_GENERATED_COMMANDS_LIMITS_NVX = 1000086004,
    VK_STRUCTURE_TYPE_DEVICE_GENERATED_COMMANDS_FEATURES_NVX = 1000086005,
    VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV = 1000087000,
    VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT = 1000090000,
    VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT = 1000091000,
    VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT = 1000091001,
    VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT = 1000091002,
    VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT = 1000091003,
    VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE = 1000092000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX = 1000097000,
    VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV = 1000098000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT = 1000099000,
    VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT = 1000099001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT = 1000101000,
    VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT = 1000101001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT = 1000102000,
    VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT = 1000102001,
    VK_STRUCTURE_TYPE_HDR_METADATA_EXT = 1000105000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES_KHR = 1000108000,
    VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO_KHR = 1000108001,
    VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO_KHR = 1000108002,
    VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO_KHR = 1000108003,
    VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2_KHR = 1000109000,
    VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2_KHR = 1000109001,
    VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2_KHR = 1000109002,
    VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2_KHR = 1000109003,
    VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2_KHR = 1000109004,
    VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO_KHR = 1000109005,
    VK_STRUCTURE_TYPE_SUBPASS_END_INFO_KHR = 1000109006,
    VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR = 1000111000,
    VK_STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR = 1000114000,
    VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR = 1000114001,
    VK_STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR = 1000114002,
    VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR = 1000115000,
    VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR = 1000115001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR = 1000119000,
    VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR = 1000119001,
    VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR = 1000119002,
    VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR = 1000121000,
    VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR = 1000121001,
    VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR = 1000121002,
    VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR = 1000121003,
    VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR = 1000121004,
    VK_STRUCTURE_TYPE_IOS_SURFACE_CREATE_INFO_MVK = 1000122000,
    VK_STRUCTURE_TYPE_MACOS_SURFACE_CREATE_INFO_MVK = 1000123000,
    VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT = 1000128000,
    VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT = 1000128001,
    VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT = 1000128002,
    VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT = 1000128003,
    VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT = 1000128004,
    VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID = 1000129000,
    VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID = 1000129001,
    VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID = 1000129002,
    VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID = 1000129003,
    VK_STRUCTURE_TYPE_MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID = 1000129004,
    VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID = 1000129005,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES_EXT = 1000130000,
    VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT = 1000130001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES_EXT = 1000138000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES_EXT = 1000138001,
    VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK_EXT = 1000138002,
    VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO_EXT = 1000138003,
    VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT = 1000143000,
    VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT = 1000143001,
    VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT = 1000143002,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT = 1000143003,
    VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT = 1000143004,
    VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO_KHR = 1000147000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT = 1000148000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT = 1000148001,
    VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT = 1000148002,
    VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV = 1000149000,
    VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV = 1000152000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV = 1000154000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV = 1000154001,
    VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT = 1000158000,
    VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT = 1000158001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT = 1000158002,
    VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT = 1000158003,
    VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT = 1000158004,
    VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT = 1000158005,
    VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT = 1000160000,
    VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT = 1000160001,
    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO_EXT = 1000161000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES_EXT = 1000161001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES_EXT = 1000161002,
    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO_EXT = 1000161003,
    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT_EXT = 1000161004,
    VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV = 1000164000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV = 1000164001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV = 1000164002,
    VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV = 1000164005,
    VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_NV = 1000165000,
    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_NV = 1000165001,
    VK_STRUCTURE_TYPE_GEOMETRY_NV = 1000165003,
    VK_STRUCTURE_TYPE_GEOMETRY_TRIANGLES_NV = 1000165004,
    VK_STRUCTURE_TYPE_GEOMETRY_AABB_NV = 1000165005,
    VK_STRUCTURE_TYPE_BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV = 1000165006,
    VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV = 1000165007,
    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV = 1000165008,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV = 1000165009,
    VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV = 1000165011,
    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_INFO_NV = 1000165012,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV = 1000166000,
    VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV = 1000166001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT = 1000170000,
    VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT = 1000170001,
    VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT = 1000174000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES_KHR = 1000177000,
    VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT = 1000178000,
    VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT = 1000178001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT = 1000178002,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES_KHR = 1000180000,
    VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD = 1000183000,
    VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_EXT = 1000184000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD = 1000185000,
    VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD = 1000189000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT = 1000190000,
    VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT = 1000190001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT = 1000190002,
    VK_STRUCTURE_TYPE_PRESENT_FRAME_TOKEN_GGP = 1000191000,
    VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO_EXT = 1000192000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES_KHR = 1000196000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES_KHR = 1000197000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES_KHR = 1000199000,
    VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE_KHR = 1000199001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV = 1000201000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV = 1000202000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV = 1000202001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_NV = 1000203000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV = 1000204000,
    VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV = 1000205000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV = 1000205002,
    VK_STRUCTURE_TYPE_CHECKPOINT_DATA_NV = 1000206000,
    VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV = 1000206001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL = 1000209000,
    VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO_INTEL = 1000210000,
    VK_STRUCTURE_TYPE_INITIALIZE_PERFORMANCE_API_INFO_INTEL = 1000210001,
    VK_STRUCTURE_TYPE_PERFORMANCE_MARKER_INFO_INTEL = 1000210002,
    VK_STRUCTURE_TYPE_PERFORMANCE_STREAM_MARKER_INFO_INTEL = 1000210003,
    VK_STRUCTURE_TYPE_PERFORMANCE_OVERRIDE_INFO_INTEL = 1000210004,
    VK_STRUCTURE_TYPE_PERFORMANCE_CONFIGURATION_ACQUIRE_INFO_INTEL = 1000210005,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES_KHR = 1000211000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT = 1000212000,
    VK_STRUCTURE_TYPE_DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD = 1000213000,
    VK_STRUCTURE_TYPE_SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD = 1000213001,
    VK_STRUCTURE_TYPE_IMAGEPIPE_SURFACE_CREATE_INFO_FUCHSIA = 1000214000,
    VK_STRUCTURE_TYPE_METAL_SURFACE_CREATE_INFO_EXT = 1000217000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT = 1000218000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT = 1000218001,
    VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT = 1000218002,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES_EXT = 1000221000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES_EXT = 1000225000,
    VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO_EXT = 1000225001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES_EXT = 1000225002,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD = 1000227000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD = 1000229000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT = 1000237000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT = 1000238000,
    VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT = 1000238001,
    VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR = 1000239000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV = 1000240000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT = 1000244000,
    VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO_EXT = 1000244001,
    VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT = 1000244002,
    VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO_EXT = 1000246000,
    VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT = 1000247000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV = 1000249000,
    VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_NV = 1000249001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV = 1000249002,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV = 1000250000,
    VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV = 1000250001,
    VK_STRUCTURE_TYPE_FRAMEBUFFER_MIXED_SAMPLES_COMBINATION_NV = 1000250002,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT = 1000251000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT = 1000252000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES_KHR = 1000253000,
    VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT = 1000255000,
    VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT = 1000255002,
    VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT = 1000255001,
    VK_STRUCTURE_TYPE_HEADLESS_SURFACE_CREATE_INFO_EXT = 1000256000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT = 1000259000,
    VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_EXT = 1000259001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT = 1000259002,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES_EXT = 1000261000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT = 1000265000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR = 1000269000,
    VK_STRUCTURE_TYPE_PIPELINE_INFO_KHR = 1000269001,
    VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_PROPERTIES_KHR = 1000269002,
    VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INFO_KHR = 1000269003,
    VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_STATISTIC_KHR = 1000269004,
    VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INTERNAL_REPRESENTATION_KHR = 1000269005,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES_EXT = 1000276000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT = 1000281000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES_EXT = 1000281001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETER_FEATURES = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES,
    VK_STRUCTURE_TYPE_DEBUG_REPORT_CREATE_INFO_EXT = VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT,
    VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
    VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2_KHR = VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2,
    VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2_KHR = VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2,
    VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2_KHR = VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2,
    VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2_KHR = VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2,
    VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO_KHR = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO,
    VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO_KHR = VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO,
    VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO_KHR = VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO,
    VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO_KHR = VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO,
    VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO_KHR = VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO,
    VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO_KHR = VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO,
    VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO_KHR = VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES,
    VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO,
    VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES_KHR = VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO,
    VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES_KHR = VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES,
    VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO,
    VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO,
    VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_KHR = VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO,
    VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES_KHR = VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES,
    VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT16_INT8_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES_KHR,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES,
    VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO,
    VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES2_EXT = VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO,
    VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES_KHR = VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES,
    VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES,
    VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO,
    VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO,
    VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES,
    VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS_KHR = VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS,
    VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO_KHR = VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO,
    VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2_KHR = VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2,
    VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2_KHR = VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2,
    VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2_KHR = VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2,
    VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2_KHR = VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2,
    VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2_KHR = VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2,
    VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO,
    VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO_KHR = VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO,
    VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO_KHR = VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO,
    VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO_KHR = VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES,
    VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES_KHR = VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES,
    VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO_KHR = VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO,
    VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO_KHR = VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES,
    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT_KHR = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_ADDRESS_FEATURES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT,
    VK_STRUCTURE_TYPE_MAX_ENUM = 0x7FFFFFFF
} VkStructureType;

typedef enum VkSystemAllocationScope {
    VK_SYSTEM_ALLOCATION_SCOPE_COMMAND = 0,
    VK_SYSTEM_ALLOCATION_SCOPE_OBJECT = 1,
    VK_SYSTEM_ALLOCATION_SCOPE_CACHE = 2,
    VK_SYSTEM_ALLOCATION_SCOPE_DEVICE = 3,
    VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE = 4,
    VK_SYSTEM_ALLOCATION_SCOPE_MAX_ENUM = 0x7FFFFFFF
} VkSystemAllocationScope;

typedef enum VkInternalAllocationType {
    VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE = 0,
    VK_INTERNAL_ALLOCATION_TYPE_MAX_ENUM = 0x7FFFFFFF
} VkInternalAllocationType;

typedef enum VkFormat {
    VK_FORMAT_UNDEFINED = 0,
    VK_FORMAT_R4G4_UNORM_PACK8 = 1,
    VK_FORMAT_R4G4B4A4_UNORM_PACK16 = 2,
    VK_FORMAT_B4G4R4A4_UNORM_PACK16 = 3,
    VK_FORMAT_R5G6B5_UNORM_PACK16 = 4,
    VK_FORMAT_B5G6R5_UNORM_PACK16 = 5,
    VK_FORMAT_R5G5B5A1_UNORM_PACK16 = 6,
    VK_FORMAT_B5G5R5A1_UNORM_PACK16 = 7,
    VK_FORMAT_A1R5G5B5_UNORM_PACK16 = 8,
    VK_FORMAT_R8_UNORM = 9,
    VK_FORMAT_R8_SNORM = 10,
    VK_FORMAT_R8_USCALED = 11,
    VK_FORMAT_R8_SSCALED = 12,
    VK_FORMAT_R8_UINT = 13,
    VK_FORMAT_R8_SINT = 14,
    VK_FORMAT_R8_SRGB = 15,
    VK_FORMAT_R8G8_UNORM = 16,
    VK_FORMAT_R8G8_SNORM = 17,
    VK_FORMAT_R8G8_USCALED = 18,
    VK_FORMAT_R8G8_SSCALED = 19,
    VK_FORMAT_R8G8_UINT = 20,
    VK_FORMAT_R8G8_SINT = 21,
    VK_FORMAT_R8G8_SRGB = 22,
    VK_FORMAT_R8G8B8_UNORM = 23,
    VK_FORMAT_R8G8B8_SNORM = 24,
    VK_FORMAT_R8G8B8_USCALED = 25,
    VK_FORMAT_R8G8B8_SSCALED = 26,
    VK_FORMAT_R8G8B8_UINT = 27,
    VK_FORMAT_R8G8B8_SINT = 28,
    VK_FORMAT_R8G8B8_SRGB = 29,
    VK_FORMAT_B8G8R8_UNORM = 30,
    VK_FORMAT_B8G8R8_SNORM = 31,
    VK_FORMAT_B8G8R8_USCALED = 32,
    VK_FORMAT_B8G8R8_SSCALED = 33,
    VK_FORMAT_B8G8R8_UINT = 34,
    VK_FORMAT_B8G8R8_SINT = 35,
    VK_FORMAT_B8G8R8_SRGB = 36,
    VK_FORMAT_R8G8B8A8_UNORM = 37,
    VK_FORMAT_R8G8B8A8_SNORM = 38,
    VK_FORMAT_R8G8B8A8_USCALED = 39,
    VK_FORMAT_R8G8B8A8_SSCALED = 40,
    VK_FORMAT_R8G8B8A8_UINT = 41,
    VK_FORMAT_R8G8B8A8_SINT = 42,
    VK_FORMAT_R8G8B8A8_SRGB = 43,
    VK_FORMAT_B8G8R8A8_UNORM = 44,
    VK_FORMAT_B8G8R8A8_SNORM = 45,
    VK_FORMAT_B8G8R8A8_USCALED = 46,
    VK_FORMAT_B8G8R8A8_SSCALED = 47,
    VK_FORMAT_B8G8R8A8_UINT = 48,
    VK_FORMAT_B8G8R8A8_SINT = 49,
    VK_FORMAT_B8G8R8A8_SRGB = 50,
    VK_FORMAT_A8B8G8R8_UNORM_PACK32 = 51,
    VK_FORMAT_A8B8G8R8_SNORM_PACK32 = 52,
    VK_FORMAT_A8B8G8R8_USCALED_PACK32 = 53,
    VK_FORMAT_A8B8G8R8_SSCALED_PACK32 = 54,
    VK_FORMAT_A8B8G8R8_UINT_PACK32 = 55,
    VK_FORMAT_A8B8G8R8_SINT_PACK32 = 56,
    VK_FORMAT_A8B8G8R8_SRGB_PACK32 = 57,
    VK_FORMAT_A2R10G10B10_UNORM_PACK32 = 58,
    VK_FORMAT_A2R10G10B10_SNORM_PACK32 = 59,
    VK_FORMAT_A2R10G10B10_USCALED_PACK32 = 60,
    VK_FORMAT_A2R10G10B10_SSCALED_PACK32 = 61,
    VK_FORMAT_A2R10G10B10_UINT_PACK32 = 62,
    VK_FORMAT_A2R10G10B10_SINT_PACK32 = 63,
    VK_FORMAT_A2B10G10R10_UNORM_PACK32 = 64,
    VK_FORMAT_A2B10G10R10_SNORM_PACK32 = 65,
    VK_FORMAT_A2B10G10R10_USCALED_PACK32 = 66,
    VK_FORMAT_A2B10G10R10_SSCALED_PACK32 = 67,
    VK_FORMAT_A2B10G10R10_UINT_PACK32 = 68,
    VK_FORMAT_A2B10G10R10_SINT_PACK32 = 69,
    VK_FORMAT_R16_UNORM = 70,
    VK_FORMAT_R16_SNORM = 71,
    VK_FORMAT_R16_USCALED = 72,
    VK_FORMAT_R16_SSCALED = 73,
    VK_FORMAT_R16_UINT = 74,
    VK_FORMAT_R16_SINT = 75,
    VK_FORMAT_R16_SFLOAT = 76,
    VK_FORMAT_R16G16_UNORM = 77,
    VK_FORMAT_R16G16_SNORM = 78,
    VK_FORMAT_R16G16_USCALED = 79,
    VK_FORMAT_R16G16_SSCALED = 80,
    VK_FORMAT_R16G16_UINT = 81,
    VK_FORMAT_R16G16_SINT = 82,
    VK_FORMAT_R16G16_SFLOAT = 83,
    VK_FORMAT_R16G16B16_UNORM = 84,
    VK_FORMAT_R16G16B16_SNORM = 85,
    VK_FORMAT_R16G16B16_USCALED = 86,
    VK_FORMAT_R16G16B16_SSCALED = 87,
    VK_FORMAT_R16G16B16_UINT = 88,
    VK_FORMAT_R16G16B16_SINT = 89,
    VK_FORMAT_R16G16B16_SFLOAT = 90,
    VK_FORMAT_R16G16B16A16_UNORM = 91,
    VK_FORMAT_R16G16B16A16_SNORM = 92,
    VK_FORMAT_R16G16B16A16_USCALED = 93,
    VK_FORMAT_R16G16B16A16_SSCALED = 94,
    VK_FORMAT_R16G16B16A16_UINT = 95,
    VK_FORMAT_R16G16B16A16_SINT = 96,
    VK_FORMAT_R16G16B16A16_SFLOAT = 97,
    VK_FORMAT_R32_UINT = 98,
    VK_FORMAT_R32_SINT = 99,
    VK_FORMAT_R32_SFLOAT = 100,
    VK_FORMAT_R32G32_UINT = 101,
    VK_FORMAT_R32G32_SINT = 102,
    VK_FORMAT_R32G32_SFLOAT = 103,
    VK_FORMAT_R32G32B32_UINT = 104,
    VK_FORMAT_R32G32B32_SINT = 105,
    VK_FORMAT_R32G32B32_SFLOAT = 106,
    VK_FORMAT_R32G32B32A32_UINT = 107,
    VK_FORMAT_R32G32B32A32_SINT = 108,
    VK_FORMAT_R32G32B32A32_SFLOAT = 109,
    VK_FORMAT_R64_UINT = 110,
    VK_FORMAT_R64_SINT = 111,
    VK_FORMAT_R64_SFLOAT = 112,
    VK_FORMAT_R64G64_UINT = 113,
    VK_FORMAT_R64G64_SINT = 114,
    VK_FORMAT_R64G64_SFLOAT = 115,
    VK_FORMAT_R64G64B64_UINT = 116,
    VK_FORMAT_R64G64B64_SINT = 117,
    VK_FORMAT_R64G64B64_SFLOAT = 118,
    VK_FORMAT_R64G64B64A64_UINT = 119,
    VK_FORMAT_R64G64B64A64_SINT = 120,
    VK_FORMAT_R64G64B64A64_SFLOAT = 121,
    VK_FORMAT_B10G11R11_UFLOAT_PACK32 = 122,
    VK_FORMAT_E5B9G9R9_UFLOAT_PACK32 = 123,
    VK_FORMAT_D16_UNORM = 124,
    VK_FORMAT_X8_D24_UNORM_PACK32 = 125,
    VK_FORMAT_D32_SFLOAT = 126,
    VK_FORMAT_S8_UINT = 127,
    VK_FORMAT_D16_UNORM_S8_UINT = 128,
    VK_FORMAT_D24_UNORM_S8_UINT = 129,
    VK_FORMAT_D32_SFLOAT_S8_UINT = 130,
    VK_FORMAT_BC1_RGB_UNORM_BLOCK = 131,
    VK_FORMAT_BC1_RGB_SRGB_BLOCK = 132,
    VK_FORMAT_BC1_RGBA_UNORM_BLOCK = 133,
    VK_FORMAT_BC1_RGBA_SRGB_BLOCK = 134,
    VK_FORMAT_BC2_UNORM_BLOCK = 135,
    VK_FORMAT_BC2_SRGB_BLOCK = 136,
    VK_FORMAT_BC3_UNORM_BLOCK = 137,
    VK_FORMAT_BC3_SRGB_BLOCK = 138,
    VK_FORMAT_BC4_UNORM_BLOCK = 139,
    VK_FORMAT_BC4_SNORM_BLOCK = 140,
    VK_FORMAT_BC5_UNORM_BLOCK = 141,
    VK_FORMAT_BC5_SNORM_BLOCK = 142,
    VK_FORMAT_BC6H_UFLOAT_BLOCK = 143,
    VK_FORMAT_BC6H_SFLOAT_BLOCK = 144,
    VK_FORMAT_BC7_UNORM_BLOCK = 145,
    VK_FORMAT_BC7_SRGB_BLOCK = 146,
    VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK = 147,
    VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK = 148,
    VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK = 149,
    VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK = 150,
    VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK = 151,
    VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK = 152,
    VK_FORMAT_EAC_R11_UNORM_BLOCK = 153,
    VK_FORMAT_EAC_R11_SNORM_BLOCK = 154,
    VK_FORMAT_EAC_R11G11_UNORM_BLOCK = 155,
    VK_FORMAT_EAC_R11G11_SNORM_BLOCK = 156,
    VK_FORMAT_ASTC_4x4_UNORM_BLOCK = 157,
    VK_FORMAT_ASTC_4x4_SRGB_BLOCK = 158,
    VK_FORMAT_ASTC_5x4_UNORM_BLOCK = 159,
    VK_FORMAT_ASTC_5x4_SRGB_BLOCK = 160,
    VK_FORMAT_ASTC_5x5_UNORM_BLOCK = 161,
    VK_FORMAT_ASTC_5x5_SRGB_BLOCK = 162,
    VK_FORMAT_ASTC_6x5_UNORM_BLOCK = 163,
    VK_FORMAT_ASTC_6x5_SRGB_BLOCK = 164,
    VK_FORMAT_ASTC_6x6_UNORM_BLOCK = 165,
    VK_FORMAT_ASTC_6x6_SRGB_BLOCK = 166,
    VK_FORMAT_ASTC_8x5_UNORM_BLOCK = 167,
    VK_FORMAT_ASTC_8x5_SRGB_BLOCK = 168,
    VK_FORMAT_ASTC_8x6_UNORM_BLOCK = 169,
    VK_FORMAT_ASTC_8x6_SRGB_BLOCK = 170,
    VK_FORMAT_ASTC_8x8_UNORM_BLOCK = 171,
    VK_FORMAT_ASTC_8x8_SRGB_BLOCK = 172,
    VK_FORMAT_ASTC_10x5_UNORM_BLOCK = 173,
    VK_FORMAT_ASTC_10x5_SRGB_BLOCK = 174,
    VK_FORMAT_ASTC_10x6_UNORM_BLOCK = 175,
    VK_FORMAT_ASTC_10x6_SRGB_BLOCK = 176,
    VK_FORMAT_ASTC_10x8_UNORM_BLOCK = 177,
    VK_FORMAT_ASTC_10x8_SRGB_BLOCK = 178,
    VK_FORMAT_ASTC_10x10_UNORM_BLOCK = 179,
    VK_FORMAT_ASTC_10x10_SRGB_BLOCK = 180,
    VK_FORMAT_ASTC_12x10_UNORM_BLOCK = 181,
    VK_FORMAT_ASTC_12x10_SRGB_BLOCK = 182,
    VK_FORMAT_ASTC_12x12_UNORM_BLOCK = 183,
    VK_FORMAT_ASTC_12x12_SRGB_BLOCK = 184,
    VK_FORMAT_G8B8G8R8_422_UNORM = 1000156000,
    VK_FORMAT_B8G8R8G8_422_UNORM = 1000156001,
    VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM = 1000156002,
    VK_FORMAT_G8_B8R8_2PLANE_420_UNORM = 1000156003,
    VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM = 1000156004,
    VK_FORMAT_G8_B8R8_2PLANE_422_UNORM = 1000156005,
    VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM = 1000156006,
    VK_FORMAT_R10X6_UNORM_PACK16 = 1000156007,
    VK_FORMAT_R10X6G10X6_UNORM_2PACK16 = 1000156008,
    VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16 = 1000156009,
    VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16 = 1000156010,
    VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16 = 1000156011,
    VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16 = 1000156012,
    VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16 = 1000156013,
    VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16 = 1000156014,
    VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16 = 1000156015,
    VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16 = 1000156016,
    VK_FORMAT_R12X4_UNORM_PACK16 = 1000156017,
    VK_FORMAT_R12X4G12X4_UNORM_2PACK16 = 1000156018,
    VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16 = 1000156019,
    VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16 = 1000156020,
    VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16 = 1000156021,
    VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16 = 1000156022,
    VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16 = 1000156023,
    VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16 = 1000156024,
    VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16 = 1000156025,
    VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16 = 1000156026,
    VK_FORMAT_G16B16G16R16_422_UNORM = 1000156027,
    VK_FORMAT_B16G16R16G16_422_UNORM = 1000156028,
    VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM = 1000156029,
    VK_FORMAT_G16_B16R16_2PLANE_420_UNORM = 1000156030,
    VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM = 1000156031,
    VK_FORMAT_G16_B16R16_2PLANE_422_UNORM = 1000156032,
    VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM = 1000156033,
    VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG = 1000054000,
    VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG = 1000054001,
    VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG = 1000054002,
    VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG = 1000054003,
    VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG = 1000054004,
    VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG = 1000054005,
    VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG = 1000054006,
    VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG = 1000054007,
    VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK_EXT = 1000066000,
    VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK_EXT = 1000066001,
    VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK_EXT = 1000066002,
    VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK_EXT = 1000066003,
    VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK_EXT = 1000066004,
    VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK_EXT = 1000066005,
    VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK_EXT = 1000066006,
    VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK_EXT = 1000066007,
    VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK_EXT = 1000066008,
    VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK_EXT = 1000066009,
    VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK_EXT = 1000066010,
    VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK_EXT = 1000066011,
    VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK_EXT = 1000066012,
    VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK_EXT = 1000066013,
    VK_FORMAT_G8B8G8R8_422_UNORM_KHR = VK_FORMAT_G8B8G8R8_422_UNORM,
    VK_FORMAT_B8G8R8G8_422_UNORM_KHR = VK_FORMAT_B8G8R8G8_422_UNORM,
    VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM_KHR = VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM,
    VK_FORMAT_G8_B8R8_2PLANE_420_UNORM_KHR = VK_FORMAT_G8_B8R8_2PLANE_420_UNORM,
    VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM_KHR = VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM,
    VK_FORMAT_G8_B8R8_2PLANE_422_UNORM_KHR = VK_FORMAT_G8_B8R8_2PLANE_422_UNORM,
    VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM_KHR = VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM,
    VK_FORMAT_R10X6_UNORM_PACK16_KHR = VK_FORMAT_R10X6_UNORM_PACK16,
    VK_FORMAT_R10X6G10X6_UNORM_2PACK16_KHR = VK_FORMAT_R10X6G10X6_UNORM_2PACK16,
    VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16_KHR = VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16,
    VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16_KHR = VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16,
    VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16_KHR = VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16,
    VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16_KHR = VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16,
    VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16_KHR = VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16,
    VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16_KHR = VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16,
    VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16_KHR = VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16,
    VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16_KHR = VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16,
    VK_FORMAT_R12X4_UNORM_PACK16_KHR = VK_FORMAT_R12X4_UNORM_PACK16,
    VK_FORMAT_R12X4G12X4_UNORM_2PACK16_KHR = VK_FORMAT_R12X4G12X4_UNORM_2PACK16,
    VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16_KHR = VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16,
    VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16_KHR = VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16,
    VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16_KHR = VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16,
    VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16_KHR = VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16,
    VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16_KHR = VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16,
    VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16_KHR = VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16,
    VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16_KHR = VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16,
    VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16_KHR = VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16,
    VK_FORMAT_G16B16G16R16_422_UNORM_KHR = VK_FORMAT_G16B16G16R16_422_UNORM,
    VK_FORMAT_B16G16R16G16_422_UNORM_KHR = VK_FORMAT_B16G16R16G16_422_UNORM,
    VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM_KHR = VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM,
    VK_FORMAT_G16_B16R16_2PLANE_420_UNORM_KHR = VK_FORMAT_G16_B16R16_2PLANE_420_UNORM,
    VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM_KHR = VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM,
    VK_FORMAT_G16_B16R16_2PLANE_422_UNORM_KHR = VK_FORMAT_G16_B16R16_2PLANE_422_UNORM,
    VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM_KHR = VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM,
    VK_FORMAT_MAX_ENUM = 0x7FFFFFFF
} VkFormat;

typedef enum VkImageType {
    VK_IMAGE_TYPE_1D = 0,
    VK_IMAGE_TYPE_2D = 1,
    VK_IMAGE_TYPE_3D = 2,
    VK_IMAGE_TYPE_MAX_ENUM = 0x7FFFFFFF
} VkImageType;

typedef enum VkImageTiling {
    VK_IMAGE_TILING_OPTIMAL = 0,
    VK_IMAGE_TILING_LINEAR = 1,
    VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT = 1000158000,
    VK_IMAGE_TILING_MAX_ENUM = 0x7FFFFFFF
} VkImageTiling;

typedef enum VkPhysicalDeviceType {
    VK_PHYSICAL_DEVICE_TYPE_OTHER = 0,
    VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU = 1,
    VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU = 2,
    VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU = 3,
    VK_PHYSICAL_DEVICE_TYPE_CPU = 4,
    VK_PHYSICAL_DEVICE_TYPE_MAX_ENUM = 0x7FFFFFFF
} VkPhysicalDeviceType;

typedef enum VkQueryType {
    VK_QUERY_TYPE_OCCLUSION = 0,
    VK_QUERY_TYPE_PIPELINE_STATISTICS = 1,
    VK_QUERY_TYPE_TIMESTAMP = 2,
    VK_QUERY_TYPE_TRANSFORM_FEEDBACK_STREAM_EXT = 1000028004,
    VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_NV = 1000165000,
    VK_QUERY_TYPE_PERFORMANCE_QUERY_INTEL = 1000210000,
    VK_QUERY_TYPE_MAX_ENUM = 0x7FFFFFFF
} VkQueryType;

typedef enum VkSharingMode {
    VK_SHARING_MODE_EXCLUSIVE = 0,
    VK_SHARING_MODE_CONCURRENT = 1,
    VK_SHARING_MODE_MAX_ENUM = 0x7FFFFFFF
} VkSharingMode;

typedef enum VkImageLayout {
    VK_IMAGE_LAYOUT_UNDEFINED = 0,
    VK_IMAGE_LAYOUT_GENERAL = 1,
    VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL = 2,
    VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL = 3,
    VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL = 4,
    VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL = 5,
    VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL = 6,
    VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL = 7,
    VK_IMAGE_LAYOUT_PREINITIALIZED = 8,
    VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL = 1000117000,
    VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL = 1000117001,
    VK_IMAGE_LAYOUT_PRESENT_SRC_KHR = 1000001002,
    VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR = 1000111000,
    VK_IMAGE_LAYOUT_SHADING_RATE_OPTIMAL_NV = 1000164003,
    VK_IMAGE_LAYOUT_FRAGMENT_DENSITY_MAP_OPTIMAL_EXT = 1000218000,
    VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL_KHR = VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL,
    VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL_KHR = VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL,
    VK_IMAGE_LAYOUT_MAX_ENUM = 0x7FFFFFFF
} VkImageLayout;

typedef enum VkImageViewType {
    VK_IMAGE_VIEW_TYPE_1D = 0,
    VK_IMAGE_VIEW_TYPE_2D = 1,
    VK_IMAGE_VIEW_TYPE_3D = 2,
    VK_IMAGE_VIEW_TYPE_CUBE = 3,
    VK_IMAGE_VIEW_TYPE_1D_ARRAY = 4,
    VK_IMAGE_VIEW_TYPE_2D_ARRAY = 5,
    VK_IMAGE_VIEW_TYPE_CUBE_ARRAY = 6,
    VK_IMAGE_VIEW_TYPE_MAX_ENUM = 0x7FFFFFFF
} VkImageViewType;

typedef enum VkComponentSwizzle {
    VK_COMPONENT_SWIZZLE_IDENTITY = 0,
    VK_COMPONENT_SWIZZLE_ZERO = 1,
    VK_COMPONENT_SWIZZLE_ONE = 2,
    VK_COMPONENT_SWIZZLE_R = 3,
    VK_COMPONENT_SWIZZLE_G = 4,
    VK_COMPONENT_SWIZZLE_B = 5,
    VK_COMPONENT_SWIZZLE_A = 6,
    VK_COMPONENT_SWIZZLE_MAX_ENUM = 0x7FFFFFFF
} VkComponentSwizzle;

typedef enum VkVertexInputRate {
    VK_VERTEX_INPUT_RATE_VERTEX = 0,
    VK_VERTEX_INPUT_RATE_INSTANCE = 1,
    VK_VERTEX_INPUT_RATE_MAX_ENUM = 0x7FFFFFFF
} VkVertexInputRate;

typedef enum VkPrimitiveTopology {
    VK_PRIMITIVE_TOPOLOGY_POINT_LIST = 0,
    VK_PRIMITIVE_TOPOLOGY_LINE_LIST = 1,
    VK_PRIMITIVE_TOPOLOGY_LINE_STRIP = 2,
    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST = 3,
    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP = 4,
    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN = 5,
    VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY = 6,
    VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY = 7,
    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY = 8,
    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY = 9,
    VK_PRIMITIVE_TOPOLOGY_PATCH_LIST = 10,
    VK_PRIMITIVE_TOPOLOGY_MAX_ENUM = 0x7FFFFFFF
} VkPrimitiveTopology;

typedef enum VkPolygonMode {
    VK_POLYGON_MODE_FILL = 0,
    VK_POLYGON_MODE_LINE = 1,
    VK_POLYGON_MODE_POINT = 2,
    VK_POLYGON_MODE_FILL_RECTANGLE_NV = 1000153000,
    VK_POLYGON_MODE_MAX_ENUM = 0x7FFFFFFF
} VkPolygonMode;

typedef enum VkFrontFace {
    VK_FRONT_FACE_COUNTER_CLOCKWISE = 0,
    VK_FRONT_FACE_CLOCKWISE = 1,
    VK_FRONT_FACE_MAX_ENUM = 0x7FFFFFFF
} VkFrontFace;

typedef enum VkCompareOp {
    VK_COMPARE_OP_NEVER = 0,
    VK_COMPARE_OP_LESS = 1,
    VK_COMPARE_OP_EQUAL = 2,
    VK_COMPARE_OP_LESS_OR_EQUAL = 3,
    VK_COMPARE_OP_GREATER = 4,
    VK_COMPARE_OP_NOT_EQUAL = 5,
    VK_COMPARE_OP_GREATER_OR_EQUAL = 6,
    VK_COMPARE_OP_ALWAYS = 7,
    VK_COMPARE_OP_MAX_ENUM = 0x7FFFFFFF
} VkCompareOp;

typedef enum VkStencilOp {
    VK_STENCIL_OP_KEEP = 0,
    VK_STENCIL_OP_ZERO = 1,
    VK_STENCIL_OP_REPLACE = 2,
    VK_STENCIL_OP_INCREMENT_AND_CLAMP = 3,
    VK_STENCIL_OP_DECREMENT_AND_CLAMP = 4,
    VK_STENCIL_OP_INVERT = 5,
    VK_STENCIL_OP_INCREMENT_AND_WRAP = 6,
    VK_STENCIL_OP_DECREMENT_AND_WRAP = 7,
    VK_STENCIL_OP_MAX_ENUM = 0x7FFFFFFF
} VkStencilOp;

typedef enum VkLogicOp {
    VK_LOGIC_OP_CLEAR = 0,
    VK_LOGIC_OP_AND = 1,
    VK_LOGIC_OP_AND_REVERSE = 2,
    VK_LOGIC_OP_COPY = 3,
    VK_LOGIC_OP_AND_INVERTED = 4,
    VK_LOGIC_OP_NO_OP = 5,
    VK_LOGIC_OP_XOR = 6,
    VK_LOGIC_OP_OR = 7,
    VK_LOGIC_OP_NOR = 8,
    VK_LOGIC_OP_EQUIVALENT = 9,
    VK_LOGIC_OP_INVERT = 10,
    VK_LOGIC_OP_OR_REVERSE = 11,
    VK_LOGIC_OP_COPY_INVERTED = 12,
    VK_LOGIC_OP_OR_INVERTED = 13,
    VK_LOGIC_OP_NAND = 14,
    VK_LOGIC_OP_SET = 15,
    VK_LOGIC_OP_MAX_ENUM = 0x7FFFFFFF
} VkLogicOp;

typedef enum VkBlendFactor {
    VK_BLEND_FACTOR_ZERO = 0,
    VK_BLEND_FACTOR_ONE = 1,
    VK_BLEND_FACTOR_SRC_COLOR = 2,
    VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR = 3,
    VK_BLEND_FACTOR_DST_COLOR = 4,
    VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR = 5,
    VK_BLEND_FACTOR_SRC_ALPHA = 6,
    VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA = 7,
    VK_BLEND_FACTOR_DST_ALPHA = 8,
    VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA = 9,
    VK_BLEND_FACTOR_CONSTANT_COLOR = 10,
    VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR = 11,
    VK_BLEND_FACTOR_CONSTANT_ALPHA = 12,
    VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA = 13,
    VK_BLEND_FACTOR_SRC_ALPHA_SATURATE = 14,
    VK_BLEND_FACTOR_SRC1_COLOR = 15,
    VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR = 16,
    VK_BLEND_FACTOR_SRC1_ALPHA = 17,
    VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA = 18,
    VK_BLEND_FACTOR_MAX_ENUM = 0x7FFFFFFF
} VkBlendFactor;

typedef enum VkBlendOp {
    VK_BLEND_OP_ADD = 0,
    VK_BLEND_OP_SUBTRACT = 1,
    VK_BLEND_OP_REVERSE_SUBTRACT = 2,
    VK_BLEND_OP_MIN = 3,
    VK_BLEND_OP_MAX = 4,
    VK_BLEND_OP_ZERO_EXT = 1000148000,
    VK_BLEND_OP_SRC_EXT = 1000148001,
    VK_BLEND_OP_DST_EXT = 1000148002,
    VK_BLEND_OP_SRC_OVER_EXT = 1000148003,
    VK_BLEND_OP_DST_OVER_EXT = 1000148004,
    VK_BLEND_OP_SRC_IN_EXT = 1000148005,
    VK_BLEND_OP_DST_IN_EXT = 1000148006,
    VK_BLEND_OP_SRC_OUT_EXT = 1000148007,
    VK_BLEND_OP_DST_OUT_EXT = 1000148008,
    VK_BLEND_OP_SRC_ATOP_EXT = 1000148009,
    VK_BLEND_OP_DST_ATOP_EXT = 1000148010,
    VK_BLEND_OP_XOR_EXT = 1000148011,
    VK_BLEND_OP_MULTIPLY_EXT = 1000148012,
    VK_BLEND_OP_SCREEN_EXT = 1000148013,
    VK_BLEND_OP_OVERLAY_EXT = 1000148014,
    VK_BLEND_OP_DARKEN_EXT = 1000148015,
    VK_BLEND_OP_LIGHTEN_EXT = 1000148016,
    VK_BLEND_OP_COLORDODGE_EXT = 1000148017,
    VK_BLEND_OP_COLORBURN_EXT = 1000148018,
    VK_BLEND_OP_HARDLIGHT_EXT = 1000148019,
    VK_BLEND_OP_SOFTLIGHT_EXT = 1000148020,
    VK_BLEND_OP_DIFFERENCE_EXT = 1000148021,
    VK_BLEND_OP_EXCLUSION_EXT = 1000148022,
    VK_BLEND_OP_INVERT_EXT = 1000148023,
    VK_BLEND_OP_INVERT_RGB_EXT = 1000148024,
    VK_BLEND_OP_LINEARDODGE_EXT = 1000148025,
    VK_BLEND_OP_LINEARBURN_EXT = 1000148026,
    VK_BLEND_OP_VIVIDLIGHT_EXT = 1000148027,
    VK_BLEND_OP_LINEARLIGHT_EXT = 1000148028,
    VK_BLEND_OP_PINLIGHT_EXT = 1000148029,
    VK_BLEND_OP_HARDMIX_EXT = 1000148030,
    VK_BLEND_OP_HSL_HUE_EXT = 1000148031,
    VK_BLEND_OP_HSL_SATURATION_EXT = 1000148032,
    VK_BLEND_OP_HSL_COLOR_EXT = 1000148033,
    VK_BLEND_OP_HSL_LUMINOSITY_EXT = 1000148034,
    VK_BLEND_OP_PLUS_EXT = 1000148035,
    VK_BLEND_OP_PLUS_CLAMPED_EXT = 1000148036,
    VK_BLEND_OP_PLUS_CLAMPED_ALPHA_EXT = 1000148037,
    VK_BLEND_OP_PLUS_DARKER_EXT = 1000148038,
    VK_BLEND_OP_MINUS_EXT = 1000148039,
    VK_BLEND_OP_MINUS_CLAMPED_EXT = 1000148040,
    VK_BLEND_OP_CONTRAST_EXT = 1000148041,
    VK_BLEND_OP_INVERT_OVG_EXT = 1000148042,
    VK_BLEND_OP_RED_EXT = 1000148043,
    VK_BLEND_OP_GREEN_EXT = 1000148044,
    VK_BLEND_OP_BLUE_EXT = 1000148045,
    VK_BLEND_OP_MAX_ENUM = 0x7FFFFFFF
} VkBlendOp;

typedef enum VkDynamicState {
    VK_DYNAMIC_STATE_VIEWPORT = 0,
    VK_DYNAMIC_STATE_SCISSOR = 1,
    VK_DYNAMIC_STATE_LINE_WIDTH = 2,
    VK_DYNAMIC_STATE_DEPTH_BIAS = 3,
    VK_DYNAMIC_STATE_BLEND_CONSTANTS = 4,
    VK_DYNAMIC_STATE_DEPTH_BOUNDS = 5,
    VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK = 6,
    VK_DYNAMIC_STATE_STENCIL_WRITE_MASK = 7,
    VK_DYNAMIC_STATE_STENCIL_REFERENCE = 8,
    VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV = 1000087000,
    VK_DYNAMIC_STATE_DISCARD_RECTANGLE_EXT = 1000099000,
    VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT = 1000143000,
    VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV = 1000164004,
    VK_DYNAMIC_STATE_VIEWPORT_COARSE_SAMPLE_ORDER_NV = 1000164006,
    VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_NV = 1000205001,
    VK_DYNAMIC_STATE_LINE_STIPPLE_EXT = 1000259000,
    VK_DYNAMIC_STATE_MAX_ENUM = 0x7FFFFFFF
} VkDynamicState;

typedef enum VkFilter {
    VK_FILTER_NEAREST = 0,
    VK_FILTER_LINEAR = 1,
    VK_FILTER_CUBIC_IMG = 1000015000,
    VK_FILTER_CUBIC_EXT = VK_FILTER_CUBIC_IMG,
    VK_FILTER_MAX_ENUM = 0x7FFFFFFF
} VkFilter;

typedef enum VkSamplerMipmapMode {
    VK_SAMPLER_MIPMAP_MODE_NEAREST = 0,
    VK_SAMPLER_MIPMAP_MODE_LINEAR = 1,
    VK_SAMPLER_MIPMAP_MODE_MAX_ENUM = 0x7FFFFFFF
} VkSamplerMipmapMode;

typedef enum VkSamplerAddressMode {
    VK_SAMPLER_ADDRESS_MODE_REPEAT = 0,
    VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT = 1,
    VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE = 2,
    VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER = 3,
    VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE = 4,
    VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE_KHR = VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE,
    VK_SAMPLER_ADDRESS_MODE_MAX_ENUM = 0x7FFFFFFF
} VkSamplerAddressMode;

typedef enum VkBorderColor {
    VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK = 0,
    VK_BORDER_COLOR_INT_TRANSPARENT_BLACK = 1,
    VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK = 2,
    VK_BORDER_COLOR_INT_OPAQUE_BLACK = 3,
    VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE = 4,
    VK_BORDER_COLOR_INT_OPAQUE_WHITE = 5,
    VK_BORDER_COLOR_MAX_ENUM = 0x7FFFFFFF
} VkBorderColor;

typedef enum VkDescriptorType {
    VK_DESCRIPTOR_TYPE_SAMPLER = 0,
    VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER = 1,
    VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE = 2,
    VK_DESCRIPTOR_TYPE_STORAGE_IMAGE = 3,
    VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER = 4,
    VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER = 5,
    VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER = 6,
    VK_DESCRIPTOR_TYPE_STORAGE_BUFFER = 7,
    VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC = 8,
    VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC = 9,
    VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT = 10,
    VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT = 1000138000,
    VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_NV = 1000165000,
    VK_DESCRIPTOR_TYPE_MAX_ENUM = 0x7FFFFFFF
} VkDescriptorType;

typedef enum VkAttachmentLoadOp {
    VK_ATTACHMENT_LOAD_OP_LOAD = 0,
    VK_ATTACHMENT_LOAD_OP_CLEAR = 1,
    VK_ATTACHMENT_LOAD_OP_DONT_CARE = 2,
    VK_ATTACHMENT_LOAD_OP_MAX_ENUM = 0x7FFFFFFF
} VkAttachmentLoadOp;

typedef enum VkAttachmentStoreOp {
    VK_ATTACHMENT_STORE_OP_STORE = 0,
    VK_ATTACHMENT_STORE_OP_DONT_CARE = 1,
    VK_ATTACHMENT_STORE_OP_MAX_ENUM = 0x7FFFFFFF
} VkAttachmentStoreOp;

typedef enum VkPipelineBindPoint {
    VK_PIPELINE_BIND_POINT_GRAPHICS = 0,
    VK_PIPELINE_BIND_POINT_COMPUTE = 1,
    VK_PIPELINE_BIND_POINT_RAY_TRACING_NV = 1000165000,
    VK_PIPELINE_BIND_POINT_MAX_ENUM = 0x7FFFFFFF
} VkPipelineBindPoint;

typedef enum VkCommandBufferLevel {
    VK_COMMAND_BUFFER_LEVEL_PRIMARY = 0,
    VK_COMMAND_BUFFER_LEVEL_SECONDARY = 1,
    VK_COMMAND_BUFFER_LEVEL_MAX_ENUM = 0x7FFFFFFF
} VkCommandBufferLevel;

typedef enum VkIndexType {
    VK_INDEX_TYPE_UINT16 = 0,
    VK_INDEX_TYPE_UINT32 = 1,
    VK_INDEX_TYPE_NONE_NV = 1000165000,
    VK_INDEX_TYPE_UINT8_EXT = 1000265000,
    VK_INDEX_TYPE_MAX_ENUM = 0x7FFFFFFF
} VkIndexType;

typedef enum VkSubpassContents {
    VK_SUBPASS_CONTENTS_INLINE = 0,
    VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS = 1,
    VK_SUBPASS_CONTENTS_MAX_ENUM = 0x7FFFFFFF
} VkSubpassContents;

typedef enum VkObjectType {
    VK_OBJECT_TYPE_UNKNOWN = 0,
    VK_OBJECT_TYPE_INSTANCE = 1,
    VK_OBJECT_TYPE_PHYSICAL_DEVICE = 2,
    VK_OBJECT_TYPE_DEVICE = 3,
    VK_OBJECT_TYPE_QUEUE = 4,
    VK_OBJECT_TYPE_SEMAPHORE = 5,
    VK_OBJECT_TYPE_COMMAND_BUFFER = 6,
    VK_OBJECT_TYPE_FENCE = 7,
    VK_OBJECT_TYPE_DEVICE_MEMORY = 8,
    VK_OBJECT_TYPE_BUFFER = 9,
    VK_OBJECT_TYPE_IMAGE = 10,
    VK_OBJECT_TYPE_EVENT = 11,
    VK_OBJECT_TYPE_QUERY_POOL = 12,
    VK_OBJECT_TYPE_BUFFER_VIEW = 13,
    VK_OBJECT_TYPE_IMAGE_VIEW = 14,
    VK_OBJECT_TYPE_SHADER_MODULE = 15,
    VK_OBJECT_TYPE_PIPELINE_CACHE = 16,
    VK_OBJECT_TYPE_PIPELINE_LAYOUT = 17,
    VK_OBJECT_TYPE_RENDER_PASS = 18,
    VK_OBJECT_TYPE_PIPELINE = 19,
    VK_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT = 20,
    VK_OBJECT_TYPE_SAMPLER = 21,
    VK_OBJECT_TYPE_DESCRIPTOR_POOL = 22,
    VK_OBJECT_TYPE_DESCRIPTOR_SET = 23,
    VK_OBJECT_TYPE_FRAMEBUFFER = 24,
    VK_OBJECT_TYPE_COMMAND_POOL = 25,
    VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION = 1000156000,
    VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE = 1000085000,
    VK_OBJECT_TYPE_SURFACE_KHR = 1000000000,
    VK_OBJECT_TYPE_SWAPCHAIN_KHR = 1000001000,
    VK_OBJECT_TYPE_DISPLAY_KHR = 1000002000,
    VK_OBJECT_TYPE_DISPLAY_MODE_KHR = 1000002001,
    VK_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT = 1000011000,
    VK_OBJECT_TYPE_OBJECT_TABLE_NVX = 1000086000,
    VK_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NVX = 1000086001,
    VK_OBJECT_TYPE_DEBUG_UTILS_MESSENGER_EXT = 1000128000,
    VK_OBJECT_TYPE_VALIDATION_CACHE_EXT = 1000160000,
    VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV = 1000165000,
    VK_OBJECT_TYPE_PERFORMANCE_CONFIGURATION_INTEL = 1000210000,
    VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR = VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE,
    VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_KHR = VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION,
    VK_OBJECT_TYPE_MAX_ENUM = 0x7FFFFFFF
} VkObjectType;

typedef enum VkVendorId {
    VK_VENDOR_ID_VIV = 0x10001,
    VK_VENDOR_ID_VSI = 0x10002,
    VK_VENDOR_ID_KAZAN = 0x10003,
    VK_VENDOR_ID_MAX_ENUM = 0x7FFFFFFF
} VkVendorId;
typedef VkFlags VkInstanceCreateFlags;

typedef enum VkFormatFeatureFlagBits {
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT = 0x00000001,
    VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT = 0x00000002,
    VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT = 0x00000004,
    VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT = 0x00000008,
    VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT = 0x00000010,
    VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT = 0x00000020,
    VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT = 0x00000040,
    VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT = 0x00000080,
    VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT = 0x00000100,
    VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT = 0x00000200,
    VK_FORMAT_FEATURE_BLIT_SRC_BIT = 0x00000400,
    VK_FORMAT_FEATURE_BLIT_DST_BIT = 0x00000800,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT = 0x00001000,
    VK_FORMAT_FEATURE_TRANSFER_SRC_BIT = 0x00004000,
    VK_FORMAT_FEATURE_TRANSFER_DST_BIT = 0x00008000,
    VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT = 0x00020000,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT = 0x00040000,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT = 0x00080000,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT = 0x00100000,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT = 0x00200000,
    VK_FORMAT_FEATURE_DISJOINT_BIT = 0x00400000,
    VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT = 0x00800000,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG = 0x00002000,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT_EXT = 0x00010000,
    VK_FORMAT_FEATURE_FRAGMENT_DENSITY_MAP_BIT_EXT = 0x01000000,
    VK_FORMAT_FEATURE_TRANSFER_SRC_BIT_KHR = VK_FORMAT_FEATURE_TRANSFER_SRC_BIT,
    VK_FORMAT_FEATURE_TRANSFER_DST_BIT_KHR = VK_FORMAT_FEATURE_TRANSFER_DST_BIT,
    VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT_KHR = VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT_KHR = VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT_KHR = VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT_KHR = VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT_KHR = VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT,
    VK_FORMAT_FEATURE_DISJOINT_BIT_KHR = VK_FORMAT_FEATURE_DISJOINT_BIT,
    VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT_KHR = VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT = VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG,
    VK_FORMAT_FEATURE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkFormatFeatureFlagBits;
typedef VkFlags VkFormatFeatureFlags;

typedef enum VkImageUsageFlagBits {
    VK_IMAGE_USAGE_TRANSFER_SRC_BIT = 0x00000001,
    VK_IMAGE_USAGE_TRANSFER_DST_BIT = 0x00000002,
    VK_IMAGE_USAGE_SAMPLED_BIT = 0x00000004,
    VK_IMAGE_USAGE_STORAGE_BIT = 0x00000008,
    VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT = 0x00000010,
    VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT = 0x00000020,
    VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT = 0x00000040,
    VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT = 0x00000080,
    VK_IMAGE_USAGE_SHADING_RATE_IMAGE_BIT_NV = 0x00000100,
    VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT = 0x00000200,
    VK_IMAGE_USAGE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkImageUsageFlagBits;
typedef VkFlags VkImageUsageFlags;

typedef enum VkImageCreateFlagBits {
    VK_IMAGE_CREATE_SPARSE_BINDING_BIT = 0x00000001,
    VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT = 0x00000002,
    VK_IMAGE_CREATE_SPARSE_ALIASED_BIT = 0x00000004,
    VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT = 0x00000008,
    VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT = 0x00000010,
    VK_IMAGE_CREATE_ALIAS_BIT = 0x00000400,
    VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT = 0x00000040,
    VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT = 0x00000020,
    VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT = 0x00000080,
    VK_IMAGE_CREATE_EXTENDED_USAGE_BIT = 0x00000100,
    VK_IMAGE_CREATE_PROTECTED_BIT = 0x00000800,
    VK_IMAGE_CREATE_DISJOINT_BIT = 0x00000200,
    VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV = 0x00002000,
    VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT = 0x00001000,
    VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT = 0x00004000,
    VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR = VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT,
    VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT_KHR = VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT,
    VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT_KHR = VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT,
    VK_IMAGE_CREATE_EXTENDED_USAGE_BIT_KHR = VK_IMAGE_CREATE_EXTENDED_USAGE_BIT,
    VK_IMAGE_CREATE_DISJOINT_BIT_KHR = VK_IMAGE_CREATE_DISJOINT_BIT,
    VK_IMAGE_CREATE_ALIAS_BIT_KHR = VK_IMAGE_CREATE_ALIAS_BIT,
    VK_IMAGE_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkImageCreateFlagBits;
typedef VkFlags VkImageCreateFlags;

typedef enum VkSampleCountFlagBits {
    VK_SAMPLE_COUNT_1_BIT = 0x00000001,
    VK_SAMPLE_COUNT_2_BIT = 0x00000002,
    VK_SAMPLE_COUNT_4_BIT = 0x00000004,
    VK_SAMPLE_COUNT_8_BIT = 0x00000008,
    VK_SAMPLE_COUNT_16_BIT = 0x00000010,
    VK_SAMPLE_COUNT_32_BIT = 0x00000020,
    VK_SAMPLE_COUNT_64_BIT = 0x00000040,
    VK_SAMPLE_COUNT_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkSampleCountFlagBits;
typedef VkFlags VkSampleCountFlags;

typedef enum VkQueueFlagBits {
    VK_QUEUE_GRAPHICS_BIT = 0x00000001,
    VK_QUEUE_COMPUTE_BIT = 0x00000002,
    VK_QUEUE_TRANSFER_BIT = 0x00000004,
    VK_QUEUE_SPARSE_BINDING_BIT = 0x00000008,
    VK_QUEUE_PROTECTED_BIT = 0x00000010,
    VK_QUEUE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkQueueFlagBits;
typedef VkFlags VkQueueFlags;

typedef enum VkMemoryPropertyFlagBits {
    VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT = 0x00000001,
    VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT = 0x00000002,
    VK_MEMORY_PROPERTY_HOST_COHERENT_BIT = 0x00000004,
    VK_MEMORY_PROPERTY_HOST_CACHED_BIT = 0x00000008,
    VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT = 0x00000010,
    VK_MEMORY_PROPERTY_PROTECTED_BIT = 0x00000020,
    VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD = 0x00000040,
    VK_MEMORY_PROPERTY_DEVICE_UNCACHED_BIT_AMD = 0x00000080,
    VK_MEMORY_PROPERTY_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkMemoryPropertyFlagBits;
typedef VkFlags VkMemoryPropertyFlags;

typedef enum VkMemoryHeapFlagBits {
    VK_MEMORY_HEAP_DEVICE_LOCAL_BIT = 0x00000001,
    VK_MEMORY_HEAP_MULTI_INSTANCE_BIT = 0x00000002,
    VK_MEMORY_HEAP_MULTI_INSTANCE_BIT_KHR = VK_MEMORY_HEAP_MULTI_INSTANCE_BIT,
    VK_MEMORY_HEAP_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkMemoryHeapFlagBits;
typedef VkFlags VkMemoryHeapFlags;
typedef VkFlags VkDeviceCreateFlags;

typedef enum VkDeviceQueueCreateFlagBits {
    VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT = 0x00000001,
    VK_DEVICE_QUEUE_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkDeviceQueueCreateFlagBits;
typedef VkFlags VkDeviceQueueCreateFlags;

typedef enum VkPipelineStageFlagBits {
    VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT = 0x00000001,
    VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT = 0x00000002,
    VK_PIPELINE_STAGE_VERTEX_INPUT_BIT = 0x00000004,
    VK_PIPELINE_STAGE_VERTEX_SHADER_BIT = 0x00000008,
    VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT = 0x00000010,
    VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT = 0x00000020,
    VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT = 0x00000040,
    VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT = 0x00000080,
    VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT = 0x00000100,
    VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT = 0x00000200,
    VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT = 0x00000400,
    VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT = 0x00000800,
    VK_PIPELINE_STAGE_TRANSFER_BIT = 0x00001000,
    VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT = 0x00002000,
    VK_PIPELINE_STAGE_HOST_BIT = 0x00004000,
    VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT = 0x00008000,
    VK_PIPELINE_STAGE_ALL_COMMANDS_BIT = 0x00010000,
    VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT = 0x01000000,
    VK_PIPELINE_STAGE_CONDITIONAL_RENDERING_BIT_EXT = 0x00040000,
    VK_PIPELINE_STAGE_COMMAND_PROCESS_BIT_NVX = 0x00020000,
    VK_PIPELINE_STAGE_SHADING_RATE_IMAGE_BIT_NV = 0x00400000,
    VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_NV = 0x00200000,
    VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_NV = 0x02000000,
    VK_PIPELINE_STAGE_TASK_SHADER_BIT_NV = 0x00080000,
    VK_PIPELINE_STAGE_MESH_SHADER_BIT_NV = 0x00100000,
    VK_PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT = 0x00800000,
    VK_PIPELINE_STAGE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkPipelineStageFlagBits;
typedef VkFlags VkPipelineStageFlags;
typedef VkFlags VkMemoryMapFlags;

typedef enum VkImageAspectFlagBits {
    VK_IMAGE_ASPECT_COLOR_BIT = 0x00000001,
    VK_IMAGE_ASPECT_DEPTH_BIT = 0x00000002,
    VK_IMAGE_ASPECT_STENCIL_BIT = 0x00000004,
    VK_IMAGE_ASPECT_METADATA_BIT = 0x00000008,
    VK_IMAGE_ASPECT_PLANE_0_BIT = 0x00000010,
    VK_IMAGE_ASPECT_PLANE_1_BIT = 0x00000020,
    VK_IMAGE_ASPECT_PLANE_2_BIT = 0x00000040,
    VK_IMAGE_ASPECT_MEMORY_PLANE_0_BIT_EXT = 0x00000080,
    VK_IMAGE_ASPECT_MEMORY_PLANE_1_BIT_EXT = 0x00000100,
    VK_IMAGE_ASPECT_MEMORY_PLANE_2_BIT_EXT = 0x00000200,
    VK_IMAGE_ASPECT_MEMORY_PLANE_3_BIT_EXT = 0x00000400,
    VK_IMAGE_ASPECT_PLANE_0_BIT_KHR = VK_IMAGE_ASPECT_PLANE_0_BIT,
    VK_IMAGE_ASPECT_PLANE_1_BIT_KHR = VK_IMAGE_ASPECT_PLANE_1_BIT,
    VK_IMAGE_ASPECT_PLANE_2_BIT_KHR = VK_IMAGE_ASPECT_PLANE_2_BIT,
    VK_IMAGE_ASPECT_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkImageAspectFlagBits;
typedef VkFlags VkImageAspectFlags;

typedef enum VkSparseImageFormatFlagBits {
    VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT = 0x00000001,
    VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT = 0x00000002,
    VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT = 0x00000004,
    VK_SPARSE_IMAGE_FORMAT_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkSparseImageFormatFlagBits;
typedef VkFlags VkSparseImageFormatFlags;

typedef enum VkSparseMemoryBindFlagBits {
    VK_SPARSE_MEMORY_BIND_METADATA_BIT = 0x00000001,
    VK_SPARSE_MEMORY_BIND_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkSparseMemoryBindFlagBits;
typedef VkFlags VkSparseMemoryBindFlags;

typedef enum VkFenceCreateFlagBits {
    VK_FENCE_CREATE_SIGNALED_BIT = 0x00000001,
    VK_FENCE_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkFenceCreateFlagBits;
typedef VkFlags VkFenceCreateFlags;
typedef VkFlags VkSemaphoreCreateFlags;
typedef VkFlags VkEventCreateFlags;
typedef VkFlags VkQueryPoolCreateFlags;

typedef enum VkQueryPipelineStatisticFlagBits {
    VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT = 0x00000001,
    VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT = 0x00000002,
    VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT = 0x00000004,
    VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT = 0x00000008,
    VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT = 0x00000010,
    VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT = 0x00000020,
    VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT = 0x00000040,
    VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT = 0x00000080,
    VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT = 0x00000100,
    VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT = 0x00000200,
    VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT = 0x00000400,
    VK_QUERY_PIPELINE_STATISTIC_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkQueryPipelineStatisticFlagBits;
typedef VkFlags VkQueryPipelineStatisticFlags;

typedef enum VkQueryResultFlagBits {
    VK_QUERY_RESULT_64_BIT = 0x00000001,
    VK_QUERY_RESULT_WAIT_BIT = 0x00000002,
    VK_QUERY_RESULT_WITH_AVAILABILITY_BIT = 0x00000004,
    VK_QUERY_RESULT_PARTIAL_BIT = 0x00000008,
    VK_QUERY_RESULT_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkQueryResultFlagBits;
typedef VkFlags VkQueryResultFlags;

typedef enum VkBufferCreateFlagBits {
    VK_BUFFER_CREATE_SPARSE_BINDING_BIT = 0x00000001,
    VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT = 0x00000002,
    VK_BUFFER_CREATE_SPARSE_ALIASED_BIT = 0x00000004,
    VK_BUFFER_CREATE_PROTECTED_BIT = 0x00000008,
    VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_EXT = 0x00000010,
    VK_BUFFER_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkBufferCreateFlagBits;
typedef VkFlags VkBufferCreateFlags;

typedef enum VkBufferUsageFlagBits {
    VK_BUFFER_USAGE_TRANSFER_SRC_BIT = 0x00000001,
    VK_BUFFER_USAGE_TRANSFER_DST_BIT = 0x00000002,
    VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT = 0x00000004,
    VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT = 0x00000008,
    VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT = 0x00000010,
    VK_BUFFER_USAGE_STORAGE_BUFFER_BIT = 0x00000020,
    VK_BUFFER_USAGE_INDEX_BUFFER_BIT = 0x00000040,
    VK_BUFFER_USAGE_VERTEX_BUFFER_BIT = 0x00000080,
    VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT = 0x00000100,
    VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_BUFFER_BIT_EXT = 0x00000800,
    VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT = 0x00001000,
    VK_BUFFER_USAGE_CONDITIONAL_RENDERING_BIT_EXT = 0x00000200,
    VK_BUFFER_USAGE_RAY_TRACING_BIT_NV = 0x00000400,
    VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_EXT = 0x00020000,
    VK_BUFFER_USAGE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkBufferUsageFlagBits;
typedef VkFlags VkBufferUsageFlags;
typedef VkFlags VkBufferViewCreateFlags;

typedef enum VkImageViewCreateFlagBits {
    VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DYNAMIC_BIT_EXT = 0x00000001,
    VK_IMAGE_VIEW_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkImageViewCreateFlagBits;
typedef VkFlags VkImageViewCreateFlags;

typedef enum VkShaderModuleCreateFlagBits {
    VK_SHADER_MODULE_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkShaderModuleCreateFlagBits;
typedef VkFlags VkShaderModuleCreateFlags;
typedef VkFlags VkPipelineCacheCreateFlags;

typedef enum VkPipelineCreateFlagBits {
    VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT = 0x00000001,
    VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT = 0x00000002,
    VK_PIPELINE_CREATE_DERIVATIVE_BIT = 0x00000004,
    VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT = 0x00000008,
    VK_PIPELINE_CREATE_DISPATCH_BASE = 0x00000010,
    VK_PIPELINE_CREATE_DEFER_COMPILE_BIT_NV = 0x00000020,
    VK_PIPELINE_CREATE_CAPTURE_STATISTICS_BIT_KHR = 0x00000040,
    VK_PIPELINE_CREATE_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR = 0x00000080,
    VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT_KHR = VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT,
    VK_PIPELINE_CREATE_DISPATCH_BASE_KHR = VK_PIPELINE_CREATE_DISPATCH_BASE,
    VK_PIPELINE_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkPipelineCreateFlagBits;
typedef VkFlags VkPipelineCreateFlags;

typedef enum VkPipelineShaderStageCreateFlagBits {
    VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT_EXT = 0x00000001,
    VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT_EXT = 0x00000002,
    VK_PIPELINE_SHADER_STAGE_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkPipelineShaderStageCreateFlagBits;
typedef VkFlags VkPipelineShaderStageCreateFlags;

typedef enum VkShaderStageFlagBits {
    VK_SHADER_STAGE_VERTEX_BIT = 0x00000001,
    VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT = 0x00000002,
    VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT = 0x00000004,
    VK_SHADER_STAGE_GEOMETRY_BIT = 0x00000008,
    VK_SHADER_STAGE_FRAGMENT_BIT = 0x00000010,
    VK_SHADER_STAGE_COMPUTE_BIT = 0x00000020,
    VK_SHADER_STAGE_ALL_GRAPHICS = 0x0000001F,
    VK_SHADER_STAGE_ALL = 0x7FFFFFFF,
    VK_SHADER_STAGE_RAYGEN_BIT_NV = 0x00000100,
    VK_SHADER_STAGE_ANY_HIT_BIT_NV = 0x00000200,
    VK_SHADER_STAGE_CLOSEST_HIT_BIT_NV = 0x00000400,
    VK_SHADER_STAGE_MISS_BIT_NV = 0x00000800,
    VK_SHADER_STAGE_INTERSECTION_BIT_NV = 0x00001000,
    VK_SHADER_STAGE_CALLABLE_BIT_NV = 0x00002000,
    VK_SHADER_STAGE_TASK_BIT_NV = 0x00000040,
    VK_SHADER_STAGE_MESH_BIT_NV = 0x00000080,
    VK_SHADER_STAGE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkShaderStageFlagBits;
typedef VkFlags VkPipelineVertexInputStateCreateFlags;
typedef VkFlags VkPipelineInputAssemblyStateCreateFlags;
typedef VkFlags VkPipelineTessellationStateCreateFlags;
typedef VkFlags VkPipelineViewportStateCreateFlags;
typedef VkFlags VkPipelineRasterizationStateCreateFlags;

typedef enum VkCullModeFlagBits {
    VK_CULL_MODE_NONE = 0,
    VK_CULL_MODE_FRONT_BIT = 0x00000001,
    VK_CULL_MODE_BACK_BIT = 0x00000002,
    VK_CULL_MODE_FRONT_AND_BACK = 0x00000003,
    VK_CULL_MODE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkCullModeFlagBits;
typedef VkFlags VkCullModeFlags;
typedef VkFlags VkPipelineMultisampleStateCreateFlags;
typedef VkFlags VkPipelineDepthStencilStateCreateFlags;
typedef VkFlags VkPipelineColorBlendStateCreateFlags;

typedef enum VkColorComponentFlagBits {
    VK_COLOR_COMPONENT_R_BIT = 0x00000001,
    VK_COLOR_COMPONENT_G_BIT = 0x00000002,
    VK_COLOR_COMPONENT_B_BIT = 0x00000004,
    VK_COLOR_COMPONENT_A_BIT = 0x00000008,
    VK_COLOR_COMPONENT_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkColorComponentFlagBits;
typedef VkFlags VkColorComponentFlags;
typedef VkFlags VkPipelineDynamicStateCreateFlags;
typedef VkFlags VkPipelineLayoutCreateFlags;
typedef VkFlags VkShaderStageFlags;

typedef enum VkSamplerCreateFlagBits {
    VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT = 0x00000001,
    VK_SAMPLER_CREATE_SUBSAMPLED_COARSE_RECONSTRUCTION_BIT_EXT = 0x00000002,
    VK_SAMPLER_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkSamplerCreateFlagBits;
typedef VkFlags VkSamplerCreateFlags;

typedef enum VkDescriptorSetLayoutCreateFlagBits {
    VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR = 0x00000001,
    VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT = 0x00000002,
    VK_DESCRIPTOR_SET_LAYOUT_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkDescriptorSetLayoutCreateFlagBits;
typedef VkFlags VkDescriptorSetLayoutCreateFlags;

typedef enum VkDescriptorPoolCreateFlagBits {
    VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT = 0x00000001,
    VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT_EXT = 0x00000002,
    VK_DESCRIPTOR_POOL_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkDescriptorPoolCreateFlagBits;
typedef VkFlags VkDescriptorPoolCreateFlags;
typedef VkFlags VkDescriptorPoolResetFlags;

typedef enum VkFramebufferCreateFlagBits {
    VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT_KHR = 0x00000001,
    VK_FRAMEBUFFER_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkFramebufferCreateFlagBits;
typedef VkFlags VkFramebufferCreateFlags;

typedef enum VkRenderPassCreateFlagBits {
    VK_RENDER_PASS_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkRenderPassCreateFlagBits;
typedef VkFlags VkRenderPassCreateFlags;

typedef enum VkAttachmentDescriptionFlagBits {
    VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT = 0x00000001,
    VK_ATTACHMENT_DESCRIPTION_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkAttachmentDescriptionFlagBits;
typedef VkFlags VkAttachmentDescriptionFlags;

typedef enum VkSubpassDescriptionFlagBits {
    VK_SUBPASS_DESCRIPTION_PER_VIEW_ATTRIBUTES_BIT_NVX = 0x00000001,
    VK_SUBPASS_DESCRIPTION_PER_VIEW_POSITION_X_ONLY_BIT_NVX = 0x00000002,
    VK_SUBPASS_DESCRIPTION_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkSubpassDescriptionFlagBits;
typedef VkFlags VkSubpassDescriptionFlags;

typedef enum VkAccessFlagBits {
    VK_ACCESS_INDIRECT_COMMAND_READ_BIT = 0x00000001,
    VK_ACCESS_INDEX_READ_BIT = 0x00000002,
    VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT = 0x00000004,
    VK_ACCESS_UNIFORM_READ_BIT = 0x00000008,
    VK_ACCESS_INPUT_ATTACHMENT_READ_BIT = 0x00000010,
    VK_ACCESS_SHADER_READ_BIT = 0x00000020,
    VK_ACCESS_SHADER_WRITE_BIT = 0x00000040,
    VK_ACCESS_COLOR_ATTACHMENT_READ_BIT = 0x00000080,
    VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT = 0x00000100,
    VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT = 0x00000200,
    VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT = 0x00000400,
    VK_ACCESS_TRANSFER_READ_BIT = 0x00000800,
    VK_ACCESS_TRANSFER_WRITE_BIT = 0x00001000,
    VK_ACCESS_HOST_READ_BIT = 0x00002000,
    VK_ACCESS_HOST_WRITE_BIT = 0x00004000,
    VK_ACCESS_MEMORY_READ_BIT = 0x00008000,
    VK_ACCESS_MEMORY_WRITE_BIT = 0x00010000,
    VK_ACCESS_TRANSFORM_FEEDBACK_WRITE_BIT_EXT = 0x02000000,
    VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT = 0x04000000,
    VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT = 0x08000000,
    VK_ACCESS_CONDITIONAL_RENDERING_READ_BIT_EXT = 0x00100000,
    VK_ACCESS_COMMAND_PROCESS_READ_BIT_NVX = 0x00020000,
    VK_ACCESS_COMMAND_PROCESS_WRITE_BIT_NVX = 0x00040000,
    VK_ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT = 0x00080000,
    VK_ACCESS_SHADING_RATE_IMAGE_READ_BIT_NV = 0x00800000,
    VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_NV = 0x00200000,
    VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_NV = 0x00400000,
    VK_ACCESS_FRAGMENT_DENSITY_MAP_READ_BIT_EXT = 0x01000000,
    VK_ACCESS_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkAccessFlagBits;
typedef VkFlags VkAccessFlags;

typedef enum VkDependencyFlagBits {
    VK_DEPENDENCY_BY_REGION_BIT = 0x00000001,
    VK_DEPENDENCY_DEVICE_GROUP_BIT = 0x00000004,
    VK_DEPENDENCY_VIEW_LOCAL_BIT = 0x00000002,
    VK_DEPENDENCY_VIEW_LOCAL_BIT_KHR = VK_DEPENDENCY_VIEW_LOCAL_BIT,
    VK_DEPENDENCY_DEVICE_GROUP_BIT_KHR = VK_DEPENDENCY_DEVICE_GROUP_BIT,
    VK_DEPENDENCY_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkDependencyFlagBits;
typedef VkFlags VkDependencyFlags;

typedef enum VkCommandPoolCreateFlagBits {
    VK_COMMAND_POOL_CREATE_TRANSIENT_BIT = 0x00000001,
    VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT = 0x00000002,
    VK_COMMAND_POOL_CREATE_PROTECTED_BIT = 0x00000004,
    VK_COMMAND_POOL_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkCommandPoolCreateFlagBits;
typedef VkFlags VkCommandPoolCreateFlags;

typedef enum VkCommandPoolResetFlagBits {
    VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT = 0x00000001,
    VK_COMMAND_POOL_RESET_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkCommandPoolResetFlagBits;
typedef VkFlags VkCommandPoolResetFlags;

typedef enum VkCommandBufferUsageFlagBits {
    VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT = 0x00000001,
    VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT = 0x00000002,
    VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT = 0x00000004,
    VK_COMMAND_BUFFER_USAGE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkCommandBufferUsageFlagBits;
typedef VkFlags VkCommandBufferUsageFlags;

typedef enum VkQueryControlFlagBits {
    VK_QUERY_CONTROL_PRECISE_BIT = 0x00000001,
    VK_QUERY_CONTROL_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkQueryControlFlagBits;
typedef VkFlags VkQueryControlFlags;

typedef enum VkCommandBufferResetFlagBits {
    VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT = 0x00000001,
    VK_COMMAND_BUFFER_RESET_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkCommandBufferResetFlagBits;
typedef VkFlags VkCommandBufferResetFlags;

typedef enum VkStencilFaceFlagBits {
    VK_STENCIL_FACE_FRONT_BIT = 0x00000001,
    VK_STENCIL_FACE_BACK_BIT = 0x00000002,
    VK_STENCIL_FACE_FRONT_AND_BACK = 0x00000003,
    VK_STENCIL_FRONT_AND_BACK = VK_STENCIL_FACE_FRONT_AND_BACK,
    VK_STENCIL_FACE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkStencilFaceFlagBits;
typedef VkFlags VkStencilFaceFlags;
typedef struct VkApplicationInfo {
    VkStructureType    sType;
    const void*        pNext;
    const char*        pApplicationName;
    uint32_t           applicationVersion;
    const char*        pEngineName;
    uint32_t           engineVersion;
    uint32_t           apiVersion;
} VkApplicationInfo;

struct VkApplicationInfoRAII {
   VkApplicationInfo nonRaiiObj;
    std::string                                 strApplicationName;
    std::string                                 strEngineName;
};

typedef struct VkInstanceCreateInfo {
    VkStructureType             sType;
    const void*                 pNext;
    VkInstanceCreateFlags       flags;
    const VkApplicationInfo*    pApplicationInfo;
    uint32_t                    enabledLayerCount;
    const char* const*          ppEnabledLayerNames;
    uint32_t                    enabledExtensionCount;
    const char* const*          ppEnabledExtensionNames;
} VkInstanceCreateInfo;

struct VkInstanceCreateInfoRAII {
   VkInstanceCreateInfo nonRaiiObj;
    std::shared_ptr<VkApplicationInfoRAII>      pApplicationInfo;
    std::vector<std::string>                    vecEnabledLayerNames;
    std::vector<const char *>                   vecPtrEnabledLayerNames;
    std::vector<std::string>                    vecEnabledExtensionNames;
    std::vector<const char *>                   vecPtrEnabledExtensionNames;
};

typedef void* (VKAPI_PTR *PFN_vkAllocationFunction)(
    void*                                       pUserData,
    size_t                                      size,
    size_t                                      alignment,
    VkSystemAllocationScope                     allocationScope);

typedef void* (VKAPI_PTR *PFN_vkReallocationFunction)(
    void*                                       pUserData,
    void*                                       pOriginal,
    size_t                                      size,
    size_t                                      alignment,
    VkSystemAllocationScope                     allocationScope);

typedef void (VKAPI_PTR *PFN_vkFreeFunction)(
    void*                                       pUserData,
    void*                                       pMemory);

typedef void (VKAPI_PTR *PFN_vkInternalAllocationNotification)(
    void*                                       pUserData,
    size_t                                      size,
    VkInternalAllocationType                    allocationType,
    VkSystemAllocationScope                     allocationScope);

typedef void (VKAPI_PTR *PFN_vkInternalFreeNotification)(
    void*                                       pUserData,
    size_t                                      size,
    VkInternalAllocationType                    allocationType,
    VkSystemAllocationScope                     allocationScope);

typedef struct VkAllocationCallbacks {
    void*                                   pUserData;
    PFN_vkAllocationFunction                pfnAllocation;
    PFN_vkReallocationFunction              pfnReallocation;
    PFN_vkFreeFunction                      pfnFree;
    PFN_vkInternalAllocationNotification    pfnInternalAllocation;
    PFN_vkInternalFreeNotification          pfnInternalFree;
} VkAllocationCallbacks;

typedef struct VkPhysicalDeviceFeatures {
    VkBool32    robustBufferAccess;
    VkBool32    fullDrawIndexUint32;
    VkBool32    imageCubeArray;
    VkBool32    independentBlend;
    VkBool32    geometryShader;
    VkBool32    tessellationShader;
    VkBool32    sampleRateShading;
    VkBool32    dualSrcBlend;
    VkBool32    logicOp;
    VkBool32    multiDrawIndirect;
    VkBool32    drawIndirectFirstInstance;
    VkBool32    depthClamp;
    VkBool32    depthBiasClamp;
    VkBool32    fillModeNonSolid;
    VkBool32    depthBounds;
    VkBool32    wideLines;
    VkBool32    largePoints;
    VkBool32    alphaToOne;
    VkBool32    multiViewport;
    VkBool32    samplerAnisotropy;
    VkBool32    textureCompressionETC2;
    VkBool32    textureCompressionASTC_LDR;
    VkBool32    textureCompressionBC;
    VkBool32    occlusionQueryPrecise;
    VkBool32    pipelineStatisticsQuery;
    VkBool32    vertexPipelineStoresAndAtomics;
    VkBool32    fragmentStoresAndAtomics;
    VkBool32    shaderTessellationAndGeometryPointSize;
    VkBool32    shaderImageGatherExtended;
    VkBool32    shaderStorageImageExtendedFormats;
    VkBool32    shaderStorageImageMultisample;
    VkBool32    shaderStorageImageReadWithoutFormat;
    VkBool32    shaderStorageImageWriteWithoutFormat;
    VkBool32    shaderUniformBufferArrayDynamicIndexing;
    VkBool32    shaderSampledImageArrayDynamicIndexing;
    VkBool32    shaderStorageBufferArrayDynamicIndexing;
    VkBool32    shaderStorageImageArrayDynamicIndexing;
    VkBool32    shaderClipDistance;
    VkBool32    shaderCullDistance;
    VkBool32    shaderFloat64;
    VkBool32    shaderInt64;
    VkBool32    shaderInt16;
    VkBool32    shaderResourceResidency;
    VkBool32    shaderResourceMinLod;
    VkBool32    sparseBinding;
    VkBool32    sparseResidencyBuffer;
    VkBool32    sparseResidencyImage2D;
    VkBool32    sparseResidencyImage3D;
    VkBool32    sparseResidency2Samples;
    VkBool32    sparseResidency4Samples;
    VkBool32    sparseResidency8Samples;
    VkBool32    sparseResidency16Samples;
    VkBool32    sparseResidencyAliased;
    VkBool32    variableMultisampleRate;
    VkBool32    inheritedQueries;
} VkPhysicalDeviceFeatures;

typedef struct VkFormatProperties {
    VkFormatFeatureFlags    linearTilingFeatures;
    VkFormatFeatureFlags    optimalTilingFeatures;
    VkFormatFeatureFlags    bufferFeatures;
} VkFormatProperties;

typedef struct VkExtent3D {
    uint32_t    width;
    uint32_t    height;
    uint32_t    depth;
} VkExtent3D;

typedef struct VkImageFormatProperties {
    VkExtent3D            maxExtent;
    uint32_t              maxMipLevels;
    uint32_t              maxArrayLayers;
    VkSampleCountFlags    sampleCounts;
    VkDeviceSize          maxResourceSize;
} VkImageFormatProperties;

typedef struct VkPhysicalDeviceLimits {
    uint32_t              maxImageDimension1D;
    uint32_t              maxImageDimension2D;
    uint32_t              maxImageDimension3D;
    uint32_t              maxImageDimensionCube;
    uint32_t              maxImageArrayLayers;
    uint32_t              maxTexelBufferElements;
    uint32_t              maxUniformBufferRange;
    uint32_t              maxStorageBufferRange;
    uint32_t              maxPushConstantsSize;
    uint32_t              maxMemoryAllocationCount;
    uint32_t              maxSamplerAllocationCount;
    VkDeviceSize          bufferImageGranularity;
    VkDeviceSize          sparseAddressSpaceSize;
    uint32_t              maxBoundDescriptorSets;
    uint32_t              maxPerStageDescriptorSamplers;
    uint32_t              maxPerStageDescriptorUniformBuffers;
    uint32_t              maxPerStageDescriptorStorageBuffers;
    uint32_t              maxPerStageDescriptorSampledImages;
    uint32_t              maxPerStageDescriptorStorageImages;
    uint32_t              maxPerStageDescriptorInputAttachments;
    uint32_t              maxPerStageResources;
    uint32_t              maxDescriptorSetSamplers;
    uint32_t              maxDescriptorSetUniformBuffers;
    uint32_t              maxDescriptorSetUniformBuffersDynamic;
    uint32_t              maxDescriptorSetStorageBuffers;
    uint32_t              maxDescriptorSetStorageBuffersDynamic;
    uint32_t              maxDescriptorSetSampledImages;
    uint32_t              maxDescriptorSetStorageImages;
    uint32_t              maxDescriptorSetInputAttachments;
    uint32_t              maxVertexInputAttributes;
    uint32_t              maxVertexInputBindings;
    uint32_t              maxVertexInputAttributeOffset;
    uint32_t              maxVertexInputBindingStride;
    uint32_t              maxVertexOutputComponents;
    uint32_t              maxTessellationGenerationLevel;
    uint32_t              maxTessellationPatchSize;
    uint32_t              maxTessellationControlPerVertexInputComponents;
    uint32_t              maxTessellationControlPerVertexOutputComponents;
    uint32_t              maxTessellationControlPerPatchOutputComponents;
    uint32_t              maxTessellationControlTotalOutputComponents;
    uint32_t              maxTessellationEvaluationInputComponents;
    uint32_t              maxTessellationEvaluationOutputComponents;
    uint32_t              maxGeometryShaderInvocations;
    uint32_t              maxGeometryInputComponents;
    uint32_t              maxGeometryOutputComponents;
    uint32_t              maxGeometryOutputVertices;
    uint32_t              maxGeometryTotalOutputComponents;
    uint32_t              maxFragmentInputComponents;
    uint32_t              maxFragmentOutputAttachments;
    uint32_t              maxFragmentDualSrcAttachments;
    uint32_t              maxFragmentCombinedOutputResources;
    uint32_t              maxComputeSharedMemorySize;
    uint32_t              maxComputeWorkGroupCount[3];
    uint32_t              maxComputeWorkGroupInvocations;
    uint32_t              maxComputeWorkGroupSize[3];
    uint32_t              subPixelPrecisionBits;
    uint32_t              subTexelPrecisionBits;
    uint32_t              mipmapPrecisionBits;
    uint32_t              maxDrawIndexedIndexValue;
    uint32_t              maxDrawIndirectCount;
    float                 maxSamplerLodBias;
    float                 maxSamplerAnisotropy;
    uint32_t              maxViewports;
    uint32_t              maxViewportDimensions[2];
    float                 viewportBoundsRange[2];
    uint32_t              viewportSubPixelBits;
    size_t                minMemoryMapAlignment;
    VkDeviceSize          minTexelBufferOffsetAlignment;
    VkDeviceSize          minUniformBufferOffsetAlignment;
    VkDeviceSize          minStorageBufferOffsetAlignment;
    int32_t               minTexelOffset;
    uint32_t              maxTexelOffset;
    int32_t               minTexelGatherOffset;
    uint32_t              maxTexelGatherOffset;
    float                 minInterpolationOffset;
    float                 maxInterpolationOffset;
    uint32_t              subPixelInterpolationOffsetBits;
    uint32_t              maxFramebufferWidth;
    uint32_t              maxFramebufferHeight;
    uint32_t              maxFramebufferLayers;
    VkSampleCountFlags    framebufferColorSampleCounts;
    VkSampleCountFlags    framebufferDepthSampleCounts;
    VkSampleCountFlags    framebufferStencilSampleCounts;
    VkSampleCountFlags    framebufferNoAttachmentsSampleCounts;
    uint32_t              maxColorAttachments;
    VkSampleCountFlags    sampledImageColorSampleCounts;
    VkSampleCountFlags    sampledImageIntegerSampleCounts;
    VkSampleCountFlags    sampledImageDepthSampleCounts;
    VkSampleCountFlags    sampledImageStencilSampleCounts;
    VkSampleCountFlags    storageImageSampleCounts;
    uint32_t              maxSampleMaskWords;
    VkBool32              timestampComputeAndGraphics;
    float                 timestampPeriod;
    uint32_t              maxClipDistances;
    uint32_t              maxCullDistances;
    uint32_t              maxCombinedClipAndCullDistances;
    uint32_t              discreteQueuePriorities;
    float                 pointSizeRange[2];
    float                 lineWidthRange[2];
    float                 pointSizeGranularity;
    float                 lineWidthGranularity;
    VkBool32              strictLines;
    VkBool32              standardSampleLocations;
    VkDeviceSize          optimalBufferCopyOffsetAlignment;
    VkDeviceSize          optimalBufferCopyRowPitchAlignment;
    VkDeviceSize          nonCoherentAtomSize;
} VkPhysicalDeviceLimits;

typedef struct VkPhysicalDeviceSparseProperties {
    VkBool32    residencyStandard2DBlockShape;
    VkBool32    residencyStandard2DMultisampleBlockShape;
    VkBool32    residencyStandard3DBlockShape;
    VkBool32    residencyAlignedMipSize;
    VkBool32    residencyNonResidentStrict;
} VkPhysicalDeviceSparseProperties;

typedef struct VkPhysicalDeviceProperties {
    uint32_t                            apiVersion;
    uint32_t                            driverVersion;
    uint32_t                            vendorID;
    uint32_t                            deviceID;
    VkPhysicalDeviceType                deviceType;
    char                                deviceName[VK_MAX_PHYSICAL_DEVICE_NAME_SIZE];
    uint8_t                             pipelineCacheUUID[VK_UUID_SIZE];
    VkPhysicalDeviceLimits              limits;
    VkPhysicalDeviceSparseProperties    sparseProperties;
} VkPhysicalDeviceProperties;

typedef struct VkQueueFamilyProperties {
    VkQueueFlags    queueFlags;
    uint32_t        queueCount;
    uint32_t        timestampValidBits;
    VkExtent3D      minImageTransferGranularity;
} VkQueueFamilyProperties;

typedef struct VkMemoryType {
    VkMemoryPropertyFlags    propertyFlags;
    uint32_t                 heapIndex;
} VkMemoryType;

typedef struct VkMemoryHeap {
    VkDeviceSize         size;
    VkMemoryHeapFlags    flags;
} VkMemoryHeap;

typedef struct VkPhysicalDeviceMemoryProperties {
    uint32_t        memoryTypeCount;
    VkMemoryType    memoryTypes[VK_MAX_MEMORY_TYPES];
    uint32_t        memoryHeapCount;
    VkMemoryHeap    memoryHeaps[VK_MAX_MEMORY_HEAPS];
} VkPhysicalDeviceMemoryProperties;

typedef void (VKAPI_PTR *PFN_vkVoidFunction)(void);
typedef struct VkDeviceQueueCreateInfo {
    VkStructureType             sType;
    const void*                 pNext;
    VkDeviceQueueCreateFlags    flags;
    uint32_t                    queueFamilyIndex;
    uint32_t                    queueCount;
    const float*                pQueuePriorities;
} VkDeviceQueueCreateInfo;

struct VkDeviceQueueCreateInfoRAII {
   VkDeviceQueueCreateInfo nonRaiiObj;
    std::vector<float>                          vecQueuePriorities;
};

typedef struct VkDeviceCreateInfo {
    VkStructureType                    sType;
    const void*                        pNext;
    VkDeviceCreateFlags                flags;
    uint32_t                           queueCreateInfoCount;
    const VkDeviceQueueCreateInfo*     pQueueCreateInfos;
    uint32_t                           enabledLayerCount;
    const char* const*                 ppEnabledLayerNames;
    uint32_t                           enabledExtensionCount;
    const char* const*                 ppEnabledExtensionNames;
    const VkPhysicalDeviceFeatures*    pEnabledFeatures;
} VkDeviceCreateInfo;

struct VkDeviceCreateInfoRAII {
   VkDeviceCreateInfo nonRaiiObj;
    std::vector<VkDeviceQueueCreateInfo>        vecQueueCreateInfos;
    std::vector<std::string>                    vecEnabledLayerNames;
    std::vector<const char *>                   vecPtrEnabledLayerNames;
    std::vector<std::string>                    vecEnabledExtensionNames;
    std::vector<const char *>                   vecPtrEnabledExtensionNames;
    std::shared_ptr<VkPhysicalDeviceFeatures>   pEnabledFeatures;
};

typedef struct VkExtensionProperties {
    char        extensionName[VK_MAX_EXTENSION_NAME_SIZE];
    uint32_t    specVersion;
} VkExtensionProperties;

typedef struct VkLayerProperties {
    char        layerName[VK_MAX_EXTENSION_NAME_SIZE];
    uint32_t    specVersion;
    uint32_t    implementationVersion;
    char        description[VK_MAX_DESCRIPTION_SIZE];
} VkLayerProperties;

typedef struct VkSubmitInfo {
    VkStructureType                sType;
    const void*                    pNext;
    uint32_t                       waitSemaphoreCount;
    const VkSemaphore*             pWaitSemaphores;
    const VkPipelineStageFlags*    pWaitDstStageMask;
    uint32_t                       commandBufferCount;
    const VkCommandBuffer*         pCommandBuffers;
    uint32_t                       signalSemaphoreCount;
    const VkSemaphore*             pSignalSemaphores;
} VkSubmitInfo;

struct VkSubmitInfoRAII {
   VkSubmitInfo nonRaiiObj;
    std::vector<VkSemaphore>                    vecWaitSemaphores;
    std::vector<VkPipelineStageFlags>           vecWaitDstStageMask;
    std::vector<VkCommandBuffer>                vecCommandBuffers;
    std::vector<VkSemaphore>                    vecSignalSemaphores;
};

typedef struct VkMemoryAllocateInfo {
    VkStructureType    sType;
    const void*        pNext;
    VkDeviceSize       allocationSize;
    uint32_t           memoryTypeIndex;
} VkMemoryAllocateInfo;

typedef struct VkMappedMemoryRange {
    VkStructureType    sType;
    const void*        pNext;
    VkDeviceMemory     memory;
    VkDeviceSize       offset;
    VkDeviceSize       size;
} VkMappedMemoryRange;

typedef struct VkMemoryRequirements {
    VkDeviceSize    size;
    VkDeviceSize    alignment;
    uint32_t        memoryTypeBits;
} VkMemoryRequirements;

typedef struct VkSparseImageFormatProperties {
    VkImageAspectFlags          aspectMask;
    VkExtent3D                  imageGranularity;
    VkSparseImageFormatFlags    flags;
} VkSparseImageFormatProperties;

typedef struct VkSparseImageMemoryRequirements {
    VkSparseImageFormatProperties    formatProperties;
    uint32_t                         imageMipTailFirstLod;
    VkDeviceSize                     imageMipTailSize;
    VkDeviceSize                     imageMipTailOffset;
    VkDeviceSize                     imageMipTailStride;
} VkSparseImageMemoryRequirements;

typedef struct VkSparseMemoryBind {
    VkDeviceSize               resourceOffset;
    VkDeviceSize               size;
    VkDeviceMemory             memory;
    VkDeviceSize               memoryOffset;
    VkSparseMemoryBindFlags    flags;
} VkSparseMemoryBind;

typedef struct VkSparseBufferMemoryBindInfo {
    VkBuffer                     buffer;
    uint32_t                     bindCount;
    const VkSparseMemoryBind*    pBinds;
} VkSparseBufferMemoryBindInfo;

struct VkSparseBufferMemoryBindInfoRAII {
   VkSparseBufferMemoryBindInfo nonRaiiObj;
    std::vector<VkSparseMemoryBind>             vecBinds;
};

typedef struct VkSparseImageOpaqueMemoryBindInfo {
    VkImage                      image;
    uint32_t                     bindCount;
    const VkSparseMemoryBind*    pBinds;
} VkSparseImageOpaqueMemoryBindInfo;

struct VkSparseImageOpaqueMemoryBindInfoRAII {
   VkSparseImageOpaqueMemoryBindInfo nonRaiiObj;
    std::vector<VkSparseMemoryBind>             vecBinds;
};

typedef struct VkImageSubresource {
    VkImageAspectFlags    aspectMask;
    uint32_t              mipLevel;
    uint32_t              arrayLayer;
} VkImageSubresource;

typedef struct VkOffset3D {
    int32_t    x;
    int32_t    y;
    int32_t    z;
} VkOffset3D;

typedef struct VkSparseImageMemoryBind {
    VkImageSubresource         subresource;
    VkOffset3D                 offset;
    VkExtent3D                 extent;
    VkDeviceMemory             memory;
    VkDeviceSize               memoryOffset;
    VkSparseMemoryBindFlags    flags;
} VkSparseImageMemoryBind;

typedef struct VkSparseImageMemoryBindInfo {
    VkImage                           image;
    uint32_t                          bindCount;
    const VkSparseImageMemoryBind*    pBinds;
} VkSparseImageMemoryBindInfo;

struct VkSparseImageMemoryBindInfoRAII {
   VkSparseImageMemoryBindInfo nonRaiiObj;
    std::vector<VkSparseImageMemoryBind>        vecBinds;
};

typedef struct VkBindSparseInfo {
    VkStructureType                             sType;
    const void*                                 pNext;
    uint32_t                                    waitSemaphoreCount;
    const VkSemaphore*                          pWaitSemaphores;
    uint32_t                                    bufferBindCount;
    const VkSparseBufferMemoryBindInfo*         pBufferBinds;
    uint32_t                                    imageOpaqueBindCount;
    const VkSparseImageOpaqueMemoryBindInfo*    pImageOpaqueBinds;
    uint32_t                                    imageBindCount;
    const VkSparseImageMemoryBindInfo*          pImageBinds;
    uint32_t                                    signalSemaphoreCount;
    const VkSemaphore*                          pSignalSemaphores;
} VkBindSparseInfo;

struct VkBindSparseInfoRAII {
   VkBindSparseInfo nonRaiiObj;
    std::vector<VkSemaphore>                    vecWaitSemaphores;
    std::vector<VkSparseBufferMemoryBindInfo>   vecBufferBinds;
    std::vector<VkSparseImageOpaqueMemoryBindInfo>vecImageOpaqueBinds;
    std::vector<VkSparseImageMemoryBindInfo>    vecImageBinds;
    std::vector<VkSemaphore>                    vecSignalSemaphores;
};

typedef struct VkFenceCreateInfo {
    VkStructureType       sType;
    const void*           pNext;
    VkFenceCreateFlags    flags;
} VkFenceCreateInfo;

typedef struct VkSemaphoreCreateInfo {
    VkStructureType           sType;
    const void*               pNext;
    VkSemaphoreCreateFlags    flags;
} VkSemaphoreCreateInfo;

typedef struct VkEventCreateInfo {
    VkStructureType       sType;
    const void*           pNext;
    VkEventCreateFlags    flags;
} VkEventCreateInfo;

typedef struct VkQueryPoolCreateInfo {
    VkStructureType                  sType;
    const void*                      pNext;
    VkQueryPoolCreateFlags           flags;
    VkQueryType                      queryType;
    uint32_t                         queryCount;
    VkQueryPipelineStatisticFlags    pipelineStatistics;
} VkQueryPoolCreateInfo;

typedef struct VkBufferCreateInfo {
    VkStructureType        sType;
    const void*            pNext;
    VkBufferCreateFlags    flags;
    VkDeviceSize           size;
    VkBufferUsageFlags     usage;
    VkSharingMode          sharingMode;
    uint32_t               queueFamilyIndexCount;
    const uint32_t*        pQueueFamilyIndices;
} VkBufferCreateInfo;

struct VkBufferCreateInfoRAII {
   VkBufferCreateInfo nonRaiiObj;
    std::vector<uint32_t>                       vecQueueFamilyIndices;
};

typedef struct VkBufferViewCreateInfo {
    VkStructureType            sType;
    const void*                pNext;
    VkBufferViewCreateFlags    flags;
    VkBuffer                   buffer;
    VkFormat                   format;
    VkDeviceSize               offset;
    VkDeviceSize               range;
} VkBufferViewCreateInfo;

typedef struct VkImageCreateInfo {
    VkStructureType          sType;
    const void*              pNext;
    VkImageCreateFlags       flags;
    VkImageType              imageType;
    VkFormat                 format;
    VkExtent3D               extent;
    uint32_t                 mipLevels;
    uint32_t                 arrayLayers;
    VkSampleCountFlagBits    samples;
    VkImageTiling            tiling;
    VkImageUsageFlags        usage;
    VkSharingMode            sharingMode;
    uint32_t                 queueFamilyIndexCount;
    const uint32_t*          pQueueFamilyIndices;
    VkImageLayout            initialLayout;
} VkImageCreateInfo;

struct VkImageCreateInfoRAII {
   VkImageCreateInfo nonRaiiObj;
    std::vector<uint32_t>                       vecQueueFamilyIndices;
};

typedef struct VkSubresourceLayout {
    VkDeviceSize    offset;
    VkDeviceSize    size;
    VkDeviceSize    rowPitch;
    VkDeviceSize    arrayPitch;
    VkDeviceSize    depthPitch;
} VkSubresourceLayout;

typedef struct VkComponentMapping {
    VkComponentSwizzle    r;
    VkComponentSwizzle    g;
    VkComponentSwizzle    b;
    VkComponentSwizzle    a;
} VkComponentMapping;

typedef struct VkImageSubresourceRange {
    VkImageAspectFlags    aspectMask;
    uint32_t              baseMipLevel;
    uint32_t              levelCount;
    uint32_t              baseArrayLayer;
    uint32_t              layerCount;
} VkImageSubresourceRange;

typedef struct VkImageViewCreateInfo {
    VkStructureType            sType;
    const void*                pNext;
    VkImageViewCreateFlags     flags;
    VkImage                    image;
    VkImageViewType            viewType;
    VkFormat                   format;
    VkComponentMapping         components;
    VkImageSubresourceRange    subresourceRange;
} VkImageViewCreateInfo;

typedef struct VkShaderModuleCreateInfo {
    VkStructureType              sType;
    const void*                  pNext;
    VkShaderModuleCreateFlags    flags;
    size_t                       codeSize;
    const uint32_t*              pCode;
} VkShaderModuleCreateInfo;

struct VkShaderModuleCreateInfoRAII {
   VkShaderModuleCreateInfo nonRaiiObj;
    std::vector<uint32_t>                       vecCode;
};

typedef struct VkPipelineCacheCreateInfo {
    VkStructureType               sType;
    const void*                   pNext;
    VkPipelineCacheCreateFlags    flags;
    size_t                        initialDataSize;
    const void*                   pInitialData;
} VkPipelineCacheCreateInfo;

struct VkPipelineCacheCreateInfoRAII {
   VkPipelineCacheCreateInfo nonRaiiObj;
    std::vector<uint8_t>                        vecInitialData;
};

typedef struct VkSpecializationMapEntry {
    uint32_t    constantID;
    uint32_t    offset;
    size_t      size;
} VkSpecializationMapEntry;

typedef struct VkSpecializationInfo {
    uint32_t                           mapEntryCount;
    const VkSpecializationMapEntry*    pMapEntries;
    size_t                             dataSize;
    const void*                        pData;
} VkSpecializationInfo;

struct VkSpecializationInfoRAII {
   VkSpecializationInfo nonRaiiObj;
    std::vector<VkSpecializationMapEntry>       vecMapEntries;
    std::vector<uint8_t>                        vecData;
};

typedef struct VkPipelineShaderStageCreateInfo {
    VkStructureType                     sType;
    const void*                         pNext;
    VkPipelineShaderStageCreateFlags    flags;
    VkShaderStageFlagBits               stage;
    VkShaderModule                      module;
    const char*                         pName;
    const VkSpecializationInfo*         pSpecializationInfo;
} VkPipelineShaderStageCreateInfo;

struct VkPipelineShaderStageCreateInfoRAII {
   VkPipelineShaderStageCreateInfo nonRaiiObj;
    std::string                                 strName;
    std::shared_ptr<VkSpecializationInfoRAII>   pSpecializationInfo;
};

typedef struct VkVertexInputBindingDescription {
    uint32_t             binding;
    uint32_t             stride;
    VkVertexInputRate    inputRate;
} VkVertexInputBindingDescription;

typedef struct VkVertexInputAttributeDescription {
    uint32_t    location;
    uint32_t    binding;
    VkFormat    format;
    uint32_t    offset;
} VkVertexInputAttributeDescription;

typedef struct VkPipelineVertexInputStateCreateInfo {
    VkStructureType                             sType;
    const void*                                 pNext;
    VkPipelineVertexInputStateCreateFlags       flags;
    uint32_t                                    vertexBindingDescriptionCount;
    const VkVertexInputBindingDescription*      pVertexBindingDescriptions;
    uint32_t                                    vertexAttributeDescriptionCount;
    const VkVertexInputAttributeDescription*    pVertexAttributeDescriptions;
} VkPipelineVertexInputStateCreateInfo;

struct VkPipelineVertexInputStateCreateInfoRAII {
   VkPipelineVertexInputStateCreateInfo nonRaiiObj;
    std::vector<VkVertexInputBindingDescription>vecVertexBindingDescriptions;
    std::vector<VkVertexInputAttributeDescription>vecVertexAttributeDescriptions;
};

typedef struct VkPipelineInputAssemblyStateCreateInfo {
    VkStructureType                            sType;
    const void*                                pNext;
    VkPipelineInputAssemblyStateCreateFlags    flags;
    VkPrimitiveTopology                        topology;
    VkBool32                                   primitiveRestartEnable;
} VkPipelineInputAssemblyStateCreateInfo;

typedef struct VkPipelineTessellationStateCreateInfo {
    VkStructureType                           sType;
    const void*                               pNext;
    VkPipelineTessellationStateCreateFlags    flags;
    uint32_t                                  patchControlPoints;
} VkPipelineTessellationStateCreateInfo;

typedef struct VkViewport {
    float    x;
    float    y;
    float    width;
    float    height;
    float    minDepth;
    float    maxDepth;
} VkViewport;

typedef struct VkOffset2D {
    int32_t    x;
    int32_t    y;
} VkOffset2D;

typedef struct VkExtent2D {
    uint32_t    width;
    uint32_t    height;
} VkExtent2D;

typedef struct VkRect2D {
    VkOffset2D    offset;
    VkExtent2D    extent;
} VkRect2D;

typedef struct VkPipelineViewportStateCreateInfo {
    VkStructureType                       sType;
    const void*                           pNext;
    VkPipelineViewportStateCreateFlags    flags;
    uint32_t                              viewportCount;
    const VkViewport*                     pViewports;
    uint32_t                              scissorCount;
    const VkRect2D*                       pScissors;
} VkPipelineViewportStateCreateInfo;

struct VkPipelineViewportStateCreateInfoRAII {
   VkPipelineViewportStateCreateInfo nonRaiiObj;
    std::vector<VkViewport>                     vecViewports;
    std::vector<VkRect2D>                       vecScissors;
};

typedef struct VkPipelineRasterizationStateCreateInfo {
    VkStructureType                            sType;
    const void*                                pNext;
    VkPipelineRasterizationStateCreateFlags    flags;
    VkBool32                                   depthClampEnable;
    VkBool32                                   rasterizerDiscardEnable;
    VkPolygonMode                              polygonMode;
    VkCullModeFlags                            cullMode;
    VkFrontFace                                frontFace;
    VkBool32                                   depthBiasEnable;
    float                                      depthBiasConstantFactor;
    float                                      depthBiasClamp;
    float                                      depthBiasSlopeFactor;
    float                                      lineWidth;
} VkPipelineRasterizationStateCreateInfo;

typedef struct VkPipelineMultisampleStateCreateInfo {
    VkStructureType                          sType;
    const void*                              pNext;
    VkPipelineMultisampleStateCreateFlags    flags;
    VkSampleCountFlagBits                    rasterizationSamples;
    VkBool32                                 sampleShadingEnable;
    float                                    minSampleShading;
    const VkSampleMask*                      pSampleMask;
    VkBool32                                 alphaToCoverageEnable;
    VkBool32                                 alphaToOneEnable;
} VkPipelineMultisampleStateCreateInfo;

typedef struct VkStencilOpState {
    VkStencilOp    failOp;
    VkStencilOp    passOp;
    VkStencilOp    depthFailOp;
    VkCompareOp    compareOp;
    uint32_t       compareMask;
    uint32_t       writeMask;
    uint32_t       reference;
} VkStencilOpState;

typedef struct VkPipelineDepthStencilStateCreateInfo {
    VkStructureType                           sType;
    const void*                               pNext;
    VkPipelineDepthStencilStateCreateFlags    flags;
    VkBool32                                  depthTestEnable;
    VkBool32                                  depthWriteEnable;
    VkCompareOp                               depthCompareOp;
    VkBool32                                  depthBoundsTestEnable;
    VkBool32                                  stencilTestEnable;
    VkStencilOpState                          front;
    VkStencilOpState                          back;
    float                                     minDepthBounds;
    float                                     maxDepthBounds;
} VkPipelineDepthStencilStateCreateInfo;

typedef struct VkPipelineColorBlendAttachmentState {
    VkBool32                 blendEnable;
    VkBlendFactor            srcColorBlendFactor;
    VkBlendFactor            dstColorBlendFactor;
    VkBlendOp                colorBlendOp;
    VkBlendFactor            srcAlphaBlendFactor;
    VkBlendFactor            dstAlphaBlendFactor;
    VkBlendOp                alphaBlendOp;
    VkColorComponentFlags    colorWriteMask;
} VkPipelineColorBlendAttachmentState;

typedef struct VkPipelineColorBlendStateCreateInfo {
    VkStructureType                               sType;
    const void*                                   pNext;
    VkPipelineColorBlendStateCreateFlags          flags;
    VkBool32                                      logicOpEnable;
    VkLogicOp                                     logicOp;
    uint32_t                                      attachmentCount;
    const VkPipelineColorBlendAttachmentState*    pAttachments;
    float                                         blendConstants[4];
} VkPipelineColorBlendStateCreateInfo;

struct VkPipelineColorBlendStateCreateInfoRAII {
   VkPipelineColorBlendStateCreateInfo nonRaiiObj;
    std::vector<VkPipelineColorBlendAttachmentState>vecAttachments;
};

typedef struct VkPipelineDynamicStateCreateInfo {
    VkStructureType                      sType;
    const void*                          pNext;
    VkPipelineDynamicStateCreateFlags    flags;
    uint32_t                             dynamicStateCount;
    const VkDynamicState*                pDynamicStates;
} VkPipelineDynamicStateCreateInfo;

struct VkPipelineDynamicStateCreateInfoRAII {
   VkPipelineDynamicStateCreateInfo nonRaiiObj;
    std::vector<VkDynamicState>                 vecDynamicStates;
};

typedef struct VkGraphicsPipelineCreateInfo {
    VkStructureType                                  sType;
    const void*                                      pNext;
    VkPipelineCreateFlags                            flags;
    uint32_t                                         stageCount;
    const VkPipelineShaderStageCreateInfo*           pStages;
    const VkPipelineVertexInputStateCreateInfo*      pVertexInputState;
    const VkPipelineInputAssemblyStateCreateInfo*    pInputAssemblyState;
    const VkPipelineTessellationStateCreateInfo*     pTessellationState;
    const VkPipelineViewportStateCreateInfo*         pViewportState;
    const VkPipelineRasterizationStateCreateInfo*    pRasterizationState;
    const VkPipelineMultisampleStateCreateInfo*      pMultisampleState;
    const VkPipelineDepthStencilStateCreateInfo*     pDepthStencilState;
    const VkPipelineColorBlendStateCreateInfo*       pColorBlendState;
    const VkPipelineDynamicStateCreateInfo*          pDynamicState;
    VkPipelineLayout                                 layout;
    VkRenderPass                                     renderPass;
    uint32_t                                         subpass;
    VkPipeline                                       basePipelineHandle;
    int32_t                                          basePipelineIndex;
} VkGraphicsPipelineCreateInfo;

struct VkGraphicsPipelineCreateInfoRAII {
   VkGraphicsPipelineCreateInfo nonRaiiObj;
    std::vector<VkPipelineShaderStageCreateInfo>vecStages;
    std::shared_ptr<VkPipelineVertexInputStateCreateInfoRAII>pVertexInputState;
    std::shared_ptr<VkPipelineInputAssemblyStateCreateInfo>pInputAssemblyState;
    std::shared_ptr<VkPipelineTessellationStateCreateInfo>pTessellationState;
    std::shared_ptr<VkPipelineViewportStateCreateInfoRAII>pViewportState;
    std::shared_ptr<VkPipelineRasterizationStateCreateInfo>pRasterizationState;
    std::shared_ptr<VkPipelineMultisampleStateCreateInfo>pMultisampleState;
    std::shared_ptr<VkPipelineDepthStencilStateCreateInfo>pDepthStencilState;
    std::shared_ptr<VkPipelineColorBlendStateCreateInfoRAII>pColorBlendState;
    std::shared_ptr<VkPipelineDynamicStateCreateInfoRAII>pDynamicState;
};

typedef struct VkComputePipelineCreateInfo {
    VkStructureType                    sType;
    const void*                        pNext;
    VkPipelineCreateFlags              flags;
    VkPipelineShaderStageCreateInfo    stage;
    VkPipelineLayout                   layout;
    VkPipeline                         basePipelineHandle;
    int32_t                            basePipelineIndex;
} VkComputePipelineCreateInfo;

typedef struct VkPushConstantRange {
    VkShaderStageFlags    stageFlags;
    uint32_t              offset;
    uint32_t              size;
} VkPushConstantRange;

typedef struct VkPipelineLayoutCreateInfo {
    VkStructureType                 sType;
    const void*                     pNext;
    VkPipelineLayoutCreateFlags     flags;
    uint32_t                        setLayoutCount;
    const VkDescriptorSetLayout*    pSetLayouts;
    uint32_t                        pushConstantRangeCount;
    const VkPushConstantRange*      pPushConstantRanges;
} VkPipelineLayoutCreateInfo;

struct VkPipelineLayoutCreateInfoRAII {
   VkPipelineLayoutCreateInfo nonRaiiObj;
    std::vector<VkDescriptorSetLayout>          vecSetLayouts;
    std::vector<VkPushConstantRange>            vecPushConstantRanges;
};

typedef struct VkSamplerCreateInfo {
    VkStructureType         sType;
    const void*             pNext;
    VkSamplerCreateFlags    flags;
    VkFilter                magFilter;
    VkFilter                minFilter;
    VkSamplerMipmapMode     mipmapMode;
    VkSamplerAddressMode    addressModeU;
    VkSamplerAddressMode    addressModeV;
    VkSamplerAddressMode    addressModeW;
    float                   mipLodBias;
    VkBool32                anisotropyEnable;
    float                   maxAnisotropy;
    VkBool32                compareEnable;
    VkCompareOp             compareOp;
    float                   minLod;
    float                   maxLod;
    VkBorderColor           borderColor;
    VkBool32                unnormalizedCoordinates;
} VkSamplerCreateInfo;

typedef struct VkDescriptorSetLayoutBinding {
    uint32_t              binding;
    VkDescriptorType      descriptorType;
    uint32_t              descriptorCount;
    VkShaderStageFlags    stageFlags;
    const VkSampler*      pImmutableSamplers;
} VkDescriptorSetLayoutBinding;

struct VkDescriptorSetLayoutBindingRAII {
   VkDescriptorSetLayoutBinding nonRaiiObj;
    std::vector<VkSampler>                      vecImmutableSamplers;
};

typedef struct VkDescriptorSetLayoutCreateInfo {
    VkStructureType                        sType;
    const void*                            pNext;
    VkDescriptorSetLayoutCreateFlags       flags;
    uint32_t                               bindingCount;
    const VkDescriptorSetLayoutBinding*    pBindings;
} VkDescriptorSetLayoutCreateInfo;

struct VkDescriptorSetLayoutCreateInfoRAII {
   VkDescriptorSetLayoutCreateInfo nonRaiiObj;
    std::vector<VkDescriptorSetLayoutBinding>   vecBindings;
};

typedef struct VkDescriptorPoolSize {
    VkDescriptorType    type;
    uint32_t            descriptorCount;
} VkDescriptorPoolSize;

typedef struct VkDescriptorPoolCreateInfo {
    VkStructureType                sType;
    const void*                    pNext;
    VkDescriptorPoolCreateFlags    flags;
    uint32_t                       maxSets;
    uint32_t                       poolSizeCount;
    const VkDescriptorPoolSize*    pPoolSizes;
} VkDescriptorPoolCreateInfo;

struct VkDescriptorPoolCreateInfoRAII {
   VkDescriptorPoolCreateInfo nonRaiiObj;
    std::vector<VkDescriptorPoolSize>           vecPoolSizes;
};

typedef struct VkDescriptorSetAllocateInfo {
    VkStructureType                 sType;
    const void*                     pNext;
    VkDescriptorPool                descriptorPool;
    uint32_t                        descriptorSetCount;
    const VkDescriptorSetLayout*    pSetLayouts;
} VkDescriptorSetAllocateInfo;

struct VkDescriptorSetAllocateInfoRAII {
   VkDescriptorSetAllocateInfo nonRaiiObj;
    std::vector<VkDescriptorSetLayout>          vecSetLayouts;
};

typedef struct VkDescriptorImageInfo {
    VkSampler        sampler;
    VkImageView      imageView;
    VkImageLayout    imageLayout;
} VkDescriptorImageInfo;

typedef struct VkDescriptorBufferInfo {
    VkBuffer        buffer;
    VkDeviceSize    offset;
    VkDeviceSize    range;
} VkDescriptorBufferInfo;

typedef struct VkWriteDescriptorSet {
    VkStructureType                  sType;
    const void*                      pNext;
    VkDescriptorSet                  dstSet;
    uint32_t                         dstBinding;
    uint32_t                         dstArrayElement;
    uint32_t                         descriptorCount;
    VkDescriptorType                 descriptorType;
    const VkDescriptorImageInfo*     pImageInfo;
    const VkDescriptorBufferInfo*    pBufferInfo;
    const VkBufferView*              pTexelBufferView;
} VkWriteDescriptorSet;

struct VkWriteDescriptorSetRAII {
   VkWriteDescriptorSet nonRaiiObj;
    std::vector<VkDescriptorImageInfo>          vecImageInfo;
    std::vector<VkDescriptorBufferInfo>         vecBufferInfo;
    std::vector<VkBufferView>                   vecTexelBufferView;
};

typedef struct VkCopyDescriptorSet {
    VkStructureType    sType;
    const void*        pNext;
    VkDescriptorSet    srcSet;
    uint32_t           srcBinding;
    uint32_t           srcArrayElement;
    VkDescriptorSet    dstSet;
    uint32_t           dstBinding;
    uint32_t           dstArrayElement;
    uint32_t           descriptorCount;
} VkCopyDescriptorSet;

typedef struct VkFramebufferCreateInfo {
    VkStructureType             sType;
    const void*                 pNext;
    VkFramebufferCreateFlags    flags;
    VkRenderPass                renderPass;
    uint32_t                    attachmentCount;
    const VkImageView*          pAttachments;
    uint32_t                    width;
    uint32_t                    height;
    uint32_t                    layers;
} VkFramebufferCreateInfo;

struct VkFramebufferCreateInfoRAII {
   VkFramebufferCreateInfo nonRaiiObj;
    std::vector<VkImageView>                    vecAttachments;
};

typedef struct VkAttachmentDescription {
    VkAttachmentDescriptionFlags    flags;
    VkFormat                        format;
    VkSampleCountFlagBits           samples;
    VkAttachmentLoadOp              loadOp;
    VkAttachmentStoreOp             storeOp;
    VkAttachmentLoadOp              stencilLoadOp;
    VkAttachmentStoreOp             stencilStoreOp;
    VkImageLayout                   initialLayout;
    VkImageLayout                   finalLayout;
} VkAttachmentDescription;

typedef struct VkAttachmentReference {
    uint32_t         attachment;
    VkImageLayout    layout;
} VkAttachmentReference;

typedef struct VkSubpassDescription {
    VkSubpassDescriptionFlags       flags;
    VkPipelineBindPoint             pipelineBindPoint;
    uint32_t                        inputAttachmentCount;
    const VkAttachmentReference*    pInputAttachments;
    uint32_t                        colorAttachmentCount;
    const VkAttachmentReference*    pColorAttachments;
    const VkAttachmentReference*    pResolveAttachments;
    const VkAttachmentReference*    pDepthStencilAttachment;
    uint32_t                        preserveAttachmentCount;
    const uint32_t*                 pPreserveAttachments;
} VkSubpassDescription;

struct VkSubpassDescriptionRAII {
   VkSubpassDescription nonRaiiObj;
    std::vector<VkAttachmentReference>          vecInputAttachments;
    std::vector<VkAttachmentReference>          vecColorAttachments;
    std::vector<VkAttachmentReference>          vecResolveAttachments;
    std::shared_ptr<VkAttachmentReference>      pDepthStencilAttachment;
    std::vector<uint32_t>                       vecPreserveAttachments;
};

typedef struct VkSubpassDependency {
    uint32_t                srcSubpass;
    uint32_t                dstSubpass;
    VkPipelineStageFlags    srcStageMask;
    VkPipelineStageFlags    dstStageMask;
    VkAccessFlags           srcAccessMask;
    VkAccessFlags           dstAccessMask;
    VkDependencyFlags       dependencyFlags;
} VkSubpassDependency;

typedef struct VkRenderPassCreateInfo {
    VkStructureType                   sType;
    const void*                       pNext;
    VkRenderPassCreateFlags           flags;
    uint32_t                          attachmentCount;
    const VkAttachmentDescription*    pAttachments;
    uint32_t                          subpassCount;
    const VkSubpassDescription*       pSubpasses;
    uint32_t                          dependencyCount;
    const VkSubpassDependency*        pDependencies;
} VkRenderPassCreateInfo;

struct VkRenderPassCreateInfoRAII {
   VkRenderPassCreateInfo nonRaiiObj;
    std::vector<VkAttachmentDescription>        vecAttachments;
    std::vector<VkSubpassDescription>           vecSubpasses;
    std::vector<VkSubpassDependency>            vecDependencies;
};

typedef struct VkCommandPoolCreateInfo {
    VkStructureType             sType;
    const void*                 pNext;
    VkCommandPoolCreateFlags    flags;
    uint32_t                    queueFamilyIndex;
} VkCommandPoolCreateInfo;

typedef struct VkCommandBufferAllocateInfo {
    VkStructureType         sType;
    const void*             pNext;
    VkCommandPool           commandPool;
    VkCommandBufferLevel    level;
    uint32_t                commandBufferCount;
} VkCommandBufferAllocateInfo;

typedef struct VkCommandBufferInheritanceInfo {
    VkStructureType                  sType;
    const void*                      pNext;
    VkRenderPass                     renderPass;
    uint32_t                         subpass;
    VkFramebuffer                    framebuffer;
    VkBool32                         occlusionQueryEnable;
    VkQueryControlFlags              queryFlags;
    VkQueryPipelineStatisticFlags    pipelineStatistics;
} VkCommandBufferInheritanceInfo;

typedef struct VkCommandBufferBeginInfo {
    VkStructureType                          sType;
    const void*                              pNext;
    VkCommandBufferUsageFlags                flags;
    const VkCommandBufferInheritanceInfo*    pInheritanceInfo;
} VkCommandBufferBeginInfo;

struct VkCommandBufferBeginInfoRAII {
   VkCommandBufferBeginInfo nonRaiiObj;
    std::shared_ptr<VkCommandBufferInheritanceInfo>pInheritanceInfo;
};

typedef struct VkBufferCopy {
    VkDeviceSize    srcOffset;
    VkDeviceSize    dstOffset;
    VkDeviceSize    size;
} VkBufferCopy;

typedef struct VkImageSubresourceLayers {
    VkImageAspectFlags    aspectMask;
    uint32_t              mipLevel;
    uint32_t              baseArrayLayer;
    uint32_t              layerCount;
} VkImageSubresourceLayers;

typedef struct VkImageCopy {
    VkImageSubresourceLayers    srcSubresource;
    VkOffset3D                  srcOffset;
    VkImageSubresourceLayers    dstSubresource;
    VkOffset3D                  dstOffset;
    VkExtent3D                  extent;
} VkImageCopy;

typedef struct VkImageBlit {
    VkImageSubresourceLayers    srcSubresource;
    VkOffset3D                  srcOffsets[2];
    VkImageSubresourceLayers    dstSubresource;
    VkOffset3D                  dstOffsets[2];
} VkImageBlit;

typedef struct VkBufferImageCopy {
    VkDeviceSize                bufferOffset;
    uint32_t                    bufferRowLength;
    uint32_t                    bufferImageHeight;
    VkImageSubresourceLayers    imageSubresource;
    VkOffset3D                  imageOffset;
    VkExtent3D                  imageExtent;
} VkBufferImageCopy;

typedef union VkClearColorValue {
    float       float32[4];
    int32_t     int32[4];
    uint32_t    uint32[4];
} VkClearColorValue;

typedef struct VkClearDepthStencilValue {
    float       depth;
    uint32_t    stencil;
} VkClearDepthStencilValue;

typedef union VkClearValue {
    VkClearColorValue           color;
    VkClearDepthStencilValue    depthStencil;
} VkClearValue;

typedef struct VkClearAttachment {
    VkImageAspectFlags    aspectMask;
    uint32_t              colorAttachment;
    VkClearValue          clearValue;
} VkClearAttachment;

typedef struct VkClearRect {
    VkRect2D    rect;
    uint32_t    baseArrayLayer;
    uint32_t    layerCount;
} VkClearRect;

typedef struct VkImageResolve {
    VkImageSubresourceLayers    srcSubresource;
    VkOffset3D                  srcOffset;
    VkImageSubresourceLayers    dstSubresource;
    VkOffset3D                  dstOffset;
    VkExtent3D                  extent;
} VkImageResolve;

typedef struct VkMemoryBarrier {
    VkStructureType    sType;
    const void*        pNext;
    VkAccessFlags      srcAccessMask;
    VkAccessFlags      dstAccessMask;
} VkMemoryBarrier;

typedef struct VkBufferMemoryBarrier {
    VkStructureType    sType;
    const void*        pNext;
    VkAccessFlags      srcAccessMask;
    VkAccessFlags      dstAccessMask;
    uint32_t           srcQueueFamilyIndex;
    uint32_t           dstQueueFamilyIndex;
    VkBuffer           buffer;
    VkDeviceSize       offset;
    VkDeviceSize       size;
} VkBufferMemoryBarrier;

typedef struct VkImageMemoryBarrier {
    VkStructureType            sType;
    const void*                pNext;
    VkAccessFlags              srcAccessMask;
    VkAccessFlags              dstAccessMask;
    VkImageLayout              oldLayout;
    VkImageLayout              newLayout;
    uint32_t                   srcQueueFamilyIndex;
    uint32_t                   dstQueueFamilyIndex;
    VkImage                    image;
    VkImageSubresourceRange    subresourceRange;
} VkImageMemoryBarrier;

typedef struct VkRenderPassBeginInfo {
    VkStructureType        sType;
    const void*            pNext;
    VkRenderPass           renderPass;
    VkFramebuffer          framebuffer;
    VkRect2D               renderArea;
    uint32_t               clearValueCount;
    const VkClearValue*    pClearValues;
} VkRenderPassBeginInfo;

struct VkRenderPassBeginInfoRAII {
   VkRenderPassBeginInfo nonRaiiObj;
    std::vector<VkClearValue>                   vecClearValues;
};

typedef struct VkDispatchIndirectCommand {
    uint32_t    x;
    uint32_t    y;
    uint32_t    z;
} VkDispatchIndirectCommand;

typedef struct VkDrawIndexedIndirectCommand {
    uint32_t    indexCount;
    uint32_t    instanceCount;
    uint32_t    firstIndex;
    int32_t     vertexOffset;
    uint32_t    firstInstance;
} VkDrawIndexedIndirectCommand;

typedef struct VkDrawIndirectCommand {
    uint32_t    vertexCount;
    uint32_t    instanceCount;
    uint32_t    firstVertex;
    uint32_t    firstInstance;
} VkDrawIndirectCommand;

typedef VkResult (VKAPI_PTR *PFN_vkCreateInstance)(const VkInstanceCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkInstance* pInstance);
typedef void (VKAPI_PTR *PFN_vkDestroyInstance)(VkInstance instance, const VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkEnumeratePhysicalDevices)(VkInstance instance, uint32_t* pPhysicalDeviceCount, VkPhysicalDevice* pPhysicalDevices);
typedef void (VKAPI_PTR *PFN_vkGetPhysicalDeviceFeatures)(VkPhysicalDevice physicalDevice, VkPhysicalDeviceFeatures* pFeatures);
typedef void (VKAPI_PTR *PFN_vkGetPhysicalDeviceFormatProperties)(VkPhysicalDevice physicalDevice, VkFormat format, VkFormatProperties* pFormatProperties);
typedef VkResult (VKAPI_PTR *PFN_vkGetPhysicalDeviceImageFormatProperties)(VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type, VkImageTiling tiling, VkImageUsageFlags usage, VkImageCreateFlags flags, VkImageFormatProperties* pImageFormatProperties);
typedef void (VKAPI_PTR *PFN_vkGetPhysicalDeviceProperties)(VkPhysicalDevice physicalDevice, VkPhysicalDeviceProperties* pProperties);
typedef void (VKAPI_PTR *PFN_vkGetPhysicalDeviceQueueFamilyProperties)(VkPhysicalDevice physicalDevice, uint32_t* pQueueFamilyPropertyCount, VkQueueFamilyProperties* pQueueFamilyProperties);
typedef void (VKAPI_PTR *PFN_vkGetPhysicalDeviceMemoryProperties)(VkPhysicalDevice physicalDevice, VkPhysicalDeviceMemoryProperties* pMemoryProperties);
typedef VkResult (VKAPI_PTR *PFN_vkCreateDevice)(VkPhysicalDevice physicalDevice, const VkDeviceCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkDevice* pDevice);
typedef void (VKAPI_PTR *PFN_vkDestroyDevice)(VkDevice device, const VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkEnumerateInstanceExtensionProperties)(const char* pLayerName, uint32_t* pPropertyCount, VkExtensionProperties* pProperties);
typedef VkResult (VKAPI_PTR *PFN_vkEnumerateDeviceExtensionProperties)(VkPhysicalDevice physicalDevice, const char* pLayerName, uint32_t* pPropertyCount, VkExtensionProperties* pProperties);
typedef VkResult (VKAPI_PTR *PFN_vkEnumerateInstanceLayerProperties)(uint32_t* pPropertyCount, VkLayerProperties* pProperties);
typedef VkResult (VKAPI_PTR *PFN_vkEnumerateDeviceLayerProperties)(VkPhysicalDevice physicalDevice, uint32_t* pPropertyCount, VkLayerProperties* pProperties);
typedef void (VKAPI_PTR *PFN_vkGetDeviceQueue)(VkDevice device, uint32_t queueFamilyIndex, uint32_t queueIndex, VkQueue* pQueue);
typedef VkResult (VKAPI_PTR *PFN_vkQueueSubmit)(VkQueue queue, uint32_t submitCount, const VkSubmitInfo* pSubmits, VkFence fence);
typedef VkResult (VKAPI_PTR *PFN_vkQueueWaitIdle)(VkQueue queue);
typedef VkResult (VKAPI_PTR *PFN_vkDeviceWaitIdle)(VkDevice device);
typedef VkResult (VKAPI_PTR *PFN_vkAllocateMemory)(VkDevice device, const VkMemoryAllocateInfo* pAllocateInfo, const VkAllocationCallbacks* pAllocator, VkDeviceMemory* pMemory);
typedef void (VKAPI_PTR *PFN_vkFreeMemory)(VkDevice device, VkDeviceMemory memory, const VkAllocationCallbacks* pAllocator);
typedef void (VKAPI_PTR *PFN_vkUnmapMemory)(VkDevice device, VkDeviceMemory memory);
typedef VkResult (VKAPI_PTR *PFN_vkFlushMappedMemoryRanges)(VkDevice device, uint32_t memoryRangeCount, const VkMappedMemoryRange* pMemoryRanges);
typedef VkResult (VKAPI_PTR *PFN_vkInvalidateMappedMemoryRanges)(VkDevice device, uint32_t memoryRangeCount, const VkMappedMemoryRange* pMemoryRanges);
typedef void (VKAPI_PTR *PFN_vkGetDeviceMemoryCommitment)(VkDevice device, VkDeviceMemory memory, VkDeviceSize* pCommittedMemoryInBytes);
typedef VkResult (VKAPI_PTR *PFN_vkBindBufferMemory)(VkDevice device, VkBuffer buffer, VkDeviceMemory memory, VkDeviceSize memoryOffset);
typedef VkResult (VKAPI_PTR *PFN_vkBindImageMemory)(VkDevice device, VkImage image, VkDeviceMemory memory, VkDeviceSize memoryOffset);
typedef void (VKAPI_PTR *PFN_vkGetBufferMemoryRequirements)(VkDevice device, VkBuffer buffer, VkMemoryRequirements* pMemoryRequirements);
typedef void (VKAPI_PTR *PFN_vkGetImageMemoryRequirements)(VkDevice device, VkImage image, VkMemoryRequirements* pMemoryRequirements);
typedef void (VKAPI_PTR *PFN_vkGetImageSparseMemoryRequirements)(VkDevice device, VkImage image, uint32_t* pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements* pSparseMemoryRequirements);
typedef void (VKAPI_PTR *PFN_vkGetPhysicalDeviceSparseImageFormatProperties)(VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type, VkSampleCountFlagBits samples, VkImageUsageFlags usage, VkImageTiling tiling, uint32_t* pPropertyCount, VkSparseImageFormatProperties* pProperties);
typedef VkResult (VKAPI_PTR *PFN_vkQueueBindSparse)(VkQueue queue, uint32_t bindInfoCount, const VkBindSparseInfo* pBindInfo, VkFence fence);
typedef VkResult (VKAPI_PTR *PFN_vkCreateFence)(VkDevice device, const VkFenceCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkFence* pFence);
typedef void (VKAPI_PTR *PFN_vkDestroyFence)(VkDevice device, VkFence fence, const VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkResetFences)(VkDevice device, uint32_t fenceCount, const VkFence* pFences);
typedef VkResult (VKAPI_PTR *PFN_vkGetFenceStatus)(VkDevice device, VkFence fence);
typedef VkResult (VKAPI_PTR *PFN_vkWaitForFences)(VkDevice device, uint32_t fenceCount, const VkFence* pFences, VkBool32 waitAll, uint64_t timeout);
typedef VkResult (VKAPI_PTR *PFN_vkCreateSemaphore)(VkDevice device, const VkSemaphoreCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSemaphore* pSemaphore);
typedef void (VKAPI_PTR *PFN_vkDestroySemaphore)(VkDevice device, VkSemaphore semaphore, const VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkCreateEvent)(VkDevice device, const VkEventCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkEvent* pEvent);
typedef void (VKAPI_PTR *PFN_vkDestroyEvent)(VkDevice device, VkEvent event, const VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkGetEventStatus)(VkDevice device, VkEvent event);
typedef VkResult (VKAPI_PTR *PFN_vkSetEvent)(VkDevice device, VkEvent event);
typedef VkResult (VKAPI_PTR *PFN_vkResetEvent)(VkDevice device, VkEvent event);
typedef VkResult (VKAPI_PTR *PFN_vkCreateQueryPool)(VkDevice device, const VkQueryPoolCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkQueryPool* pQueryPool);
typedef void (VKAPI_PTR *PFN_vkDestroyQueryPool)(VkDevice device, VkQueryPool queryPool, const VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkGetQueryPoolResults)(VkDevice device, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount, size_t dataSize, void* pData, VkDeviceSize stride, VkQueryResultFlags flags);
typedef VkResult (VKAPI_PTR *PFN_vkCreateBuffer)(VkDevice device, const VkBufferCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkBuffer* pBuffer);
typedef void (VKAPI_PTR *PFN_vkDestroyBuffer)(VkDevice device, VkBuffer buffer, const VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkCreateBufferView)(VkDevice device, const VkBufferViewCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkBufferView* pView);
typedef void (VKAPI_PTR *PFN_vkDestroyBufferView)(VkDevice device, VkBufferView bufferView, const VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkCreateImage)(VkDevice device, const VkImageCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkImage* pImage);
typedef void (VKAPI_PTR *PFN_vkDestroyImage)(VkDevice device, VkImage image, const VkAllocationCallbacks* pAllocator);
typedef void (VKAPI_PTR *PFN_vkGetImageSubresourceLayout)(VkDevice device, VkImage image, const VkImageSubresource* pSubresource, VkSubresourceLayout* pLayout);
typedef VkResult (VKAPI_PTR *PFN_vkCreateImageView)(VkDevice device, const VkImageViewCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkImageView* pView);
typedef void (VKAPI_PTR *PFN_vkDestroyImageView)(VkDevice device, VkImageView imageView, const VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkCreateShaderModule)(VkDevice device, const VkShaderModuleCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkShaderModule* pShaderModule);
typedef void (VKAPI_PTR *PFN_vkDestroyShaderModule)(VkDevice device, VkShaderModule shaderModule, const VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkCreatePipelineCache)(VkDevice device, const VkPipelineCacheCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkPipelineCache* pPipelineCache);
typedef void (VKAPI_PTR *PFN_vkDestroyPipelineCache)(VkDevice device, VkPipelineCache pipelineCache, const VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkGetPipelineCacheData)(VkDevice device, VkPipelineCache pipelineCache, size_t* pDataSize, void* pData);
typedef VkResult (VKAPI_PTR *PFN_vkMergePipelineCaches)(VkDevice device, VkPipelineCache dstCache, uint32_t srcCacheCount, const VkPipelineCache* pSrcCaches);
typedef VkResult (VKAPI_PTR *PFN_vkCreateGraphicsPipelines)(VkDevice device, VkPipelineCache pipelineCache, uint32_t createInfoCount, const VkGraphicsPipelineCreateInfo* pCreateInfos, const VkAllocationCallbacks* pAllocator, VkPipeline* pPipelines);
typedef VkResult (VKAPI_PTR *PFN_vkCreateComputePipelines)(VkDevice device, VkPipelineCache pipelineCache, uint32_t createInfoCount, const VkComputePipelineCreateInfo* pCreateInfos, const VkAllocationCallbacks* pAllocator, VkPipeline* pPipelines);
typedef void (VKAPI_PTR *PFN_vkDestroyPipeline)(VkDevice device, VkPipeline pipeline, const VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkCreatePipelineLayout)(VkDevice device, const VkPipelineLayoutCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkPipelineLayout* pPipelineLayout);
typedef void (VKAPI_PTR *PFN_vkDestroyPipelineLayout)(VkDevice device, VkPipelineLayout pipelineLayout, const VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkCreateSampler)(VkDevice device, const VkSamplerCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSampler* pSampler);
typedef void (VKAPI_PTR *PFN_vkDestroySampler)(VkDevice device, VkSampler sampler, const VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkCreateDescriptorSetLayout)(VkDevice device, const VkDescriptorSetLayoutCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkDescriptorSetLayout* pSetLayout);
typedef void (VKAPI_PTR *PFN_vkDestroyDescriptorSetLayout)(VkDevice device, VkDescriptorSetLayout descriptorSetLayout, const VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkCreateDescriptorPool)(VkDevice device, const VkDescriptorPoolCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkDescriptorPool* pDescriptorPool);
typedef void (VKAPI_PTR *PFN_vkDestroyDescriptorPool)(VkDevice device, VkDescriptorPool descriptorPool, const VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkResetDescriptorPool)(VkDevice device, VkDescriptorPool descriptorPool, VkDescriptorPoolResetFlags flags);
typedef VkResult (VKAPI_PTR *PFN_vkFreeDescriptorSets)(VkDevice device, VkDescriptorPool descriptorPool, uint32_t descriptorSetCount, const VkDescriptorSet* pDescriptorSets);
typedef void (VKAPI_PTR *PFN_vkUpdateDescriptorSets)(VkDevice device, uint32_t descriptorWriteCount, const VkWriteDescriptorSet* pDescriptorWrites, uint32_t descriptorCopyCount, const VkCopyDescriptorSet* pDescriptorCopies);
typedef VkResult (VKAPI_PTR *PFN_vkCreateFramebuffer)(VkDevice device, const VkFramebufferCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkFramebuffer* pFramebuffer);
typedef void (VKAPI_PTR *PFN_vkDestroyFramebuffer)(VkDevice device, VkFramebuffer framebuffer, const VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkCreateRenderPass)(VkDevice device, const VkRenderPassCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkRenderPass* pRenderPass);
typedef void (VKAPI_PTR *PFN_vkDestroyRenderPass)(VkDevice device, VkRenderPass renderPass, const VkAllocationCallbacks* pAllocator);
typedef void (VKAPI_PTR *PFN_vkGetRenderAreaGranularity)(VkDevice device, VkRenderPass renderPass, VkExtent2D* pGranularity);
typedef VkResult (VKAPI_PTR *PFN_vkCreateCommandPool)(VkDevice device, const VkCommandPoolCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkCommandPool* pCommandPool);
typedef void (VKAPI_PTR *PFN_vkDestroyCommandPool)(VkDevice device, VkCommandPool commandPool, const VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkResetCommandPool)(VkDevice device, VkCommandPool commandPool, VkCommandPoolResetFlags flags);
typedef void (VKAPI_PTR *PFN_vkFreeCommandBuffers)(VkDevice device, VkCommandPool commandPool, uint32_t commandBufferCount, const VkCommandBuffer* pCommandBuffers);
typedef VkResult (VKAPI_PTR *PFN_vkBeginCommandBuffer)(VkCommandBuffer commandBuffer, const VkCommandBufferBeginInfo* pBeginInfo);
typedef VkResult (VKAPI_PTR *PFN_vkEndCommandBuffer)(VkCommandBuffer commandBuffer);
typedef VkResult (VKAPI_PTR *PFN_vkResetCommandBuffer)(VkCommandBuffer commandBuffer, VkCommandBufferResetFlags flags);
typedef void (VKAPI_PTR *PFN_vkCmdBindPipeline)(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipeline pipeline);
typedef void (VKAPI_PTR *PFN_vkCmdSetViewport)(VkCommandBuffer commandBuffer, uint32_t firstViewport, uint32_t viewportCount, const VkViewport* pViewports);
typedef void (VKAPI_PTR *PFN_vkCmdSetScissor)(VkCommandBuffer commandBuffer, uint32_t firstScissor, uint32_t scissorCount, const VkRect2D* pScissors);
typedef void (VKAPI_PTR *PFN_vkCmdSetLineWidth)(VkCommandBuffer commandBuffer, float lineWidth);
typedef void (VKAPI_PTR *PFN_vkCmdSetDepthBias)(VkCommandBuffer commandBuffer, float depthBiasConstantFactor, float depthBiasClamp, float depthBiasSlopeFactor);
typedef void (VKAPI_PTR *PFN_vkCmdSetBlendConstants)(VkCommandBuffer commandBuffer, const float blendConstants[4]);
typedef void (VKAPI_PTR *PFN_vkCmdSetDepthBounds)(VkCommandBuffer commandBuffer, float minDepthBounds, float maxDepthBounds);
typedef void (VKAPI_PTR *PFN_vkCmdSetStencilCompareMask)(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, uint32_t compareMask);
typedef void (VKAPI_PTR *PFN_vkCmdSetStencilWriteMask)(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, uint32_t writeMask);
typedef void (VKAPI_PTR *PFN_vkCmdSetStencilReference)(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, uint32_t reference);
typedef void (VKAPI_PTR *PFN_vkCmdBindDescriptorSets)(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout, uint32_t firstSet, uint32_t descriptorSetCount, const VkDescriptorSet* pDescriptorSets, uint32_t dynamicOffsetCount, const uint32_t* pDynamicOffsets);
typedef void (VKAPI_PTR *PFN_vkCmdBindIndexBuffer)(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkIndexType indexType);
typedef void (VKAPI_PTR *PFN_vkCmdBindVertexBuffers)(VkCommandBuffer commandBuffer, uint32_t firstBinding, uint32_t bindingCount, const VkBuffer* pBuffers, const VkDeviceSize* pOffsets);
typedef void (VKAPI_PTR *PFN_vkCmdDraw)(VkCommandBuffer commandBuffer, uint32_t vertexCount, uint32_t instanceCount, uint32_t firstVertex, uint32_t firstInstance);
typedef void (VKAPI_PTR *PFN_vkCmdDrawIndexed)(VkCommandBuffer commandBuffer, uint32_t indexCount, uint32_t instanceCount, uint32_t firstIndex, int32_t vertexOffset, uint32_t firstInstance);
typedef void (VKAPI_PTR *PFN_vkCmdDrawIndirect)(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, uint32_t drawCount, uint32_t stride);
typedef void (VKAPI_PTR *PFN_vkCmdDrawIndexedIndirect)(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, uint32_t drawCount, uint32_t stride);
typedef void (VKAPI_PTR *PFN_vkCmdDispatch)(VkCommandBuffer commandBuffer, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ);
typedef void (VKAPI_PTR *PFN_vkCmdDispatchIndirect)(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset);
typedef void (VKAPI_PTR *PFN_vkCmdCopyBuffer)(VkCommandBuffer commandBuffer, VkBuffer srcBuffer, VkBuffer dstBuffer, uint32_t regionCount, const VkBufferCopy* pRegions);
typedef void (VKAPI_PTR *PFN_vkCmdCopyImage)(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, const VkImageCopy* pRegions);
typedef void (VKAPI_PTR *PFN_vkCmdBlitImage)(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, const VkImageBlit* pRegions, VkFilter filter);
typedef void (VKAPI_PTR *PFN_vkCmdCopyBufferToImage)(VkCommandBuffer commandBuffer, VkBuffer srcBuffer, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, const VkBufferImageCopy* pRegions);
typedef void (VKAPI_PTR *PFN_vkCmdCopyImageToBuffer)(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkBuffer dstBuffer, uint32_t regionCount, const VkBufferImageCopy* pRegions);
typedef void (VKAPI_PTR *PFN_vkCmdFillBuffer)(VkCommandBuffer commandBuffer, VkBuffer dstBuffer, VkDeviceSize dstOffset, VkDeviceSize size, uint32_t data);
typedef void (VKAPI_PTR *PFN_vkCmdClearColorImage)(VkCommandBuffer commandBuffer, VkImage image, VkImageLayout imageLayout, const VkClearColorValue* pColor, uint32_t rangeCount, const VkImageSubresourceRange* pRanges);
typedef void (VKAPI_PTR *PFN_vkCmdClearDepthStencilImage)(VkCommandBuffer commandBuffer, VkImage image, VkImageLayout imageLayout, const VkClearDepthStencilValue* pDepthStencil, uint32_t rangeCount, const VkImageSubresourceRange* pRanges);
typedef void (VKAPI_PTR *PFN_vkCmdClearAttachments)(VkCommandBuffer commandBuffer, uint32_t attachmentCount, const VkClearAttachment* pAttachments, uint32_t rectCount, const VkClearRect* pRects);
typedef void (VKAPI_PTR *PFN_vkCmdResolveImage)(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, const VkImageResolve* pRegions);
typedef void (VKAPI_PTR *PFN_vkCmdSetEvent)(VkCommandBuffer commandBuffer, VkEvent event, VkPipelineStageFlags stageMask);
typedef void (VKAPI_PTR *PFN_vkCmdResetEvent)(VkCommandBuffer commandBuffer, VkEvent event, VkPipelineStageFlags stageMask);
typedef void (VKAPI_PTR *PFN_vkCmdWaitEvents)(VkCommandBuffer commandBuffer, uint32_t eventCount, const VkEvent* pEvents, VkPipelineStageFlags srcStageMask, VkPipelineStageFlags dstStageMask, uint32_t memoryBarrierCount, const VkMemoryBarrier* pMemoryBarriers, uint32_t bufferMemoryBarrierCount, const VkBufferMemoryBarrier* pBufferMemoryBarriers, uint32_t imageMemoryBarrierCount, const VkImageMemoryBarrier* pImageMemoryBarriers);
typedef void (VKAPI_PTR *PFN_vkCmdPipelineBarrier)(VkCommandBuffer commandBuffer, VkPipelineStageFlags srcStageMask, VkPipelineStageFlags dstStageMask, VkDependencyFlags dependencyFlags, uint32_t memoryBarrierCount, const VkMemoryBarrier* pMemoryBarriers, uint32_t bufferMemoryBarrierCount, const VkBufferMemoryBarrier* pBufferMemoryBarriers, uint32_t imageMemoryBarrierCount, const VkImageMemoryBarrier* pImageMemoryBarriers);
typedef void (VKAPI_PTR *PFN_vkCmdBeginQuery)(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query, VkQueryControlFlags flags);
typedef void (VKAPI_PTR *PFN_vkCmdEndQuery)(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query);
typedef void (VKAPI_PTR *PFN_vkCmdResetQueryPool)(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount);
typedef void (VKAPI_PTR *PFN_vkCmdWriteTimestamp)(VkCommandBuffer commandBuffer, VkPipelineStageFlagBits pipelineStage, VkQueryPool queryPool, uint32_t query);
typedef void (VKAPI_PTR *PFN_vkCmdCopyQueryPoolResults)(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount, VkBuffer dstBuffer, VkDeviceSize dstOffset, VkDeviceSize stride, VkQueryResultFlags flags);
typedef void (VKAPI_PTR *PFN_vkCmdBeginRenderPass)(VkCommandBuffer commandBuffer, const VkRenderPassBeginInfo* pRenderPassBegin, VkSubpassContents contents);
typedef void (VKAPI_PTR *PFN_vkCmdNextSubpass)(VkCommandBuffer commandBuffer, VkSubpassContents contents);
typedef void (VKAPI_PTR *PFN_vkCmdEndRenderPass)(VkCommandBuffer commandBuffer);
typedef void (VKAPI_PTR *PFN_vkCmdExecuteCommands)(VkCommandBuffer commandBuffer, uint32_t commandBufferCount, const VkCommandBuffer* pCommandBuffers);

std::shared_ptr<VkApplicationInfoRAII> ApplicationInfo(
    const std::string &                         strApplicationName,
    uint32_t                                    applicationVersion,
    const std::string &                         strEngineName,
    uint32_t                                    engineVersion,
    uint32_t                                    apiVersion);


std::shared_ptr<VkInstanceCreateInfoRAII> InstanceCreateInfo(
    VkInstanceCreateFlags                       flags,
    const std::shared_ptr<VkApplicationInfoRAII> &pApplicationInfo,
    const std::vector<std::string> &            vecEnabledLayerNames,
    const std::vector<std::string> &            vecEnabledExtensionNames);


VkAllocationCallbacks AllocationCallbacks(
    PFN_vkAllocationFunction                    pfnAllocation,
    PFN_vkReallocationFunction                  pfnReallocation,
    PFN_vkFreeFunction                          pfnFree,
    PFN_vkInternalAllocationNotification        pfnInternalAllocation,
    PFN_vkInternalFreeNotification              pfnInternalFree);


std::shared_ptr<VkInstance_T> createInstance(
        const VkInstanceCreateInfo & pCreateInfo);

std::vector< VkPhysicalDevice > enumeratePhysicalDevices(
        VkInstance instance);

VkPhysicalDeviceFeatures PhysicalDeviceFeatures(
    VkBool32                                    robustBufferAccess,
    VkBool32                                    fullDrawIndexUint32,
    VkBool32                                    imageCubeArray,
    VkBool32                                    independentBlend,
    VkBool32                                    geometryShader,
    VkBool32                                    tessellationShader,
    VkBool32                                    sampleRateShading,
    VkBool32                                    dualSrcBlend,
    VkBool32                                    logicOp,
    VkBool32                                    multiDrawIndirect,
    VkBool32                                    drawIndirectFirstInstance,
    VkBool32                                    depthClamp,
    VkBool32                                    depthBiasClamp,
    VkBool32                                    fillModeNonSolid,
    VkBool32                                    depthBounds,
    VkBool32                                    wideLines,
    VkBool32                                    largePoints,
    VkBool32                                    alphaToOne,
    VkBool32                                    multiViewport,
    VkBool32                                    samplerAnisotropy,
    VkBool32                                    textureCompressionETC2,
    VkBool32                                    textureCompressionASTC_LDR,
    VkBool32                                    textureCompressionBC,
    VkBool32                                    occlusionQueryPrecise,
    VkBool32                                    pipelineStatisticsQuery,
    VkBool32                                    vertexPipelineStoresAndAtomics,
    VkBool32                                    fragmentStoresAndAtomics,
    VkBool32                                    shaderTessellationAndGeometryPointSize,
    VkBool32                                    shaderImageGatherExtended,
    VkBool32                                    shaderStorageImageExtendedFormats,
    VkBool32                                    shaderStorageImageMultisample,
    VkBool32                                    shaderStorageImageReadWithoutFormat,
    VkBool32                                    shaderStorageImageWriteWithoutFormat,
    VkBool32                                    shaderUniformBufferArrayDynamicIndexing,
    VkBool32                                    shaderSampledImageArrayDynamicIndexing,
    VkBool32                                    shaderStorageBufferArrayDynamicIndexing,
    VkBool32                                    shaderStorageImageArrayDynamicIndexing,
    VkBool32                                    shaderClipDistance,
    VkBool32                                    shaderCullDistance,
    VkBool32                                    shaderFloat64,
    VkBool32                                    shaderInt64,
    VkBool32                                    shaderInt16,
    VkBool32                                    shaderResourceResidency,
    VkBool32                                    shaderResourceMinLod,
    VkBool32                                    sparseBinding,
    VkBool32                                    sparseResidencyBuffer,
    VkBool32                                    sparseResidencyImage2D,
    VkBool32                                    sparseResidencyImage3D,
    VkBool32                                    sparseResidency2Samples,
    VkBool32                                    sparseResidency4Samples,
    VkBool32                                    sparseResidency8Samples,
    VkBool32                                    sparseResidency16Samples,
    VkBool32                                    sparseResidencyAliased,
    VkBool32                                    variableMultisampleRate,
    VkBool32                                    inheritedQueries);


VkPhysicalDeviceFeatures getPhysicalDeviceFeatures(
        VkPhysicalDevice physicalDevice);

VkFormatProperties FormatProperties(
    VkFormatFeatureFlags                        linearTilingFeatures,
    VkFormatFeatureFlags                        optimalTilingFeatures,
    VkFormatFeatureFlags                        bufferFeatures);


VkFormatProperties getPhysicalDeviceFormatProperties(
        VkPhysicalDevice physicalDevice,
        VkFormat format);

VkExtent3D Extent3D(
    uint32_t                                    width,
    uint32_t                                    height,
    uint32_t                                    depth);


VkImageFormatProperties ImageFormatProperties(
    VkExtent3D                                  maxExtent,
    uint32_t                                    maxMipLevels,
    uint32_t                                    maxArrayLayers,
    VkSampleCountFlags                          sampleCounts,
    VkDeviceSize                                maxResourceSize);


VkImageFormatProperties getPhysicalDeviceImageFormatProperties(
        VkPhysicalDevice physicalDevice,
        VkFormat format,
        VkImageType type,
        VkImageTiling tiling,
        VkImageUsageFlags usage,
        VkImageCreateFlags flags);

VkPhysicalDeviceLimits PhysicalDeviceLimits(
    uint32_t                                    maxImageDimension1D,
    uint32_t                                    maxImageDimension2D,
    uint32_t                                    maxImageDimension3D,
    uint32_t                                    maxImageDimensionCube,
    uint32_t                                    maxImageArrayLayers,
    uint32_t                                    maxTexelBufferElements,
    uint32_t                                    maxUniformBufferRange,
    uint32_t                                    maxStorageBufferRange,
    uint32_t                                    maxPushConstantsSize,
    uint32_t                                    maxMemoryAllocationCount,
    uint32_t                                    maxSamplerAllocationCount,
    VkDeviceSize                                bufferImageGranularity,
    VkDeviceSize                                sparseAddressSpaceSize,
    uint32_t                                    maxBoundDescriptorSets,
    uint32_t                                    maxPerStageDescriptorSamplers,
    uint32_t                                    maxPerStageDescriptorUniformBuffers,
    uint32_t                                    maxPerStageDescriptorStorageBuffers,
    uint32_t                                    maxPerStageDescriptorSampledImages,
    uint32_t                                    maxPerStageDescriptorStorageImages,
    uint32_t                                    maxPerStageDescriptorInputAttachments,
    uint32_t                                    maxPerStageResources,
    uint32_t                                    maxDescriptorSetSamplers,
    uint32_t                                    maxDescriptorSetUniformBuffers,
    uint32_t                                    maxDescriptorSetUniformBuffersDynamic,
    uint32_t                                    maxDescriptorSetStorageBuffers,
    uint32_t                                    maxDescriptorSetStorageBuffersDynamic,
    uint32_t                                    maxDescriptorSetSampledImages,
    uint32_t                                    maxDescriptorSetStorageImages,
    uint32_t                                    maxDescriptorSetInputAttachments,
    uint32_t                                    maxVertexInputAttributes,
    uint32_t                                    maxVertexInputBindings,
    uint32_t                                    maxVertexInputAttributeOffset,
    uint32_t                                    maxVertexInputBindingStride,
    uint32_t                                    maxVertexOutputComponents,
    uint32_t                                    maxTessellationGenerationLevel,
    uint32_t                                    maxTessellationPatchSize,
    uint32_t                                    maxTessellationControlPerVertexInputComponents,
    uint32_t                                    maxTessellationControlPerVertexOutputComponents,
    uint32_t                                    maxTessellationControlPerPatchOutputComponents,
    uint32_t                                    maxTessellationControlTotalOutputComponents,
    uint32_t                                    maxTessellationEvaluationInputComponents,
    uint32_t                                    maxTessellationEvaluationOutputComponents,
    uint32_t                                    maxGeometryShaderInvocations,
    uint32_t                                    maxGeometryInputComponents,
    uint32_t                                    maxGeometryOutputComponents,
    uint32_t                                    maxGeometryOutputVertices,
    uint32_t                                    maxGeometryTotalOutputComponents,
    uint32_t                                    maxFragmentInputComponents,
    uint32_t                                    maxFragmentOutputAttachments,
    uint32_t                                    maxFragmentDualSrcAttachments,
    uint32_t                                    maxFragmentCombinedOutputResources,
    uint32_t                                    maxComputeSharedMemorySize,
    uint32_t                                    maxComputeWorkGroupCount[3],
    uint32_t                                    maxComputeWorkGroupInvocations,
    uint32_t                                    maxComputeWorkGroupSize[3],
    uint32_t                                    subPixelPrecisionBits,
    uint32_t                                    subTexelPrecisionBits,
    uint32_t                                    mipmapPrecisionBits,
    uint32_t                                    maxDrawIndexedIndexValue,
    uint32_t                                    maxDrawIndirectCount,
    float                                       maxSamplerLodBias,
    float                                       maxSamplerAnisotropy,
    uint32_t                                    maxViewports,
    uint32_t                                    maxViewportDimensions[2],
    float                                       viewportBoundsRange[2],
    uint32_t                                    viewportSubPixelBits,
    size_t                                      minMemoryMapAlignment,
    VkDeviceSize                                minTexelBufferOffsetAlignment,
    VkDeviceSize                                minUniformBufferOffsetAlignment,
    VkDeviceSize                                minStorageBufferOffsetAlignment,
    int32_t                                     minTexelOffset,
    uint32_t                                    maxTexelOffset,
    int32_t                                     minTexelGatherOffset,
    uint32_t                                    maxTexelGatherOffset,
    float                                       minInterpolationOffset,
    float                                       maxInterpolationOffset,
    uint32_t                                    subPixelInterpolationOffsetBits,
    uint32_t                                    maxFramebufferWidth,
    uint32_t                                    maxFramebufferHeight,
    uint32_t                                    maxFramebufferLayers,
    VkSampleCountFlags                          framebufferColorSampleCounts,
    VkSampleCountFlags                          framebufferDepthSampleCounts,
    VkSampleCountFlags                          framebufferStencilSampleCounts,
    VkSampleCountFlags                          framebufferNoAttachmentsSampleCounts,
    uint32_t                                    maxColorAttachments,
    VkSampleCountFlags                          sampledImageColorSampleCounts,
    VkSampleCountFlags                          sampledImageIntegerSampleCounts,
    VkSampleCountFlags                          sampledImageDepthSampleCounts,
    VkSampleCountFlags                          sampledImageStencilSampleCounts,
    VkSampleCountFlags                          storageImageSampleCounts,
    uint32_t                                    maxSampleMaskWords,
    VkBool32                                    timestampComputeAndGraphics,
    float                                       timestampPeriod,
    uint32_t                                    maxClipDistances,
    uint32_t                                    maxCullDistances,
    uint32_t                                    maxCombinedClipAndCullDistances,
    uint32_t                                    discreteQueuePriorities,
    float                                       pointSizeRange[2],
    float                                       lineWidthRange[2],
    float                                       pointSizeGranularity,
    float                                       lineWidthGranularity,
    VkBool32                                    strictLines,
    VkBool32                                    standardSampleLocations,
    VkDeviceSize                                optimalBufferCopyOffsetAlignment,
    VkDeviceSize                                optimalBufferCopyRowPitchAlignment,
    VkDeviceSize                                nonCoherentAtomSize);


VkPhysicalDeviceSparseProperties PhysicalDeviceSparseProperties(
    VkBool32                                    residencyStandard2DBlockShape,
    VkBool32                                    residencyStandard2DMultisampleBlockShape,
    VkBool32                                    residencyStandard3DBlockShape,
    VkBool32                                    residencyAlignedMipSize,
    VkBool32                                    residencyNonResidentStrict);


VkPhysicalDeviceProperties PhysicalDeviceProperties(
    uint32_t                                    apiVersion,
    uint32_t                                    driverVersion,
    uint32_t                                    vendorID,
    uint32_t                                    deviceID,
    VkPhysicalDeviceType                        deviceType,
    char                                        deviceName[VK_MAX_PHYSICAL_DEVICE_NAME_SIZE],
    uint8_t                                     pipelineCacheUUID[VK_UUID_SIZE],
    VkPhysicalDeviceLimits                      limits,
    VkPhysicalDeviceSparseProperties            sparseProperties);


VkPhysicalDeviceProperties getPhysicalDeviceProperties(
        VkPhysicalDevice physicalDevice);

VkQueueFamilyProperties QueueFamilyProperties(
    VkQueueFlags                                queueFlags,
    uint32_t                                    queueCount,
    uint32_t                                    timestampValidBits,
    VkExtent3D                                  minImageTransferGranularity);


std::vector< VkQueueFamilyProperties > getPhysicalDeviceQueueFamilyProperties(
        VkPhysicalDevice physicalDevice);

VkMemoryType MemoryType(
    VkMemoryPropertyFlags                       propertyFlags,
    uint32_t                                    heapIndex);


VkMemoryHeap MemoryHeap(
    VkDeviceSize                                size,
    VkMemoryHeapFlags                           flags);


VkPhysicalDeviceMemoryProperties PhysicalDeviceMemoryProperties(
    uint32_t                                    memoryTypeCount,
    VkMemoryType                                memoryTypes[VK_MAX_MEMORY_TYPES],
    uint32_t                                    memoryHeapCount,
    VkMemoryHeap                                memoryHeaps[VK_MAX_MEMORY_HEAPS]);


VkPhysicalDeviceMemoryProperties getPhysicalDeviceMemoryProperties(
        VkPhysicalDevice physicalDevice);

std::shared_ptr<VkDeviceQueueCreateInfoRAII> DeviceQueueCreateInfo(
    VkDeviceQueueCreateFlags                    flags,
    uint32_t                                    queueFamilyIndex,
    float* pQueuePriorities_in_array1, int pQueuePriorities_dim1);


std::shared_ptr<VkDeviceCreateInfoRAII> DeviceCreateInfo(
    VkDeviceCreateFlags                         flags,
    const std::vector<VkDeviceQueueCreateInfo> &vecQueueCreateInfos,
    const std::vector<std::string> &            vecEnabledLayerNames,
    const std::vector<std::string> &            vecEnabledExtensionNames,
    const VkPhysicalDeviceFeatures *            pEnabledFeatures);


std::shared_ptr<VkDevice_T> createDevice(
        VkPhysicalDevice physicalDevice,
        const VkDeviceCreateInfo & pCreateInfo);

VkExtensionProperties ExtensionProperties(
    char                                        extensionName[VK_MAX_EXTENSION_NAME_SIZE],
    uint32_t                                    specVersion);


std::vector< VkExtensionProperties > enumerateInstanceExtensionProperties(
        const char* pLayerName);

std::vector< VkExtensionProperties > enumerateDeviceExtensionProperties(
        VkPhysicalDevice physicalDevice,
        const char* pLayerName);

VkLayerProperties LayerProperties(
    char                                        layerName[VK_MAX_EXTENSION_NAME_SIZE],
    uint32_t                                    specVersion,
    uint32_t                                    implementationVersion,
    char                                        description[VK_MAX_DESCRIPTION_SIZE]);


std::vector< VkLayerProperties > enumerateInstanceLayerProperties(void);

std::vector< VkLayerProperties > enumerateDeviceLayerProperties(
        VkPhysicalDevice physicalDevice);

VkQueue getDeviceQueue(
        VkDevice device,
        uint32_t queueFamilyIndex,
        uint32_t queueIndex);

std::shared_ptr<VkSubmitInfoRAII> SubmitInfo(
    const std::vector<VkSemaphore> &            vecWaitSemaphores,
    const std::vector<VkPipelineStageFlags> &   vecWaitDstStageMask,
    const std::vector<VkCommandBuffer> &        vecCommandBuffers,
    const std::vector<VkSemaphore> &            vecSignalSemaphores);


void  queueSubmit(
        VkQueue queue,
        const std::vector<VkSubmitInfo> & pSubmits,
        VkFence fence);

void  queueWaitIdle(
        VkQueue queue);

void  deviceWaitIdle(
        VkDevice device);

VkMemoryAllocateInfo MemoryAllocateInfo(
    VkDeviceSize                                allocationSize,
    uint32_t                                    memoryTypeIndex);


std::shared_ptr<VkDeviceMemory_T> allocateMemory(
        VkDevice device,
        const VkMemoryAllocateInfo & pAllocateInfo);

void  unmapMemory(
        VkDevice device,
        VkDeviceMemory memory);

VkMappedMemoryRange MappedMemoryRange(
    VkDeviceMemory                              memory,
    VkDeviceSize                                offset,
    VkDeviceSize                                size);


void  flushMappedMemoryRanges(
        VkDevice device,
        const std::vector<VkMappedMemoryRange> & pMemoryRanges);

void  invalidateMappedMemoryRanges(
        VkDevice device,
        const std::vector<VkMappedMemoryRange> & pMemoryRanges);

VkDeviceSize getDeviceMemoryCommitment(
        VkDevice device,
        VkDeviceMemory memory);

void  bindBufferMemory(
        VkDevice device,
        VkBuffer buffer,
        VkDeviceMemory memory,
        VkDeviceSize memoryOffset);

void  bindImageMemory(
        VkDevice device,
        VkImage image,
        VkDeviceMemory memory,
        VkDeviceSize memoryOffset);

VkMemoryRequirements MemoryRequirements(
    VkDeviceSize                                size,
    VkDeviceSize                                alignment,
    uint32_t                                    memoryTypeBits);


VkMemoryRequirements getBufferMemoryRequirements(
        VkDevice device,
        VkBuffer buffer);

VkMemoryRequirements getImageMemoryRequirements(
        VkDevice device,
        VkImage image);

VkSparseImageFormatProperties SparseImageFormatProperties(
    VkImageAspectFlags                          aspectMask,
    VkExtent3D                                  imageGranularity,
    VkSparseImageFormatFlags                    flags);


VkSparseImageMemoryRequirements SparseImageMemoryRequirements(
    VkSparseImageFormatProperties               formatProperties,
    uint32_t                                    imageMipTailFirstLod,
    VkDeviceSize                                imageMipTailSize,
    VkDeviceSize                                imageMipTailOffset,
    VkDeviceSize                                imageMipTailStride);


std::vector< VkSparseImageMemoryRequirements > getImageSparseMemoryRequirements(
        VkDevice device,
        VkImage image);

std::vector< VkSparseImageFormatProperties > getPhysicalDeviceSparseImageFormatProperties(
        VkPhysicalDevice physicalDevice,
        VkFormat format,
        VkImageType type,
        VkSampleCountFlagBits samples,
        VkImageUsageFlags usage,
        VkImageTiling tiling);

VkSparseMemoryBind SparseMemoryBind(
    VkDeviceSize                                resourceOffset,
    VkDeviceSize                                size,
    VkDeviceMemory                              memory,
    VkDeviceSize                                memoryOffset,
    VkSparseMemoryBindFlags                     flags);


std::shared_ptr<VkSparseBufferMemoryBindInfoRAII> SparseBufferMemoryBindInfo(
    VkBuffer                                    buffer,
    const std::vector<VkSparseMemoryBind> &     vecBinds);


std::shared_ptr<VkSparseImageOpaqueMemoryBindInfoRAII> SparseImageOpaqueMemoryBindInfo(
    VkImage                                     image,
    const std::vector<VkSparseMemoryBind> &     vecBinds);


VkImageSubresource ImageSubresource(
    VkImageAspectFlags                          aspectMask,
    uint32_t                                    mipLevel,
    uint32_t                                    arrayLayer);


VkOffset3D Offset3D(
    int32_t                                     x,
    int32_t                                     y,
    int32_t                                     z);


VkSparseImageMemoryBind SparseImageMemoryBind(
    VkImageSubresource                          subresource,
    VkOffset3D                                  offset,
    VkExtent3D                                  extent,
    VkDeviceMemory                              memory,
    VkDeviceSize                                memoryOffset,
    VkSparseMemoryBindFlags                     flags);


std::shared_ptr<VkSparseImageMemoryBindInfoRAII> SparseImageMemoryBindInfo(
    VkImage                                     image,
    const std::vector<VkSparseImageMemoryBind> &vecBinds);


std::shared_ptr<VkBindSparseInfoRAII> BindSparseInfo(
    const std::vector<VkSemaphore> &            vecWaitSemaphores,
    const std::vector<VkSparseBufferMemoryBindInfo> &vecBufferBinds,
    const std::vector<VkSparseImageOpaqueMemoryBindInfo> &vecImageOpaqueBinds,
    const std::vector<VkSparseImageMemoryBindInfo> &vecImageBinds,
    const std::vector<VkSemaphore> &            vecSignalSemaphores);


void  queueBindSparse(
        VkQueue queue,
        const std::vector<VkBindSparseInfo> & pBindInfo,
        VkFence fence);

VkFenceCreateInfo FenceCreateInfo(
    VkFenceCreateFlags                          flags);


std::shared_ptr<VkFence_T> createFence(
        VkDevice device,
        const VkFenceCreateInfo & pCreateInfo);

void  resetFences(
        VkDevice device,
        const std::vector<VkFence> & pFences);

void  getFenceStatus(
        VkDevice device,
        VkFence fence);

void  waitForFences(
        VkDevice device,
        const std::vector<VkFence> & pFences,
        VkBool32 waitAll,
        uint64_t timeout);

VkSemaphoreCreateInfo SemaphoreCreateInfo(
    VkSemaphoreCreateFlags                      flags);


std::shared_ptr<VkSemaphore_T> createSemaphore(
        VkDevice device,
        const VkSemaphoreCreateInfo & pCreateInfo);

VkEventCreateInfo EventCreateInfo(
    VkEventCreateFlags                          flags);


std::shared_ptr<VkEvent_T> createEvent(
        VkDevice device,
        const VkEventCreateInfo & pCreateInfo);

void  getEventStatus(
        VkDevice device,
        VkEvent event);

void  setEvent(
        VkDevice device,
        VkEvent event);

void  resetEvent(
        VkDevice device,
        VkEvent event);

VkQueryPoolCreateInfo QueryPoolCreateInfo(
    VkQueryPoolCreateFlags                      flags,
    VkQueryType                                 queryType,
    uint32_t                                    queryCount,
    VkQueryPipelineStatisticFlags               pipelineStatistics);


std::shared_ptr<VkQueryPool_T> createQueryPool(
        VkDevice device,
        const VkQueryPoolCreateInfo & pCreateInfo);

void  getQueryPoolResults(
        VkDevice device,
        VkQueryPool queryPool,
        uint32_t firstQuery,
        uint32_t queryCount,
        size_t dataSize,
        VkDeviceSize stride,
        VkQueryResultFlags flags);

std::shared_ptr<VkBufferCreateInfoRAII> BufferCreateInfo(
    VkBufferCreateFlags                         flags,
    VkDeviceSize                                size,
    VkBufferUsageFlags                          usage,
    VkSharingMode                               sharingMode,
    unsigned int* pQueueFamilyIndices_in_array1, int pQueueFamilyIndices_dim1);


std::shared_ptr<VkBuffer_T> createBuffer(
        VkDevice device,
        const VkBufferCreateInfo & pCreateInfo);

VkBufferViewCreateInfo BufferViewCreateInfo(
    VkBufferViewCreateFlags                     flags,
    VkBuffer                                    buffer,
    VkFormat                                    format,
    VkDeviceSize                                offset,
    VkDeviceSize                                range);


std::shared_ptr<VkBufferView_T> createBufferView(
        VkDevice device,
        const VkBufferViewCreateInfo & pCreateInfo);

std::shared_ptr<VkImageCreateInfoRAII> ImageCreateInfo(
    VkImageCreateFlags                          flags,
    VkImageType                                 imageType,
    VkFormat                                    format,
    VkExtent3D                                  extent,
    uint32_t                                    mipLevels,
    uint32_t                                    arrayLayers,
    VkSampleCountFlagBits                       samples,
    VkImageTiling                               tiling,
    VkImageUsageFlags                           usage,
    VkSharingMode                               sharingMode,
    unsigned int* pQueueFamilyIndices_in_array1, int pQueueFamilyIndices_dim1,
    VkImageLayout                               initialLayout);


std::shared_ptr<VkImage_T> createImage(
        VkDevice device,
        const VkImageCreateInfo & pCreateInfo);

VkSubresourceLayout SubresourceLayout(
    VkDeviceSize                                offset,
    VkDeviceSize                                size,
    VkDeviceSize                                rowPitch,
    VkDeviceSize                                arrayPitch,
    VkDeviceSize                                depthPitch);


VkSubresourceLayout getImageSubresourceLayout(
        VkDevice device,
        VkImage image,
        const VkImageSubresource & pSubresource);

VkComponentMapping ComponentMapping(
    VkComponentSwizzle                          r,
    VkComponentSwizzle                          g,
    VkComponentSwizzle                          b,
    VkComponentSwizzle                          a);


VkImageSubresourceRange ImageSubresourceRange(
    VkImageAspectFlags                          aspectMask,
    uint32_t                                    baseMipLevel,
    uint32_t                                    levelCount,
    uint32_t                                    baseArrayLayer,
    uint32_t                                    layerCount);


VkImageViewCreateInfo ImageViewCreateInfo(
    VkImageViewCreateFlags                      flags,
    VkImage                                     image,
    VkImageViewType                             viewType,
    VkFormat                                    format,
    VkComponentMapping                          components,
    VkImageSubresourceRange                     subresourceRange);


std::shared_ptr<VkImageView_T> createImageView(
        VkDevice device,
        const VkImageViewCreateInfo & pCreateInfo);

std::shared_ptr<VkShaderModuleCreateInfoRAII> ShaderModuleCreateInfo(
    VkShaderModuleCreateFlags                   flags,
    unsigned int* pCode_in_array1, int pCode_dim1);


std::shared_ptr<VkShaderModule_T> createShaderModule(
        VkDevice device,
        const VkShaderModuleCreateInfo & pCreateInfo);

std::shared_ptr<VkPipelineCacheCreateInfoRAII> PipelineCacheCreateInfo(
    VkPipelineCacheCreateFlags                  flags,
    const std::vector<uint8_t> &                vecInitialData);


std::shared_ptr<VkPipelineCache_T> createPipelineCache(
        VkDevice device,
        const VkPipelineCacheCreateInfo & pCreateInfo);

size_t getPipelineCacheData(
        VkDevice device,
        VkPipelineCache pipelineCache);

void  mergePipelineCaches(
        VkDevice device,
        VkPipelineCache dstCache,
        const std::vector<VkPipelineCache> & pSrcCaches);

VkSpecializationMapEntry SpecializationMapEntry(
    uint32_t                                    constantID,
    uint32_t                                    offset,
    size_t                                      size);


std::shared_ptr<VkSpecializationInfoRAII> SpecializationInfo(
    const std::vector<VkSpecializationMapEntry> &vecMapEntries,
    const std::vector<uint8_t> &                vecData);


std::shared_ptr<VkPipelineShaderStageCreateInfoRAII> PipelineShaderStageCreateInfo(
    VkPipelineShaderStageCreateFlags            flags,
    VkShaderStageFlagBits                       stage,
    VkShaderModule                              module,
    const std::string &                         strName,
    const std::shared_ptr<VkSpecializationInfoRAII> &pSpecializationInfo);


VkVertexInputBindingDescription VertexInputBindingDescription(
    uint32_t                                    binding,
    uint32_t                                    stride,
    VkVertexInputRate                           inputRate);


VkVertexInputAttributeDescription VertexInputAttributeDescription(
    uint32_t                                    location,
    uint32_t                                    binding,
    VkFormat                                    format,
    uint32_t                                    offset);


std::shared_ptr<VkPipelineVertexInputStateCreateInfoRAII> PipelineVertexInputStateCreateInfo(
    VkPipelineVertexInputStateCreateFlags       flags,
    const std::vector<VkVertexInputBindingDescription> &vecVertexBindingDescriptions,
    const std::vector<VkVertexInputAttributeDescription> &vecVertexAttributeDescriptions);


VkPipelineInputAssemblyStateCreateInfo PipelineInputAssemblyStateCreateInfo(
    VkPipelineInputAssemblyStateCreateFlags     flags,
    VkPrimitiveTopology                         topology,
    VkBool32                                    primitiveRestartEnable);


VkPipelineTessellationStateCreateInfo PipelineTessellationStateCreateInfo(
    VkPipelineTessellationStateCreateFlags      flags,
    uint32_t                                    patchControlPoints);


VkViewport Viewport(
    float                                       x,
    float                                       y,
    float                                       width,
    float                                       height,
    float                                       minDepth,
    float                                       maxDepth);


VkOffset2D Offset2D(
    int32_t                                     x,
    int32_t                                     y);


VkExtent2D Extent2D(
    uint32_t                                    width,
    uint32_t                                    height);


VkRect2D Rect2D(
    VkOffset2D                                  offset,
    VkExtent2D                                  extent);


std::shared_ptr<VkPipelineViewportStateCreateInfoRAII> PipelineViewportStateCreateInfo(
    VkPipelineViewportStateCreateFlags          flags,
    const std::vector<VkViewport> &             vecViewports,
    const std::vector<VkRect2D> &               vecScissors);


VkPipelineRasterizationStateCreateInfo PipelineRasterizationStateCreateInfo(
    VkPipelineRasterizationStateCreateFlags     flags,
    VkBool32                                    depthClampEnable,
    VkBool32                                    rasterizerDiscardEnable,
    VkPolygonMode                               polygonMode,
    VkCullModeFlags                             cullMode,
    VkFrontFace                                 frontFace,
    VkBool32                                    depthBiasEnable,
    float                                       depthBiasConstantFactor,
    float                                       depthBiasClamp,
    float                                       depthBiasSlopeFactor,
    float                                       lineWidth);


VkPipelineMultisampleStateCreateInfo PipelineMultisampleStateCreateInfo(
    VkPipelineMultisampleStateCreateFlags       flags,
    VkSampleCountFlagBits                       rasterizationSamples,
    VkBool32                                    sampleShadingEnable,
    float                                       minSampleShading,
    const VkSampleMask*                         pSampleMask,
    VkBool32                                    alphaToCoverageEnable,
    VkBool32                                    alphaToOneEnable);


VkStencilOpState StencilOpState(
    VkStencilOp                                 failOp,
    VkStencilOp                                 passOp,
    VkStencilOp                                 depthFailOp,
    VkCompareOp                                 compareOp,
    uint32_t                                    compareMask,
    uint32_t                                    writeMask,
    uint32_t                                    reference);


VkPipelineDepthStencilStateCreateInfo PipelineDepthStencilStateCreateInfo(
    VkPipelineDepthStencilStateCreateFlags      flags,
    VkBool32                                    depthTestEnable,
    VkBool32                                    depthWriteEnable,
    VkCompareOp                                 depthCompareOp,
    VkBool32                                    depthBoundsTestEnable,
    VkBool32                                    stencilTestEnable,
    VkStencilOpState                            front,
    VkStencilOpState                            back,
    float                                       minDepthBounds,
    float                                       maxDepthBounds);


VkPipelineColorBlendAttachmentState PipelineColorBlendAttachmentState(
    VkBool32                                    blendEnable,
    VkBlendFactor                               srcColorBlendFactor,
    VkBlendFactor                               dstColorBlendFactor,
    VkBlendOp                                   colorBlendOp,
    VkBlendFactor                               srcAlphaBlendFactor,
    VkBlendFactor                               dstAlphaBlendFactor,
    VkBlendOp                                   alphaBlendOp,
    VkColorComponentFlags                       colorWriteMask);


std::shared_ptr<VkPipelineColorBlendStateCreateInfoRAII> PipelineColorBlendStateCreateInfo(
    VkPipelineColorBlendStateCreateFlags        flags,
    VkBool32                                    logicOpEnable,
    VkLogicOp                                   logicOp,
    const std::vector<VkPipelineColorBlendAttachmentState> &vecAttachments,
    float                                       blendConstants[4]);


std::shared_ptr<VkPipelineDynamicStateCreateInfoRAII> PipelineDynamicStateCreateInfo(
    VkPipelineDynamicStateCreateFlags           flags,
    const std::vector<VkDynamicState> &         vecDynamicStates);


std::shared_ptr<VkGraphicsPipelineCreateInfoRAII> GraphicsPipelineCreateInfo(
    VkPipelineCreateFlags                       flags,
    const std::vector<VkPipelineShaderStageCreateInfo> &vecStages,
    const std::shared_ptr<VkPipelineVertexInputStateCreateInfoRAII> &pVertexInputState,
    const VkPipelineInputAssemblyStateCreateInfo *pInputAssemblyState,
    const VkPipelineTessellationStateCreateInfo *pTessellationState,
    const std::shared_ptr<VkPipelineViewportStateCreateInfoRAII> &pViewportState,
    const VkPipelineRasterizationStateCreateInfo *pRasterizationState,
    const VkPipelineMultisampleStateCreateInfo *pMultisampleState,
    const VkPipelineDepthStencilStateCreateInfo *pDepthStencilState,
    const std::shared_ptr<VkPipelineColorBlendStateCreateInfoRAII> &pColorBlendState,
    const std::shared_ptr<VkPipelineDynamicStateCreateInfoRAII> &pDynamicState,
    VkPipelineLayout                            layout,
    VkRenderPass                                renderPass,
    uint32_t                                    subpass,
    VkPipeline                                  basePipelineHandle,
    int32_t                                     basePipelineIndex);


std::vector< std::shared_ptr<VkPipeline_T> > createGraphicsPipelines(
        VkDevice device,
        VkPipelineCache pipelineCache,
        const std::vector<VkGraphicsPipelineCreateInfo> & pCreateInfos);

VkComputePipelineCreateInfo ComputePipelineCreateInfo(
    VkPipelineCreateFlags                       flags,
    VkPipelineShaderStageCreateInfo             stage,
    VkPipelineLayout                            layout,
    VkPipeline                                  basePipelineHandle,
    int32_t                                     basePipelineIndex);


std::vector< std::shared_ptr<VkPipeline_T> > createComputePipelines(
        VkDevice device,
        VkPipelineCache pipelineCache,
        const std::vector<VkComputePipelineCreateInfo> & pCreateInfos);

VkPushConstantRange PushConstantRange(
    VkShaderStageFlags                          stageFlags,
    uint32_t                                    offset,
    uint32_t                                    size);


std::shared_ptr<VkPipelineLayoutCreateInfoRAII> PipelineLayoutCreateInfo(
    VkPipelineLayoutCreateFlags                 flags,
    const std::vector<VkDescriptorSetLayout> &  vecSetLayouts,
    const std::vector<VkPushConstantRange> &    vecPushConstantRanges);


std::shared_ptr<VkPipelineLayout_T> createPipelineLayout(
        VkDevice device,
        const VkPipelineLayoutCreateInfo & pCreateInfo);

VkSamplerCreateInfo SamplerCreateInfo(
    VkSamplerCreateFlags                        flags,
    VkFilter                                    magFilter,
    VkFilter                                    minFilter,
    VkSamplerMipmapMode                         mipmapMode,
    VkSamplerAddressMode                        addressModeU,
    VkSamplerAddressMode                        addressModeV,
    VkSamplerAddressMode                        addressModeW,
    float                                       mipLodBias,
    VkBool32                                    anisotropyEnable,
    float                                       maxAnisotropy,
    VkBool32                                    compareEnable,
    VkCompareOp                                 compareOp,
    float                                       minLod,
    float                                       maxLod,
    VkBorderColor                               borderColor,
    VkBool32                                    unnormalizedCoordinates);


std::shared_ptr<VkSampler_T> createSampler(
        VkDevice device,
        const VkSamplerCreateInfo & pCreateInfo);

std::shared_ptr<VkDescriptorSetLayoutBindingRAII> DescriptorSetLayoutBinding(
    uint32_t                                    binding,
    VkDescriptorType                            descriptorType,
    uint32_t                                    descriptorCount,
    VkShaderStageFlags                          stageFlags,
    const std::vector<VkSampler> &              vecImmutableSamplers);


std::shared_ptr<VkDescriptorSetLayoutCreateInfoRAII> DescriptorSetLayoutCreateInfo(
    VkDescriptorSetLayoutCreateFlags            flags,
    const std::vector<VkDescriptorSetLayoutBinding> &vecBindings);


std::shared_ptr<VkDescriptorSetLayout_T> createDescriptorSetLayout(
        VkDevice device,
        const VkDescriptorSetLayoutCreateInfo & pCreateInfo);

VkDescriptorPoolSize DescriptorPoolSize(
    VkDescriptorType                            type,
    uint32_t                                    descriptorCount);


std::shared_ptr<VkDescriptorPoolCreateInfoRAII> DescriptorPoolCreateInfo(
    VkDescriptorPoolCreateFlags                 flags,
    uint32_t                                    maxSets,
    const std::vector<VkDescriptorPoolSize> &   vecPoolSizes);


std::shared_ptr<VkDescriptorPool_T> createDescriptorPool(
        VkDevice device,
        const VkDescriptorPoolCreateInfo & pCreateInfo);

void  resetDescriptorPool(
        VkDevice device,
        VkDescriptorPool descriptorPool,
        VkDescriptorPoolResetFlags flags);

std::shared_ptr<VkDescriptorSetAllocateInfoRAII> DescriptorSetAllocateInfo(
    VkDescriptorPool                            descriptorPool,
    const std::vector<VkDescriptorSetLayout> &  vecSetLayouts);


VkDescriptorImageInfo DescriptorImageInfo(
    VkSampler                                   sampler,
    VkImageView                                 imageView,
    VkImageLayout                               imageLayout);


VkDescriptorBufferInfo DescriptorBufferInfo(
    VkBuffer                                    buffer,
    VkDeviceSize                                offset,
    VkDeviceSize                                range);


std::shared_ptr<VkWriteDescriptorSetRAII> WriteDescriptorSet(
    VkDescriptorSet                             dstSet,
    uint32_t                                    dstBinding,
    uint32_t                                    dstArrayElement,
    uint32_t                                    descriptorCount,
    VkDescriptorType                            descriptorType,
    const std::vector<VkDescriptorImageInfo> &  vecImageInfo,
    const std::vector<VkDescriptorBufferInfo> & vecBufferInfo,
    const std::vector<VkBufferView> &           vecTexelBufferView);


VkCopyDescriptorSet CopyDescriptorSet(
    VkDescriptorSet                             srcSet,
    uint32_t                                    srcBinding,
    uint32_t                                    srcArrayElement,
    VkDescriptorSet                             dstSet,
    uint32_t                                    dstBinding,
    uint32_t                                    dstArrayElement,
    uint32_t                                    descriptorCount);


void  updateDescriptorSets(
        VkDevice device,
        const std::vector<VkWriteDescriptorSet> & pDescriptorWrites,
        const std::vector<VkCopyDescriptorSet> & pDescriptorCopies);

std::shared_ptr<VkFramebufferCreateInfoRAII> FramebufferCreateInfo(
    VkFramebufferCreateFlags                    flags,
    VkRenderPass                                renderPass,
    const std::vector<VkImageView> &            vecAttachments,
    uint32_t                                    width,
    uint32_t                                    height,
    uint32_t                                    layers);


std::shared_ptr<VkFramebuffer_T> createFramebuffer(
        VkDevice device,
        const VkFramebufferCreateInfo & pCreateInfo);

VkAttachmentDescription AttachmentDescription(
    VkAttachmentDescriptionFlags                flags,
    VkFormat                                    format,
    VkSampleCountFlagBits                       samples,
    VkAttachmentLoadOp                          loadOp,
    VkAttachmentStoreOp                         storeOp,
    VkAttachmentLoadOp                          stencilLoadOp,
    VkAttachmentStoreOp                         stencilStoreOp,
    VkImageLayout                               initialLayout,
    VkImageLayout                               finalLayout);


VkAttachmentReference AttachmentReference(
    uint32_t                                    attachment,
    VkImageLayout                               layout);


std::shared_ptr<VkSubpassDescriptionRAII> SubpassDescription(
    VkSubpassDescriptionFlags                   flags,
    VkPipelineBindPoint                         pipelineBindPoint,
    const std::vector<VkAttachmentReference> &  vecInputAttachments,
    const std::vector<VkAttachmentReference> &  vecColorAttachments,
    const std::vector<VkAttachmentReference> &  vecResolveAttachments,
    const VkAttachmentReference *               pDepthStencilAttachment,
    unsigned int* pPreserveAttachments_in_array1, int pPreserveAttachments_dim1);


VkSubpassDependency SubpassDependency(
    uint32_t                                    srcSubpass,
    uint32_t                                    dstSubpass,
    VkPipelineStageFlags                        srcStageMask,
    VkPipelineStageFlags                        dstStageMask,
    VkAccessFlags                               srcAccessMask,
    VkAccessFlags                               dstAccessMask,
    VkDependencyFlags                           dependencyFlags);


std::shared_ptr<VkRenderPassCreateInfoRAII> RenderPassCreateInfo(
    VkRenderPassCreateFlags                     flags,
    const std::vector<VkAttachmentDescription> &vecAttachments,
    const std::vector<VkSubpassDescription> &   vecSubpasses,
    const std::vector<VkSubpassDependency> &    vecDependencies);


std::shared_ptr<VkRenderPass_T> createRenderPass(
        VkDevice device,
        const VkRenderPassCreateInfo & pCreateInfo);

VkExtent2D getRenderAreaGranularity(
        VkDevice device,
        VkRenderPass renderPass);

VkCommandPoolCreateInfo CommandPoolCreateInfo(
    VkCommandPoolCreateFlags                    flags,
    uint32_t                                    queueFamilyIndex);


std::shared_ptr<VkCommandPool_T> createCommandPool(
        VkDevice device,
        const VkCommandPoolCreateInfo & pCreateInfo);

void  resetCommandPool(
        VkDevice device,
        VkCommandPool commandPool,
        VkCommandPoolResetFlags flags);

VkCommandBufferAllocateInfo CommandBufferAllocateInfo(
    VkCommandPool                               commandPool,
    VkCommandBufferLevel                        level,
    uint32_t                                    commandBufferCount);


VkCommandBufferInheritanceInfo CommandBufferInheritanceInfo(
    VkRenderPass                                renderPass,
    uint32_t                                    subpass,
    VkFramebuffer                               framebuffer,
    VkBool32                                    occlusionQueryEnable,
    VkQueryControlFlags                         queryFlags,
    VkQueryPipelineStatisticFlags               pipelineStatistics);


std::shared_ptr<VkCommandBufferBeginInfoRAII> CommandBufferBeginInfo(
    VkCommandBufferUsageFlags                   flags,
    const VkCommandBufferInheritanceInfo *      pInheritanceInfo);


void  beginCommandBuffer(
        VkCommandBuffer commandBuffer,
        const VkCommandBufferBeginInfo & pBeginInfo);

void  endCommandBuffer(
        VkCommandBuffer commandBuffer);

void  resetCommandBuffer(
        VkCommandBuffer commandBuffer,
        VkCommandBufferResetFlags flags);

void  cmdBindPipeline(
        VkCommandBuffer commandBuffer,
        VkPipelineBindPoint pipelineBindPoint,
        VkPipeline pipeline);

void  cmdSetViewport(
        VkCommandBuffer commandBuffer,
        uint32_t firstViewport,
        const std::vector<VkViewport> & pViewports);

void  cmdSetScissor(
        VkCommandBuffer commandBuffer,
        uint32_t firstScissor,
        const std::vector<VkRect2D> & pScissors);

void  cmdSetLineWidth(
        VkCommandBuffer commandBuffer,
        float lineWidth);

void  cmdSetDepthBias(
        VkCommandBuffer commandBuffer,
        float depthBiasConstantFactor,
        float depthBiasClamp,
        float depthBiasSlopeFactor);

void  cmdSetBlendConstants(
        VkCommandBuffer commandBuffer,
        const float blendConstants[4]);

void  cmdSetDepthBounds(
        VkCommandBuffer commandBuffer,
        float minDepthBounds,
        float maxDepthBounds);

void  cmdSetStencilCompareMask(
        VkCommandBuffer commandBuffer,
        VkStencilFaceFlags faceMask,
        uint32_t compareMask);

void  cmdSetStencilWriteMask(
        VkCommandBuffer commandBuffer,
        VkStencilFaceFlags faceMask,
        uint32_t writeMask);

void  cmdSetStencilReference(
        VkCommandBuffer commandBuffer,
        VkStencilFaceFlags faceMask,
        uint32_t reference);

void  cmdBindDescriptorSets(
        VkCommandBuffer commandBuffer,
        VkPipelineBindPoint pipelineBindPoint,
        VkPipelineLayout layout,
        uint32_t firstSet,
        const std::vector<VkDescriptorSet> & pDescriptorSets,
        unsigned int* pDynamicOffsets_in_array1, int pDynamicOffsets_dim1);

void  cmdBindIndexBuffer(
        VkCommandBuffer commandBuffer,
        VkBuffer buffer,
        VkDeviceSize offset,
        VkIndexType indexType);

void  cmdBindVertexBuffers(
        VkCommandBuffer commandBuffer,
        uint32_t firstBinding,
        const std::vector<VkBuffer> & pBuffers,
        const std::vector<VkDeviceSize> & pOffsets);

void  cmdDraw(
        VkCommandBuffer commandBuffer,
        uint32_t vertexCount,
        uint32_t instanceCount,
        uint32_t firstVertex,
        uint32_t firstInstance);

void  cmdDrawIndexed(
        VkCommandBuffer commandBuffer,
        uint32_t indexCount,
        uint32_t instanceCount,
        uint32_t firstIndex,
        int32_t vertexOffset,
        uint32_t firstInstance);

void  cmdDrawIndirect(
        VkCommandBuffer commandBuffer,
        VkBuffer buffer,
        VkDeviceSize offset,
        uint32_t drawCount,
        uint32_t stride);

void  cmdDrawIndexedIndirect(
        VkCommandBuffer commandBuffer,
        VkBuffer buffer,
        VkDeviceSize offset,
        uint32_t drawCount,
        uint32_t stride);

void  cmdDispatch(
        VkCommandBuffer commandBuffer,
        uint32_t groupCountX,
        uint32_t groupCountY,
        uint32_t groupCountZ);

void  cmdDispatchIndirect(
        VkCommandBuffer commandBuffer,
        VkBuffer buffer,
        VkDeviceSize offset);

VkBufferCopy BufferCopy(
    VkDeviceSize                                srcOffset,
    VkDeviceSize                                dstOffset,
    VkDeviceSize                                size);


void  cmdCopyBuffer(
        VkCommandBuffer commandBuffer,
        VkBuffer srcBuffer,
        VkBuffer dstBuffer,
        const std::vector<VkBufferCopy> & pRegions);

VkImageSubresourceLayers ImageSubresourceLayers(
    VkImageAspectFlags                          aspectMask,
    uint32_t                                    mipLevel,
    uint32_t                                    baseArrayLayer,
    uint32_t                                    layerCount);


VkImageCopy ImageCopy(
    VkImageSubresourceLayers                    srcSubresource,
    VkOffset3D                                  srcOffset,
    VkImageSubresourceLayers                    dstSubresource,
    VkOffset3D                                  dstOffset,
    VkExtent3D                                  extent);


void  cmdCopyImage(
        VkCommandBuffer commandBuffer,
        VkImage srcImage,
        VkImageLayout srcImageLayout,
        VkImage dstImage,
        VkImageLayout dstImageLayout,
        const std::vector<VkImageCopy> & pRegions);

VkImageBlit ImageBlit(
    VkImageSubresourceLayers                    srcSubresource,
    VkOffset3D                                  srcOffsets[2],
    VkImageSubresourceLayers                    dstSubresource,
    VkOffset3D                                  dstOffsets[2]);


void  cmdBlitImage(
        VkCommandBuffer commandBuffer,
        VkImage srcImage,
        VkImageLayout srcImageLayout,
        VkImage dstImage,
        VkImageLayout dstImageLayout,
        const std::vector<VkImageBlit> & pRegions,
        VkFilter filter);

VkBufferImageCopy BufferImageCopy(
    VkDeviceSize                                bufferOffset,
    uint32_t                                    bufferRowLength,
    uint32_t                                    bufferImageHeight,
    VkImageSubresourceLayers                    imageSubresource,
    VkOffset3D                                  imageOffset,
    VkExtent3D                                  imageExtent);


void  cmdCopyBufferToImage(
        VkCommandBuffer commandBuffer,
        VkBuffer srcBuffer,
        VkImage dstImage,
        VkImageLayout dstImageLayout,
        const std::vector<VkBufferImageCopy> & pRegions);

void  cmdCopyImageToBuffer(
        VkCommandBuffer commandBuffer,
        VkImage srcImage,
        VkImageLayout srcImageLayout,
        VkBuffer dstBuffer,
        const std::vector<VkBufferImageCopy> & pRegions);

void  cmdFillBuffer(
        VkCommandBuffer commandBuffer,
        VkBuffer dstBuffer,
        VkDeviceSize dstOffset,
        VkDeviceSize size,
        uint32_t data);

void  cmdClearColorImage(
        VkCommandBuffer commandBuffer,
        VkImage image,
        VkImageLayout imageLayout,
        const VkClearColorValue & pColor,
        const std::vector<VkImageSubresourceRange> & pRanges);

VkClearDepthStencilValue ClearDepthStencilValue(
    float                                       depth,
    uint32_t                                    stencil);


void  cmdClearDepthStencilImage(
        VkCommandBuffer commandBuffer,
        VkImage image,
        VkImageLayout imageLayout,
        const VkClearDepthStencilValue & pDepthStencil,
        const std::vector<VkImageSubresourceRange> & pRanges);

VkClearAttachment ClearAttachment(
    VkImageAspectFlags                          aspectMask,
    uint32_t                                    colorAttachment,
    VkClearValue                                clearValue);


VkClearRect ClearRect(
    VkRect2D                                    rect,
    uint32_t                                    baseArrayLayer,
    uint32_t                                    layerCount);


void  cmdClearAttachments(
        VkCommandBuffer commandBuffer,
        const std::vector<VkClearAttachment> & pAttachments,
        const std::vector<VkClearRect> & pRects);

VkImageResolve ImageResolve(
    VkImageSubresourceLayers                    srcSubresource,
    VkOffset3D                                  srcOffset,
    VkImageSubresourceLayers                    dstSubresource,
    VkOffset3D                                  dstOffset,
    VkExtent3D                                  extent);


void  cmdResolveImage(
        VkCommandBuffer commandBuffer,
        VkImage srcImage,
        VkImageLayout srcImageLayout,
        VkImage dstImage,
        VkImageLayout dstImageLayout,
        const std::vector<VkImageResolve> & pRegions);

void  cmdSetEvent(
        VkCommandBuffer commandBuffer,
        VkEvent event,
        VkPipelineStageFlags stageMask);

void  cmdResetEvent(
        VkCommandBuffer commandBuffer,
        VkEvent event,
        VkPipelineStageFlags stageMask);

VkMemoryBarrier MemoryBarrier(
    VkAccessFlags                               srcAccessMask,
    VkAccessFlags                               dstAccessMask);


VkBufferMemoryBarrier BufferMemoryBarrier(
    VkAccessFlags                               srcAccessMask,
    VkAccessFlags                               dstAccessMask,
    uint32_t                                    srcQueueFamilyIndex,
    uint32_t                                    dstQueueFamilyIndex,
    VkBuffer                                    buffer,
    VkDeviceSize                                offset,
    VkDeviceSize                                size);


VkImageMemoryBarrier ImageMemoryBarrier(
    VkAccessFlags                               srcAccessMask,
    VkAccessFlags                               dstAccessMask,
    VkImageLayout                               oldLayout,
    VkImageLayout                               newLayout,
    uint32_t                                    srcQueueFamilyIndex,
    uint32_t                                    dstQueueFamilyIndex,
    VkImage                                     image,
    VkImageSubresourceRange                     subresourceRange);


void  cmdWaitEvents(
        VkCommandBuffer commandBuffer,
        const std::vector<VkEvent> & pEvents,
        VkPipelineStageFlags srcStageMask,
        VkPipelineStageFlags dstStageMask,
        const std::vector<VkMemoryBarrier> & pMemoryBarriers,
        const std::vector<VkBufferMemoryBarrier> & pBufferMemoryBarriers,
        const std::vector<VkImageMemoryBarrier> & pImageMemoryBarriers);

void  cmdPipelineBarrier(
        VkCommandBuffer commandBuffer,
        VkPipelineStageFlags srcStageMask,
        VkPipelineStageFlags dstStageMask,
        VkDependencyFlags dependencyFlags,
        const std::vector<VkMemoryBarrier> & pMemoryBarriers,
        const std::vector<VkBufferMemoryBarrier> & pBufferMemoryBarriers,
        const std::vector<VkImageMemoryBarrier> & pImageMemoryBarriers);

void  cmdBeginQuery(
        VkCommandBuffer commandBuffer,
        VkQueryPool queryPool,
        uint32_t query,
        VkQueryControlFlags flags);

void  cmdEndQuery(
        VkCommandBuffer commandBuffer,
        VkQueryPool queryPool,
        uint32_t query);

void  cmdResetQueryPool(
        VkCommandBuffer commandBuffer,
        VkQueryPool queryPool,
        uint32_t firstQuery,
        uint32_t queryCount);

void  cmdWriteTimestamp(
        VkCommandBuffer commandBuffer,
        VkPipelineStageFlagBits pipelineStage,
        VkQueryPool queryPool,
        uint32_t query);

void  cmdCopyQueryPoolResults(
        VkCommandBuffer commandBuffer,
        VkQueryPool queryPool,
        uint32_t firstQuery,
        uint32_t queryCount,
        VkBuffer dstBuffer,
        VkDeviceSize dstOffset,
        VkDeviceSize stride,
        VkQueryResultFlags flags);

std::shared_ptr<VkRenderPassBeginInfoRAII> RenderPassBeginInfo(
    VkRenderPass                                renderPass,
    VkFramebuffer                               framebuffer,
    VkRect2D                                    renderArea,
    const std::vector<VkClearValue> &           vecClearValues);


void  cmdBeginRenderPass(
        VkCommandBuffer commandBuffer,
        const VkRenderPassBeginInfo & pRenderPassBegin,
        VkSubpassContents contents);

void  cmdNextSubpass(
        VkCommandBuffer commandBuffer,
        VkSubpassContents contents);

void  cmdEndRenderPass(
        VkCommandBuffer commandBuffer);

void  cmdExecuteCommands(
        VkCommandBuffer commandBuffer,
        const std::vector<VkCommandBuffer> & pCommandBuffers);

VkDispatchIndirectCommand DispatchIndirectCommand(
    uint32_t                                    x,
    uint32_t                                    y,
    uint32_t                                    z);


VkDrawIndexedIndirectCommand DrawIndexedIndirectCommand(
    uint32_t                                    indexCount,
    uint32_t                                    instanceCount,
    uint32_t                                    firstIndex,
    int32_t                                     vertexOffset,
    uint32_t                                    firstInstance);


VkDrawIndirectCommand DrawIndirectCommand(
    uint32_t                                    vertexCount,
    uint32_t                                    instanceCount,
    uint32_t                                    firstVertex,
    uint32_t                                    firstInstance);




#define VK_VERSION_1_1 1
// Vulkan 1.1 version number
#define VK_API_VERSION_1_1 VK_MAKE_VERSION(1, 1, 0)// Patch version should always be set to 0

VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkSamplerYcbcrConversion)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkDescriptorUpdateTemplate)
#define VK_MAX_DEVICE_GROUP_SIZE          32
#define VK_LUID_SIZE                      8
#define VK_QUEUE_FAMILY_EXTERNAL          (~0U-1)

typedef enum VkPointClippingBehavior {
    VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES = 0,
    VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY = 1,
    VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES_KHR = VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES,
    VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY_KHR = VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY,
    VK_POINT_CLIPPING_BEHAVIOR_MAX_ENUM = 0x7FFFFFFF
} VkPointClippingBehavior;

typedef enum VkTessellationDomainOrigin {
    VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT = 0,
    VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT = 1,
    VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT_KHR = VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT,
    VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT_KHR = VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT,
    VK_TESSELLATION_DOMAIN_ORIGIN_MAX_ENUM = 0x7FFFFFFF
} VkTessellationDomainOrigin;

typedef enum VkSamplerYcbcrModelConversion {
    VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY = 0,
    VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY = 1,
    VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709 = 2,
    VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601 = 3,
    VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020 = 4,
    VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY_KHR = VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY,
    VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY_KHR = VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY,
    VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709_KHR = VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709,
    VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601_KHR = VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601,
    VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020_KHR = VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020,
    VK_SAMPLER_YCBCR_MODEL_CONVERSION_MAX_ENUM = 0x7FFFFFFF
} VkSamplerYcbcrModelConversion;

typedef enum VkSamplerYcbcrRange {
    VK_SAMPLER_YCBCR_RANGE_ITU_FULL = 0,
    VK_SAMPLER_YCBCR_RANGE_ITU_NARROW = 1,
    VK_SAMPLER_YCBCR_RANGE_ITU_FULL_KHR = VK_SAMPLER_YCBCR_RANGE_ITU_FULL,
    VK_SAMPLER_YCBCR_RANGE_ITU_NARROW_KHR = VK_SAMPLER_YCBCR_RANGE_ITU_NARROW,
    VK_SAMPLER_YCBCR_RANGE_MAX_ENUM = 0x7FFFFFFF
} VkSamplerYcbcrRange;

typedef enum VkChromaLocation {
    VK_CHROMA_LOCATION_COSITED_EVEN = 0,
    VK_CHROMA_LOCATION_MIDPOINT = 1,
    VK_CHROMA_LOCATION_COSITED_EVEN_KHR = VK_CHROMA_LOCATION_COSITED_EVEN,
    VK_CHROMA_LOCATION_MIDPOINT_KHR = VK_CHROMA_LOCATION_MIDPOINT,
    VK_CHROMA_LOCATION_MAX_ENUM = 0x7FFFFFFF
} VkChromaLocation;

typedef enum VkDescriptorUpdateTemplateType {
    VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET = 0,
    VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR = 1,
    VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET_KHR = VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET,
    VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_MAX_ENUM = 0x7FFFFFFF
} VkDescriptorUpdateTemplateType;

typedef enum VkSubgroupFeatureFlagBits {
    VK_SUBGROUP_FEATURE_BASIC_BIT = 0x00000001,
    VK_SUBGROUP_FEATURE_VOTE_BIT = 0x00000002,
    VK_SUBGROUP_FEATURE_ARITHMETIC_BIT = 0x00000004,
    VK_SUBGROUP_FEATURE_BALLOT_BIT = 0x00000008,
    VK_SUBGROUP_FEATURE_SHUFFLE_BIT = 0x00000010,
    VK_SUBGROUP_FEATURE_SHUFFLE_RELATIVE_BIT = 0x00000020,
    VK_SUBGROUP_FEATURE_CLUSTERED_BIT = 0x00000040,
    VK_SUBGROUP_FEATURE_QUAD_BIT = 0x00000080,
    VK_SUBGROUP_FEATURE_PARTITIONED_BIT_NV = 0x00000100,
    VK_SUBGROUP_FEATURE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkSubgroupFeatureFlagBits;
typedef VkFlags VkSubgroupFeatureFlags;

typedef enum VkPeerMemoryFeatureFlagBits {
    VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT = 0x00000001,
    VK_PEER_MEMORY_FEATURE_COPY_DST_BIT = 0x00000002,
    VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT = 0x00000004,
    VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT = 0x00000008,
    VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT_KHR = VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT,
    VK_PEER_MEMORY_FEATURE_COPY_DST_BIT_KHR = VK_PEER_MEMORY_FEATURE_COPY_DST_BIT,
    VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT_KHR = VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT,
    VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT_KHR = VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT,
    VK_PEER_MEMORY_FEATURE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkPeerMemoryFeatureFlagBits;
typedef VkFlags VkPeerMemoryFeatureFlags;

typedef enum VkMemoryAllocateFlagBits {
    VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT = 0x00000001,
    VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT_KHR = VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT,
    VK_MEMORY_ALLOCATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkMemoryAllocateFlagBits;
typedef VkFlags VkMemoryAllocateFlags;
typedef VkFlags VkCommandPoolTrimFlags;
typedef VkFlags VkDescriptorUpdateTemplateCreateFlags;

typedef enum VkExternalMemoryHandleTypeFlagBits {
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT = 0x00000001,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT = 0x00000002,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT = 0x00000004,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT = 0x00000008,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT = 0x00000010,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT = 0x00000020,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT = 0x00000040,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT = 0x00000200,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID = 0x00000400,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT = 0x00000080,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT = 0x00000100,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT_KHR = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT_KHR = VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT_KHR = VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT_KHR = VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT_KHR = VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkExternalMemoryHandleTypeFlagBits;
typedef VkFlags VkExternalMemoryHandleTypeFlags;

typedef enum VkExternalMemoryFeatureFlagBits {
    VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT = 0x00000001,
    VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT = 0x00000002,
    VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT = 0x00000004,
    VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_KHR = VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT,
    VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_KHR = VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT,
    VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_KHR = VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT,
    VK_EXTERNAL_MEMORY_FEATURE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkExternalMemoryFeatureFlagBits;
typedef VkFlags VkExternalMemoryFeatureFlags;

typedef enum VkExternalFenceHandleTypeFlagBits {
    VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT = 0x00000001,
    VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT = 0x00000002,
    VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT = 0x00000004,
    VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT = 0x00000008,
    VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR = VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT,
    VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR = VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT,
    VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR = VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT,
    VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT_KHR = VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT,
    VK_EXTERNAL_FENCE_HANDLE_TYPE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkExternalFenceHandleTypeFlagBits;
typedef VkFlags VkExternalFenceHandleTypeFlags;

typedef enum VkExternalFenceFeatureFlagBits {
    VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT = 0x00000001,
    VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT = 0x00000002,
    VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT_KHR = VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT,
    VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT_KHR = VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT,
    VK_EXTERNAL_FENCE_FEATURE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkExternalFenceFeatureFlagBits;
typedef VkFlags VkExternalFenceFeatureFlags;

typedef enum VkFenceImportFlagBits {
    VK_FENCE_IMPORT_TEMPORARY_BIT = 0x00000001,
    VK_FENCE_IMPORT_TEMPORARY_BIT_KHR = VK_FENCE_IMPORT_TEMPORARY_BIT,
    VK_FENCE_IMPORT_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkFenceImportFlagBits;
typedef VkFlags VkFenceImportFlags;

typedef enum VkSemaphoreImportFlagBits {
    VK_SEMAPHORE_IMPORT_TEMPORARY_BIT = 0x00000001,
    VK_SEMAPHORE_IMPORT_TEMPORARY_BIT_KHR = VK_SEMAPHORE_IMPORT_TEMPORARY_BIT,
    VK_SEMAPHORE_IMPORT_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkSemaphoreImportFlagBits;
typedef VkFlags VkSemaphoreImportFlags;

typedef enum VkExternalSemaphoreHandleTypeFlagBits {
    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT = 0x00000001,
    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT = 0x00000002,
    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT = 0x00000004,
    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT = 0x00000008,
    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT = 0x00000010,
    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT,
    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT,
    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT,
    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT_KHR = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT,
    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT_KHR = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT,
    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkExternalSemaphoreHandleTypeFlagBits;
typedef VkFlags VkExternalSemaphoreHandleTypeFlags;

typedef enum VkExternalSemaphoreFeatureFlagBits {
    VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT = 0x00000001,
    VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT = 0x00000002,
    VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT_KHR = VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT,
    VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT_KHR = VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT,
    VK_EXTERNAL_SEMAPHORE_FEATURE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkExternalSemaphoreFeatureFlagBits;
typedef VkFlags VkExternalSemaphoreFeatureFlags;
typedef struct VkPhysicalDeviceSubgroupProperties {
    VkStructureType           sType;
    void*                     pNext;
    uint32_t                  subgroupSize;
    VkShaderStageFlags        supportedStages;
    VkSubgroupFeatureFlags    supportedOperations;
    VkBool32                  quadOperationsInAllStages;
} VkPhysicalDeviceSubgroupProperties;

typedef struct VkBindBufferMemoryInfo {
    VkStructureType    sType;
    const void*        pNext;
    VkBuffer           buffer;
    VkDeviceMemory     memory;
    VkDeviceSize       memoryOffset;
} VkBindBufferMemoryInfo;

typedef struct VkBindImageMemoryInfo {
    VkStructureType    sType;
    const void*        pNext;
    VkImage            image;
    VkDeviceMemory     memory;
    VkDeviceSize       memoryOffset;
} VkBindImageMemoryInfo;

typedef struct VkPhysicalDevice16BitStorageFeatures {
    VkStructureType    sType;
    void*              pNext;
    VkBool32           storageBuffer16BitAccess;
    VkBool32           uniformAndStorageBuffer16BitAccess;
    VkBool32           storagePushConstant16;
    VkBool32           storageInputOutput16;
} VkPhysicalDevice16BitStorageFeatures;

typedef struct VkMemoryDedicatedRequirements {
    VkStructureType    sType;
    void*              pNext;
    VkBool32           prefersDedicatedAllocation;
    VkBool32           requiresDedicatedAllocation;
} VkMemoryDedicatedRequirements;

typedef struct VkMemoryDedicatedAllocateInfo {
    VkStructureType    sType;
    const void*        pNext;
    VkImage            image;
    VkBuffer           buffer;
} VkMemoryDedicatedAllocateInfo;

typedef struct VkMemoryAllocateFlagsInfo {
    VkStructureType          sType;
    const void*              pNext;
    VkMemoryAllocateFlags    flags;
    uint32_t                 deviceMask;
} VkMemoryAllocateFlagsInfo;

typedef struct VkDeviceGroupRenderPassBeginInfo {
    VkStructureType    sType;
    const void*        pNext;
    uint32_t           deviceMask;
    uint32_t           deviceRenderAreaCount;
    const VkRect2D*    pDeviceRenderAreas;
} VkDeviceGroupRenderPassBeginInfo;

struct VkDeviceGroupRenderPassBeginInfoRAII {
   VkDeviceGroupRenderPassBeginInfo nonRaiiObj;
    std::vector<VkRect2D>                       vecDeviceRenderAreas;
};

typedef struct VkDeviceGroupCommandBufferBeginInfo {
    VkStructureType    sType;
    const void*        pNext;
    uint32_t           deviceMask;
} VkDeviceGroupCommandBufferBeginInfo;

typedef struct VkDeviceGroupSubmitInfo {
    VkStructureType    sType;
    const void*        pNext;
    uint32_t           waitSemaphoreCount;
    const uint32_t*    pWaitSemaphoreDeviceIndices;
    uint32_t           commandBufferCount;
    const uint32_t*    pCommandBufferDeviceMasks;
    uint32_t           signalSemaphoreCount;
    const uint32_t*    pSignalSemaphoreDeviceIndices;
} VkDeviceGroupSubmitInfo;

struct VkDeviceGroupSubmitInfoRAII {
   VkDeviceGroupSubmitInfo nonRaiiObj;
    std::vector<uint32_t>                       vecWaitSemaphoreDeviceIndices;
    std::vector<uint32_t>                       vecCommandBufferDeviceMasks;
    std::vector<uint32_t>                       vecSignalSemaphoreDeviceIndices;
};

typedef struct VkDeviceGroupBindSparseInfo {
    VkStructureType    sType;
    const void*        pNext;
    uint32_t           resourceDeviceIndex;
    uint32_t           memoryDeviceIndex;
} VkDeviceGroupBindSparseInfo;

typedef struct VkBindBufferMemoryDeviceGroupInfo {
    VkStructureType    sType;
    const void*        pNext;
    uint32_t           deviceIndexCount;
    const uint32_t*    pDeviceIndices;
} VkBindBufferMemoryDeviceGroupInfo;

struct VkBindBufferMemoryDeviceGroupInfoRAII {
   VkBindBufferMemoryDeviceGroupInfo nonRaiiObj;
    std::vector<uint32_t>                       vecDeviceIndices;
};

typedef struct VkBindImageMemoryDeviceGroupInfo {
    VkStructureType    sType;
    const void*        pNext;
    uint32_t           deviceIndexCount;
    const uint32_t*    pDeviceIndices;
    uint32_t           splitInstanceBindRegionCount;
    const VkRect2D*    pSplitInstanceBindRegions;
} VkBindImageMemoryDeviceGroupInfo;

struct VkBindImageMemoryDeviceGroupInfoRAII {
   VkBindImageMemoryDeviceGroupInfo nonRaiiObj;
    std::vector<uint32_t>                       vecDeviceIndices;
    std::vector<VkRect2D>                       vecSplitInstanceBindRegions;
};

typedef struct VkPhysicalDeviceGroupProperties {
    VkStructureType     sType;
    void*               pNext;
    uint32_t            physicalDeviceCount;
    VkPhysicalDevice    physicalDevices[VK_MAX_DEVICE_GROUP_SIZE];
    VkBool32            subsetAllocation;
} VkPhysicalDeviceGroupProperties;

typedef struct VkDeviceGroupDeviceCreateInfo {
    VkStructureType            sType;
    const void*                pNext;
    uint32_t                   physicalDeviceCount;
    const VkPhysicalDevice*    pPhysicalDevices;
} VkDeviceGroupDeviceCreateInfo;

struct VkDeviceGroupDeviceCreateInfoRAII {
   VkDeviceGroupDeviceCreateInfo nonRaiiObj;
    std::vector<VkPhysicalDevice>               vecPhysicalDevices;
};

typedef struct VkBufferMemoryRequirementsInfo2 {
    VkStructureType    sType;
    const void*        pNext;
    VkBuffer           buffer;
} VkBufferMemoryRequirementsInfo2;

typedef struct VkImageMemoryRequirementsInfo2 {
    VkStructureType    sType;
    const void*        pNext;
    VkImage            image;
} VkImageMemoryRequirementsInfo2;

typedef struct VkImageSparseMemoryRequirementsInfo2 {
    VkStructureType    sType;
    const void*        pNext;
    VkImage            image;
} VkImageSparseMemoryRequirementsInfo2;

typedef struct VkMemoryRequirements2 {
    VkStructureType         sType;
    void*                   pNext;
    VkMemoryRequirements    memoryRequirements;
} VkMemoryRequirements2;

typedef VkMemoryRequirements2 VkMemoryRequirements2KHR;

typedef struct VkSparseImageMemoryRequirements2 {
    VkStructureType                    sType;
    void*                              pNext;
    VkSparseImageMemoryRequirements    memoryRequirements;
} VkSparseImageMemoryRequirements2;

typedef struct VkPhysicalDeviceFeatures2 {
    VkStructureType             sType;
    void*                       pNext;
    VkPhysicalDeviceFeatures    features;
} VkPhysicalDeviceFeatures2;

typedef struct VkPhysicalDeviceProperties2 {
    VkStructureType               sType;
    void*                         pNext;
    VkPhysicalDeviceProperties    properties;
} VkPhysicalDeviceProperties2;

typedef struct VkFormatProperties2 {
    VkStructureType       sType;
    void*                 pNext;
    VkFormatProperties    formatProperties;
} VkFormatProperties2;

typedef struct VkImageFormatProperties2 {
    VkStructureType            sType;
    void*                      pNext;
    VkImageFormatProperties    imageFormatProperties;
} VkImageFormatProperties2;

typedef struct VkPhysicalDeviceImageFormatInfo2 {
    VkStructureType       sType;
    const void*           pNext;
    VkFormat              format;
    VkImageType           type;
    VkImageTiling         tiling;
    VkImageUsageFlags     usage;
    VkImageCreateFlags    flags;
} VkPhysicalDeviceImageFormatInfo2;

typedef struct VkQueueFamilyProperties2 {
    VkStructureType            sType;
    void*                      pNext;
    VkQueueFamilyProperties    queueFamilyProperties;
} VkQueueFamilyProperties2;

typedef struct VkPhysicalDeviceMemoryProperties2 {
    VkStructureType                     sType;
    void*                               pNext;
    VkPhysicalDeviceMemoryProperties    memoryProperties;
} VkPhysicalDeviceMemoryProperties2;

typedef struct VkSparseImageFormatProperties2 {
    VkStructureType                  sType;
    void*                            pNext;
    VkSparseImageFormatProperties    properties;
} VkSparseImageFormatProperties2;

typedef struct VkPhysicalDeviceSparseImageFormatInfo2 {
    VkStructureType          sType;
    const void*              pNext;
    VkFormat                 format;
    VkImageType              type;
    VkSampleCountFlagBits    samples;
    VkImageUsageFlags        usage;
    VkImageTiling            tiling;
} VkPhysicalDeviceSparseImageFormatInfo2;

typedef struct VkPhysicalDevicePointClippingProperties {
    VkStructureType            sType;
    void*                      pNext;
    VkPointClippingBehavior    pointClippingBehavior;
} VkPhysicalDevicePointClippingProperties;

typedef struct VkInputAttachmentAspectReference {
    uint32_t              subpass;
    uint32_t              inputAttachmentIndex;
    VkImageAspectFlags    aspectMask;
} VkInputAttachmentAspectReference;

typedef struct VkRenderPassInputAttachmentAspectCreateInfo {
    VkStructureType                            sType;
    const void*                                pNext;
    uint32_t                                   aspectReferenceCount;
    const VkInputAttachmentAspectReference*    pAspectReferences;
} VkRenderPassInputAttachmentAspectCreateInfo;

struct VkRenderPassInputAttachmentAspectCreateInfoRAII {
   VkRenderPassInputAttachmentAspectCreateInfo nonRaiiObj;
    std::vector<VkInputAttachmentAspectReference>vecAspectReferences;
};

typedef struct VkImageViewUsageCreateInfo {
    VkStructureType      sType;
    const void*          pNext;
    VkImageUsageFlags    usage;
} VkImageViewUsageCreateInfo;

typedef struct VkPipelineTessellationDomainOriginStateCreateInfo {
    VkStructureType               sType;
    const void*                   pNext;
    VkTessellationDomainOrigin    domainOrigin;
} VkPipelineTessellationDomainOriginStateCreateInfo;

typedef struct VkRenderPassMultiviewCreateInfo {
    VkStructureType    sType;
    const void*        pNext;
    uint32_t           subpassCount;
    const uint32_t*    pViewMasks;
    uint32_t           dependencyCount;
    const int32_t*     pViewOffsets;
    uint32_t           correlationMaskCount;
    const uint32_t*    pCorrelationMasks;
} VkRenderPassMultiviewCreateInfo;

struct VkRenderPassMultiviewCreateInfoRAII {
   VkRenderPassMultiviewCreateInfo nonRaiiObj;
    std::vector<uint32_t>                       vecViewMasks;
    std::vector<int32_t>                        vecViewOffsets;
    std::vector<uint32_t>                       vecCorrelationMasks;
};

typedef struct VkPhysicalDeviceMultiviewFeatures {
    VkStructureType    sType;
    void*              pNext;
    VkBool32           multiview;
    VkBool32           multiviewGeometryShader;
    VkBool32           multiviewTessellationShader;
} VkPhysicalDeviceMultiviewFeatures;

typedef struct VkPhysicalDeviceMultiviewProperties {
    VkStructureType    sType;
    void*              pNext;
    uint32_t           maxMultiviewViewCount;
    uint32_t           maxMultiviewInstanceIndex;
} VkPhysicalDeviceMultiviewProperties;

typedef struct VkPhysicalDeviceVariablePointersFeatures {
    VkStructureType    sType;
    void*              pNext;
    VkBool32           variablePointersStorageBuffer;
    VkBool32           variablePointers;
} VkPhysicalDeviceVariablePointersFeatures;

typedef VkPhysicalDeviceVariablePointersFeatures VkPhysicalDeviceVariablePointerFeatures;

typedef struct VkPhysicalDeviceProtectedMemoryFeatures {
    VkStructureType    sType;
    void*              pNext;
    VkBool32           protectedMemory;
} VkPhysicalDeviceProtectedMemoryFeatures;

typedef struct VkPhysicalDeviceProtectedMemoryProperties {
    VkStructureType    sType;
    void*              pNext;
    VkBool32           protectedNoFault;
} VkPhysicalDeviceProtectedMemoryProperties;

typedef struct VkDeviceQueueInfo2 {
    VkStructureType             sType;
    const void*                 pNext;
    VkDeviceQueueCreateFlags    flags;
    uint32_t                    queueFamilyIndex;
    uint32_t                    queueIndex;
} VkDeviceQueueInfo2;

typedef struct VkProtectedSubmitInfo {
    VkStructureType    sType;
    const void*        pNext;
    VkBool32           protectedSubmit;
} VkProtectedSubmitInfo;

typedef struct VkSamplerYcbcrConversionCreateInfo {
    VkStructureType                  sType;
    const void*                      pNext;
    VkFormat                         format;
    VkSamplerYcbcrModelConversion    ycbcrModel;
    VkSamplerYcbcrRange              ycbcrRange;
    VkComponentMapping               components;
    VkChromaLocation                 xChromaOffset;
    VkChromaLocation                 yChromaOffset;
    VkFilter                         chromaFilter;
    VkBool32                         forceExplicitReconstruction;
} VkSamplerYcbcrConversionCreateInfo;

typedef struct VkSamplerYcbcrConversionInfo {
    VkStructureType             sType;
    const void*                 pNext;
    VkSamplerYcbcrConversion    conversion;
} VkSamplerYcbcrConversionInfo;

typedef struct VkBindImagePlaneMemoryInfo {
    VkStructureType          sType;
    const void*              pNext;
    VkImageAspectFlagBits    planeAspect;
} VkBindImagePlaneMemoryInfo;

typedef struct VkImagePlaneMemoryRequirementsInfo {
    VkStructureType          sType;
    const void*              pNext;
    VkImageAspectFlagBits    planeAspect;
} VkImagePlaneMemoryRequirementsInfo;

typedef struct VkPhysicalDeviceSamplerYcbcrConversionFeatures {
    VkStructureType    sType;
    void*              pNext;
    VkBool32           samplerYcbcrConversion;
} VkPhysicalDeviceSamplerYcbcrConversionFeatures;

typedef struct VkSamplerYcbcrConversionImageFormatProperties {
    VkStructureType    sType;
    void*              pNext;
    uint32_t           combinedImageSamplerDescriptorCount;
} VkSamplerYcbcrConversionImageFormatProperties;

typedef struct VkDescriptorUpdateTemplateEntry {
    uint32_t            dstBinding;
    uint32_t            dstArrayElement;
    uint32_t            descriptorCount;
    VkDescriptorType    descriptorType;
    size_t              offset;
    size_t              stride;
} VkDescriptorUpdateTemplateEntry;

typedef struct VkDescriptorUpdateTemplateCreateInfo {
    VkStructureType                           sType;
    const void*                               pNext;
    VkDescriptorUpdateTemplateCreateFlags     flags;
    uint32_t                                  descriptorUpdateEntryCount;
    const VkDescriptorUpdateTemplateEntry*    pDescriptorUpdateEntries;
    VkDescriptorUpdateTemplateType            templateType;
    VkDescriptorSetLayout                     descriptorSetLayout;
    VkPipelineBindPoint                       pipelineBindPoint;
    VkPipelineLayout                          pipelineLayout;
    uint32_t                                  set;
} VkDescriptorUpdateTemplateCreateInfo;

struct VkDescriptorUpdateTemplateCreateInfoRAII {
   VkDescriptorUpdateTemplateCreateInfo nonRaiiObj;
    std::vector<VkDescriptorUpdateTemplateEntry>vecDescriptorUpdateEntries;
};

typedef struct VkExternalMemoryProperties {
    VkExternalMemoryFeatureFlags       externalMemoryFeatures;
    VkExternalMemoryHandleTypeFlags    exportFromImportedHandleTypes;
    VkExternalMemoryHandleTypeFlags    compatibleHandleTypes;
} VkExternalMemoryProperties;

typedef struct VkPhysicalDeviceExternalImageFormatInfo {
    VkStructureType                       sType;
    const void*                           pNext;
    VkExternalMemoryHandleTypeFlagBits    handleType;
} VkPhysicalDeviceExternalImageFormatInfo;

typedef struct VkExternalImageFormatProperties {
    VkStructureType               sType;
    void*                         pNext;
    VkExternalMemoryProperties    externalMemoryProperties;
} VkExternalImageFormatProperties;

typedef struct VkPhysicalDeviceExternalBufferInfo {
    VkStructureType                       sType;
    const void*                           pNext;
    VkBufferCreateFlags                   flags;
    VkBufferUsageFlags                    usage;
    VkExternalMemoryHandleTypeFlagBits    handleType;
} VkPhysicalDeviceExternalBufferInfo;

typedef struct VkExternalBufferProperties {
    VkStructureType               sType;
    void*                         pNext;
    VkExternalMemoryProperties    externalMemoryProperties;
} VkExternalBufferProperties;

typedef struct VkPhysicalDeviceIDProperties {
    VkStructureType    sType;
    void*              pNext;
    uint8_t            deviceUUID[VK_UUID_SIZE];
    uint8_t            driverUUID[VK_UUID_SIZE];
    uint8_t            deviceLUID[VK_LUID_SIZE];
    uint32_t           deviceNodeMask;
    VkBool32           deviceLUIDValid;
} VkPhysicalDeviceIDProperties;

typedef struct VkExternalMemoryImageCreateInfo {
    VkStructureType                    sType;
    const void*                        pNext;
    VkExternalMemoryHandleTypeFlags    handleTypes;
} VkExternalMemoryImageCreateInfo;

typedef struct VkExternalMemoryBufferCreateInfo {
    VkStructureType                    sType;
    const void*                        pNext;
    VkExternalMemoryHandleTypeFlags    handleTypes;
} VkExternalMemoryBufferCreateInfo;

typedef struct VkExportMemoryAllocateInfo {
    VkStructureType                    sType;
    const void*                        pNext;
    VkExternalMemoryHandleTypeFlags    handleTypes;
} VkExportMemoryAllocateInfo;

typedef struct VkPhysicalDeviceExternalFenceInfo {
    VkStructureType                      sType;
    const void*                          pNext;
    VkExternalFenceHandleTypeFlagBits    handleType;
} VkPhysicalDeviceExternalFenceInfo;

typedef struct VkExternalFenceProperties {
    VkStructureType                   sType;
    void*                             pNext;
    VkExternalFenceHandleTypeFlags    exportFromImportedHandleTypes;
    VkExternalFenceHandleTypeFlags    compatibleHandleTypes;
    VkExternalFenceFeatureFlags       externalFenceFeatures;
} VkExternalFenceProperties;

typedef struct VkExportFenceCreateInfo {
    VkStructureType                   sType;
    const void*                       pNext;
    VkExternalFenceHandleTypeFlags    handleTypes;
} VkExportFenceCreateInfo;

typedef struct VkExportSemaphoreCreateInfo {
    VkStructureType                       sType;
    const void*                           pNext;
    VkExternalSemaphoreHandleTypeFlags    handleTypes;
} VkExportSemaphoreCreateInfo;

typedef struct VkPhysicalDeviceExternalSemaphoreInfo {
    VkStructureType                          sType;
    const void*                              pNext;
    VkExternalSemaphoreHandleTypeFlagBits    handleType;
} VkPhysicalDeviceExternalSemaphoreInfo;

typedef struct VkExternalSemaphoreProperties {
    VkStructureType                       sType;
    void*                                 pNext;
    VkExternalSemaphoreHandleTypeFlags    exportFromImportedHandleTypes;
    VkExternalSemaphoreHandleTypeFlags    compatibleHandleTypes;
    VkExternalSemaphoreFeatureFlags       externalSemaphoreFeatures;
} VkExternalSemaphoreProperties;

typedef struct VkPhysicalDeviceMaintenance3Properties {
    VkStructureType    sType;
    void*              pNext;
    uint32_t           maxPerSetDescriptors;
    VkDeviceSize       maxMemoryAllocationSize;
} VkPhysicalDeviceMaintenance3Properties;

typedef struct VkDescriptorSetLayoutSupport {
    VkStructureType    sType;
    void*              pNext;
    VkBool32           supported;
} VkDescriptorSetLayoutSupport;

typedef struct VkPhysicalDeviceShaderDrawParametersFeatures {
    VkStructureType    sType;
    void*              pNext;
    VkBool32           shaderDrawParameters;
} VkPhysicalDeviceShaderDrawParametersFeatures;

typedef VkPhysicalDeviceShaderDrawParametersFeatures VkPhysicalDeviceShaderDrawParameterFeatures;

typedef VkResult (VKAPI_PTR *PFN_vkEnumerateInstanceVersion)(uint32_t* pApiVersion);
typedef VkResult (VKAPI_PTR *PFN_vkBindBufferMemory2)(VkDevice device, uint32_t bindInfoCount, const VkBindBufferMemoryInfo* pBindInfos);
typedef VkResult (VKAPI_PTR *PFN_vkBindImageMemory2)(VkDevice device, uint32_t bindInfoCount, const VkBindImageMemoryInfo* pBindInfos);
typedef void (VKAPI_PTR *PFN_vkGetDeviceGroupPeerMemoryFeatures)(VkDevice device, uint32_t heapIndex, uint32_t localDeviceIndex, uint32_t remoteDeviceIndex, VkPeerMemoryFeatureFlags* pPeerMemoryFeatures);
typedef void (VKAPI_PTR *PFN_vkCmdSetDeviceMask)(VkCommandBuffer commandBuffer, uint32_t deviceMask);
typedef void (VKAPI_PTR *PFN_vkCmdDispatchBase)(VkCommandBuffer commandBuffer, uint32_t baseGroupX, uint32_t baseGroupY, uint32_t baseGroupZ, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ);
typedef VkResult (VKAPI_PTR *PFN_vkEnumeratePhysicalDeviceGroups)(VkInstance instance, uint32_t* pPhysicalDeviceGroupCount, VkPhysicalDeviceGroupProperties* pPhysicalDeviceGroupProperties);
typedef void (VKAPI_PTR *PFN_vkGetImageMemoryRequirements2)(VkDevice device, const VkImageMemoryRequirementsInfo2* pInfo, VkMemoryRequirements2* pMemoryRequirements);
typedef void (VKAPI_PTR *PFN_vkGetBufferMemoryRequirements2)(VkDevice device, const VkBufferMemoryRequirementsInfo2* pInfo, VkMemoryRequirements2* pMemoryRequirements);
typedef void (VKAPI_PTR *PFN_vkGetImageSparseMemoryRequirements2)(VkDevice device, const VkImageSparseMemoryRequirementsInfo2* pInfo, uint32_t* pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements2* pSparseMemoryRequirements);
typedef void (VKAPI_PTR *PFN_vkGetPhysicalDeviceFeatures2)(VkPhysicalDevice physicalDevice, VkPhysicalDeviceFeatures2* pFeatures);
typedef void (VKAPI_PTR *PFN_vkGetPhysicalDeviceProperties2)(VkPhysicalDevice physicalDevice, VkPhysicalDeviceProperties2* pProperties);
typedef void (VKAPI_PTR *PFN_vkGetPhysicalDeviceFormatProperties2)(VkPhysicalDevice physicalDevice, VkFormat format, VkFormatProperties2* pFormatProperties);
typedef VkResult (VKAPI_PTR *PFN_vkGetPhysicalDeviceImageFormatProperties2)(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceImageFormatInfo2* pImageFormatInfo, VkImageFormatProperties2* pImageFormatProperties);
typedef void (VKAPI_PTR *PFN_vkGetPhysicalDeviceQueueFamilyProperties2)(VkPhysicalDevice physicalDevice, uint32_t* pQueueFamilyPropertyCount, VkQueueFamilyProperties2* pQueueFamilyProperties);
typedef void (VKAPI_PTR *PFN_vkGetPhysicalDeviceMemoryProperties2)(VkPhysicalDevice physicalDevice, VkPhysicalDeviceMemoryProperties2* pMemoryProperties);
typedef void (VKAPI_PTR *PFN_vkGetPhysicalDeviceSparseImageFormatProperties2)(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSparseImageFormatInfo2* pFormatInfo, uint32_t* pPropertyCount, VkSparseImageFormatProperties2* pProperties);
typedef void (VKAPI_PTR *PFN_vkTrimCommandPool)(VkDevice device, VkCommandPool commandPool, VkCommandPoolTrimFlags flags);
typedef void (VKAPI_PTR *PFN_vkGetDeviceQueue2)(VkDevice device, const VkDeviceQueueInfo2* pQueueInfo, VkQueue* pQueue);
typedef VkResult (VKAPI_PTR *PFN_vkCreateSamplerYcbcrConversion)(VkDevice device, const VkSamplerYcbcrConversionCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSamplerYcbcrConversion* pYcbcrConversion);
typedef void (VKAPI_PTR *PFN_vkDestroySamplerYcbcrConversion)(VkDevice device, VkSamplerYcbcrConversion ycbcrConversion, const VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkCreateDescriptorUpdateTemplate)(VkDevice device, const VkDescriptorUpdateTemplateCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkDescriptorUpdateTemplate* pDescriptorUpdateTemplate);
typedef void (VKAPI_PTR *PFN_vkDestroyDescriptorUpdateTemplate)(VkDevice device, VkDescriptorUpdateTemplate descriptorUpdateTemplate, const VkAllocationCallbacks* pAllocator);
typedef void (VKAPI_PTR *PFN_vkGetPhysicalDeviceExternalBufferProperties)(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalBufferInfo* pExternalBufferInfo, VkExternalBufferProperties* pExternalBufferProperties);
typedef void (VKAPI_PTR *PFN_vkGetPhysicalDeviceExternalFenceProperties)(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalFenceInfo* pExternalFenceInfo, VkExternalFenceProperties* pExternalFenceProperties);
typedef void (VKAPI_PTR *PFN_vkGetPhysicalDeviceExternalSemaphoreProperties)(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalSemaphoreInfo* pExternalSemaphoreInfo, VkExternalSemaphoreProperties* pExternalSemaphoreProperties);
typedef void (VKAPI_PTR *PFN_vkGetDescriptorSetLayoutSupport)(VkDevice device, const VkDescriptorSetLayoutCreateInfo* pCreateInfo, VkDescriptorSetLayoutSupport* pSupport);

uint32_t enumerateInstanceVersion(void);

VkPhysicalDeviceSubgroupProperties PhysicalDeviceSubgroupProperties(
    uint32_t                                    subgroupSize,
    VkShaderStageFlags                          supportedStages,
    VkSubgroupFeatureFlags                      supportedOperations,
    VkBool32                                    quadOperationsInAllStages);


VkBindBufferMemoryInfo BindBufferMemoryInfo(
    VkBuffer                                    buffer,
    VkDeviceMemory                              memory,
    VkDeviceSize                                memoryOffset);


VkBindImageMemoryInfo BindImageMemoryInfo(
    VkImage                                     image,
    VkDeviceMemory                              memory,
    VkDeviceSize                                memoryOffset);


void  bindBufferMemory2(
        VkDevice device,
        const std::vector<VkBindBufferMemoryInfo> & pBindInfos);

void  bindImageMemory2(
        VkDevice device,
        const std::vector<VkBindImageMemoryInfo> & pBindInfos);

VkPhysicalDevice16BitStorageFeatures PhysicalDevice16BitStorageFeatures(
    VkBool32                                    storageBuffer16BitAccess,
    VkBool32                                    uniformAndStorageBuffer16BitAccess,
    VkBool32                                    storagePushConstant16,
    VkBool32                                    storageInputOutput16);


VkMemoryDedicatedRequirements MemoryDedicatedRequirements(
    VkBool32                                    prefersDedicatedAllocation,
    VkBool32                                    requiresDedicatedAllocation);


VkMemoryDedicatedAllocateInfo MemoryDedicatedAllocateInfo(
    VkImage                                     image,
    VkBuffer                                    buffer);


VkMemoryAllocateFlagsInfo MemoryAllocateFlagsInfo(
    VkMemoryAllocateFlags                       flags,
    uint32_t                                    deviceMask);


std::shared_ptr<VkDeviceGroupRenderPassBeginInfoRAII> DeviceGroupRenderPassBeginInfo(
    uint32_t                                    deviceMask,
    const std::vector<VkRect2D> &               vecDeviceRenderAreas);


VkDeviceGroupCommandBufferBeginInfo DeviceGroupCommandBufferBeginInfo(
    uint32_t                                    deviceMask);


std::shared_ptr<VkDeviceGroupSubmitInfoRAII> DeviceGroupSubmitInfo(
    unsigned int* pWaitSemaphoreDeviceIndices_in_array1, int pWaitSemaphoreDeviceIndices_dim1,
    unsigned int* pCommandBufferDeviceMasks_in_array1, int pCommandBufferDeviceMasks_dim1,
    unsigned int* pSignalSemaphoreDeviceIndices_in_array1, int pSignalSemaphoreDeviceIndices_dim1);


VkDeviceGroupBindSparseInfo DeviceGroupBindSparseInfo(
    uint32_t                                    resourceDeviceIndex,
    uint32_t                                    memoryDeviceIndex);


std::shared_ptr< VkPeerMemoryFeatureFlags > getDeviceGroupPeerMemoryFeatures(
        VkDevice device,
        uint32_t heapIndex,
        uint32_t localDeviceIndex,
        uint32_t remoteDeviceIndex);

void  cmdSetDeviceMask(
        VkCommandBuffer commandBuffer,
        uint32_t deviceMask);

void  cmdDispatchBase(
        VkCommandBuffer commandBuffer,
        uint32_t baseGroupX,
        uint32_t baseGroupY,
        uint32_t baseGroupZ,
        uint32_t groupCountX,
        uint32_t groupCountY,
        uint32_t groupCountZ);

std::shared_ptr<VkBindBufferMemoryDeviceGroupInfoRAII> BindBufferMemoryDeviceGroupInfo(
    unsigned int* pDeviceIndices_in_array1, int pDeviceIndices_dim1);


std::shared_ptr<VkBindImageMemoryDeviceGroupInfoRAII> BindImageMemoryDeviceGroupInfo(
    unsigned int* pDeviceIndices_in_array1, int pDeviceIndices_dim1,
    const std::vector<VkRect2D> &               vecSplitInstanceBindRegions);


VkPhysicalDeviceGroupProperties PhysicalDeviceGroupProperties(
    uint32_t                                    physicalDeviceCount,
    VkPhysicalDevice                            physicalDevices[VK_MAX_DEVICE_GROUP_SIZE],
    VkBool32                                    subsetAllocation);


std::shared_ptr<VkDeviceGroupDeviceCreateInfoRAII> DeviceGroupDeviceCreateInfo(
    const std::vector<VkPhysicalDevice> &       vecPhysicalDevices);


std::vector< VkPhysicalDeviceGroupProperties > enumeratePhysicalDeviceGroups(
        VkInstance instance);

VkBufferMemoryRequirementsInfo2 BufferMemoryRequirementsInfo2(
    VkBuffer                                    buffer);


VkImageMemoryRequirementsInfo2 ImageMemoryRequirementsInfo2(
    VkImage                                     image);


VkImageSparseMemoryRequirementsInfo2 ImageSparseMemoryRequirementsInfo2(
    VkImage                                     image);


VkMemoryRequirements2 MemoryRequirements2(
    VkMemoryRequirements                        memoryRequirements);


VkSparseImageMemoryRequirements2 SparseImageMemoryRequirements2(
    VkSparseImageMemoryRequirements             memoryRequirements);


VkMemoryRequirements2 getImageMemoryRequirements2(
        VkDevice device,
        const VkImageMemoryRequirementsInfo2 & pInfo);

VkMemoryRequirements2 getBufferMemoryRequirements2(
        VkDevice device,
        const VkBufferMemoryRequirementsInfo2 & pInfo);

std::vector< VkSparseImageMemoryRequirements2 > getImageSparseMemoryRequirements2(
        VkDevice device,
        const VkImageSparseMemoryRequirementsInfo2 & pInfo);

VkPhysicalDeviceFeatures2 PhysicalDeviceFeatures2(
    VkPhysicalDeviceFeatures                    features);


VkPhysicalDeviceProperties2 PhysicalDeviceProperties2(
    VkPhysicalDeviceProperties                  properties);


VkFormatProperties2 FormatProperties2(
    VkFormatProperties                          formatProperties);


VkImageFormatProperties2 ImageFormatProperties2(
    VkImageFormatProperties                     imageFormatProperties);


VkPhysicalDeviceImageFormatInfo2 PhysicalDeviceImageFormatInfo2(
    VkFormat                                    format,
    VkImageType                                 type,
    VkImageTiling                               tiling,
    VkImageUsageFlags                           usage,
    VkImageCreateFlags                          flags);


VkQueueFamilyProperties2 QueueFamilyProperties2(
    VkQueueFamilyProperties                     queueFamilyProperties);


VkPhysicalDeviceMemoryProperties2 PhysicalDeviceMemoryProperties2(
    VkPhysicalDeviceMemoryProperties            memoryProperties);


VkSparseImageFormatProperties2 SparseImageFormatProperties2(
    VkSparseImageFormatProperties               properties);


VkPhysicalDeviceSparseImageFormatInfo2 PhysicalDeviceSparseImageFormatInfo2(
    VkFormat                                    format,
    VkImageType                                 type,
    VkSampleCountFlagBits                       samples,
    VkImageUsageFlags                           usage,
    VkImageTiling                               tiling);


VkPhysicalDeviceFeatures2 getPhysicalDeviceFeatures2(
        VkPhysicalDevice physicalDevice);

VkPhysicalDeviceProperties2 getPhysicalDeviceProperties2(
        VkPhysicalDevice physicalDevice);

VkFormatProperties2 getPhysicalDeviceFormatProperties2(
        VkPhysicalDevice physicalDevice,
        VkFormat format);

VkImageFormatProperties2 getPhysicalDeviceImageFormatProperties2(
        VkPhysicalDevice physicalDevice,
        const VkPhysicalDeviceImageFormatInfo2 & pImageFormatInfo);

std::vector< VkQueueFamilyProperties2 > getPhysicalDeviceQueueFamilyProperties2(
        VkPhysicalDevice physicalDevice);

VkPhysicalDeviceMemoryProperties2 getPhysicalDeviceMemoryProperties2(
        VkPhysicalDevice physicalDevice);

std::vector< VkSparseImageFormatProperties2 > getPhysicalDeviceSparseImageFormatProperties2(
        VkPhysicalDevice physicalDevice,
        const VkPhysicalDeviceSparseImageFormatInfo2 & pFormatInfo);

void  trimCommandPool(
        VkDevice device,
        VkCommandPool commandPool,
        VkCommandPoolTrimFlags flags);

VkPhysicalDevicePointClippingProperties PhysicalDevicePointClippingProperties(
    VkPointClippingBehavior                     pointClippingBehavior);


VkInputAttachmentAspectReference InputAttachmentAspectReference(
    uint32_t                                    subpass,
    uint32_t                                    inputAttachmentIndex,
    VkImageAspectFlags                          aspectMask);


std::shared_ptr<VkRenderPassInputAttachmentAspectCreateInfoRAII> RenderPassInputAttachmentAspectCreateInfo(
    const std::vector<VkInputAttachmentAspectReference> &vecAspectReferences);


VkImageViewUsageCreateInfo ImageViewUsageCreateInfo(
    VkImageUsageFlags                           usage);


VkPipelineTessellationDomainOriginStateCreateInfo PipelineTessellationDomainOriginStateCreateInfo(
    VkTessellationDomainOrigin                  domainOrigin);


std::shared_ptr<VkRenderPassMultiviewCreateInfoRAII> RenderPassMultiviewCreateInfo(
    unsigned int* pViewMasks_in_array1, int pViewMasks_dim1,
    int* pViewOffsets_in_array1, int pViewOffsets_dim1,
    unsigned int* pCorrelationMasks_in_array1, int pCorrelationMasks_dim1);


VkPhysicalDeviceMultiviewFeatures PhysicalDeviceMultiviewFeatures(
    VkBool32                                    multiview,
    VkBool32                                    multiviewGeometryShader,
    VkBool32                                    multiviewTessellationShader);


VkPhysicalDeviceMultiviewProperties PhysicalDeviceMultiviewProperties(
    uint32_t                                    maxMultiviewViewCount,
    uint32_t                                    maxMultiviewInstanceIndex);


VkPhysicalDeviceVariablePointersFeatures PhysicalDeviceVariablePointersFeatures(
    VkBool32                                    variablePointersStorageBuffer,
    VkBool32                                    variablePointers);


VkPhysicalDeviceProtectedMemoryFeatures PhysicalDeviceProtectedMemoryFeatures(
    VkBool32                                    protectedMemory);


VkPhysicalDeviceProtectedMemoryProperties PhysicalDeviceProtectedMemoryProperties(
    VkBool32                                    protectedNoFault);


VkDeviceQueueInfo2 DeviceQueueInfo2(
    VkDeviceQueueCreateFlags                    flags,
    uint32_t                                    queueFamilyIndex,
    uint32_t                                    queueIndex);


VkProtectedSubmitInfo ProtectedSubmitInfo(
    VkBool32                                    protectedSubmit);


VkQueue getDeviceQueue2(
        VkDevice device,
        const VkDeviceQueueInfo2 & pQueueInfo);

VkSamplerYcbcrConversionCreateInfo SamplerYcbcrConversionCreateInfo(
    VkFormat                                    format,
    VkSamplerYcbcrModelConversion               ycbcrModel,
    VkSamplerYcbcrRange                         ycbcrRange,
    VkComponentMapping                          components,
    VkChromaLocation                            xChromaOffset,
    VkChromaLocation                            yChromaOffset,
    VkFilter                                    chromaFilter,
    VkBool32                                    forceExplicitReconstruction);


VkSamplerYcbcrConversionInfo SamplerYcbcrConversionInfo(
    VkSamplerYcbcrConversion                    conversion);


VkBindImagePlaneMemoryInfo BindImagePlaneMemoryInfo(
    VkImageAspectFlagBits                       planeAspect);


VkImagePlaneMemoryRequirementsInfo ImagePlaneMemoryRequirementsInfo(
    VkImageAspectFlagBits                       planeAspect);


VkPhysicalDeviceSamplerYcbcrConversionFeatures PhysicalDeviceSamplerYcbcrConversionFeatures(
    VkBool32                                    samplerYcbcrConversion);


VkSamplerYcbcrConversionImageFormatProperties SamplerYcbcrConversionImageFormatProperties(
    uint32_t                                    combinedImageSamplerDescriptorCount);


std::shared_ptr<VkSamplerYcbcrConversion_T> createSamplerYcbcrConversion(
        VkDevice device,
        const VkSamplerYcbcrConversionCreateInfo & pCreateInfo);

VkDescriptorUpdateTemplateEntry DescriptorUpdateTemplateEntry(
    uint32_t                                    dstBinding,
    uint32_t                                    dstArrayElement,
    uint32_t                                    descriptorCount,
    VkDescriptorType                            descriptorType,
    size_t                                      offset,
    size_t                                      stride);


std::shared_ptr<VkDescriptorUpdateTemplateCreateInfoRAII> DescriptorUpdateTemplateCreateInfo(
    VkDescriptorUpdateTemplateCreateFlags       flags,
    const std::vector<VkDescriptorUpdateTemplateEntry> &vecDescriptorUpdateEntries,
    VkDescriptorUpdateTemplateType              templateType,
    VkDescriptorSetLayout                       descriptorSetLayout,
    VkPipelineBindPoint                         pipelineBindPoint,
    VkPipelineLayout                            pipelineLayout,
    uint32_t                                    set);


std::shared_ptr<VkDescriptorUpdateTemplate_T> createDescriptorUpdateTemplate(
        VkDevice device,
        const VkDescriptorUpdateTemplateCreateInfo & pCreateInfo);

VkExternalMemoryProperties ExternalMemoryProperties(
    VkExternalMemoryFeatureFlags                externalMemoryFeatures,
    VkExternalMemoryHandleTypeFlags             exportFromImportedHandleTypes,
    VkExternalMemoryHandleTypeFlags             compatibleHandleTypes);


VkPhysicalDeviceExternalImageFormatInfo PhysicalDeviceExternalImageFormatInfo(
    VkExternalMemoryHandleTypeFlagBits          handleType);


VkExternalImageFormatProperties ExternalImageFormatProperties(
    VkExternalMemoryProperties                  externalMemoryProperties);


VkPhysicalDeviceExternalBufferInfo PhysicalDeviceExternalBufferInfo(
    VkBufferCreateFlags                         flags,
    VkBufferUsageFlags                          usage,
    VkExternalMemoryHandleTypeFlagBits          handleType);


VkExternalBufferProperties ExternalBufferProperties(
    VkExternalMemoryProperties                  externalMemoryProperties);


VkPhysicalDeviceIDProperties PhysicalDeviceIDProperties(
    uint8_t                                     deviceUUID[VK_UUID_SIZE],
    uint8_t                                     driverUUID[VK_UUID_SIZE],
    uint8_t                                     deviceLUID[VK_LUID_SIZE],
    uint32_t                                    deviceNodeMask,
    VkBool32                                    deviceLUIDValid);


VkExternalBufferProperties getPhysicalDeviceExternalBufferProperties(
        VkPhysicalDevice physicalDevice,
        const VkPhysicalDeviceExternalBufferInfo & pExternalBufferInfo);

VkExternalMemoryImageCreateInfo ExternalMemoryImageCreateInfo(
    VkExternalMemoryHandleTypeFlags             handleTypes);


VkExternalMemoryBufferCreateInfo ExternalMemoryBufferCreateInfo(
    VkExternalMemoryHandleTypeFlags             handleTypes);


VkExportMemoryAllocateInfo ExportMemoryAllocateInfo(
    VkExternalMemoryHandleTypeFlags             handleTypes);


VkPhysicalDeviceExternalFenceInfo PhysicalDeviceExternalFenceInfo(
    VkExternalFenceHandleTypeFlagBits           handleType);


VkExternalFenceProperties ExternalFenceProperties(
    VkExternalFenceHandleTypeFlags              exportFromImportedHandleTypes,
    VkExternalFenceHandleTypeFlags              compatibleHandleTypes,
    VkExternalFenceFeatureFlags                 externalFenceFeatures);


VkExternalFenceProperties getPhysicalDeviceExternalFenceProperties(
        VkPhysicalDevice physicalDevice,
        const VkPhysicalDeviceExternalFenceInfo & pExternalFenceInfo);

VkExportFenceCreateInfo ExportFenceCreateInfo(
    VkExternalFenceHandleTypeFlags              handleTypes);


VkExportSemaphoreCreateInfo ExportSemaphoreCreateInfo(
    VkExternalSemaphoreHandleTypeFlags          handleTypes);


VkPhysicalDeviceExternalSemaphoreInfo PhysicalDeviceExternalSemaphoreInfo(
    VkExternalSemaphoreHandleTypeFlagBits       handleType);


VkExternalSemaphoreProperties ExternalSemaphoreProperties(
    VkExternalSemaphoreHandleTypeFlags          exportFromImportedHandleTypes,
    VkExternalSemaphoreHandleTypeFlags          compatibleHandleTypes,
    VkExternalSemaphoreFeatureFlags             externalSemaphoreFeatures);


VkExternalSemaphoreProperties getPhysicalDeviceExternalSemaphoreProperties(
        VkPhysicalDevice physicalDevice,
        const VkPhysicalDeviceExternalSemaphoreInfo & pExternalSemaphoreInfo);

VkPhysicalDeviceMaintenance3Properties PhysicalDeviceMaintenance3Properties(
    uint32_t                                    maxPerSetDescriptors,
    VkDeviceSize                                maxMemoryAllocationSize);


VkDescriptorSetLayoutSupport DescriptorSetLayoutSupport(
    VkBool32                                    supported);


VkDescriptorSetLayoutSupport getDescriptorSetLayoutSupport(
        VkDevice device,
        const VkDescriptorSetLayoutCreateInfo & pCreateInfo);

VkPhysicalDeviceShaderDrawParametersFeatures PhysicalDeviceShaderDrawParametersFeatures(
    VkBool32                                    shaderDrawParameters);




#define VK_KHR_surface 1
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkSurfaceKHR)
#define VK_KHR_SURFACE_SPEC_VERSION       25
#define VK_KHR_SURFACE_EXTENSION_NAME     "VK_KHR_surface"

typedef enum VkColorSpaceKHR {
    VK_COLOR_SPACE_SRGB_NONLINEAR_KHR = 0,
    VK_COLOR_SPACE_DISPLAY_P3_NONLINEAR_EXT = 1000104001,
    VK_COLOR_SPACE_EXTENDED_SRGB_LINEAR_EXT = 1000104002,
    VK_COLOR_SPACE_DISPLAY_P3_LINEAR_EXT = 1000104003,
    VK_COLOR_SPACE_DCI_P3_NONLINEAR_EXT = 1000104004,
    VK_COLOR_SPACE_BT709_LINEAR_EXT = 1000104005,
    VK_COLOR_SPACE_BT709_NONLINEAR_EXT = 1000104006,
    VK_COLOR_SPACE_BT2020_LINEAR_EXT = 1000104007,
    VK_COLOR_SPACE_HDR10_ST2084_EXT = 1000104008,
    VK_COLOR_SPACE_DOLBYVISION_EXT = 1000104009,
    VK_COLOR_SPACE_HDR10_HLG_EXT = 1000104010,
    VK_COLOR_SPACE_ADOBERGB_LINEAR_EXT = 1000104011,
    VK_COLOR_SPACE_ADOBERGB_NONLINEAR_EXT = 1000104012,
    VK_COLOR_SPACE_PASS_THROUGH_EXT = 1000104013,
    VK_COLOR_SPACE_EXTENDED_SRGB_NONLINEAR_EXT = 1000104014,
    VK_COLOR_SPACE_DISPLAY_NATIVE_AMD = 1000213000,
    VK_COLORSPACE_SRGB_NONLINEAR_KHR = VK_COLOR_SPACE_SRGB_NONLINEAR_KHR,
    VK_COLOR_SPACE_DCI_P3_LINEAR_EXT = VK_COLOR_SPACE_DISPLAY_P3_LINEAR_EXT,
    VK_COLOR_SPACE_MAX_ENUM_KHR = 0x7FFFFFFF
} VkColorSpaceKHR;

typedef enum VkPresentModeKHR {
    VK_PRESENT_MODE_IMMEDIATE_KHR = 0,
    VK_PRESENT_MODE_MAILBOX_KHR = 1,
    VK_PRESENT_MODE_FIFO_KHR = 2,
    VK_PRESENT_MODE_FIFO_RELAXED_KHR = 3,
    VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR = 1000111000,
    VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR = 1000111001,
    VK_PRESENT_MODE_MAX_ENUM_KHR = 0x7FFFFFFF
} VkPresentModeKHR;

typedef enum VkSurfaceTransformFlagBitsKHR {
    VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR = 0x00000001,
    VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR = 0x00000002,
    VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR = 0x00000004,
    VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR = 0x00000008,
    VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR = 0x00000010,
    VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR = 0x00000020,
    VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR = 0x00000040,
    VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR = 0x00000080,
    VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR = 0x00000100,
    VK_SURFACE_TRANSFORM_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF
} VkSurfaceTransformFlagBitsKHR;
typedef VkFlags VkSurfaceTransformFlagsKHR;

typedef enum VkCompositeAlphaFlagBitsKHR {
    VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR = 0x00000001,
    VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR = 0x00000002,
    VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR = 0x00000004,
    VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR = 0x00000008,
    VK_COMPOSITE_ALPHA_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF
} VkCompositeAlphaFlagBitsKHR;
typedef VkFlags VkCompositeAlphaFlagsKHR;
typedef struct VkSurfaceCapabilitiesKHR {
    uint32_t                         minImageCount;
    uint32_t                         maxImageCount;
    VkExtent2D                       currentExtent;
    VkExtent2D                       minImageExtent;
    VkExtent2D                       maxImageExtent;
    uint32_t                         maxImageArrayLayers;
    VkSurfaceTransformFlagsKHR       supportedTransforms;
    VkSurfaceTransformFlagBitsKHR    currentTransform;
    VkCompositeAlphaFlagsKHR         supportedCompositeAlpha;
    VkImageUsageFlags                supportedUsageFlags;
} VkSurfaceCapabilitiesKHR;

typedef struct VkSurfaceFormatKHR {
    VkFormat           format;
    VkColorSpaceKHR    colorSpace;
} VkSurfaceFormatKHR;

typedef void (VKAPI_PTR *PFN_vkDestroySurfaceKHR)(VkInstance instance, VkSurfaceKHR surface, const VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkGetPhysicalDeviceSurfaceSupportKHR)(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, VkSurfaceKHR surface, VkBool32* pSupported);
typedef VkResult (VKAPI_PTR *PFN_vkGetPhysicalDeviceSurfaceCapabilitiesKHR)(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, VkSurfaceCapabilitiesKHR* pSurfaceCapabilities);
typedef VkResult (VKAPI_PTR *PFN_vkGetPhysicalDeviceSurfaceFormatsKHR)(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, uint32_t* pSurfaceFormatCount, VkSurfaceFormatKHR* pSurfaceFormats);
typedef VkResult (VKAPI_PTR *PFN_vkGetPhysicalDeviceSurfacePresentModesKHR)(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, uint32_t* pPresentModeCount, VkPresentModeKHR* pPresentModes);

VkBool32 getPhysicalDeviceSurfaceSupportKHR(
        VkPhysicalDevice physicalDevice,
        uint32_t queueFamilyIndex,
        VkSurfaceKHR surface);

VkSurfaceCapabilitiesKHR SurfaceCapabilitiesKHR(
    uint32_t                                    minImageCount,
    uint32_t                                    maxImageCount,
    VkExtent2D                                  currentExtent,
    VkExtent2D                                  minImageExtent,
    VkExtent2D                                  maxImageExtent,
    uint32_t                                    maxImageArrayLayers,
    VkSurfaceTransformFlagsKHR                  supportedTransforms,
    VkSurfaceTransformFlagBitsKHR               currentTransform,
    VkCompositeAlphaFlagsKHR                    supportedCompositeAlpha,
    VkImageUsageFlags                           supportedUsageFlags);


VkSurfaceCapabilitiesKHR getPhysicalDeviceSurfaceCapabilitiesKHR(
        VkPhysicalDevice physicalDevice,
        VkSurfaceKHR surface);

VkSurfaceFormatKHR SurfaceFormatKHR(
    VkFormat                                    format,
    VkColorSpaceKHR                             colorSpace);


std::vector< VkSurfaceFormatKHR > getPhysicalDeviceSurfaceFormatsKHR(
        VkPhysicalDevice physicalDevice,
        VkSurfaceKHR surface);

std::vector< VkPresentModeKHR > getPhysicalDeviceSurfacePresentModesKHR(
        VkPhysicalDevice physicalDevice,
        VkSurfaceKHR surface);



#define VK_KHR_swapchain 1
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkSwapchainKHR)
#define VK_KHR_SWAPCHAIN_SPEC_VERSION     70
#define VK_KHR_SWAPCHAIN_EXTENSION_NAME   "VK_KHR_swapchain"

typedef enum VkSwapchainCreateFlagBitsKHR {
    VK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR = 0x00000001,
    VK_SWAPCHAIN_CREATE_PROTECTED_BIT_KHR = 0x00000002,
    VK_SWAPCHAIN_CREATE_MUTABLE_FORMAT_BIT_KHR = 0x00000004,
    VK_SWAPCHAIN_CREATE_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF
} VkSwapchainCreateFlagBitsKHR;
typedef VkFlags VkSwapchainCreateFlagsKHR;

typedef enum VkDeviceGroupPresentModeFlagBitsKHR {
    VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR = 0x00000001,
    VK_DEVICE_GROUP_PRESENT_MODE_REMOTE_BIT_KHR = 0x00000002,
    VK_DEVICE_GROUP_PRESENT_MODE_SUM_BIT_KHR = 0x00000004,
    VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_MULTI_DEVICE_BIT_KHR = 0x00000008,
    VK_DEVICE_GROUP_PRESENT_MODE_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF
} VkDeviceGroupPresentModeFlagBitsKHR;
typedef VkFlags VkDeviceGroupPresentModeFlagsKHR;
typedef struct VkSwapchainCreateInfoKHR {
    VkStructureType                  sType;
    const void*                      pNext;
    VkSwapchainCreateFlagsKHR        flags;
    VkSurfaceKHR                     surface;
    uint32_t                         minImageCount;
    VkFormat                         imageFormat;
    VkColorSpaceKHR                  imageColorSpace;
    VkExtent2D                       imageExtent;
    uint32_t                         imageArrayLayers;
    VkImageUsageFlags                imageUsage;
    VkSharingMode                    imageSharingMode;
    uint32_t                         queueFamilyIndexCount;
    const uint32_t*                  pQueueFamilyIndices;
    VkSurfaceTransformFlagBitsKHR    preTransform;
    VkCompositeAlphaFlagBitsKHR      compositeAlpha;
    VkPresentModeKHR                 presentMode;
    VkBool32                         clipped;
    VkSwapchainKHR                   oldSwapchain;
} VkSwapchainCreateInfoKHR;

struct VkSwapchainCreateInfoKHRRAII {
   VkSwapchainCreateInfoKHR nonRaiiObj;
    std::vector<uint32_t>                       vecQueueFamilyIndices;
};

typedef struct VkPresentInfoKHR {
    VkStructureType          sType;
    const void*              pNext;
    uint32_t                 waitSemaphoreCount;
    const VkSemaphore*       pWaitSemaphores;
    uint32_t                 swapchainCount;
    const VkSwapchainKHR*    pSwapchains;
    const uint32_t*          pImageIndices;
    VkResult*                pResults;
} VkPresentInfoKHR;

struct VkPresentInfoKHRRAII {
   VkPresentInfoKHR nonRaiiObj;
    std::vector<VkSemaphore>                    vecWaitSemaphores;
    std::vector<VkSwapchainKHR>                 vecSwapchains;
    std::vector<uint32_t>                       vecImageIndices;
    std::vector<VkResult>                       vecResults;
};

typedef struct VkImageSwapchainCreateInfoKHR {
    VkStructureType    sType;
    const void*        pNext;
    VkSwapchainKHR     swapchain;
} VkImageSwapchainCreateInfoKHR;

typedef struct VkBindImageMemorySwapchainInfoKHR {
    VkStructureType    sType;
    const void*        pNext;
    VkSwapchainKHR     swapchain;
    uint32_t           imageIndex;
} VkBindImageMemorySwapchainInfoKHR;

typedef struct VkAcquireNextImageInfoKHR {
    VkStructureType    sType;
    const void*        pNext;
    VkSwapchainKHR     swapchain;
    uint64_t           timeout;
    VkSemaphore        semaphore;
    VkFence            fence;
    uint32_t           deviceMask;
} VkAcquireNextImageInfoKHR;

typedef struct VkDeviceGroupPresentCapabilitiesKHR {
    VkStructureType                     sType;
    const void*                         pNext;
    uint32_t                            presentMask[VK_MAX_DEVICE_GROUP_SIZE];
    VkDeviceGroupPresentModeFlagsKHR    modes;
} VkDeviceGroupPresentCapabilitiesKHR;

typedef struct VkDeviceGroupPresentInfoKHR {
    VkStructureType                        sType;
    const void*                            pNext;
    uint32_t                               swapchainCount;
    const uint32_t*                        pDeviceMasks;
    VkDeviceGroupPresentModeFlagBitsKHR    mode;
} VkDeviceGroupPresentInfoKHR;

struct VkDeviceGroupPresentInfoKHRRAII {
   VkDeviceGroupPresentInfoKHR nonRaiiObj;
    std::vector<uint32_t>                       vecDeviceMasks;
};

typedef struct VkDeviceGroupSwapchainCreateInfoKHR {
    VkStructureType                     sType;
    const void*                         pNext;
    VkDeviceGroupPresentModeFlagsKHR    modes;
} VkDeviceGroupSwapchainCreateInfoKHR;

typedef VkResult (VKAPI_PTR *PFN_vkCreateSwapchainKHR)(VkDevice device, const VkSwapchainCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSwapchainKHR* pSwapchain);
typedef void (VKAPI_PTR *PFN_vkDestroySwapchainKHR)(VkDevice device, VkSwapchainKHR swapchain, const VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkGetSwapchainImagesKHR)(VkDevice device, VkSwapchainKHR swapchain, uint32_t* pSwapchainImageCount, VkImage* pSwapchainImages);
typedef VkResult (VKAPI_PTR *PFN_vkAcquireNextImageKHR)(VkDevice device, VkSwapchainKHR swapchain, uint64_t timeout, VkSemaphore semaphore, VkFence fence, uint32_t* pImageIndex);
typedef VkResult (VKAPI_PTR *PFN_vkQueuePresentKHR)(VkQueue queue, const VkPresentInfoKHR* pPresentInfo);
typedef VkResult (VKAPI_PTR *PFN_vkGetDeviceGroupPresentCapabilitiesKHR)(VkDevice device, VkDeviceGroupPresentCapabilitiesKHR* pDeviceGroupPresentCapabilities);
typedef VkResult (VKAPI_PTR *PFN_vkGetDeviceGroupSurfacePresentModesKHR)(VkDevice device, VkSurfaceKHR surface, VkDeviceGroupPresentModeFlagsKHR* pModes);
typedef VkResult (VKAPI_PTR *PFN_vkGetPhysicalDevicePresentRectanglesKHR)(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, uint32_t* pRectCount, VkRect2D* pRects);
typedef VkResult (VKAPI_PTR *PFN_vkAcquireNextImage2KHR)(VkDevice device, const VkAcquireNextImageInfoKHR* pAcquireInfo, uint32_t* pImageIndex);

std::shared_ptr<VkSwapchainCreateInfoKHRRAII> SwapchainCreateInfoKHR(
    VkSwapchainCreateFlagsKHR                   flags,
    VkSurfaceKHR                                surface,
    uint32_t                                    minImageCount,
    VkFormat                                    imageFormat,
    VkColorSpaceKHR                             imageColorSpace,
    VkExtent2D                                  imageExtent,
    uint32_t                                    imageArrayLayers,
    VkImageUsageFlags                           imageUsage,
    VkSharingMode                               imageSharingMode,
    unsigned int* pQueueFamilyIndices_in_array1, int pQueueFamilyIndices_dim1,
    VkSurfaceTransformFlagBitsKHR               preTransform,
    VkCompositeAlphaFlagBitsKHR                 compositeAlpha,
    VkPresentModeKHR                            presentMode,
    VkBool32                                    clipped,
    VkSwapchainKHR                              oldSwapchain);


std::shared_ptr<VkSwapchainKHR_T> createSwapchainKHR(
        VkDevice device,
        const VkSwapchainCreateInfoKHR & pCreateInfo);

std::vector< VkImage > getSwapchainImagesKHR(
        VkDevice device,
        VkSwapchainKHR swapchain);

uint32_t acquireNextImageKHR(
        VkDevice device,
        VkSwapchainKHR swapchain,
        uint64_t timeout,
        VkSemaphore semaphore,
        VkFence fence);

std::shared_ptr<VkPresentInfoKHRRAII> PresentInfoKHR(
    const std::vector<VkSemaphore> &            vecWaitSemaphores,
    const std::vector<VkSwapchainKHR> &         vecSwapchains,
    unsigned int* pImageIndices_in_array1, int pImageIndices_dim1,
    const std::vector<VkResult> &               vecResults);


void  queuePresentKHR(
        VkQueue queue,
        const VkPresentInfoKHR & pPresentInfo);

VkImageSwapchainCreateInfoKHR ImageSwapchainCreateInfoKHR(
    VkSwapchainKHR                              swapchain);


VkBindImageMemorySwapchainInfoKHR BindImageMemorySwapchainInfoKHR(
    VkSwapchainKHR                              swapchain,
    uint32_t                                    imageIndex);


VkAcquireNextImageInfoKHR AcquireNextImageInfoKHR(
    VkSwapchainKHR                              swapchain,
    uint64_t                                    timeout,
    VkSemaphore                                 semaphore,
    VkFence                                     fence,
    uint32_t                                    deviceMask);


VkDeviceGroupPresentCapabilitiesKHR DeviceGroupPresentCapabilitiesKHR(
    uint32_t                                    presentMask[VK_MAX_DEVICE_GROUP_SIZE],
    VkDeviceGroupPresentModeFlagsKHR            modes);


std::shared_ptr<VkDeviceGroupPresentInfoKHRRAII> DeviceGroupPresentInfoKHR(
    unsigned int* pDeviceMasks_in_array1, int pDeviceMasks_dim1,
    VkDeviceGroupPresentModeFlagBitsKHR         mode);


VkDeviceGroupSwapchainCreateInfoKHR DeviceGroupSwapchainCreateInfoKHR(
    VkDeviceGroupPresentModeFlagsKHR            modes);


VkDeviceGroupPresentCapabilitiesKHR getDeviceGroupPresentCapabilitiesKHR(
        VkDevice device);

std::shared_ptr< VkDeviceGroupPresentModeFlagsKHR > getDeviceGroupSurfacePresentModesKHR(
        VkDevice device,
        VkSurfaceKHR surface);

std::vector< VkRect2D > getPhysicalDevicePresentRectanglesKHR(
        VkPhysicalDevice physicalDevice,
        VkSurfaceKHR surface);

uint32_t acquireNextImage2KHR(
        VkDevice device,
        const VkAcquireNextImageInfoKHR & pAcquireInfo);



#define VK_KHR_display 1
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkDisplayKHR)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkDisplayModeKHR)
#define VK_KHR_DISPLAY_SPEC_VERSION       23
#define VK_KHR_DISPLAY_EXTENSION_NAME     "VK_KHR_display"

typedef enum VkDisplayPlaneAlphaFlagBitsKHR {
    VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR = 0x00000001,
    VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR = 0x00000002,
    VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR = 0x00000004,
    VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR = 0x00000008,
    VK_DISPLAY_PLANE_ALPHA_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF
} VkDisplayPlaneAlphaFlagBitsKHR;
typedef VkFlags VkDisplayPlaneAlphaFlagsKHR;
typedef VkFlags VkDisplayModeCreateFlagsKHR;
typedef VkFlags VkDisplaySurfaceCreateFlagsKHR;
typedef struct VkDisplayPropertiesKHR {
    VkDisplayKHR                  display;
    const char*                   displayName;
    VkExtent2D                    physicalDimensions;
    VkExtent2D                    physicalResolution;
    VkSurfaceTransformFlagsKHR    supportedTransforms;
    VkBool32                      planeReorderPossible;
    VkBool32                      persistentContent;
} VkDisplayPropertiesKHR;

struct VkDisplayPropertiesKHRRAII {
   VkDisplayPropertiesKHR nonRaiiObj;
    std::string                                 strisplayName;
};

typedef struct VkDisplayModeParametersKHR {
    VkExtent2D    visibleRegion;
    uint32_t      refreshRate;
} VkDisplayModeParametersKHR;

typedef struct VkDisplayModePropertiesKHR {
    VkDisplayModeKHR              displayMode;
    VkDisplayModeParametersKHR    parameters;
} VkDisplayModePropertiesKHR;

typedef struct VkDisplayModeCreateInfoKHR {
    VkStructureType                sType;
    const void*                    pNext;
    VkDisplayModeCreateFlagsKHR    flags;
    VkDisplayModeParametersKHR     parameters;
} VkDisplayModeCreateInfoKHR;

typedef struct VkDisplayPlaneCapabilitiesKHR {
    VkDisplayPlaneAlphaFlagsKHR    supportedAlpha;
    VkOffset2D                     minSrcPosition;
    VkOffset2D                     maxSrcPosition;
    VkExtent2D                     minSrcExtent;
    VkExtent2D                     maxSrcExtent;
    VkOffset2D                     minDstPosition;
    VkOffset2D                     maxDstPosition;
    VkExtent2D                     minDstExtent;
    VkExtent2D                     maxDstExtent;
} VkDisplayPlaneCapabilitiesKHR;

typedef struct VkDisplayPlanePropertiesKHR {
    VkDisplayKHR    currentDisplay;
    uint32_t        currentStackIndex;
} VkDisplayPlanePropertiesKHR;

typedef struct VkDisplaySurfaceCreateInfoKHR {
    VkStructureType                   sType;
    const void*                       pNext;
    VkDisplaySurfaceCreateFlagsKHR    flags;
    VkDisplayModeKHR                  displayMode;
    uint32_t                          planeIndex;
    uint32_t                          planeStackIndex;
    VkSurfaceTransformFlagBitsKHR     transform;
    float                             globalAlpha;
    VkDisplayPlaneAlphaFlagBitsKHR    alphaMode;
    VkExtent2D                        imageExtent;
} VkDisplaySurfaceCreateInfoKHR;

typedef VkResult (VKAPI_PTR *PFN_vkGetPhysicalDeviceDisplayPropertiesKHR)(VkPhysicalDevice physicalDevice, uint32_t* pPropertyCount, VkDisplayPropertiesKHR* pProperties);
typedef VkResult (VKAPI_PTR *PFN_vkGetPhysicalDeviceDisplayPlanePropertiesKHR)(VkPhysicalDevice physicalDevice, uint32_t* pPropertyCount, VkDisplayPlanePropertiesKHR* pProperties);
typedef VkResult (VKAPI_PTR *PFN_vkGetDisplayPlaneSupportedDisplaysKHR)(VkPhysicalDevice physicalDevice, uint32_t planeIndex, uint32_t* pDisplayCount, VkDisplayKHR* pDisplays);
typedef VkResult (VKAPI_PTR *PFN_vkGetDisplayModePropertiesKHR)(VkPhysicalDevice physicalDevice, VkDisplayKHR display, uint32_t* pPropertyCount, VkDisplayModePropertiesKHR* pProperties);
typedef VkResult (VKAPI_PTR *PFN_vkCreateDisplayModeKHR)(VkPhysicalDevice physicalDevice, VkDisplayKHR display, const VkDisplayModeCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkDisplayModeKHR* pMode);
typedef VkResult (VKAPI_PTR *PFN_vkGetDisplayPlaneCapabilitiesKHR)(VkPhysicalDevice physicalDevice, VkDisplayModeKHR mode, uint32_t planeIndex, VkDisplayPlaneCapabilitiesKHR* pCapabilities);
typedef VkResult (VKAPI_PTR *PFN_vkCreateDisplayPlaneSurfaceKHR)(VkInstance instance, const VkDisplaySurfaceCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface);

std::shared_ptr<VkDisplayPropertiesKHRRAII> DisplayPropertiesKHR(
    VkDisplayKHR                                display,
    const std::string &                         strisplayName,
    VkExtent2D                                  physicalDimensions,
    VkExtent2D                                  physicalResolution,
    VkSurfaceTransformFlagsKHR                  supportedTransforms,
    VkBool32                                    planeReorderPossible,
    VkBool32                                    persistentContent);


VkDisplayModeParametersKHR DisplayModeParametersKHR(
    VkExtent2D                                  visibleRegion,
    uint32_t                                    refreshRate);


VkDisplayModePropertiesKHR DisplayModePropertiesKHR(
    VkDisplayModeKHR                            displayMode,
    VkDisplayModeParametersKHR                  parameters);


VkDisplayModeCreateInfoKHR DisplayModeCreateInfoKHR(
    VkDisplayModeCreateFlagsKHR                 flags,
    VkDisplayModeParametersKHR                  parameters);


VkDisplayPlaneCapabilitiesKHR DisplayPlaneCapabilitiesKHR(
    VkDisplayPlaneAlphaFlagsKHR                 supportedAlpha,
    VkOffset2D                                  minSrcPosition,
    VkOffset2D                                  maxSrcPosition,
    VkExtent2D                                  minSrcExtent,
    VkExtent2D                                  maxSrcExtent,
    VkOffset2D                                  minDstPosition,
    VkOffset2D                                  maxDstPosition,
    VkExtent2D                                  minDstExtent,
    VkExtent2D                                  maxDstExtent);


VkDisplayPlanePropertiesKHR DisplayPlanePropertiesKHR(
    VkDisplayKHR                                currentDisplay,
    uint32_t                                    currentStackIndex);


VkDisplaySurfaceCreateInfoKHR DisplaySurfaceCreateInfoKHR(
    VkDisplaySurfaceCreateFlagsKHR              flags,
    VkDisplayModeKHR                            displayMode,
    uint32_t                                    planeIndex,
    uint32_t                                    planeStackIndex,
    VkSurfaceTransformFlagBitsKHR               transform,
    float                                       globalAlpha,
    VkDisplayPlaneAlphaFlagBitsKHR              alphaMode,
    VkExtent2D                                  imageExtent);


std::vector< VkDisplayPropertiesKHR > getPhysicalDeviceDisplayPropertiesKHR(
        VkPhysicalDevice physicalDevice);

std::vector< VkDisplayPlanePropertiesKHR > getPhysicalDeviceDisplayPlanePropertiesKHR(
        VkPhysicalDevice physicalDevice);

std::vector< VkDisplayKHR > getDisplayPlaneSupportedDisplaysKHR(
        VkPhysicalDevice physicalDevice,
        uint32_t planeIndex);

std::vector< VkDisplayModePropertiesKHR > getDisplayModePropertiesKHR(
        VkPhysicalDevice physicalDevice,
        VkDisplayKHR display);

std::shared_ptr<VkDisplayModeKHR_T> createDisplayModeKHR(
        VkPhysicalDevice physicalDevice,
        VkDisplayKHR display,
        const VkDisplayModeCreateInfoKHR & pCreateInfo);

VkDisplayPlaneCapabilitiesKHR getDisplayPlaneCapabilitiesKHR(
        VkPhysicalDevice physicalDevice,
        VkDisplayModeKHR mode,
        uint32_t planeIndex);

std::shared_ptr<VkSurfaceKHR_T> createDisplayPlaneSurfaceKHR(
        VkInstance instance,
        const VkDisplaySurfaceCreateInfoKHR & pCreateInfo);



#define VK_KHR_display_swapchain 1
#define VK_KHR_DISPLAY_SWAPCHAIN_SPEC_VERSION 10
#define VK_KHR_DISPLAY_SWAPCHAIN_EXTENSION_NAME "VK_KHR_display_swapchain"
typedef struct VkDisplayPresentInfoKHR {
    VkStructureType    sType;
    const void*        pNext;
    VkRect2D           srcRect;
    VkRect2D           dstRect;
    VkBool32           persistent;
} VkDisplayPresentInfoKHR;

typedef VkResult (VKAPI_PTR *PFN_vkCreateSharedSwapchainsKHR)(VkDevice device, uint32_t swapchainCount, const VkSwapchainCreateInfoKHR* pCreateInfos, const VkAllocationCallbacks* pAllocator, VkSwapchainKHR* pSwapchains);

VkDisplayPresentInfoKHR DisplayPresentInfoKHR(
    VkRect2D                                    srcRect,
    VkRect2D                                    dstRect,
    VkBool32                                    persistent);


std::vector< std::shared_ptr<VkSwapchainKHR_T> > createSharedSwapchainsKHR(
        VkDevice device,
        const std::vector<VkSwapchainCreateInfoKHR> & pCreateInfos);



#define VK_KHR_win32_surface 1
#define VK_KHR_WIN32_SURFACE_SPEC_VERSION 6
#define VK_KHR_WIN32_SURFACE_EXTENSION_NAME "VK_KHR_win32_surface"
typedef VkFlags VkWin32SurfaceCreateFlagsKHR;
typedef struct VkWin32SurfaceCreateInfoKHR {
    VkStructureType                 sType;
    const void*                     pNext;
    VkWin32SurfaceCreateFlagsKHR    flags;
    HINSTANCE                       hinstance;
    HWND                            hwnd;
} VkWin32SurfaceCreateInfoKHR;

typedef VkResult (VKAPI_PTR *PFN_vkCreateWin32SurfaceKHR)(VkInstance instance, const VkWin32SurfaceCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface);
typedef VkBool32 (VKAPI_PTR *PFN_vkGetPhysicalDeviceWin32PresentationSupportKHR)(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex);

VkWin32SurfaceCreateInfoKHR Win32SurfaceCreateInfoKHR(
    VkWin32SurfaceCreateFlagsKHR                flags,
    HINSTANCE                                   hinstance,
    HWND                                        hwnd);


std::shared_ptr<VkSurfaceKHR_T> createWin32SurfaceKHR(
        VkInstance instance,
        const VkWin32SurfaceCreateInfoKHR & pCreateInfo);

void  getPhysicalDeviceWin32PresentationSupportKHR(
        VkPhysicalDevice physicalDevice,
        uint32_t queueFamilyIndex);



#define VK_KHR_external_memory_capabilities 1
#define VK_KHR_EXTERNAL_MEMORY_CAPABILITIES_SPEC_VERSION 1
#define VK_KHR_EXTERNAL_MEMORY_CAPABILITIES_EXTENSION_NAME "VK_KHR_external_memory_capabilities"
#define VK_LUID_SIZE_KHR                  VK_LUID_SIZE
typedef VkExternalMemoryHandleTypeFlags VkExternalMemoryHandleTypeFlagsKHR;

typedef VkExternalMemoryHandleTypeFlagBits VkExternalMemoryHandleTypeFlagBitsKHR;

typedef VkExternalMemoryFeatureFlags VkExternalMemoryFeatureFlagsKHR;

typedef VkExternalMemoryFeatureFlagBits VkExternalMemoryFeatureFlagBitsKHR;

typedef VkExternalMemoryProperties VkExternalMemoryPropertiesKHR;

typedef VkPhysicalDeviceExternalImageFormatInfo VkPhysicalDeviceExternalImageFormatInfoKHR;

typedef VkExternalImageFormatProperties VkExternalImageFormatPropertiesKHR;

typedef VkPhysicalDeviceExternalBufferInfo VkPhysicalDeviceExternalBufferInfoKHR;

typedef VkExternalBufferProperties VkExternalBufferPropertiesKHR;

typedef VkPhysicalDeviceIDProperties VkPhysicalDeviceIDPropertiesKHR;

typedef void (VKAPI_PTR *PFN_vkGetPhysicalDeviceExternalBufferPropertiesKHR)(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalBufferInfo* pExternalBufferInfo, VkExternalBufferProperties* pExternalBufferProperties);

VkExternalBufferProperties getPhysicalDeviceExternalBufferPropertiesKHR(
        VkPhysicalDevice physicalDevice,
        const VkPhysicalDeviceExternalBufferInfo & pExternalBufferInfo);



#define VK_KHR_external_memory 1
#define VK_KHR_EXTERNAL_MEMORY_SPEC_VERSION 1
#define VK_KHR_EXTERNAL_MEMORY_EXTENSION_NAME "VK_KHR_external_memory"
#define VK_QUEUE_FAMILY_EXTERNAL_KHR      VK_QUEUE_FAMILY_EXTERNAL
typedef VkExternalMemoryImageCreateInfo VkExternalMemoryImageCreateInfoKHR;

typedef VkExternalMemoryBufferCreateInfo VkExternalMemoryBufferCreateInfoKHR;

typedef VkExportMemoryAllocateInfo VkExportMemoryAllocateInfoKHR;



#define VK_KHR_external_memory_win32 1
#define VK_KHR_EXTERNAL_MEMORY_WIN32_SPEC_VERSION 1
#define VK_KHR_EXTERNAL_MEMORY_WIN32_EXTENSION_NAME "VK_KHR_external_memory_win32"
typedef struct VkImportMemoryWin32HandleInfoKHR {
    VkStructureType                       sType;
    const void*                           pNext;
    VkExternalMemoryHandleTypeFlagBits    handleType;
    HANDLE                                handle;
    LPCWSTR                               name;
} VkImportMemoryWin32HandleInfoKHR;

typedef struct VkExportMemoryWin32HandleInfoKHR {
    VkStructureType               sType;
    const void*                   pNext;
    const SECURITY_ATTRIBUTES*    pAttributes;
    DWORD                         dwAccess;
    LPCWSTR                       name;
} VkExportMemoryWin32HandleInfoKHR;

struct VkExportMemoryWin32HandleInfoKHRRAII {
   VkExportMemoryWin32HandleInfoKHR nonRaiiObj;
    std::shared_ptr<SECURITY_ATTRIBUTES>        pAttributes;
};

typedef struct VkMemoryWin32HandlePropertiesKHR {
    VkStructureType    sType;
    void*              pNext;
    uint32_t           memoryTypeBits;
} VkMemoryWin32HandlePropertiesKHR;

typedef struct VkMemoryGetWin32HandleInfoKHR {
    VkStructureType                       sType;
    const void*                           pNext;
    VkDeviceMemory                        memory;
    VkExternalMemoryHandleTypeFlagBits    handleType;
} VkMemoryGetWin32HandleInfoKHR;

typedef VkResult (VKAPI_PTR *PFN_vkGetMemoryWin32HandleKHR)(VkDevice device, const VkMemoryGetWin32HandleInfoKHR* pGetWin32HandleInfo, HANDLE* pHandle);
typedef VkResult (VKAPI_PTR *PFN_vkGetMemoryWin32HandlePropertiesKHR)(VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType, HANDLE handle, VkMemoryWin32HandlePropertiesKHR* pMemoryWin32HandleProperties);

VkImportMemoryWin32HandleInfoKHR ImportMemoryWin32HandleInfoKHR(
    VkExternalMemoryHandleTypeFlagBits          handleType,
    HANDLE                                      handle,
    LPCWSTR                                     name);


std::shared_ptr<VkExportMemoryWin32HandleInfoKHRRAII> ExportMemoryWin32HandleInfoKHR(
    const SECURITY_ATTRIBUTES *                 pAttributes,
    DWORD                                       dwAccess,
    LPCWSTR                                     name);


VkMemoryWin32HandlePropertiesKHR MemoryWin32HandlePropertiesKHR(
    uint32_t                                    memoryTypeBits);


VkMemoryGetWin32HandleInfoKHR MemoryGetWin32HandleInfoKHR(
    VkDeviceMemory                              memory,
    VkExternalMemoryHandleTypeFlagBits          handleType);


HANDLE getMemoryWin32HandleKHR(
        VkDevice device,
        const VkMemoryGetWin32HandleInfoKHR & pGetWin32HandleInfo);

VkMemoryWin32HandlePropertiesKHR getMemoryWin32HandlePropertiesKHR(
        VkDevice device,
        VkExternalMemoryHandleTypeFlagBits handleType,
        HANDLE handle);



#define VK_KHR_external_memory_fd 1
#define VK_KHR_EXTERNAL_MEMORY_FD_SPEC_VERSION 1
#define VK_KHR_EXTERNAL_MEMORY_FD_EXTENSION_NAME "VK_KHR_external_memory_fd"
typedef struct VkImportMemoryFdInfoKHR {
    VkStructureType                       sType;
    const void*                           pNext;
    VkExternalMemoryHandleTypeFlagBits    handleType;
    int                                   fd;
} VkImportMemoryFdInfoKHR;

typedef struct VkMemoryFdPropertiesKHR {
    VkStructureType    sType;
    void*              pNext;
    uint32_t           memoryTypeBits;
} VkMemoryFdPropertiesKHR;

typedef struct VkMemoryGetFdInfoKHR {
    VkStructureType                       sType;
    const void*                           pNext;
    VkDeviceMemory                        memory;
    VkExternalMemoryHandleTypeFlagBits    handleType;
} VkMemoryGetFdInfoKHR;

typedef VkResult (VKAPI_PTR *PFN_vkGetMemoryFdKHR)(VkDevice device, const VkMemoryGetFdInfoKHR* pGetFdInfo, int* pFd);
typedef VkResult (VKAPI_PTR *PFN_vkGetMemoryFdPropertiesKHR)(VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType, int fd, VkMemoryFdPropertiesKHR* pMemoryFdProperties);

VkImportMemoryFdInfoKHR ImportMemoryFdInfoKHR(
    VkExternalMemoryHandleTypeFlagBits          handleType,
    int                                         fd);


VkMemoryFdPropertiesKHR MemoryFdPropertiesKHR(
    uint32_t                                    memoryTypeBits);


VkMemoryGetFdInfoKHR MemoryGetFdInfoKHR(
    VkDeviceMemory                              memory,
    VkExternalMemoryHandleTypeFlagBits          handleType);


int getMemoryFdKHR(
        VkDevice device,
        const VkMemoryGetFdInfoKHR & pGetFdInfo);

VkMemoryFdPropertiesKHR getMemoryFdPropertiesKHR(
        VkDevice device,
        VkExternalMemoryHandleTypeFlagBits handleType,
        int fd);



#define VK_KHR_win32_keyed_mutex 1
#define VK_KHR_WIN32_KEYED_MUTEX_SPEC_VERSION 1
#define VK_KHR_WIN32_KEYED_MUTEX_EXTENSION_NAME "VK_KHR_win32_keyed_mutex"
typedef struct VkWin32KeyedMutexAcquireReleaseInfoKHR {
    VkStructureType          sType;
    const void*              pNext;
    uint32_t                 acquireCount;
    const VkDeviceMemory*    pAcquireSyncs;
    const uint64_t*          pAcquireKeys;
    const uint32_t*          pAcquireTimeouts;
    uint32_t                 releaseCount;
    const VkDeviceMemory*    pReleaseSyncs;
    const uint64_t*          pReleaseKeys;
} VkWin32KeyedMutexAcquireReleaseInfoKHR;

struct VkWin32KeyedMutexAcquireReleaseInfoKHRRAII {
   VkWin32KeyedMutexAcquireReleaseInfoKHR nonRaiiObj;
    std::vector<VkDeviceMemory>                 vecAcquireSyncs;
    std::vector<uint64_t>                       vecAcquireKeys;
    std::vector<uint32_t>                       vecAcquireTimeouts;
    std::vector<VkDeviceMemory>                 vecReleaseSyncs;
    std::vector<uint64_t>                       vecReleaseKeys;
};

std::shared_ptr<VkWin32KeyedMutexAcquireReleaseInfoKHRRAII> Win32KeyedMutexAcquireReleaseInfoKHR(
    const std::vector<VkDeviceMemory> &         vecAcquireSyncs,
    const std::vector<uint64_t> &               vecAcquireKeys,
    unsigned int* pAcquireTimeouts_in_array1, int pAcquireTimeouts_dim1,
    const std::vector<VkDeviceMemory> &         vecReleaseSyncs,
    const std::vector<uint64_t> &               vecReleaseKeys);




#define VK_KHR_external_semaphore_capabilities 1
#define VK_KHR_EXTERNAL_SEMAPHORE_CAPABILITIES_SPEC_VERSION 1
#define VK_KHR_EXTERNAL_SEMAPHORE_CAPABILITIES_EXTENSION_NAME "VK_KHR_external_semaphore_capabilities"
typedef VkExternalSemaphoreHandleTypeFlags VkExternalSemaphoreHandleTypeFlagsKHR;

typedef VkExternalSemaphoreHandleTypeFlagBits VkExternalSemaphoreHandleTypeFlagBitsKHR;

typedef VkExternalSemaphoreFeatureFlags VkExternalSemaphoreFeatureFlagsKHR;

typedef VkExternalSemaphoreFeatureFlagBits VkExternalSemaphoreFeatureFlagBitsKHR;

typedef VkPhysicalDeviceExternalSemaphoreInfo VkPhysicalDeviceExternalSemaphoreInfoKHR;

typedef VkExternalSemaphoreProperties VkExternalSemaphorePropertiesKHR;

typedef void (VKAPI_PTR *PFN_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR)(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalSemaphoreInfo* pExternalSemaphoreInfo, VkExternalSemaphoreProperties* pExternalSemaphoreProperties);

VkExternalSemaphoreProperties getPhysicalDeviceExternalSemaphorePropertiesKHR(
        VkPhysicalDevice physicalDevice,
        const VkPhysicalDeviceExternalSemaphoreInfo & pExternalSemaphoreInfo);



#define VK_KHR_external_semaphore 1
#define VK_KHR_EXTERNAL_SEMAPHORE_SPEC_VERSION 1
#define VK_KHR_EXTERNAL_SEMAPHORE_EXTENSION_NAME "VK_KHR_external_semaphore"
typedef VkSemaphoreImportFlags VkSemaphoreImportFlagsKHR;

typedef VkSemaphoreImportFlagBits VkSemaphoreImportFlagBitsKHR;

typedef VkExportSemaphoreCreateInfo VkExportSemaphoreCreateInfoKHR;



#define VK_KHR_external_semaphore_win32 1
#define VK_KHR_EXTERNAL_SEMAPHORE_WIN32_SPEC_VERSION 1
#define VK_KHR_EXTERNAL_SEMAPHORE_WIN32_EXTENSION_NAME "VK_KHR_external_semaphore_win32"
typedef struct VkImportSemaphoreWin32HandleInfoKHR {
    VkStructureType                          sType;
    const void*                              pNext;
    VkSemaphore                              semaphore;
    VkSemaphoreImportFlags                   flags;
    VkExternalSemaphoreHandleTypeFlagBits    handleType;
    HANDLE                                   handle;
    LPCWSTR                                  name;
} VkImportSemaphoreWin32HandleInfoKHR;

typedef struct VkExportSemaphoreWin32HandleInfoKHR {
    VkStructureType               sType;
    const void*                   pNext;
    const SECURITY_ATTRIBUTES*    pAttributes;
    DWORD                         dwAccess;
    LPCWSTR                       name;
} VkExportSemaphoreWin32HandleInfoKHR;

struct VkExportSemaphoreWin32HandleInfoKHRRAII {
   VkExportSemaphoreWin32HandleInfoKHR nonRaiiObj;
    std::shared_ptr<SECURITY_ATTRIBUTES>        pAttributes;
};

typedef struct VkD3D12FenceSubmitInfoKHR {
    VkStructureType    sType;
    const void*        pNext;
    uint32_t           waitSemaphoreValuesCount;
    const uint64_t*    pWaitSemaphoreValues;
    uint32_t           signalSemaphoreValuesCount;
    const uint64_t*    pSignalSemaphoreValues;
} VkD3D12FenceSubmitInfoKHR;

struct VkD3D12FenceSubmitInfoKHRRAII {
   VkD3D12FenceSubmitInfoKHR nonRaiiObj;
    std::vector<uint64_t>                       vecWaitSemaphoreValues;
    std::vector<uint64_t>                       vecSignalSemaphoreValues;
};

typedef struct VkSemaphoreGetWin32HandleInfoKHR {
    VkStructureType                          sType;
    const void*                              pNext;
    VkSemaphore                              semaphore;
    VkExternalSemaphoreHandleTypeFlagBits    handleType;
} VkSemaphoreGetWin32HandleInfoKHR;

typedef VkResult (VKAPI_PTR *PFN_vkImportSemaphoreWin32HandleKHR)(VkDevice device, const VkImportSemaphoreWin32HandleInfoKHR* pImportSemaphoreWin32HandleInfo);
typedef VkResult (VKAPI_PTR *PFN_vkGetSemaphoreWin32HandleKHR)(VkDevice device, const VkSemaphoreGetWin32HandleInfoKHR* pGetWin32HandleInfo, HANDLE* pHandle);

VkImportSemaphoreWin32HandleInfoKHR ImportSemaphoreWin32HandleInfoKHR(
    VkSemaphore                                 semaphore,
    VkSemaphoreImportFlags                      flags,
    VkExternalSemaphoreHandleTypeFlagBits       handleType,
    HANDLE                                      handle,
    LPCWSTR                                     name);


std::shared_ptr<VkExportSemaphoreWin32HandleInfoKHRRAII> ExportSemaphoreWin32HandleInfoKHR(
    const SECURITY_ATTRIBUTES *                 pAttributes,
    DWORD                                       dwAccess,
    LPCWSTR                                     name);


std::shared_ptr<VkD3D12FenceSubmitInfoKHRRAII> D3D12FenceSubmitInfoKHR(
    const std::vector<uint64_t> &               vecWaitSemaphoreValues,
    const std::vector<uint64_t> &               vecSignalSemaphoreValues);


VkSemaphoreGetWin32HandleInfoKHR SemaphoreGetWin32HandleInfoKHR(
    VkSemaphore                                 semaphore,
    VkExternalSemaphoreHandleTypeFlagBits       handleType);


void  importSemaphoreWin32HandleKHR(
        VkDevice device,
        const VkImportSemaphoreWin32HandleInfoKHR & pImportSemaphoreWin32HandleInfo);

HANDLE getSemaphoreWin32HandleKHR(
        VkDevice device,
        const VkSemaphoreGetWin32HandleInfoKHR & pGetWin32HandleInfo);



#define VK_KHR_external_semaphore_fd 1
#define VK_KHR_EXTERNAL_SEMAPHORE_FD_SPEC_VERSION 1
#define VK_KHR_EXTERNAL_SEMAPHORE_FD_EXTENSION_NAME "VK_KHR_external_semaphore_fd"
typedef struct VkImportSemaphoreFdInfoKHR {
    VkStructureType                          sType;
    const void*                              pNext;
    VkSemaphore                              semaphore;
    VkSemaphoreImportFlags                   flags;
    VkExternalSemaphoreHandleTypeFlagBits    handleType;
    int                                      fd;
} VkImportSemaphoreFdInfoKHR;

typedef struct VkSemaphoreGetFdInfoKHR {
    VkStructureType                          sType;
    const void*                              pNext;
    VkSemaphore                              semaphore;
    VkExternalSemaphoreHandleTypeFlagBits    handleType;
} VkSemaphoreGetFdInfoKHR;

typedef VkResult (VKAPI_PTR *PFN_vkImportSemaphoreFdKHR)(VkDevice device, const VkImportSemaphoreFdInfoKHR* pImportSemaphoreFdInfo);
typedef VkResult (VKAPI_PTR *PFN_vkGetSemaphoreFdKHR)(VkDevice device, const VkSemaphoreGetFdInfoKHR* pGetFdInfo, int* pFd);

VkImportSemaphoreFdInfoKHR ImportSemaphoreFdInfoKHR(
    VkSemaphore                                 semaphore,
    VkSemaphoreImportFlags                      flags,
    VkExternalSemaphoreHandleTypeFlagBits       handleType,
    int                                         fd);


VkSemaphoreGetFdInfoKHR SemaphoreGetFdInfoKHR(
    VkSemaphore                                 semaphore,
    VkExternalSemaphoreHandleTypeFlagBits       handleType);


void  importSemaphoreFdKHR(
        VkDevice device,
        const VkImportSemaphoreFdInfoKHR & pImportSemaphoreFdInfo);

int getSemaphoreFdKHR(
        VkDevice device,
        const VkSemaphoreGetFdInfoKHR & pGetFdInfo);



#define VK_KHR_external_fence_win32 1
#define VK_KHR_EXTERNAL_FENCE_WIN32_SPEC_VERSION 1
#define VK_KHR_EXTERNAL_FENCE_WIN32_EXTENSION_NAME "VK_KHR_external_fence_win32"
typedef struct VkImportFenceWin32HandleInfoKHR {
    VkStructureType                      sType;
    const void*                          pNext;
    VkFence                              fence;
    VkFenceImportFlags                   flags;
    VkExternalFenceHandleTypeFlagBits    handleType;
    HANDLE                               handle;
    LPCWSTR                              name;
} VkImportFenceWin32HandleInfoKHR;

typedef struct VkExportFenceWin32HandleInfoKHR {
    VkStructureType               sType;
    const void*                   pNext;
    const SECURITY_ATTRIBUTES*    pAttributes;
    DWORD                         dwAccess;
    LPCWSTR                       name;
} VkExportFenceWin32HandleInfoKHR;

struct VkExportFenceWin32HandleInfoKHRRAII {
   VkExportFenceWin32HandleInfoKHR nonRaiiObj;
    std::shared_ptr<SECURITY_ATTRIBUTES>        pAttributes;
};

typedef struct VkFenceGetWin32HandleInfoKHR {
    VkStructureType                      sType;
    const void*                          pNext;
    VkFence                              fence;
    VkExternalFenceHandleTypeFlagBits    handleType;
} VkFenceGetWin32HandleInfoKHR;

typedef VkResult (VKAPI_PTR *PFN_vkImportFenceWin32HandleKHR)(VkDevice device, const VkImportFenceWin32HandleInfoKHR* pImportFenceWin32HandleInfo);
typedef VkResult (VKAPI_PTR *PFN_vkGetFenceWin32HandleKHR)(VkDevice device, const VkFenceGetWin32HandleInfoKHR* pGetWin32HandleInfo, HANDLE* pHandle);

VkImportFenceWin32HandleInfoKHR ImportFenceWin32HandleInfoKHR(
    VkFence                                     fence,
    VkFenceImportFlags                          flags,
    VkExternalFenceHandleTypeFlagBits           handleType,
    HANDLE                                      handle,
    LPCWSTR                                     name);


std::shared_ptr<VkExportFenceWin32HandleInfoKHRRAII> ExportFenceWin32HandleInfoKHR(
    const SECURITY_ATTRIBUTES *                 pAttributes,
    DWORD                                       dwAccess,
    LPCWSTR                                     name);


VkFenceGetWin32HandleInfoKHR FenceGetWin32HandleInfoKHR(
    VkFence                                     fence,
    VkExternalFenceHandleTypeFlagBits           handleType);


void  importFenceWin32HandleKHR(
        VkDevice device,
        const VkImportFenceWin32HandleInfoKHR & pImportFenceWin32HandleInfo);

HANDLE getFenceWin32HandleKHR(
        VkDevice device,
        const VkFenceGetWin32HandleInfoKHR & pGetWin32HandleInfo);



#define VK_KHR_swapchain_mutable_format 1
#define VK_KHR_SWAPCHAIN_MUTABLE_FORMAT_SPEC_VERSION 1
#define VK_KHR_SWAPCHAIN_MUTABLE_FORMAT_EXTENSION_NAME "VK_KHR_swapchain_mutable_format"


#define VK_KHR_surface_protected_capabilities 1
#define VK_KHR_SURFACE_PROTECTED_CAPABILITIES_SPEC_VERSION 1
#define VK_KHR_SURFACE_PROTECTED_CAPABILITIES_EXTENSION_NAME "VK_KHR_surface_protected_capabilities"
typedef struct VkSurfaceProtectedCapabilitiesKHR {
    VkStructureType    sType;
    const void*        pNext;
    VkBool32           supportsProtected;
} VkSurfaceProtectedCapabilitiesKHR;

VkSurfaceProtectedCapabilitiesKHR SurfaceProtectedCapabilitiesKHR(
    VkBool32                                    supportsProtected);




#define VK_EXT_debug_report 1
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkDebugReportCallbackEXT)
#define VK_EXT_DEBUG_REPORT_SPEC_VERSION  9
#define VK_EXT_DEBUG_REPORT_EXTENSION_NAME "VK_EXT_debug_report"

typedef enum VkDebugReportObjectTypeEXT {
    VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT = 0,
    VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT = 1,
    VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT = 2,
    VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT = 3,
    VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT = 4,
    VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT = 5,
    VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT = 6,
    VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT = 7,
    VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT = 8,
    VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT = 9,
    VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT = 10,
    VK_DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT = 11,
    VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT = 12,
    VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT = 13,
    VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT = 14,
    VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT = 15,
    VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT = 16,
    VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT = 17,
    VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT = 18,
    VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT = 19,
    VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT = 20,
    VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT = 21,
    VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT = 22,
    VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT = 23,
    VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT = 24,
    VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT = 25,
    VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT = 26,
    VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT = 27,
    VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT_EXT = 28,
    VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_KHR_EXT = 29,
    VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_MODE_KHR_EXT = 30,
    VK_DEBUG_REPORT_OBJECT_TYPE_OBJECT_TABLE_NVX_EXT = 31,
    VK_DEBUG_REPORT_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NVX_EXT = 32,
    VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT_EXT = 33,
    VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_EXT = 1000156000,
    VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_EXT = 1000085000,
    VK_DEBUG_REPORT_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV_EXT = 1000165000,
    VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT_EXT,
    VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT_EXT,
    VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_EXT,
    VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_KHR_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_EXT,
    VK_DEBUG_REPORT_OBJECT_TYPE_MAX_ENUM_EXT = 0x7FFFFFFF
} VkDebugReportObjectTypeEXT;

typedef enum VkDebugReportFlagBitsEXT {
    VK_DEBUG_REPORT_INFORMATION_BIT_EXT = 0x00000001,
    VK_DEBUG_REPORT_WARNING_BIT_EXT = 0x00000002,
    VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT = 0x00000004,
    VK_DEBUG_REPORT_ERROR_BIT_EXT = 0x00000008,
    VK_DEBUG_REPORT_DEBUG_BIT_EXT = 0x00000010,
    VK_DEBUG_REPORT_FLAG_BITS_MAX_ENUM_EXT = 0x7FFFFFFF
} VkDebugReportFlagBitsEXT;
typedef VkFlags VkDebugReportFlagsEXT;
typedef VkBool32 (VKAPI_PTR *PFN_vkDebugReportCallbackEXT)(
    VkDebugReportFlagsEXT                       flags,
    VkDebugReportObjectTypeEXT                  objectType,
    uint64_t                                    object,
    size_t                                      location,
    int32_t                                     messageCode,
    const char*                                 pLayerPrefix,
    const char*                                 pMessage,
    void*                                       pUserData);

typedef struct VkDebugReportCallbackCreateInfoEXT {
    VkStructureType                 sType;
    const void*                     pNext;
    VkDebugReportFlagsEXT           flags;
    PFN_vkDebugReportCallbackEXT    pfnCallback;
    void*                           pUserData;
} VkDebugReportCallbackCreateInfoEXT;

typedef VkResult (VKAPI_PTR *PFN_vkCreateDebugReportCallbackEXT)(VkInstance instance, const VkDebugReportCallbackCreateInfoEXT* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkDebugReportCallbackEXT* pCallback);
typedef void (VKAPI_PTR *PFN_vkDestroyDebugReportCallbackEXT)(VkInstance instance, VkDebugReportCallbackEXT callback, const VkAllocationCallbacks* pAllocator);
typedef void (VKAPI_PTR *PFN_vkDebugReportMessageEXT)(VkInstance instance, VkDebugReportFlagsEXT flags, VkDebugReportObjectTypeEXT objectType, uint64_t object, size_t location, int32_t messageCode, const char* pLayerPrefix, const char* pMessage);

VkDebugReportCallbackCreateInfoEXT DebugReportCallbackCreateInfoEXT(
    VkDebugReportFlagsEXT                       flags,
    PFN_vkDebugReportCallbackEXT                pfnCallback);


std::shared_ptr<VkDebugReportCallbackEXT_T> createDebugReportCallbackEXT(
        VkInstance instance,
        const VkDebugReportCallbackCreateInfoEXT & pCreateInfo);

void  debugReportMessageEXT(
        VkInstance instance,
        VkDebugReportFlagsEXT flags,
        VkDebugReportObjectTypeEXT objectType,
        uint64_t object,
        size_t location,
        int32_t messageCode,
        const char* pLayerPrefix,
        const char* pMessage);



#define VK_NV_external_memory_win32 1
#define VK_NV_EXTERNAL_MEMORY_WIN32_SPEC_VERSION 1
#define VK_NV_EXTERNAL_MEMORY_WIN32_EXTENSION_NAME "VK_NV_external_memory_win32"
typedef struct VkImportMemoryWin32HandleInfoNV {
    VkStructureType                      sType;
    const void*                          pNext;
    VkExternalMemoryHandleTypeFlagsNV    handleType;
    HANDLE                               handle;
} VkImportMemoryWin32HandleInfoNV;

typedef struct VkExportMemoryWin32HandleInfoNV {
    VkStructureType               sType;
    const void*                   pNext;
    const SECURITY_ATTRIBUTES*    pAttributes;
    DWORD                         dwAccess;
} VkExportMemoryWin32HandleInfoNV;

struct VkExportMemoryWin32HandleInfoNVRAII {
   VkExportMemoryWin32HandleInfoNV nonRaiiObj;
    std::shared_ptr<SECURITY_ATTRIBUTES>        pAttributes;
};

typedef VkResult (VKAPI_PTR *PFN_vkGetMemoryWin32HandleNV)(VkDevice device, VkDeviceMemory memory, VkExternalMemoryHandleTypeFlagsNV handleType, HANDLE* pHandle);

VkImportMemoryWin32HandleInfoNV ImportMemoryWin32HandleInfoNV(
    VkExternalMemoryHandleTypeFlagsNV           handleType,
    HANDLE                                      handle);


std::shared_ptr<VkExportMemoryWin32HandleInfoNVRAII> ExportMemoryWin32HandleInfoNV(
    const SECURITY_ATTRIBUTES *                 pAttributes,
    DWORD                                       dwAccess);


HANDLE getMemoryWin32HandleNV(
        VkDevice device,
        VkDeviceMemory memory,
        VkExternalMemoryHandleTypeFlagsNV handleType);



#define VK_NV_win32_keyed_mutex 1
#define VK_NV_WIN32_KEYED_MUTEX_SPEC_VERSION 2
#define VK_NV_WIN32_KEYED_MUTEX_EXTENSION_NAME "VK_NV_win32_keyed_mutex"
typedef struct VkWin32KeyedMutexAcquireReleaseInfoNV {
    VkStructureType          sType;
    const void*              pNext;
    uint32_t                 acquireCount;
    const VkDeviceMemory*    pAcquireSyncs;
    const uint64_t*          pAcquireKeys;
    const uint32_t*          pAcquireTimeoutMilliseconds;
    uint32_t                 releaseCount;
    const VkDeviceMemory*    pReleaseSyncs;
    const uint64_t*          pReleaseKeys;
} VkWin32KeyedMutexAcquireReleaseInfoNV;

struct VkWin32KeyedMutexAcquireReleaseInfoNVRAII {
   VkWin32KeyedMutexAcquireReleaseInfoNV nonRaiiObj;
    std::vector<VkDeviceMemory>                 vecAcquireSyncs;
    std::vector<uint64_t>                       vecAcquireKeys;
    std::vector<uint32_t>                       vecAcquireTimeoutMilliseconds;
    std::vector<VkDeviceMemory>                 vecReleaseSyncs;
    std::vector<uint64_t>                       vecReleaseKeys;
};

std::shared_ptr<VkWin32KeyedMutexAcquireReleaseInfoNVRAII> Win32KeyedMutexAcquireReleaseInfoNV(
    const std::vector<VkDeviceMemory> &         vecAcquireSyncs,
    const std::vector<uint64_t> &               vecAcquireKeys,
    unsigned int* pAcquireTimeoutMilliseconds_in_array1, int pAcquireTimeoutMilliseconds_dim1,
    const std::vector<VkDeviceMemory> &         vecReleaseSyncs,
    const std::vector<uint64_t> &               vecReleaseKeys);


void load_vulkan_fct_ptrs(VkInstance instance);

%{

     const char* vkGetErrorString(VkResult retval)
     {
         static const char vk_err_messages[32][123] = {
             "Vulkan error (VK_SUCCESS) : Command completed successfully",
             "Vulkan error (VK_NOT_READY) : A fence or query has not yet completed",
             "Vulkan error (VK_TIMEOUT) : A wait operation has not completed in the specified time",
             "Vulkan error (VK_EVENT_SET) : An event is signaled",
             "Vulkan error (VK_EVENT_RESET) : An event is unsignaled",
             "Vulkan error (VK_INCOMPLETE) : A return array was too small for the result",
             "Vulkan error (VK_ERROR_OUT_OF_HOST_MEMORY) : A host memory allocation has failed",
             "Vulkan error (VK_ERROR_OUT_OF_DEVICE_MEMORY) : A device memory allocation has failed",
             "Vulkan error (VK_ERROR_INITIALIZATION_FAILED) : Initialization of a object has failed",
             "Vulkan error (VK_ERROR_DEVICE_LOST) : The logical device has been lost. See <<devsandqueues-lost-device>>",
             "Vulkan error (VK_ERROR_MEMORY_MAP_FAILED) : Mapping of a memory object has failed",
             "Vulkan error (VK_ERROR_LAYER_NOT_PRESENT) : Layer specified does not exist",
             "Vulkan error (VK_ERROR_EXTENSION_NOT_PRESENT) : Extension specified does not exist",
             "Vulkan error (VK_ERROR_FEATURE_NOT_PRESENT) : Requested feature is not available on this device",
             "Vulkan error (VK_ERROR_INCOMPATIBLE_DRIVER) : Unable to find a Vulkan driver",
             "Vulkan error (VK_ERROR_TOO_MANY_OBJECTS) : Too many objects of the type have already been created",
             "Vulkan error (VK_ERROR_FORMAT_NOT_SUPPORTED) : Requested format is not supported on this device",
             "Vulkan error (VK_ERROR_FRAGMENTED_POOL) : A requested pool allocation has failed due to fragmentation of the pool's memory",
             "Vulkan error: VK_ERROR_OUT_OF_POOL_MEMORY",
             "Vulkan error: VK_ERROR_INVALID_EXTERNAL_HANDLE",
             "Vulkan error: VK_ERROR_SURFACE_LOST_KHR",
             "Vulkan error: VK_ERROR_NATIVE_WINDOW_IN_USE_KHR",
             "Vulkan error: VK_SUBOPTIMAL_KHR",
             "Vulkan error: VK_ERROR_OUT_OF_DATE_KHR",
             "Vulkan error: VK_ERROR_INCOMPATIBLE_DISPLAY_KHR",
             "Vulkan error: VK_ERROR_VALIDATION_FAILED_EXT",
             "Vulkan error: VK_ERROR_INVALID_SHADER_NV",
             "Vulkan error: VK_ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT",
             "Vulkan error: VK_ERROR_FRAGMENTATION_EXT",
             "Vulkan error: VK_ERROR_NOT_PERMITTED_EXT",
             "Vulkan error: VK_ERROR_INVALID_DEVICE_ADDRESS_EXT",
             "Vulkan error: VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT",
         };
         switch (retval) {
             case VK_SUCCESS : return vk_err_messages[0];
             case VK_NOT_READY : return vk_err_messages[1];
             case VK_TIMEOUT : return vk_err_messages[2];
             case VK_EVENT_SET : return vk_err_messages[3];
             case VK_EVENT_RESET : return vk_err_messages[4];
             case VK_INCOMPLETE : return vk_err_messages[5];
             case VK_ERROR_OUT_OF_HOST_MEMORY : return vk_err_messages[6];
             case VK_ERROR_OUT_OF_DEVICE_MEMORY : return vk_err_messages[7];
             case VK_ERROR_INITIALIZATION_FAILED : return vk_err_messages[8];
             case VK_ERROR_DEVICE_LOST : return vk_err_messages[9];
             case VK_ERROR_MEMORY_MAP_FAILED : return vk_err_messages[10];
             case VK_ERROR_LAYER_NOT_PRESENT : return vk_err_messages[11];
             case VK_ERROR_EXTENSION_NOT_PRESENT : return vk_err_messages[12];
             case VK_ERROR_FEATURE_NOT_PRESENT : return vk_err_messages[13];
             case VK_ERROR_INCOMPATIBLE_DRIVER : return vk_err_messages[14];
             case VK_ERROR_TOO_MANY_OBJECTS : return vk_err_messages[15];
             case VK_ERROR_FORMAT_NOT_SUPPORTED : return vk_err_messages[16];
             case VK_ERROR_FRAGMENTED_POOL : return vk_err_messages[17];
             case VK_ERROR_OUT_OF_POOL_MEMORY : return vk_err_messages[18];
             case VK_ERROR_INVALID_EXTERNAL_HANDLE : return vk_err_messages[19];
             case VK_ERROR_SURFACE_LOST_KHR : return vk_err_messages[20];
             case VK_ERROR_NATIVE_WINDOW_IN_USE_KHR : return vk_err_messages[21];
             case VK_SUBOPTIMAL_KHR : return vk_err_messages[22];
             case VK_ERROR_OUT_OF_DATE_KHR : return vk_err_messages[23];
             case VK_ERROR_INCOMPATIBLE_DISPLAY_KHR : return vk_err_messages[24];
             case VK_ERROR_VALIDATION_FAILED_EXT : return vk_err_messages[25];
             case VK_ERROR_INVALID_SHADER_NV : return vk_err_messages[26];
             case VK_ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT : return vk_err_messages[27];
             case VK_ERROR_FRAGMENTATION_EXT : return vk_err_messages[28];
             case VK_ERROR_NOT_PERMITTED_EXT : return vk_err_messages[29];
             case VK_ERROR_INVALID_DEVICE_ADDRESS_EXT : return vk_err_messages[30];
             case VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT : return vk_err_messages[31];
         }
         return nullptr;
     }

#ifdef VK_KHR_display
    PFN_vkGetPhysicalDeviceDisplayPropertiesKHR pfvkGetPhysicalDeviceDisplayPropertiesKHR;
    #endif //VK_KHR_display
    #ifdef VK_KHR_display
    PFN_vkGetPhysicalDeviceDisplayPlanePropertiesKHR pfvkGetPhysicalDeviceDisplayPlanePropertiesKHR;
    #endif //VK_KHR_display
    #ifdef VK_KHR_display
    PFN_vkGetDisplayPlaneSupportedDisplaysKHR pfvkGetDisplayPlaneSupportedDisplaysKHR;
    #endif //VK_KHR_display
    #ifdef VK_KHR_display
    PFN_vkGetDisplayModePropertiesKHR pfvkGetDisplayModePropertiesKHR;
    #endif //VK_KHR_display
    #ifdef VK_KHR_display
    PFN_vkCreateDisplayModeKHR pfvkCreateDisplayModeKHR;
    #endif //VK_KHR_display
    #ifdef VK_KHR_display
    PFN_vkGetDisplayPlaneCapabilitiesKHR pfvkGetDisplayPlaneCapabilitiesKHR;
    #endif //VK_KHR_display
    #ifdef VK_KHR_display
    PFN_vkCreateDisplayPlaneSurfaceKHR pfvkCreateDisplayPlaneSurfaceKHR;
    #endif //VK_KHR_display
    #ifdef VK_KHR_display
    PFN_vkDestroySurfaceKHR pfvkDestroySurfaceKHR;
    #endif //VK_KHR_display
    #ifdef VK_KHR_display_swapchain
    PFN_vkCreateSharedSwapchainsKHR pfvkCreateSharedSwapchainsKHR;
    #endif //VK_KHR_display_swapchain
    #ifdef VK_KHR_external_memory_capabilities
    PFN_vkGetPhysicalDeviceExternalBufferPropertiesKHR pfvkGetPhysicalDeviceExternalBufferPropertiesKHR;
    #endif //VK_KHR_external_memory_capabilities
    #ifdef VK_KHR_external_memory_win32
    PFN_vkGetMemoryWin32HandleKHR pfvkGetMemoryWin32HandleKHR;
    #endif //VK_KHR_external_memory_win32
    #ifdef VK_KHR_external_memory_win32
    PFN_vkGetMemoryWin32HandlePropertiesKHR pfvkGetMemoryWin32HandlePropertiesKHR;
    #endif //VK_KHR_external_memory_win32
    #ifdef VK_KHR_external_memory_fd
    PFN_vkGetMemoryFdKHR pfvkGetMemoryFdKHR;
    #endif //VK_KHR_external_memory_fd
    #ifdef VK_KHR_external_memory_fd
    PFN_vkGetMemoryFdPropertiesKHR pfvkGetMemoryFdPropertiesKHR;
    #endif //VK_KHR_external_memory_fd
    #ifdef VK_KHR_external_semaphore_capabilities
    PFN_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR pfvkGetPhysicalDeviceExternalSemaphorePropertiesKHR;
    #endif //VK_KHR_external_semaphore_capabilities
    #ifdef VK_KHR_external_semaphore_win32
    PFN_vkImportSemaphoreWin32HandleKHR pfvkImportSemaphoreWin32HandleKHR;
    #endif //VK_KHR_external_semaphore_win32
    #ifdef VK_KHR_external_semaphore_win32
    PFN_vkGetSemaphoreWin32HandleKHR pfvkGetSemaphoreWin32HandleKHR;
    #endif //VK_KHR_external_semaphore_win32
    #ifdef VK_KHR_external_semaphore_fd
    PFN_vkImportSemaphoreFdKHR pfvkImportSemaphoreFdKHR;
    #endif //VK_KHR_external_semaphore_fd
    #ifdef VK_KHR_external_semaphore_fd
    PFN_vkGetSemaphoreFdKHR pfvkGetSemaphoreFdKHR;
    #endif //VK_KHR_external_semaphore_fd
    #ifdef VK_KHR_external_fence_win32
    PFN_vkImportFenceWin32HandleKHR pfvkImportFenceWin32HandleKHR;
    #endif //VK_KHR_external_fence_win32
    #ifdef VK_KHR_external_fence_win32
    PFN_vkGetFenceWin32HandleKHR pfvkGetFenceWin32HandleKHR;
    #endif //VK_KHR_external_fence_win32
    #ifdef VK_EXT_debug_report
    PFN_vkCreateDebugReportCallbackEXT pfvkCreateDebugReportCallbackEXT;
    #endif //VK_EXT_debug_report
    #ifdef VK_EXT_debug_report
    PFN_vkDestroyDebugReportCallbackEXT pfvkDestroyDebugReportCallbackEXT;
    #endif //VK_EXT_debug_report
    #ifdef VK_EXT_debug_report
    PFN_vkDebugReportMessageEXT pfvkDebugReportMessageEXT;
    #endif //VK_EXT_debug_report
    #ifdef VK_NV_external_memory_win32
    PFN_vkGetMemoryWin32HandleNV pfvkGetMemoryWin32HandleNV;
    #endif //VK_NV_external_memory_win32

    void load_vulkan_fct_ptrs(VkInstance instance)
    {
#ifdef VK_KHR_display
	    pfvkGetPhysicalDeviceDisplayPropertiesKHR = reinterpret_cast<PFN_vkGetPhysicalDeviceDisplayPropertiesKHR>(vkGetInstanceProcAddr(instance, "vkGetPhysicalDeviceDisplayPropertiesKHR"));
#endif
#ifdef VK_KHR_display
	    pfvkGetPhysicalDeviceDisplayPlanePropertiesKHR = reinterpret_cast<PFN_vkGetPhysicalDeviceDisplayPlanePropertiesKHR>(vkGetInstanceProcAddr(instance, "vkGetPhysicalDeviceDisplayPlanePropertiesKHR"));
#endif
#ifdef VK_KHR_display
	    pfvkGetDisplayPlaneSupportedDisplaysKHR = reinterpret_cast<PFN_vkGetDisplayPlaneSupportedDisplaysKHR>(vkGetInstanceProcAddr(instance, "vkGetDisplayPlaneSupportedDisplaysKHR"));
#endif
#ifdef VK_KHR_display
	    pfvkGetDisplayModePropertiesKHR = reinterpret_cast<PFN_vkGetDisplayModePropertiesKHR>(vkGetInstanceProcAddr(instance, "vkGetDisplayModePropertiesKHR"));
#endif
#ifdef VK_KHR_display
	    pfvkCreateDisplayModeKHR = reinterpret_cast<PFN_vkCreateDisplayModeKHR>(vkGetInstanceProcAddr(instance, "vkCreateDisplayModeKHR"));
#endif
#ifdef VK_KHR_display
	    pfvkGetDisplayPlaneCapabilitiesKHR = reinterpret_cast<PFN_vkGetDisplayPlaneCapabilitiesKHR>(vkGetInstanceProcAddr(instance, "vkGetDisplayPlaneCapabilitiesKHR"));
#endif
#ifdef VK_KHR_display
	    pfvkCreateDisplayPlaneSurfaceKHR = reinterpret_cast<PFN_vkCreateDisplayPlaneSurfaceKHR>(vkGetInstanceProcAddr(instance, "vkCreateDisplayPlaneSurfaceKHR"));
#endif
#ifdef VK_KHR_display
	    pfvkDestroySurfaceKHR = reinterpret_cast<PFN_vkDestroySurfaceKHR>(vkGetInstanceProcAddr(instance, "vkDestroySurfaceKHR"));
#endif
#ifdef VK_KHR_display_swapchain
	    pfvkCreateSharedSwapchainsKHR = reinterpret_cast<PFN_vkCreateSharedSwapchainsKHR>(vkGetInstanceProcAddr(instance, "vkCreateSharedSwapchainsKHR"));
#endif
#ifdef VK_KHR_external_memory_capabilities
	    pfvkGetPhysicalDeviceExternalBufferPropertiesKHR = reinterpret_cast<PFN_vkGetPhysicalDeviceExternalBufferPropertiesKHR>(vkGetInstanceProcAddr(instance, "vkGetPhysicalDeviceExternalBufferPropertiesKHR"));
#endif
#ifdef VK_KHR_external_memory_win32
	    pfvkGetMemoryWin32HandleKHR = reinterpret_cast<PFN_vkGetMemoryWin32HandleKHR>(vkGetInstanceProcAddr(instance, "vkGetMemoryWin32HandleKHR"));
#endif
#ifdef VK_KHR_external_memory_win32
	    pfvkGetMemoryWin32HandlePropertiesKHR = reinterpret_cast<PFN_vkGetMemoryWin32HandlePropertiesKHR>(vkGetInstanceProcAddr(instance, "vkGetMemoryWin32HandlePropertiesKHR"));
#endif
#ifdef VK_KHR_external_memory_fd
	    pfvkGetMemoryFdKHR = reinterpret_cast<PFN_vkGetMemoryFdKHR>(vkGetInstanceProcAddr(instance, "vkGetMemoryFdKHR"));
#endif
#ifdef VK_KHR_external_memory_fd
	    pfvkGetMemoryFdPropertiesKHR = reinterpret_cast<PFN_vkGetMemoryFdPropertiesKHR>(vkGetInstanceProcAddr(instance, "vkGetMemoryFdPropertiesKHR"));
#endif
#ifdef VK_KHR_external_semaphore_capabilities
	    pfvkGetPhysicalDeviceExternalSemaphorePropertiesKHR = reinterpret_cast<PFN_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR>(vkGetInstanceProcAddr(instance, "vkGetPhysicalDeviceExternalSemaphorePropertiesKHR"));
#endif
#ifdef VK_KHR_external_semaphore_win32
	    pfvkImportSemaphoreWin32HandleKHR = reinterpret_cast<PFN_vkImportSemaphoreWin32HandleKHR>(vkGetInstanceProcAddr(instance, "vkImportSemaphoreWin32HandleKHR"));
#endif
#ifdef VK_KHR_external_semaphore_win32
	    pfvkGetSemaphoreWin32HandleKHR = reinterpret_cast<PFN_vkGetSemaphoreWin32HandleKHR>(vkGetInstanceProcAddr(instance, "vkGetSemaphoreWin32HandleKHR"));
#endif
#ifdef VK_KHR_external_semaphore_fd
	    pfvkImportSemaphoreFdKHR = reinterpret_cast<PFN_vkImportSemaphoreFdKHR>(vkGetInstanceProcAddr(instance, "vkImportSemaphoreFdKHR"));
#endif
#ifdef VK_KHR_external_semaphore_fd
	    pfvkGetSemaphoreFdKHR = reinterpret_cast<PFN_vkGetSemaphoreFdKHR>(vkGetInstanceProcAddr(instance, "vkGetSemaphoreFdKHR"));
#endif
#ifdef VK_KHR_external_fence_win32
	    pfvkImportFenceWin32HandleKHR = reinterpret_cast<PFN_vkImportFenceWin32HandleKHR>(vkGetInstanceProcAddr(instance, "vkImportFenceWin32HandleKHR"));
#endif
#ifdef VK_KHR_external_fence_win32
	    pfvkGetFenceWin32HandleKHR = reinterpret_cast<PFN_vkGetFenceWin32HandleKHR>(vkGetInstanceProcAddr(instance, "vkGetFenceWin32HandleKHR"));
#endif
#ifdef VK_EXT_debug_report
	    pfvkCreateDebugReportCallbackEXT = reinterpret_cast<PFN_vkCreateDebugReportCallbackEXT>(vkGetInstanceProcAddr(instance, "vkCreateDebugReportCallbackEXT"));
#endif
#ifdef VK_EXT_debug_report
	    pfvkDestroyDebugReportCallbackEXT = reinterpret_cast<PFN_vkDestroyDebugReportCallbackEXT>(vkGetInstanceProcAddr(instance, "vkDestroyDebugReportCallbackEXT"));
#endif
#ifdef VK_EXT_debug_report
	    pfvkDebugReportMessageEXT = reinterpret_cast<PFN_vkDebugReportMessageEXT>(vkGetInstanceProcAddr(instance, "vkDebugReportMessageEXT"));
#endif
#ifdef VK_NV_external_memory_win32
	    pfvkGetMemoryWin32HandleNV = reinterpret_cast<PFN_vkGetMemoryWin32HandleNV>(vkGetInstanceProcAddr(instance, "vkGetMemoryWin32HandleNV"));
#endif
  }
%}

%{

struct VkApplicationInfoRAII {
   VkApplicationInfo nonRaiiObj;
    std::string                                 strApplicationName;
    std::string                                 strEngineName;
};

std::shared_ptr<VkApplicationInfoRAII> ApplicationInfo(
    const std::string &                         strApplicationName,
    uint32_t                                    applicationVersion,
    const std::string &                         strEngineName,
    uint32_t                                    engineVersion,
    uint32_t                                    apiVersion)
   {
      std::shared_ptr<VkApplicationInfoRAII> raii_obj(new VkApplicationInfoRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_APPLICATION_INFO;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->strApplicationName = strApplicationName;
      raii_obj->nonRaiiObj.pApplicationName = &raii_obj->strApplicationName[0];
      raii_obj->nonRaiiObj.applicationVersion = applicationVersion;
      raii_obj->strEngineName = strEngineName;
      raii_obj->nonRaiiObj.pEngineName = &raii_obj->strEngineName[0];
      raii_obj->nonRaiiObj.engineVersion = engineVersion;
      raii_obj->nonRaiiObj.apiVersion = apiVersion;
      return raii_obj;
   }

struct VkInstanceCreateInfoRAII {
   VkInstanceCreateInfo nonRaiiObj;
    std::shared_ptr<VkApplicationInfoRAII>      pApplicationInfo;
    std::vector<std::string>                    vecEnabledLayerNames;
    std::vector<const char *>                   vecPtrEnabledLayerNames;
    std::vector<std::string>                    vecEnabledExtensionNames;
    std::vector<const char *>                   vecPtrEnabledExtensionNames;
};

std::shared_ptr<VkInstanceCreateInfoRAII> InstanceCreateInfo(
    VkInstanceCreateFlags                       flags,
    const std::shared_ptr<VkApplicationInfoRAII> &pApplicationInfo,
    const std::vector<std::string> &            vecEnabledLayerNames,
    const std::vector<std::string> &            vecEnabledExtensionNames)
   {
      std::shared_ptr<VkInstanceCreateInfoRAII> raii_obj(new VkInstanceCreateInfoRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.flags = flags;
      raii_obj->pApplicationInfo = pApplicationInfo;
      if ( pApplicationInfo ) 
      {
          raii_obj->nonRaiiObj.pApplicationInfo = &(pApplicationInfo->nonRaiiObj);
      }
      else
      {
          raii_obj->nonRaiiObj.pApplicationInfo = nullptr;
      }
      raii_obj->nonRaiiObj.enabledLayerCount = static_cast<uint32_t>(vecEnabledLayerNames.size());
      raii_obj->vecEnabledLayerNames = vecEnabledLayerNames;
      raii_obj->vecPtrEnabledLayerNames.resize(vecEnabledLayerNames.size());
      for (size_t i=0; i<vecEnabledLayerNames.size(); ++i) 
           raii_obj->vecPtrEnabledLayerNames[i] = raii_obj->vecEnabledLayerNames[i].c_str();
      raii_obj->nonRaiiObj.ppEnabledLayerNames = &raii_obj->vecPtrEnabledLayerNames[0];
      raii_obj->nonRaiiObj.enabledExtensionCount = static_cast<uint32_t>(vecEnabledExtensionNames.size());
      raii_obj->vecEnabledExtensionNames = vecEnabledExtensionNames;
      raii_obj->vecPtrEnabledExtensionNames.resize(vecEnabledExtensionNames.size());
      for (size_t i=0; i<vecEnabledExtensionNames.size(); ++i) 
           raii_obj->vecPtrEnabledExtensionNames[i] = raii_obj->vecEnabledExtensionNames[i].c_str();
      raii_obj->nonRaiiObj.ppEnabledExtensionNames = &raii_obj->vecPtrEnabledExtensionNames[0];
      return raii_obj;
   }

VkAllocationCallbacks AllocationCallbacks(
    PFN_vkAllocationFunction                    pfnAllocation,
    PFN_vkReallocationFunction                  pfnReallocation,
    PFN_vkFreeFunction                          pfnFree,
    PFN_vkInternalAllocationNotification        pfnInternalAllocation,
    PFN_vkInternalFreeNotification              pfnInternalFree)
   {
      VkAllocationCallbacks obj;
      obj.pUserData = nullptr;
      obj.pfnAllocation = pfnAllocation;
      obj.pfnReallocation = pfnReallocation;
      obj.pfnFree = pfnFree;
      obj.pfnInternalAllocation = pfnInternalAllocation;
      obj.pfnInternalFree = pfnInternalFree;
      return obj;
   }

std::shared_ptr<VkInstance_T> createInstance(
        const VkInstanceCreateInfo & pCreateInfo)
   {
      VkInstance hInstance; 
      V( vkCreateInstance(
          &pCreateInfo,
          nullptr,
          &hInstance  ));
      return std::shared_ptr<VkInstance_T>(hInstance, 
              [=](VkInstance to_free) {vkDestroyInstance( to_free, nullptr);});
   }

std::vector< VkPhysicalDevice > enumeratePhysicalDevices(
        VkInstance instance)
   {
      std::vector<VkPhysicalDevice> vecpPhysicalDevices; 
      uint32_t pPhysicalDevicesCount; 
      V( vkEnumeratePhysicalDevices(
          instance,
          &pPhysicalDevicesCount,
          nullptr  ));

      vecpPhysicalDevices.resize(pPhysicalDevicesCount); 

      V( vkEnumeratePhysicalDevices(
          instance,
          &pPhysicalDevicesCount,
          &vecpPhysicalDevices[0]  ));
      return vecpPhysicalDevices; 
   }

VkPhysicalDeviceFeatures PhysicalDeviceFeatures(
    VkBool32                                    robustBufferAccess,
    VkBool32                                    fullDrawIndexUint32,
    VkBool32                                    imageCubeArray,
    VkBool32                                    independentBlend,
    VkBool32                                    geometryShader,
    VkBool32                                    tessellationShader,
    VkBool32                                    sampleRateShading,
    VkBool32                                    dualSrcBlend,
    VkBool32                                    logicOp,
    VkBool32                                    multiDrawIndirect,
    VkBool32                                    drawIndirectFirstInstance,
    VkBool32                                    depthClamp,
    VkBool32                                    depthBiasClamp,
    VkBool32                                    fillModeNonSolid,
    VkBool32                                    depthBounds,
    VkBool32                                    wideLines,
    VkBool32                                    largePoints,
    VkBool32                                    alphaToOne,
    VkBool32                                    multiViewport,
    VkBool32                                    samplerAnisotropy,
    VkBool32                                    textureCompressionETC2,
    VkBool32                                    textureCompressionASTC_LDR,
    VkBool32                                    textureCompressionBC,
    VkBool32                                    occlusionQueryPrecise,
    VkBool32                                    pipelineStatisticsQuery,
    VkBool32                                    vertexPipelineStoresAndAtomics,
    VkBool32                                    fragmentStoresAndAtomics,
    VkBool32                                    shaderTessellationAndGeometryPointSize,
    VkBool32                                    shaderImageGatherExtended,
    VkBool32                                    shaderStorageImageExtendedFormats,
    VkBool32                                    shaderStorageImageMultisample,
    VkBool32                                    shaderStorageImageReadWithoutFormat,
    VkBool32                                    shaderStorageImageWriteWithoutFormat,
    VkBool32                                    shaderUniformBufferArrayDynamicIndexing,
    VkBool32                                    shaderSampledImageArrayDynamicIndexing,
    VkBool32                                    shaderStorageBufferArrayDynamicIndexing,
    VkBool32                                    shaderStorageImageArrayDynamicIndexing,
    VkBool32                                    shaderClipDistance,
    VkBool32                                    shaderCullDistance,
    VkBool32                                    shaderFloat64,
    VkBool32                                    shaderInt64,
    VkBool32                                    shaderInt16,
    VkBool32                                    shaderResourceResidency,
    VkBool32                                    shaderResourceMinLod,
    VkBool32                                    sparseBinding,
    VkBool32                                    sparseResidencyBuffer,
    VkBool32                                    sparseResidencyImage2D,
    VkBool32                                    sparseResidencyImage3D,
    VkBool32                                    sparseResidency2Samples,
    VkBool32                                    sparseResidency4Samples,
    VkBool32                                    sparseResidency8Samples,
    VkBool32                                    sparseResidency16Samples,
    VkBool32                                    sparseResidencyAliased,
    VkBool32                                    variableMultisampleRate,
    VkBool32                                    inheritedQueries)
   {
      VkPhysicalDeviceFeatures obj;
      obj.robustBufferAccess = robustBufferAccess;
      obj.fullDrawIndexUint32 = fullDrawIndexUint32;
      obj.imageCubeArray = imageCubeArray;
      obj.independentBlend = independentBlend;
      obj.geometryShader = geometryShader;
      obj.tessellationShader = tessellationShader;
      obj.sampleRateShading = sampleRateShading;
      obj.dualSrcBlend = dualSrcBlend;
      obj.logicOp = logicOp;
      obj.multiDrawIndirect = multiDrawIndirect;
      obj.drawIndirectFirstInstance = drawIndirectFirstInstance;
      obj.depthClamp = depthClamp;
      obj.depthBiasClamp = depthBiasClamp;
      obj.fillModeNonSolid = fillModeNonSolid;
      obj.depthBounds = depthBounds;
      obj.wideLines = wideLines;
      obj.largePoints = largePoints;
      obj.alphaToOne = alphaToOne;
      obj.multiViewport = multiViewport;
      obj.samplerAnisotropy = samplerAnisotropy;
      obj.textureCompressionETC2 = textureCompressionETC2;
      obj.textureCompressionASTC_LDR = textureCompressionASTC_LDR;
      obj.textureCompressionBC = textureCompressionBC;
      obj.occlusionQueryPrecise = occlusionQueryPrecise;
      obj.pipelineStatisticsQuery = pipelineStatisticsQuery;
      obj.vertexPipelineStoresAndAtomics = vertexPipelineStoresAndAtomics;
      obj.fragmentStoresAndAtomics = fragmentStoresAndAtomics;
      obj.shaderTessellationAndGeometryPointSize = shaderTessellationAndGeometryPointSize;
      obj.shaderImageGatherExtended = shaderImageGatherExtended;
      obj.shaderStorageImageExtendedFormats = shaderStorageImageExtendedFormats;
      obj.shaderStorageImageMultisample = shaderStorageImageMultisample;
      obj.shaderStorageImageReadWithoutFormat = shaderStorageImageReadWithoutFormat;
      obj.shaderStorageImageWriteWithoutFormat = shaderStorageImageWriteWithoutFormat;
      obj.shaderUniformBufferArrayDynamicIndexing = shaderUniformBufferArrayDynamicIndexing;
      obj.shaderSampledImageArrayDynamicIndexing = shaderSampledImageArrayDynamicIndexing;
      obj.shaderStorageBufferArrayDynamicIndexing = shaderStorageBufferArrayDynamicIndexing;
      obj.shaderStorageImageArrayDynamicIndexing = shaderStorageImageArrayDynamicIndexing;
      obj.shaderClipDistance = shaderClipDistance;
      obj.shaderCullDistance = shaderCullDistance;
      obj.shaderFloat64 = shaderFloat64;
      obj.shaderInt64 = shaderInt64;
      obj.shaderInt16 = shaderInt16;
      obj.shaderResourceResidency = shaderResourceResidency;
      obj.shaderResourceMinLod = shaderResourceMinLod;
      obj.sparseBinding = sparseBinding;
      obj.sparseResidencyBuffer = sparseResidencyBuffer;
      obj.sparseResidencyImage2D = sparseResidencyImage2D;
      obj.sparseResidencyImage3D = sparseResidencyImage3D;
      obj.sparseResidency2Samples = sparseResidency2Samples;
      obj.sparseResidency4Samples = sparseResidency4Samples;
      obj.sparseResidency8Samples = sparseResidency8Samples;
      obj.sparseResidency16Samples = sparseResidency16Samples;
      obj.sparseResidencyAliased = sparseResidencyAliased;
      obj.variableMultisampleRate = variableMultisampleRate;
      obj.inheritedQueries = inheritedQueries;
      return obj;
   }

VkPhysicalDeviceFeatures getPhysicalDeviceFeatures(
        VkPhysicalDevice physicalDevice)
   {
      VkPhysicalDeviceFeatures pFeatures; 
      vkGetPhysicalDeviceFeatures(
          physicalDevice,
          &pFeatures  );
      return pFeatures; 
   }

VkFormatProperties FormatProperties(
    VkFormatFeatureFlags                        linearTilingFeatures,
    VkFormatFeatureFlags                        optimalTilingFeatures,
    VkFormatFeatureFlags                        bufferFeatures)
   {
      VkFormatProperties obj;
      obj.linearTilingFeatures = linearTilingFeatures;
      obj.optimalTilingFeatures = optimalTilingFeatures;
      obj.bufferFeatures = bufferFeatures;
      return obj;
   }

VkFormatProperties getPhysicalDeviceFormatProperties(
        VkPhysicalDevice physicalDevice,
        VkFormat format)
   {
      VkFormatProperties pFormatProperties; 
      vkGetPhysicalDeviceFormatProperties(
          physicalDevice,
          format,
          &pFormatProperties  );
      return pFormatProperties; 
   }

VkExtent3D Extent3D(
    uint32_t                                    width,
    uint32_t                                    height,
    uint32_t                                    depth)
   {
      VkExtent3D obj;
      obj.width = width;
      obj.height = height;
      obj.depth = depth;
      return obj;
   }

VkImageFormatProperties ImageFormatProperties(
    VkExtent3D                                  maxExtent,
    uint32_t                                    maxMipLevels,
    uint32_t                                    maxArrayLayers,
    VkSampleCountFlags                          sampleCounts,
    VkDeviceSize                                maxResourceSize)
   {
      VkImageFormatProperties obj;
      obj.maxExtent = maxExtent;
      obj.maxMipLevels = maxMipLevels;
      obj.maxArrayLayers = maxArrayLayers;
      obj.sampleCounts = sampleCounts;
      obj.maxResourceSize = maxResourceSize;
      return obj;
   }

VkImageFormatProperties getPhysicalDeviceImageFormatProperties(
        VkPhysicalDevice physicalDevice,
        VkFormat format,
        VkImageType type,
        VkImageTiling tiling,
        VkImageUsageFlags usage,
        VkImageCreateFlags flags)
   {
      VkImageFormatProperties pImageFormatProperties; 
      V( vkGetPhysicalDeviceImageFormatProperties(
          physicalDevice,
          format,
          type,
          tiling,
          usage,
          flags,
          &pImageFormatProperties  ));
      return pImageFormatProperties; 
   }

VkPhysicalDeviceLimits PhysicalDeviceLimits(
    uint32_t                                    maxImageDimension1D,
    uint32_t                                    maxImageDimension2D,
    uint32_t                                    maxImageDimension3D,
    uint32_t                                    maxImageDimensionCube,
    uint32_t                                    maxImageArrayLayers,
    uint32_t                                    maxTexelBufferElements,
    uint32_t                                    maxUniformBufferRange,
    uint32_t                                    maxStorageBufferRange,
    uint32_t                                    maxPushConstantsSize,
    uint32_t                                    maxMemoryAllocationCount,
    uint32_t                                    maxSamplerAllocationCount,
    VkDeviceSize                                bufferImageGranularity,
    VkDeviceSize                                sparseAddressSpaceSize,
    uint32_t                                    maxBoundDescriptorSets,
    uint32_t                                    maxPerStageDescriptorSamplers,
    uint32_t                                    maxPerStageDescriptorUniformBuffers,
    uint32_t                                    maxPerStageDescriptorStorageBuffers,
    uint32_t                                    maxPerStageDescriptorSampledImages,
    uint32_t                                    maxPerStageDescriptorStorageImages,
    uint32_t                                    maxPerStageDescriptorInputAttachments,
    uint32_t                                    maxPerStageResources,
    uint32_t                                    maxDescriptorSetSamplers,
    uint32_t                                    maxDescriptorSetUniformBuffers,
    uint32_t                                    maxDescriptorSetUniformBuffersDynamic,
    uint32_t                                    maxDescriptorSetStorageBuffers,
    uint32_t                                    maxDescriptorSetStorageBuffersDynamic,
    uint32_t                                    maxDescriptorSetSampledImages,
    uint32_t                                    maxDescriptorSetStorageImages,
    uint32_t                                    maxDescriptorSetInputAttachments,
    uint32_t                                    maxVertexInputAttributes,
    uint32_t                                    maxVertexInputBindings,
    uint32_t                                    maxVertexInputAttributeOffset,
    uint32_t                                    maxVertexInputBindingStride,
    uint32_t                                    maxVertexOutputComponents,
    uint32_t                                    maxTessellationGenerationLevel,
    uint32_t                                    maxTessellationPatchSize,
    uint32_t                                    maxTessellationControlPerVertexInputComponents,
    uint32_t                                    maxTessellationControlPerVertexOutputComponents,
    uint32_t                                    maxTessellationControlPerPatchOutputComponents,
    uint32_t                                    maxTessellationControlTotalOutputComponents,
    uint32_t                                    maxTessellationEvaluationInputComponents,
    uint32_t                                    maxTessellationEvaluationOutputComponents,
    uint32_t                                    maxGeometryShaderInvocations,
    uint32_t                                    maxGeometryInputComponents,
    uint32_t                                    maxGeometryOutputComponents,
    uint32_t                                    maxGeometryOutputVertices,
    uint32_t                                    maxGeometryTotalOutputComponents,
    uint32_t                                    maxFragmentInputComponents,
    uint32_t                                    maxFragmentOutputAttachments,
    uint32_t                                    maxFragmentDualSrcAttachments,
    uint32_t                                    maxFragmentCombinedOutputResources,
    uint32_t                                    maxComputeSharedMemorySize,
    uint32_t                                    maxComputeWorkGroupCount[3],
    uint32_t                                    maxComputeWorkGroupInvocations,
    uint32_t                                    maxComputeWorkGroupSize[3],
    uint32_t                                    subPixelPrecisionBits,
    uint32_t                                    subTexelPrecisionBits,
    uint32_t                                    mipmapPrecisionBits,
    uint32_t                                    maxDrawIndexedIndexValue,
    uint32_t                                    maxDrawIndirectCount,
    float                                       maxSamplerLodBias,
    float                                       maxSamplerAnisotropy,
    uint32_t                                    maxViewports,
    uint32_t                                    maxViewportDimensions[2],
    float                                       viewportBoundsRange[2],
    uint32_t                                    viewportSubPixelBits,
    size_t                                      minMemoryMapAlignment,
    VkDeviceSize                                minTexelBufferOffsetAlignment,
    VkDeviceSize                                minUniformBufferOffsetAlignment,
    VkDeviceSize                                minStorageBufferOffsetAlignment,
    int32_t                                     minTexelOffset,
    uint32_t                                    maxTexelOffset,
    int32_t                                     minTexelGatherOffset,
    uint32_t                                    maxTexelGatherOffset,
    float                                       minInterpolationOffset,
    float                                       maxInterpolationOffset,
    uint32_t                                    subPixelInterpolationOffsetBits,
    uint32_t                                    maxFramebufferWidth,
    uint32_t                                    maxFramebufferHeight,
    uint32_t                                    maxFramebufferLayers,
    VkSampleCountFlags                          framebufferColorSampleCounts,
    VkSampleCountFlags                          framebufferDepthSampleCounts,
    VkSampleCountFlags                          framebufferStencilSampleCounts,
    VkSampleCountFlags                          framebufferNoAttachmentsSampleCounts,
    uint32_t                                    maxColorAttachments,
    VkSampleCountFlags                          sampledImageColorSampleCounts,
    VkSampleCountFlags                          sampledImageIntegerSampleCounts,
    VkSampleCountFlags                          sampledImageDepthSampleCounts,
    VkSampleCountFlags                          sampledImageStencilSampleCounts,
    VkSampleCountFlags                          storageImageSampleCounts,
    uint32_t                                    maxSampleMaskWords,
    VkBool32                                    timestampComputeAndGraphics,
    float                                       timestampPeriod,
    uint32_t                                    maxClipDistances,
    uint32_t                                    maxCullDistances,
    uint32_t                                    maxCombinedClipAndCullDistances,
    uint32_t                                    discreteQueuePriorities,
    float                                       pointSizeRange[2],
    float                                       lineWidthRange[2],
    float                                       pointSizeGranularity,
    float                                       lineWidthGranularity,
    VkBool32                                    strictLines,
    VkBool32                                    standardSampleLocations,
    VkDeviceSize                                optimalBufferCopyOffsetAlignment,
    VkDeviceSize                                optimalBufferCopyRowPitchAlignment,
    VkDeviceSize                                nonCoherentAtomSize)
   {
      VkPhysicalDeviceLimits obj;
      obj.maxImageDimension1D = maxImageDimension1D;
      obj.maxImageDimension2D = maxImageDimension2D;
      obj.maxImageDimension3D = maxImageDimension3D;
      obj.maxImageDimensionCube = maxImageDimensionCube;
      obj.maxImageArrayLayers = maxImageArrayLayers;
      obj.maxTexelBufferElements = maxTexelBufferElements;
      obj.maxUniformBufferRange = maxUniformBufferRange;
      obj.maxStorageBufferRange = maxStorageBufferRange;
      obj.maxPushConstantsSize = maxPushConstantsSize;
      obj.maxMemoryAllocationCount = maxMemoryAllocationCount;
      obj.maxSamplerAllocationCount = maxSamplerAllocationCount;
      obj.bufferImageGranularity = bufferImageGranularity;
      obj.sparseAddressSpaceSize = sparseAddressSpaceSize;
      obj.maxBoundDescriptorSets = maxBoundDescriptorSets;
      obj.maxPerStageDescriptorSamplers = maxPerStageDescriptorSamplers;
      obj.maxPerStageDescriptorUniformBuffers = maxPerStageDescriptorUniformBuffers;
      obj.maxPerStageDescriptorStorageBuffers = maxPerStageDescriptorStorageBuffers;
      obj.maxPerStageDescriptorSampledImages = maxPerStageDescriptorSampledImages;
      obj.maxPerStageDescriptorStorageImages = maxPerStageDescriptorStorageImages;
      obj.maxPerStageDescriptorInputAttachments = maxPerStageDescriptorInputAttachments;
      obj.maxPerStageResources = maxPerStageResources;
      obj.maxDescriptorSetSamplers = maxDescriptorSetSamplers;
      obj.maxDescriptorSetUniformBuffers = maxDescriptorSetUniformBuffers;
      obj.maxDescriptorSetUniformBuffersDynamic = maxDescriptorSetUniformBuffersDynamic;
      obj.maxDescriptorSetStorageBuffers = maxDescriptorSetStorageBuffers;
      obj.maxDescriptorSetStorageBuffersDynamic = maxDescriptorSetStorageBuffersDynamic;
      obj.maxDescriptorSetSampledImages = maxDescriptorSetSampledImages;
      obj.maxDescriptorSetStorageImages = maxDescriptorSetStorageImages;
      obj.maxDescriptorSetInputAttachments = maxDescriptorSetInputAttachments;
      obj.maxVertexInputAttributes = maxVertexInputAttributes;
      obj.maxVertexInputBindings = maxVertexInputBindings;
      obj.maxVertexInputAttributeOffset = maxVertexInputAttributeOffset;
      obj.maxVertexInputBindingStride = maxVertexInputBindingStride;
      obj.maxVertexOutputComponents = maxVertexOutputComponents;
      obj.maxTessellationGenerationLevel = maxTessellationGenerationLevel;
      obj.maxTessellationPatchSize = maxTessellationPatchSize;
      obj.maxTessellationControlPerVertexInputComponents = maxTessellationControlPerVertexInputComponents;
      obj.maxTessellationControlPerVertexOutputComponents = maxTessellationControlPerVertexOutputComponents;
      obj.maxTessellationControlPerPatchOutputComponents = maxTessellationControlPerPatchOutputComponents;
      obj.maxTessellationControlTotalOutputComponents = maxTessellationControlTotalOutputComponents;
      obj.maxTessellationEvaluationInputComponents = maxTessellationEvaluationInputComponents;
      obj.maxTessellationEvaluationOutputComponents = maxTessellationEvaluationOutputComponents;
      obj.maxGeometryShaderInvocations = maxGeometryShaderInvocations;
      obj.maxGeometryInputComponents = maxGeometryInputComponents;
      obj.maxGeometryOutputComponents = maxGeometryOutputComponents;
      obj.maxGeometryOutputVertices = maxGeometryOutputVertices;
      obj.maxGeometryTotalOutputComponents = maxGeometryTotalOutputComponents;
      obj.maxFragmentInputComponents = maxFragmentInputComponents;
      obj.maxFragmentOutputAttachments = maxFragmentOutputAttachments;
      obj.maxFragmentDualSrcAttachments = maxFragmentDualSrcAttachments;
      obj.maxFragmentCombinedOutputResources = maxFragmentCombinedOutputResources;
      obj.maxComputeSharedMemorySize = maxComputeSharedMemorySize;
      std::copy(maxComputeWorkGroupCount, maxComputeWorkGroupCount + 3, obj.maxComputeWorkGroupCount);
      obj.maxComputeWorkGroupInvocations = maxComputeWorkGroupInvocations;
      std::copy(maxComputeWorkGroupSize, maxComputeWorkGroupSize + 3, obj.maxComputeWorkGroupSize);
      obj.subPixelPrecisionBits = subPixelPrecisionBits;
      obj.subTexelPrecisionBits = subTexelPrecisionBits;
      obj.mipmapPrecisionBits = mipmapPrecisionBits;
      obj.maxDrawIndexedIndexValue = maxDrawIndexedIndexValue;
      obj.maxDrawIndirectCount = maxDrawIndirectCount;
      obj.maxSamplerLodBias = maxSamplerLodBias;
      obj.maxSamplerAnisotropy = maxSamplerAnisotropy;
      obj.maxViewports = maxViewports;
      std::copy(maxViewportDimensions, maxViewportDimensions + 2, obj.maxViewportDimensions);
      std::copy(viewportBoundsRange, viewportBoundsRange + 2, obj.viewportBoundsRange);
      obj.viewportSubPixelBits = viewportSubPixelBits;
      obj.minMemoryMapAlignment = minMemoryMapAlignment;
      obj.minTexelBufferOffsetAlignment = minTexelBufferOffsetAlignment;
      obj.minUniformBufferOffsetAlignment = minUniformBufferOffsetAlignment;
      obj.minStorageBufferOffsetAlignment = minStorageBufferOffsetAlignment;
      obj.minTexelOffset = minTexelOffset;
      obj.maxTexelOffset = maxTexelOffset;
      obj.minTexelGatherOffset = minTexelGatherOffset;
      obj.maxTexelGatherOffset = maxTexelGatherOffset;
      obj.minInterpolationOffset = minInterpolationOffset;
      obj.maxInterpolationOffset = maxInterpolationOffset;
      obj.subPixelInterpolationOffsetBits = subPixelInterpolationOffsetBits;
      obj.maxFramebufferWidth = maxFramebufferWidth;
      obj.maxFramebufferHeight = maxFramebufferHeight;
      obj.maxFramebufferLayers = maxFramebufferLayers;
      obj.framebufferColorSampleCounts = framebufferColorSampleCounts;
      obj.framebufferDepthSampleCounts = framebufferDepthSampleCounts;
      obj.framebufferStencilSampleCounts = framebufferStencilSampleCounts;
      obj.framebufferNoAttachmentsSampleCounts = framebufferNoAttachmentsSampleCounts;
      obj.maxColorAttachments = maxColorAttachments;
      obj.sampledImageColorSampleCounts = sampledImageColorSampleCounts;
      obj.sampledImageIntegerSampleCounts = sampledImageIntegerSampleCounts;
      obj.sampledImageDepthSampleCounts = sampledImageDepthSampleCounts;
      obj.sampledImageStencilSampleCounts = sampledImageStencilSampleCounts;
      obj.storageImageSampleCounts = storageImageSampleCounts;
      obj.maxSampleMaskWords = maxSampleMaskWords;
      obj.timestampComputeAndGraphics = timestampComputeAndGraphics;
      obj.timestampPeriod = timestampPeriod;
      obj.maxClipDistances = maxClipDistances;
      obj.maxCullDistances = maxCullDistances;
      obj.maxCombinedClipAndCullDistances = maxCombinedClipAndCullDistances;
      obj.discreteQueuePriorities = discreteQueuePriorities;
      std::copy(pointSizeRange, pointSizeRange + 2, obj.pointSizeRange);
      std::copy(lineWidthRange, lineWidthRange + 2, obj.lineWidthRange);
      obj.pointSizeGranularity = pointSizeGranularity;
      obj.lineWidthGranularity = lineWidthGranularity;
      obj.strictLines = strictLines;
      obj.standardSampleLocations = standardSampleLocations;
      obj.optimalBufferCopyOffsetAlignment = optimalBufferCopyOffsetAlignment;
      obj.optimalBufferCopyRowPitchAlignment = optimalBufferCopyRowPitchAlignment;
      obj.nonCoherentAtomSize = nonCoherentAtomSize;
      return obj;
   }

VkPhysicalDeviceSparseProperties PhysicalDeviceSparseProperties(
    VkBool32                                    residencyStandard2DBlockShape,
    VkBool32                                    residencyStandard2DMultisampleBlockShape,
    VkBool32                                    residencyStandard3DBlockShape,
    VkBool32                                    residencyAlignedMipSize,
    VkBool32                                    residencyNonResidentStrict)
   {
      VkPhysicalDeviceSparseProperties obj;
      obj.residencyStandard2DBlockShape = residencyStandard2DBlockShape;
      obj.residencyStandard2DMultisampleBlockShape = residencyStandard2DMultisampleBlockShape;
      obj.residencyStandard3DBlockShape = residencyStandard3DBlockShape;
      obj.residencyAlignedMipSize = residencyAlignedMipSize;
      obj.residencyNonResidentStrict = residencyNonResidentStrict;
      return obj;
   }

VkPhysicalDeviceProperties PhysicalDeviceProperties(
    uint32_t                                    apiVersion,
    uint32_t                                    driverVersion,
    uint32_t                                    vendorID,
    uint32_t                                    deviceID,
    VkPhysicalDeviceType                        deviceType,
    char                                        deviceName[VK_MAX_PHYSICAL_DEVICE_NAME_SIZE],
    uint8_t                                     pipelineCacheUUID[VK_UUID_SIZE],
    VkPhysicalDeviceLimits                      limits,
    VkPhysicalDeviceSparseProperties            sparseProperties)
   {
      VkPhysicalDeviceProperties obj;
      obj.apiVersion = apiVersion;
      obj.driverVersion = driverVersion;
      obj.vendorID = vendorID;
      obj.deviceID = deviceID;
      obj.deviceType = deviceType;
      std::copy(deviceName, deviceName + VK_MAX_PHYSICAL_DEVICE_NAME_SIZE, obj.deviceName);
      std::copy(pipelineCacheUUID, pipelineCacheUUID + VK_UUID_SIZE, obj.pipelineCacheUUID);
      obj.limits = limits;
      obj.sparseProperties = sparseProperties;
      return obj;
   }

VkPhysicalDeviceProperties getPhysicalDeviceProperties(
        VkPhysicalDevice physicalDevice)
   {
      VkPhysicalDeviceProperties pProperties; 
      vkGetPhysicalDeviceProperties(
          physicalDevice,
          &pProperties  );
      return pProperties; 
   }

VkQueueFamilyProperties QueueFamilyProperties(
    VkQueueFlags                                queueFlags,
    uint32_t                                    queueCount,
    uint32_t                                    timestampValidBits,
    VkExtent3D                                  minImageTransferGranularity)
   {
      VkQueueFamilyProperties obj;
      obj.queueFlags = queueFlags;
      obj.queueCount = queueCount;
      obj.timestampValidBits = timestampValidBits;
      obj.minImageTransferGranularity = minImageTransferGranularity;
      return obj;
   }

std::vector< VkQueueFamilyProperties > getPhysicalDeviceQueueFamilyProperties(
        VkPhysicalDevice physicalDevice)
   {
      std::vector<VkQueueFamilyProperties> vecpQueueFamilyProperties; 
      uint32_t pQueueFamilyPropertiesCount; 
      vkGetPhysicalDeviceQueueFamilyProperties(
          physicalDevice,
          &pQueueFamilyPropertiesCount,
          nullptr  );

      vecpQueueFamilyProperties.resize(pQueueFamilyPropertiesCount); 

      vkGetPhysicalDeviceQueueFamilyProperties(
          physicalDevice,
          &pQueueFamilyPropertiesCount,
          &vecpQueueFamilyProperties[0]  );
      return vecpQueueFamilyProperties; 
   }

VkMemoryType MemoryType(
    VkMemoryPropertyFlags                       propertyFlags,
    uint32_t                                    heapIndex)
   {
      VkMemoryType obj;
      obj.propertyFlags = propertyFlags;
      obj.heapIndex = heapIndex;
      return obj;
   }

VkMemoryHeap MemoryHeap(
    VkDeviceSize                                size,
    VkMemoryHeapFlags                           flags)
   {
      VkMemoryHeap obj;
      obj.size = size;
      obj.flags = flags;
      return obj;
   }

VkPhysicalDeviceMemoryProperties PhysicalDeviceMemoryProperties(
    uint32_t                                    memoryTypeCount,
    VkMemoryType                                memoryTypes[VK_MAX_MEMORY_TYPES],
    uint32_t                                    memoryHeapCount,
    VkMemoryHeap                                memoryHeaps[VK_MAX_MEMORY_HEAPS])
   {
      VkPhysicalDeviceMemoryProperties obj;
      obj.memoryTypeCount = memoryTypeCount;
      std::copy(memoryTypes, memoryTypes + VK_MAX_MEMORY_TYPES, obj.memoryTypes);
      obj.memoryHeapCount = memoryHeapCount;
      std::copy(memoryHeaps, memoryHeaps + VK_MAX_MEMORY_HEAPS, obj.memoryHeaps);
      return obj;
   }

VkPhysicalDeviceMemoryProperties getPhysicalDeviceMemoryProperties(
        VkPhysicalDevice physicalDevice)
   {
      VkPhysicalDeviceMemoryProperties pMemoryProperties; 
      vkGetPhysicalDeviceMemoryProperties(
          physicalDevice,
          &pMemoryProperties  );
      return pMemoryProperties; 
   }

struct VkDeviceQueueCreateInfoRAII {
   VkDeviceQueueCreateInfo nonRaiiObj;
    std::vector<float>                          vecQueuePriorities;
};

std::shared_ptr<VkDeviceQueueCreateInfoRAII> DeviceQueueCreateInfo(
    VkDeviceQueueCreateFlags                    flags,
    uint32_t                                    queueFamilyIndex,
    float* pQueuePriorities_in_array1, int pQueuePriorities_dim1)
   {
      std::shared_ptr<VkDeviceQueueCreateInfoRAII> raii_obj(new VkDeviceQueueCreateInfoRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.flags = flags;
      raii_obj->nonRaiiObj.queueFamilyIndex = queueFamilyIndex;
      raii_obj->nonRaiiObj.queueCount = static_cast<uint32_t>(pQueuePriorities_dim1);
      raii_obj->vecQueuePriorities.assign(pQueuePriorities_in_array1, pQueuePriorities_in_array1 + pQueuePriorities_dim1);
      if ( raii_obj->vecQueuePriorities.size() > 0)
      {
          raii_obj->nonRaiiObj.pQueuePriorities = &raii_obj->vecQueuePriorities[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pQueuePriorities = nullptr;
      }
      return raii_obj;
   }

struct VkDeviceCreateInfoRAII {
   VkDeviceCreateInfo nonRaiiObj;
    std::vector<VkDeviceQueueCreateInfo>        vecQueueCreateInfos;
    std::vector<std::string>                    vecEnabledLayerNames;
    std::vector<const char *>                   vecPtrEnabledLayerNames;
    std::vector<std::string>                    vecEnabledExtensionNames;
    std::vector<const char *>                   vecPtrEnabledExtensionNames;
    std::shared_ptr<VkPhysicalDeviceFeatures>   pEnabledFeatures;
};

std::shared_ptr<VkDeviceCreateInfoRAII> DeviceCreateInfo(
    VkDeviceCreateFlags                         flags,
    const std::vector<VkDeviceQueueCreateInfo> &vecQueueCreateInfos,
    const std::vector<std::string> &            vecEnabledLayerNames,
    const std::vector<std::string> &            vecEnabledExtensionNames,
    const VkPhysicalDeviceFeatures *            pEnabledFeatures)
   {
      std::shared_ptr<VkDeviceCreateInfoRAII> raii_obj(new VkDeviceCreateInfoRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.flags = flags;
      raii_obj->nonRaiiObj.queueCreateInfoCount = static_cast<uint32_t>(vecQueueCreateInfos.size());
      raii_obj->vecQueueCreateInfos = vecQueueCreateInfos;
      if ( raii_obj->vecQueueCreateInfos.size() > 0)
      {
          raii_obj->nonRaiiObj.pQueueCreateInfos = &raii_obj->vecQueueCreateInfos[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pQueueCreateInfos = nullptr;
      }
      raii_obj->nonRaiiObj.enabledLayerCount = static_cast<uint32_t>(vecEnabledLayerNames.size());
      raii_obj->vecEnabledLayerNames = vecEnabledLayerNames;
      raii_obj->vecPtrEnabledLayerNames.resize(vecEnabledLayerNames.size());
      for (size_t i=0; i<vecEnabledLayerNames.size(); ++i) 
           raii_obj->vecPtrEnabledLayerNames[i] = raii_obj->vecEnabledLayerNames[i].c_str();
      raii_obj->nonRaiiObj.ppEnabledLayerNames = &raii_obj->vecPtrEnabledLayerNames[0];
      raii_obj->nonRaiiObj.enabledExtensionCount = static_cast<uint32_t>(vecEnabledExtensionNames.size());
      raii_obj->vecEnabledExtensionNames = vecEnabledExtensionNames;
      raii_obj->vecPtrEnabledExtensionNames.resize(vecEnabledExtensionNames.size());
      for (size_t i=0; i<vecEnabledExtensionNames.size(); ++i) 
           raii_obj->vecPtrEnabledExtensionNames[i] = raii_obj->vecEnabledExtensionNames[i].c_str();
      raii_obj->nonRaiiObj.ppEnabledExtensionNames = &raii_obj->vecPtrEnabledExtensionNames[0];
      raii_obj->nonRaiiObj.pEnabledFeatures = nullptr;
      if ( pEnabledFeatures ) 
      { 
          raii_obj->pEnabledFeatures.reset( new VkPhysicalDeviceFeatures );
          *raii_obj->pEnabledFeatures = *pEnabledFeatures;
          raii_obj->nonRaiiObj.pEnabledFeatures = raii_obj->pEnabledFeatures.get();
      } 
      return raii_obj;
   }

std::shared_ptr<VkDevice_T> createDevice(
        VkPhysicalDevice physicalDevice,
        const VkDeviceCreateInfo & pCreateInfo)
   {
      VkDevice hDevice; 
      V( vkCreateDevice(
          physicalDevice,
          &pCreateInfo,
          nullptr,
          &hDevice  ));
      return std::shared_ptr<VkDevice_T>(hDevice, 
              [=](VkDevice to_free) {vkDestroyDevice( to_free, nullptr);});
   }

VkExtensionProperties ExtensionProperties(
    char                                        extensionName[VK_MAX_EXTENSION_NAME_SIZE],
    uint32_t                                    specVersion)
   {
      VkExtensionProperties obj;
      std::copy(extensionName, extensionName + VK_MAX_EXTENSION_NAME_SIZE, obj.extensionName);
      obj.specVersion = specVersion;
      return obj;
   }

std::vector< VkExtensionProperties > enumerateInstanceExtensionProperties(
        const char* pLayerName)
   {
      std::vector<VkExtensionProperties> vecpProperties; 
      uint32_t pPropertiesCount; 
      V( vkEnumerateInstanceExtensionProperties(
          pLayerName,
          &pPropertiesCount,
          nullptr  ));

      vecpProperties.resize(pPropertiesCount); 

      V( vkEnumerateInstanceExtensionProperties(
          pLayerName,
          &pPropertiesCount,
          &vecpProperties[0]  ));
      return vecpProperties; 
   }

std::vector< VkExtensionProperties > enumerateDeviceExtensionProperties(
        VkPhysicalDevice physicalDevice,
        const char* pLayerName)
   {
      std::vector<VkExtensionProperties> vecpProperties; 
      uint32_t pPropertiesCount; 
      V( vkEnumerateDeviceExtensionProperties(
          physicalDevice,
          pLayerName,
          &pPropertiesCount,
          nullptr  ));

      vecpProperties.resize(pPropertiesCount); 

      V( vkEnumerateDeviceExtensionProperties(
          physicalDevice,
          pLayerName,
          &pPropertiesCount,
          &vecpProperties[0]  ));
      return vecpProperties; 
   }

VkLayerProperties LayerProperties(
    char                                        layerName[VK_MAX_EXTENSION_NAME_SIZE],
    uint32_t                                    specVersion,
    uint32_t                                    implementationVersion,
    char                                        description[VK_MAX_DESCRIPTION_SIZE])
   {
      VkLayerProperties obj;
      std::copy(layerName, layerName + VK_MAX_EXTENSION_NAME_SIZE, obj.layerName);
      obj.specVersion = specVersion;
      obj.implementationVersion = implementationVersion;
      std::copy(description, description + VK_MAX_DESCRIPTION_SIZE, obj.description);
      return obj;
   }

std::vector< VkLayerProperties > enumerateInstanceLayerProperties(void)
   {
      std::vector<VkLayerProperties> vecpProperties; 
      uint32_t pPropertiesCount; 
      V( vkEnumerateInstanceLayerProperties(
          &pPropertiesCount,
          nullptr  ));

      vecpProperties.resize(pPropertiesCount); 

      V( vkEnumerateInstanceLayerProperties(
          &pPropertiesCount,
          &vecpProperties[0]  ));
      return vecpProperties; 
   }

std::vector< VkLayerProperties > enumerateDeviceLayerProperties(
        VkPhysicalDevice physicalDevice)
   {
      std::vector<VkLayerProperties> vecpProperties; 
      uint32_t pPropertiesCount; 
      V( vkEnumerateDeviceLayerProperties(
          physicalDevice,
          &pPropertiesCount,
          nullptr  ));

      vecpProperties.resize(pPropertiesCount); 

      V( vkEnumerateDeviceLayerProperties(
          physicalDevice,
          &pPropertiesCount,
          &vecpProperties[0]  ));
      return vecpProperties; 
   }

VkQueue getDeviceQueue(
        VkDevice device,
        uint32_t queueFamilyIndex,
        uint32_t queueIndex)
   {
      VkQueue hQueue; 
      vkGetDeviceQueue(
          device,
          queueFamilyIndex,
          queueIndex,
          &hQueue  );
      return hQueue; 
   }

struct VkSubmitInfoRAII {
   VkSubmitInfo nonRaiiObj;
    std::vector<VkSemaphore>                    vecWaitSemaphores;
    std::vector<VkPipelineStageFlags>           vecWaitDstStageMask;
    std::vector<VkCommandBuffer>                vecCommandBuffers;
    std::vector<VkSemaphore>                    vecSignalSemaphores;
};

std::shared_ptr<VkSubmitInfoRAII> SubmitInfo(
    const std::vector<VkSemaphore> &            vecWaitSemaphores,
    const std::vector<VkPipelineStageFlags> &   vecWaitDstStageMask,
    const std::vector<VkCommandBuffer> &        vecCommandBuffers,
    const std::vector<VkSemaphore> &            vecSignalSemaphores)
   {
      std::shared_ptr<VkSubmitInfoRAII> raii_obj(new VkSubmitInfoRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.waitSemaphoreCount = static_cast<uint32_t>(vecWaitSemaphores.size());
      raii_obj->vecWaitSemaphores = vecWaitSemaphores;
      if ( raii_obj->vecWaitSemaphores.size() > 0)
      {
          raii_obj->nonRaiiObj.pWaitSemaphores = &raii_obj->vecWaitSemaphores[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pWaitSemaphores = nullptr;
      }
      raii_obj->vecWaitDstStageMask = vecWaitDstStageMask;
      if ( raii_obj->vecWaitDstStageMask.size() > 0)
      {
          raii_obj->nonRaiiObj.pWaitDstStageMask = &raii_obj->vecWaitDstStageMask[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pWaitDstStageMask = nullptr;
      }
      raii_obj->nonRaiiObj.commandBufferCount = static_cast<uint32_t>(vecCommandBuffers.size());
      raii_obj->vecCommandBuffers = vecCommandBuffers;
      if ( raii_obj->vecCommandBuffers.size() > 0)
      {
          raii_obj->nonRaiiObj.pCommandBuffers = &raii_obj->vecCommandBuffers[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pCommandBuffers = nullptr;
      }
      raii_obj->nonRaiiObj.signalSemaphoreCount = static_cast<uint32_t>(vecSignalSemaphores.size());
      raii_obj->vecSignalSemaphores = vecSignalSemaphores;
      if ( raii_obj->vecSignalSemaphores.size() > 0)
      {
          raii_obj->nonRaiiObj.pSignalSemaphores = &raii_obj->vecSignalSemaphores[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pSignalSemaphores = nullptr;
      }
      return raii_obj;
   }

void  queueSubmit(
        VkQueue queue,
        const std::vector<VkSubmitInfo> & pSubmits,
        VkFence fence)
   {
      V( vkQueueSubmit(
          queue,
          static_cast<uint32_t>(pSubmits.size()),
          &pSubmits[0],
          fence  ));
   }

void  queueWaitIdle(
        VkQueue queue)
   {
      V( vkQueueWaitIdle(
          queue  ));
   }

void  deviceWaitIdle(
        VkDevice device)
   {
      V( vkDeviceWaitIdle(
          device  ));
   }

VkMemoryAllocateInfo MemoryAllocateInfo(
    VkDeviceSize                                allocationSize,
    uint32_t                                    memoryTypeIndex)
   {
      VkMemoryAllocateInfo obj;
      obj.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
      obj.pNext = nullptr;
      obj.allocationSize = allocationSize;
      obj.memoryTypeIndex = memoryTypeIndex;
      return obj;
   }

std::shared_ptr<VkDeviceMemory_T> allocateMemory(
        VkDevice device,
        const VkMemoryAllocateInfo & pAllocateInfo)
   {
      VkDeviceMemory hMemory; 
      V( vkAllocateMemory(
          device,
          &pAllocateInfo,
          nullptr,
          &hMemory  ));
      return std::shared_ptr<VkDeviceMemory_T>(hMemory, 
              [=](VkDeviceMemory to_free) {vkFreeMemory(device, to_free, nullptr);});
   }

void  unmapMemory(
        VkDevice device,
        VkDeviceMemory memory)
   {
      vkUnmapMemory(
          device,
          memory  );
   }

VkMappedMemoryRange MappedMemoryRange(
    VkDeviceMemory                              memory,
    VkDeviceSize                                offset,
    VkDeviceSize                                size)
   {
      VkMappedMemoryRange obj;
      obj.sType = VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE;
      obj.pNext = nullptr;
      obj.memory = memory;
      obj.offset = offset;
      obj.size = size;
      return obj;
   }

void  flushMappedMemoryRanges(
        VkDevice device,
        const std::vector<VkMappedMemoryRange> & pMemoryRanges)
   {
      V( vkFlushMappedMemoryRanges(
          device,
          static_cast<uint32_t>(pMemoryRanges.size()),
          &pMemoryRanges[0]  ));
   }

void  invalidateMappedMemoryRanges(
        VkDevice device,
        const std::vector<VkMappedMemoryRange> & pMemoryRanges)
   {
      V( vkInvalidateMappedMemoryRanges(
          device,
          static_cast<uint32_t>(pMemoryRanges.size()),
          &pMemoryRanges[0]  ));
   }

VkDeviceSize getDeviceMemoryCommitment(
        VkDevice device,
        VkDeviceMemory memory)
   {
      VkDeviceSize pCommittedMemoryInBytes; 
      vkGetDeviceMemoryCommitment(
          device,
          memory,
          &pCommittedMemoryInBytes  );
      return pCommittedMemoryInBytes; 
   }

void  bindBufferMemory(
        VkDevice device,
        VkBuffer buffer,
        VkDeviceMemory memory,
        VkDeviceSize memoryOffset)
   {
      V( vkBindBufferMemory(
          device,
          buffer,
          memory,
          memoryOffset  ));
   }

void  bindImageMemory(
        VkDevice device,
        VkImage image,
        VkDeviceMemory memory,
        VkDeviceSize memoryOffset)
   {
      V( vkBindImageMemory(
          device,
          image,
          memory,
          memoryOffset  ));
   }

VkMemoryRequirements MemoryRequirements(
    VkDeviceSize                                size,
    VkDeviceSize                                alignment,
    uint32_t                                    memoryTypeBits)
   {
      VkMemoryRequirements obj;
      obj.size = size;
      obj.alignment = alignment;
      obj.memoryTypeBits = memoryTypeBits;
      return obj;
   }

VkMemoryRequirements getBufferMemoryRequirements(
        VkDevice device,
        VkBuffer buffer)
   {
      VkMemoryRequirements pMemoryRequirements; 
      vkGetBufferMemoryRequirements(
          device,
          buffer,
          &pMemoryRequirements  );
      return pMemoryRequirements; 
   }

VkMemoryRequirements getImageMemoryRequirements(
        VkDevice device,
        VkImage image)
   {
      VkMemoryRequirements pMemoryRequirements; 
      vkGetImageMemoryRequirements(
          device,
          image,
          &pMemoryRequirements  );
      return pMemoryRequirements; 
   }

VkSparseImageFormatProperties SparseImageFormatProperties(
    VkImageAspectFlags                          aspectMask,
    VkExtent3D                                  imageGranularity,
    VkSparseImageFormatFlags                    flags)
   {
      VkSparseImageFormatProperties obj;
      obj.aspectMask = aspectMask;
      obj.imageGranularity = imageGranularity;
      obj.flags = flags;
      return obj;
   }

VkSparseImageMemoryRequirements SparseImageMemoryRequirements(
    VkSparseImageFormatProperties               formatProperties,
    uint32_t                                    imageMipTailFirstLod,
    VkDeviceSize                                imageMipTailSize,
    VkDeviceSize                                imageMipTailOffset,
    VkDeviceSize                                imageMipTailStride)
   {
      VkSparseImageMemoryRequirements obj;
      obj.formatProperties = formatProperties;
      obj.imageMipTailFirstLod = imageMipTailFirstLod;
      obj.imageMipTailSize = imageMipTailSize;
      obj.imageMipTailOffset = imageMipTailOffset;
      obj.imageMipTailStride = imageMipTailStride;
      return obj;
   }

std::vector< VkSparseImageMemoryRequirements > getImageSparseMemoryRequirements(
        VkDevice device,
        VkImage image)
   {
      std::vector<VkSparseImageMemoryRequirements> vecpSparseMemoryRequirements; 
      uint32_t pSparseMemoryRequirementsCount; 
      vkGetImageSparseMemoryRequirements(
          device,
          image,
          &pSparseMemoryRequirementsCount,
          nullptr  );

      vecpSparseMemoryRequirements.resize(pSparseMemoryRequirementsCount); 

      vkGetImageSparseMemoryRequirements(
          device,
          image,
          &pSparseMemoryRequirementsCount,
          &vecpSparseMemoryRequirements[0]  );
      return vecpSparseMemoryRequirements; 
   }

std::vector< VkSparseImageFormatProperties > getPhysicalDeviceSparseImageFormatProperties(
        VkPhysicalDevice physicalDevice,
        VkFormat format,
        VkImageType type,
        VkSampleCountFlagBits samples,
        VkImageUsageFlags usage,
        VkImageTiling tiling)
   {
      std::vector<VkSparseImageFormatProperties> vecpProperties; 
      uint32_t pPropertiesCount; 
      vkGetPhysicalDeviceSparseImageFormatProperties(
          physicalDevice,
          format,
          type,
          samples,
          usage,
          tiling,
          &pPropertiesCount,
          nullptr  );

      vecpProperties.resize(pPropertiesCount); 

      vkGetPhysicalDeviceSparseImageFormatProperties(
          physicalDevice,
          format,
          type,
          samples,
          usage,
          tiling,
          &pPropertiesCount,
          &vecpProperties[0]  );
      return vecpProperties; 
   }

VkSparseMemoryBind SparseMemoryBind(
    VkDeviceSize                                resourceOffset,
    VkDeviceSize                                size,
    VkDeviceMemory                              memory,
    VkDeviceSize                                memoryOffset,
    VkSparseMemoryBindFlags                     flags)
   {
      VkSparseMemoryBind obj;
      obj.resourceOffset = resourceOffset;
      obj.size = size;
      obj.memory = memory;
      obj.memoryOffset = memoryOffset;
      obj.flags = flags;
      return obj;
   }

struct VkSparseBufferMemoryBindInfoRAII {
   VkSparseBufferMemoryBindInfo nonRaiiObj;
    std::vector<VkSparseMemoryBind>             vecBinds;
};

std::shared_ptr<VkSparseBufferMemoryBindInfoRAII> SparseBufferMemoryBindInfo(
    VkBuffer                                    buffer,
    const std::vector<VkSparseMemoryBind> &     vecBinds)
   {
      std::shared_ptr<VkSparseBufferMemoryBindInfoRAII> raii_obj(new VkSparseBufferMemoryBindInfoRAII);
      raii_obj->nonRaiiObj.buffer = buffer;
      raii_obj->nonRaiiObj.bindCount = static_cast<uint32_t>(vecBinds.size());
      raii_obj->vecBinds = vecBinds;
      if ( raii_obj->vecBinds.size() > 0)
      {
          raii_obj->nonRaiiObj.pBinds = &raii_obj->vecBinds[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pBinds = nullptr;
      }
      return raii_obj;
   }

struct VkSparseImageOpaqueMemoryBindInfoRAII {
   VkSparseImageOpaqueMemoryBindInfo nonRaiiObj;
    std::vector<VkSparseMemoryBind>             vecBinds;
};

std::shared_ptr<VkSparseImageOpaqueMemoryBindInfoRAII> SparseImageOpaqueMemoryBindInfo(
    VkImage                                     image,
    const std::vector<VkSparseMemoryBind> &     vecBinds)
   {
      std::shared_ptr<VkSparseImageOpaqueMemoryBindInfoRAII> raii_obj(new VkSparseImageOpaqueMemoryBindInfoRAII);
      raii_obj->nonRaiiObj.image = image;
      raii_obj->nonRaiiObj.bindCount = static_cast<uint32_t>(vecBinds.size());
      raii_obj->vecBinds = vecBinds;
      if ( raii_obj->vecBinds.size() > 0)
      {
          raii_obj->nonRaiiObj.pBinds = &raii_obj->vecBinds[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pBinds = nullptr;
      }
      return raii_obj;
   }

VkImageSubresource ImageSubresource(
    VkImageAspectFlags                          aspectMask,
    uint32_t                                    mipLevel,
    uint32_t                                    arrayLayer)
   {
      VkImageSubresource obj;
      obj.aspectMask = aspectMask;
      obj.mipLevel = mipLevel;
      obj.arrayLayer = arrayLayer;
      return obj;
   }

VkOffset3D Offset3D(
    int32_t                                     x,
    int32_t                                     y,
    int32_t                                     z)
   {
      VkOffset3D obj;
      obj.x = x;
      obj.y = y;
      obj.z = z;
      return obj;
   }

VkSparseImageMemoryBind SparseImageMemoryBind(
    VkImageSubresource                          subresource,
    VkOffset3D                                  offset,
    VkExtent3D                                  extent,
    VkDeviceMemory                              memory,
    VkDeviceSize                                memoryOffset,
    VkSparseMemoryBindFlags                     flags)
   {
      VkSparseImageMemoryBind obj;
      obj.subresource = subresource;
      obj.offset = offset;
      obj.extent = extent;
      obj.memory = memory;
      obj.memoryOffset = memoryOffset;
      obj.flags = flags;
      return obj;
   }

struct VkSparseImageMemoryBindInfoRAII {
   VkSparseImageMemoryBindInfo nonRaiiObj;
    std::vector<VkSparseImageMemoryBind>        vecBinds;
};

std::shared_ptr<VkSparseImageMemoryBindInfoRAII> SparseImageMemoryBindInfo(
    VkImage                                     image,
    const std::vector<VkSparseImageMemoryBind> &vecBinds)
   {
      std::shared_ptr<VkSparseImageMemoryBindInfoRAII> raii_obj(new VkSparseImageMemoryBindInfoRAII);
      raii_obj->nonRaiiObj.image = image;
      raii_obj->nonRaiiObj.bindCount = static_cast<uint32_t>(vecBinds.size());
      raii_obj->vecBinds = vecBinds;
      if ( raii_obj->vecBinds.size() > 0)
      {
          raii_obj->nonRaiiObj.pBinds = &raii_obj->vecBinds[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pBinds = nullptr;
      }
      return raii_obj;
   }

struct VkBindSparseInfoRAII {
   VkBindSparseInfo nonRaiiObj;
    std::vector<VkSemaphore>                    vecWaitSemaphores;
    std::vector<VkSparseBufferMemoryBindInfo>   vecBufferBinds;
    std::vector<VkSparseImageOpaqueMemoryBindInfo>vecImageOpaqueBinds;
    std::vector<VkSparseImageMemoryBindInfo>    vecImageBinds;
    std::vector<VkSemaphore>                    vecSignalSemaphores;
};

std::shared_ptr<VkBindSparseInfoRAII> BindSparseInfo(
    const std::vector<VkSemaphore> &            vecWaitSemaphores,
    const std::vector<VkSparseBufferMemoryBindInfo> &vecBufferBinds,
    const std::vector<VkSparseImageOpaqueMemoryBindInfo> &vecImageOpaqueBinds,
    const std::vector<VkSparseImageMemoryBindInfo> &vecImageBinds,
    const std::vector<VkSemaphore> &            vecSignalSemaphores)
   {
      std::shared_ptr<VkBindSparseInfoRAII> raii_obj(new VkBindSparseInfoRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_BIND_SPARSE_INFO;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.waitSemaphoreCount = static_cast<uint32_t>(vecWaitSemaphores.size());
      raii_obj->vecWaitSemaphores = vecWaitSemaphores;
      if ( raii_obj->vecWaitSemaphores.size() > 0)
      {
          raii_obj->nonRaiiObj.pWaitSemaphores = &raii_obj->vecWaitSemaphores[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pWaitSemaphores = nullptr;
      }
      raii_obj->nonRaiiObj.bufferBindCount = static_cast<uint32_t>(vecBufferBinds.size());
      raii_obj->vecBufferBinds = vecBufferBinds;
      if ( raii_obj->vecBufferBinds.size() > 0)
      {
          raii_obj->nonRaiiObj.pBufferBinds = &raii_obj->vecBufferBinds[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pBufferBinds = nullptr;
      }
      raii_obj->nonRaiiObj.imageOpaqueBindCount = static_cast<uint32_t>(vecImageOpaqueBinds.size());
      raii_obj->vecImageOpaqueBinds = vecImageOpaqueBinds;
      if ( raii_obj->vecImageOpaqueBinds.size() > 0)
      {
          raii_obj->nonRaiiObj.pImageOpaqueBinds = &raii_obj->vecImageOpaqueBinds[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pImageOpaqueBinds = nullptr;
      }
      raii_obj->nonRaiiObj.imageBindCount = static_cast<uint32_t>(vecImageBinds.size());
      raii_obj->vecImageBinds = vecImageBinds;
      if ( raii_obj->vecImageBinds.size() > 0)
      {
          raii_obj->nonRaiiObj.pImageBinds = &raii_obj->vecImageBinds[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pImageBinds = nullptr;
      }
      raii_obj->nonRaiiObj.signalSemaphoreCount = static_cast<uint32_t>(vecSignalSemaphores.size());
      raii_obj->vecSignalSemaphores = vecSignalSemaphores;
      if ( raii_obj->vecSignalSemaphores.size() > 0)
      {
          raii_obj->nonRaiiObj.pSignalSemaphores = &raii_obj->vecSignalSemaphores[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pSignalSemaphores = nullptr;
      }
      return raii_obj;
   }

void  queueBindSparse(
        VkQueue queue,
        const std::vector<VkBindSparseInfo> & pBindInfo,
        VkFence fence)
   {
      V( vkQueueBindSparse(
          queue,
          static_cast<uint32_t>(pBindInfo.size()),
          &pBindInfo[0],
          fence  ));
   }

VkFenceCreateInfo FenceCreateInfo(
    VkFenceCreateFlags                          flags)
   {
      VkFenceCreateInfo obj;
      obj.sType = VK_STRUCTURE_TYPE_FENCE_CREATE_INFO;
      obj.pNext = nullptr;
      obj.flags = flags;
      return obj;
   }

std::shared_ptr<VkFence_T> createFence(
        VkDevice device,
        const VkFenceCreateInfo & pCreateInfo)
   {
      VkFence hFence; 
      V( vkCreateFence(
          device,
          &pCreateInfo,
          nullptr,
          &hFence  ));
      return std::shared_ptr<VkFence_T>(hFence, 
              [=](VkFence to_free) {vkDestroyFence(device, to_free, nullptr);});
   }

void  resetFences(
        VkDevice device,
        const std::vector<VkFence> & pFences)
   {
      V( vkResetFences(
          device,
          static_cast<uint32_t>(pFences.size()),
          &pFences[0]  ));
   }

void  getFenceStatus(
        VkDevice device,
        VkFence fence)
   {
      V( vkGetFenceStatus(
          device,
          fence  ));
   }

void  waitForFences(
        VkDevice device,
        const std::vector<VkFence> & pFences,
        VkBool32 waitAll,
        uint64_t timeout)
   {
      V( vkWaitForFences(
          device,
          static_cast<uint32_t>(pFences.size()),
          &pFences[0],
          waitAll,
          timeout  ));
   }

VkSemaphoreCreateInfo SemaphoreCreateInfo(
    VkSemaphoreCreateFlags                      flags)
   {
      VkSemaphoreCreateInfo obj;
      obj.sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO;
      obj.pNext = nullptr;
      obj.flags = flags;
      return obj;
   }

std::shared_ptr<VkSemaphore_T> createSemaphore(
        VkDevice device,
        const VkSemaphoreCreateInfo & pCreateInfo)
   {
      VkSemaphore hSemaphore; 
      V( vkCreateSemaphore(
          device,
          &pCreateInfo,
          nullptr,
          &hSemaphore  ));
      return std::shared_ptr<VkSemaphore_T>(hSemaphore, 
              [=](VkSemaphore to_free) {vkDestroySemaphore(device, to_free, nullptr);});
   }

VkEventCreateInfo EventCreateInfo(
    VkEventCreateFlags                          flags)
   {
      VkEventCreateInfo obj;
      obj.sType = VK_STRUCTURE_TYPE_EVENT_CREATE_INFO;
      obj.pNext = nullptr;
      obj.flags = flags;
      return obj;
   }

std::shared_ptr<VkEvent_T> createEvent(
        VkDevice device,
        const VkEventCreateInfo & pCreateInfo)
   {
      VkEvent hEvent; 
      V( vkCreateEvent(
          device,
          &pCreateInfo,
          nullptr,
          &hEvent  ));
      return std::shared_ptr<VkEvent_T>(hEvent, 
              [=](VkEvent to_free) {vkDestroyEvent(device, to_free, nullptr);});
   }

void  getEventStatus(
        VkDevice device,
        VkEvent event)
   {
      V( vkGetEventStatus(
          device,
          event  ));
   }

void  setEvent(
        VkDevice device,
        VkEvent event)
   {
      V( vkSetEvent(
          device,
          event  ));
   }

void  resetEvent(
        VkDevice device,
        VkEvent event)
   {
      V( vkResetEvent(
          device,
          event  ));
   }

VkQueryPoolCreateInfo QueryPoolCreateInfo(
    VkQueryPoolCreateFlags                      flags,
    VkQueryType                                 queryType,
    uint32_t                                    queryCount,
    VkQueryPipelineStatisticFlags               pipelineStatistics)
   {
      VkQueryPoolCreateInfo obj;
      obj.sType = VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO;
      obj.pNext = nullptr;
      obj.flags = flags;
      obj.queryType = queryType;
      obj.queryCount = queryCount;
      obj.pipelineStatistics = pipelineStatistics;
      return obj;
   }

std::shared_ptr<VkQueryPool_T> createQueryPool(
        VkDevice device,
        const VkQueryPoolCreateInfo & pCreateInfo)
   {
      VkQueryPool hQueryPool; 
      V( vkCreateQueryPool(
          device,
          &pCreateInfo,
          nullptr,
          &hQueryPool  ));
      return std::shared_ptr<VkQueryPool_T>(hQueryPool, 
              [=](VkQueryPool to_free) {vkDestroyQueryPool(device, to_free, nullptr);});
   }

void  getQueryPoolResults(
        VkDevice device,
        VkQueryPool queryPool,
        uint32_t firstQuery,
        uint32_t queryCount,
        size_t dataSize,
        VkDeviceSize stride,
        VkQueryResultFlags flags)
   {
      V( vkGetQueryPoolResults(
          device,
          queryPool,
          firstQuery,
          queryCount,
          dataSize,
          nullptr,
          stride,
          flags  ));
   }

struct VkBufferCreateInfoRAII {
   VkBufferCreateInfo nonRaiiObj;
    std::vector<uint32_t>                       vecQueueFamilyIndices;
};

std::shared_ptr<VkBufferCreateInfoRAII> BufferCreateInfo(
    VkBufferCreateFlags                         flags,
    VkDeviceSize                                size,
    VkBufferUsageFlags                          usage,
    VkSharingMode                               sharingMode,
    unsigned int* pQueueFamilyIndices_in_array1, int pQueueFamilyIndices_dim1)
   {
      std::shared_ptr<VkBufferCreateInfoRAII> raii_obj(new VkBufferCreateInfoRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.flags = flags;
      raii_obj->nonRaiiObj.size = size;
      raii_obj->nonRaiiObj.usage = usage;
      raii_obj->nonRaiiObj.sharingMode = sharingMode;
      raii_obj->nonRaiiObj.queueFamilyIndexCount = static_cast<uint32_t>(pQueueFamilyIndices_dim1);
      raii_obj->vecQueueFamilyIndices.assign(pQueueFamilyIndices_in_array1, pQueueFamilyIndices_in_array1 + pQueueFamilyIndices_dim1);
      if ( raii_obj->vecQueueFamilyIndices.size() > 0)
      {
          raii_obj->nonRaiiObj.pQueueFamilyIndices = &raii_obj->vecQueueFamilyIndices[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pQueueFamilyIndices = nullptr;
      }
      return raii_obj;
   }

std::shared_ptr<VkBuffer_T> createBuffer(
        VkDevice device,
        const VkBufferCreateInfo & pCreateInfo)
   {
      VkBuffer hBuffer; 
      V( vkCreateBuffer(
          device,
          &pCreateInfo,
          nullptr,
          &hBuffer  ));
      return std::shared_ptr<VkBuffer_T>(hBuffer, 
              [=](VkBuffer to_free) {vkDestroyBuffer(device, to_free, nullptr);});
   }

VkBufferViewCreateInfo BufferViewCreateInfo(
    VkBufferViewCreateFlags                     flags,
    VkBuffer                                    buffer,
    VkFormat                                    format,
    VkDeviceSize                                offset,
    VkDeviceSize                                range)
   {
      VkBufferViewCreateInfo obj;
      obj.sType = VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO;
      obj.pNext = nullptr;
      obj.flags = flags;
      obj.buffer = buffer;
      obj.format = format;
      obj.offset = offset;
      obj.range = range;
      return obj;
   }

std::shared_ptr<VkBufferView_T> createBufferView(
        VkDevice device,
        const VkBufferViewCreateInfo & pCreateInfo)
   {
      VkBufferView hView; 
      V( vkCreateBufferView(
          device,
          &pCreateInfo,
          nullptr,
          &hView  ));
      return std::shared_ptr<VkBufferView_T>(hView, 
              [=](VkBufferView to_free) {vkDestroyBufferView(device, to_free, nullptr);});
   }

struct VkImageCreateInfoRAII {
   VkImageCreateInfo nonRaiiObj;
    std::vector<uint32_t>                       vecQueueFamilyIndices;
};

std::shared_ptr<VkImageCreateInfoRAII> ImageCreateInfo(
    VkImageCreateFlags                          flags,
    VkImageType                                 imageType,
    VkFormat                                    format,
    VkExtent3D                                  extent,
    uint32_t                                    mipLevels,
    uint32_t                                    arrayLayers,
    VkSampleCountFlagBits                       samples,
    VkImageTiling                               tiling,
    VkImageUsageFlags                           usage,
    VkSharingMode                               sharingMode,
    unsigned int* pQueueFamilyIndices_in_array1, int pQueueFamilyIndices_dim1,
    VkImageLayout                               initialLayout)
   {
      std::shared_ptr<VkImageCreateInfoRAII> raii_obj(new VkImageCreateInfoRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.flags = flags;
      raii_obj->nonRaiiObj.imageType = imageType;
      raii_obj->nonRaiiObj.format = format;
      raii_obj->nonRaiiObj.extent = extent;
      raii_obj->nonRaiiObj.mipLevels = mipLevels;
      raii_obj->nonRaiiObj.arrayLayers = arrayLayers;
      raii_obj->nonRaiiObj.samples = samples;
      raii_obj->nonRaiiObj.tiling = tiling;
      raii_obj->nonRaiiObj.usage = usage;
      raii_obj->nonRaiiObj.sharingMode = sharingMode;
      raii_obj->nonRaiiObj.queueFamilyIndexCount = static_cast<uint32_t>(pQueueFamilyIndices_dim1);
      raii_obj->vecQueueFamilyIndices.assign(pQueueFamilyIndices_in_array1, pQueueFamilyIndices_in_array1 + pQueueFamilyIndices_dim1);
      if ( raii_obj->vecQueueFamilyIndices.size() > 0)
      {
          raii_obj->nonRaiiObj.pQueueFamilyIndices = &raii_obj->vecQueueFamilyIndices[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pQueueFamilyIndices = nullptr;
      }
      raii_obj->nonRaiiObj.initialLayout = initialLayout;
      return raii_obj;
   }

std::shared_ptr<VkImage_T> createImage(
        VkDevice device,
        const VkImageCreateInfo & pCreateInfo)
   {
      VkImage hImage; 
      V( vkCreateImage(
          device,
          &pCreateInfo,
          nullptr,
          &hImage  ));
      return std::shared_ptr<VkImage_T>(hImage, 
              [=](VkImage to_free) {vkDestroyImage(device, to_free, nullptr);});
   }

VkSubresourceLayout SubresourceLayout(
    VkDeviceSize                                offset,
    VkDeviceSize                                size,
    VkDeviceSize                                rowPitch,
    VkDeviceSize                                arrayPitch,
    VkDeviceSize                                depthPitch)
   {
      VkSubresourceLayout obj;
      obj.offset = offset;
      obj.size = size;
      obj.rowPitch = rowPitch;
      obj.arrayPitch = arrayPitch;
      obj.depthPitch = depthPitch;
      return obj;
   }

VkSubresourceLayout getImageSubresourceLayout(
        VkDevice device,
        VkImage image,
        const VkImageSubresource & pSubresource)
   {
      VkSubresourceLayout pLayout; 
      vkGetImageSubresourceLayout(
          device,
          image,
          &pSubresource,
          &pLayout  );
      return pLayout; 
   }

VkComponentMapping ComponentMapping(
    VkComponentSwizzle                          r,
    VkComponentSwizzle                          g,
    VkComponentSwizzle                          b,
    VkComponentSwizzle                          a)
   {
      VkComponentMapping obj;
      obj.r = r;
      obj.g = g;
      obj.b = b;
      obj.a = a;
      return obj;
   }

VkImageSubresourceRange ImageSubresourceRange(
    VkImageAspectFlags                          aspectMask,
    uint32_t                                    baseMipLevel,
    uint32_t                                    levelCount,
    uint32_t                                    baseArrayLayer,
    uint32_t                                    layerCount)
   {
      VkImageSubresourceRange obj;
      obj.aspectMask = aspectMask;
      obj.baseMipLevel = baseMipLevel;
      obj.levelCount = levelCount;
      obj.baseArrayLayer = baseArrayLayer;
      obj.layerCount = layerCount;
      return obj;
   }

VkImageViewCreateInfo ImageViewCreateInfo(
    VkImageViewCreateFlags                      flags,
    VkImage                                     image,
    VkImageViewType                             viewType,
    VkFormat                                    format,
    VkComponentMapping                          components,
    VkImageSubresourceRange                     subresourceRange)
   {
      VkImageViewCreateInfo obj;
      obj.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO;
      obj.pNext = nullptr;
      obj.flags = flags;
      obj.image = image;
      obj.viewType = viewType;
      obj.format = format;
      obj.components = components;
      obj.subresourceRange = subresourceRange;
      return obj;
   }

std::shared_ptr<VkImageView_T> createImageView(
        VkDevice device,
        const VkImageViewCreateInfo & pCreateInfo)
   {
      VkImageView hView; 
      V( vkCreateImageView(
          device,
          &pCreateInfo,
          nullptr,
          &hView  ));
      return std::shared_ptr<VkImageView_T>(hView, 
              [=](VkImageView to_free) {vkDestroyImageView(device, to_free, nullptr);});
   }

struct VkShaderModuleCreateInfoRAII {
   VkShaderModuleCreateInfo nonRaiiObj;
    std::vector<uint32_t>                       vecCode;
};

std::shared_ptr<VkShaderModuleCreateInfoRAII> ShaderModuleCreateInfo(
    VkShaderModuleCreateFlags                   flags,
    unsigned int* pCode_in_array1, int pCode_dim1)
   {
      std::shared_ptr<VkShaderModuleCreateInfoRAII> raii_obj(new VkShaderModuleCreateInfoRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.flags = flags;
      raii_obj->nonRaiiObj.codeSize = static_cast<size_t>(pCode_dim1) * sizeof(unsigned int);
      raii_obj->vecCode.assign(pCode_in_array1, pCode_in_array1 + pCode_dim1);
      if ( raii_obj->vecCode.size() > 0)
      {
          raii_obj->nonRaiiObj.pCode = &raii_obj->vecCode[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pCode = nullptr;
      }
      return raii_obj;
   }

std::shared_ptr<VkShaderModule_T> createShaderModule(
        VkDevice device,
        const VkShaderModuleCreateInfo & pCreateInfo)
   {
      VkShaderModule hShaderModule; 
      V( vkCreateShaderModule(
          device,
          &pCreateInfo,
          nullptr,
          &hShaderModule  ));
      return std::shared_ptr<VkShaderModule_T>(hShaderModule, 
              [=](VkShaderModule to_free) {vkDestroyShaderModule(device, to_free, nullptr);});
   }

struct VkPipelineCacheCreateInfoRAII {
   VkPipelineCacheCreateInfo nonRaiiObj;
    std::vector<uint8_t>                        vecInitialData;
};

std::shared_ptr<VkPipelineCacheCreateInfoRAII> PipelineCacheCreateInfo(
    VkPipelineCacheCreateFlags                  flags,
    const std::vector<uint8_t> &                vecInitialData)
   {
      std::shared_ptr<VkPipelineCacheCreateInfoRAII> raii_obj(new VkPipelineCacheCreateInfoRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.flags = flags;
      raii_obj->nonRaiiObj.initialDataSize = static_cast<size_t>(vecInitialData.size());
      raii_obj->vecInitialData = vecInitialData;
      if ( raii_obj->vecInitialData.size() > 0)
      {
          raii_obj->nonRaiiObj.pInitialData = &raii_obj->vecInitialData[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pInitialData = nullptr;
      }
      return raii_obj;
   }

std::shared_ptr<VkPipelineCache_T> createPipelineCache(
        VkDevice device,
        const VkPipelineCacheCreateInfo & pCreateInfo)
   {
      VkPipelineCache hPipelineCache; 
      V( vkCreatePipelineCache(
          device,
          &pCreateInfo,
          nullptr,
          &hPipelineCache  ));
      return std::shared_ptr<VkPipelineCache_T>(hPipelineCache, 
              [=](VkPipelineCache to_free) {vkDestroyPipelineCache(device, to_free, nullptr);});
   }

size_t getPipelineCacheData(
        VkDevice device,
        VkPipelineCache pipelineCache)
   {
      size_t pDataSize; 
      V( vkGetPipelineCacheData(
          device,
          pipelineCache,
          &pDataSize,
          nullptr  ));
      return pDataSize; 
   }

void  mergePipelineCaches(
        VkDevice device,
        VkPipelineCache dstCache,
        const std::vector<VkPipelineCache> & pSrcCaches)
   {
      V( vkMergePipelineCaches(
          device,
          dstCache,
          static_cast<uint32_t>(pSrcCaches.size()),
          &pSrcCaches[0]  ));
   }

VkSpecializationMapEntry SpecializationMapEntry(
    uint32_t                                    constantID,
    uint32_t                                    offset,
    size_t                                      size)
   {
      VkSpecializationMapEntry obj;
      obj.constantID = constantID;
      obj.offset = offset;
      obj.size = size;
      return obj;
   }

struct VkSpecializationInfoRAII {
   VkSpecializationInfo nonRaiiObj;
    std::vector<VkSpecializationMapEntry>       vecMapEntries;
    std::vector<uint8_t>                        vecData;
};

std::shared_ptr<VkSpecializationInfoRAII> SpecializationInfo(
    const std::vector<VkSpecializationMapEntry> &vecMapEntries,
    const std::vector<uint8_t> &                vecData)
   {
      std::shared_ptr<VkSpecializationInfoRAII> raii_obj(new VkSpecializationInfoRAII);
      raii_obj->nonRaiiObj.mapEntryCount = static_cast<uint32_t>(vecMapEntries.size());
      raii_obj->vecMapEntries = vecMapEntries;
      if ( raii_obj->vecMapEntries.size() > 0)
      {
          raii_obj->nonRaiiObj.pMapEntries = &raii_obj->vecMapEntries[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pMapEntries = nullptr;
      }
      raii_obj->nonRaiiObj.dataSize = static_cast<size_t>(vecData.size());
      raii_obj->vecData = vecData;
      if ( raii_obj->vecData.size() > 0)
      {
          raii_obj->nonRaiiObj.pData = &raii_obj->vecData[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pData = nullptr;
      }
      return raii_obj;
   }

struct VkPipelineShaderStageCreateInfoRAII {
   VkPipelineShaderStageCreateInfo nonRaiiObj;
    std::string                                 strName;
    std::shared_ptr<VkSpecializationInfoRAII>   pSpecializationInfo;
};

std::shared_ptr<VkPipelineShaderStageCreateInfoRAII> PipelineShaderStageCreateInfo(
    VkPipelineShaderStageCreateFlags            flags,
    VkShaderStageFlagBits                       stage,
    VkShaderModule                              module,
    const std::string &                         strName,
    const std::shared_ptr<VkSpecializationInfoRAII> &pSpecializationInfo)
   {
      std::shared_ptr<VkPipelineShaderStageCreateInfoRAII> raii_obj(new VkPipelineShaderStageCreateInfoRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.flags = flags;
      raii_obj->nonRaiiObj.stage = stage;
      raii_obj->nonRaiiObj.module = module;
      raii_obj->strName = strName;
      raii_obj->nonRaiiObj.pName = &raii_obj->strName[0];
      raii_obj->pSpecializationInfo = pSpecializationInfo;
      if ( pSpecializationInfo ) 
      {
          raii_obj->nonRaiiObj.pSpecializationInfo = &(pSpecializationInfo->nonRaiiObj);
      }
      else
      {
          raii_obj->nonRaiiObj.pSpecializationInfo = nullptr;
      }
      return raii_obj;
   }

VkVertexInputBindingDescription VertexInputBindingDescription(
    uint32_t                                    binding,
    uint32_t                                    stride,
    VkVertexInputRate                           inputRate)
   {
      VkVertexInputBindingDescription obj;
      obj.binding = binding;
      obj.stride = stride;
      obj.inputRate = inputRate;
      return obj;
   }

VkVertexInputAttributeDescription VertexInputAttributeDescription(
    uint32_t                                    location,
    uint32_t                                    binding,
    VkFormat                                    format,
    uint32_t                                    offset)
   {
      VkVertexInputAttributeDescription obj;
      obj.location = location;
      obj.binding = binding;
      obj.format = format;
      obj.offset = offset;
      return obj;
   }

struct VkPipelineVertexInputStateCreateInfoRAII {
   VkPipelineVertexInputStateCreateInfo nonRaiiObj;
    std::vector<VkVertexInputBindingDescription>vecVertexBindingDescriptions;
    std::vector<VkVertexInputAttributeDescription>vecVertexAttributeDescriptions;
};

std::shared_ptr<VkPipelineVertexInputStateCreateInfoRAII> PipelineVertexInputStateCreateInfo(
    VkPipelineVertexInputStateCreateFlags       flags,
    const std::vector<VkVertexInputBindingDescription> &vecVertexBindingDescriptions,
    const std::vector<VkVertexInputAttributeDescription> &vecVertexAttributeDescriptions)
   {
      std::shared_ptr<VkPipelineVertexInputStateCreateInfoRAII> raii_obj(new VkPipelineVertexInputStateCreateInfoRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.flags = flags;
      raii_obj->nonRaiiObj.vertexBindingDescriptionCount = static_cast<uint32_t>(vecVertexBindingDescriptions.size());
      raii_obj->vecVertexBindingDescriptions = vecVertexBindingDescriptions;
      if ( raii_obj->vecVertexBindingDescriptions.size() > 0)
      {
          raii_obj->nonRaiiObj.pVertexBindingDescriptions = &raii_obj->vecVertexBindingDescriptions[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pVertexBindingDescriptions = nullptr;
      }
      raii_obj->nonRaiiObj.vertexAttributeDescriptionCount = static_cast<uint32_t>(vecVertexAttributeDescriptions.size());
      raii_obj->vecVertexAttributeDescriptions = vecVertexAttributeDescriptions;
      if ( raii_obj->vecVertexAttributeDescriptions.size() > 0)
      {
          raii_obj->nonRaiiObj.pVertexAttributeDescriptions = &raii_obj->vecVertexAttributeDescriptions[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pVertexAttributeDescriptions = nullptr;
      }
      return raii_obj;
   }

VkPipelineInputAssemblyStateCreateInfo PipelineInputAssemblyStateCreateInfo(
    VkPipelineInputAssemblyStateCreateFlags     flags,
    VkPrimitiveTopology                         topology,
    VkBool32                                    primitiveRestartEnable)
   {
      VkPipelineInputAssemblyStateCreateInfo obj;
      obj.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
      obj.pNext = nullptr;
      obj.flags = flags;
      obj.topology = topology;
      obj.primitiveRestartEnable = primitiveRestartEnable;
      return obj;
   }

VkPipelineTessellationStateCreateInfo PipelineTessellationStateCreateInfo(
    VkPipelineTessellationStateCreateFlags      flags,
    uint32_t                                    patchControlPoints)
   {
      VkPipelineTessellationStateCreateInfo obj;
      obj.sType = VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO;
      obj.pNext = nullptr;
      obj.flags = flags;
      obj.patchControlPoints = patchControlPoints;
      return obj;
   }

VkViewport Viewport(
    float                                       x,
    float                                       y,
    float                                       width,
    float                                       height,
    float                                       minDepth,
    float                                       maxDepth)
   {
      VkViewport obj;
      obj.x = x;
      obj.y = y;
      obj.width = width;
      obj.height = height;
      obj.minDepth = minDepth;
      obj.maxDepth = maxDepth;
      return obj;
   }

VkOffset2D Offset2D(
    int32_t                                     x,
    int32_t                                     y)
   {
      VkOffset2D obj;
      obj.x = x;
      obj.y = y;
      return obj;
   }

VkExtent2D Extent2D(
    uint32_t                                    width,
    uint32_t                                    height)
   {
      VkExtent2D obj;
      obj.width = width;
      obj.height = height;
      return obj;
   }

VkRect2D Rect2D(
    VkOffset2D                                  offset,
    VkExtent2D                                  extent)
   {
      VkRect2D obj;
      obj.offset = offset;
      obj.extent = extent;
      return obj;
   }

struct VkPipelineViewportStateCreateInfoRAII {
   VkPipelineViewportStateCreateInfo nonRaiiObj;
    std::vector<VkViewport>                     vecViewports;
    std::vector<VkRect2D>                       vecScissors;
};

std::shared_ptr<VkPipelineViewportStateCreateInfoRAII> PipelineViewportStateCreateInfo(
    VkPipelineViewportStateCreateFlags          flags,
    const std::vector<VkViewport> &             vecViewports,
    const std::vector<VkRect2D> &               vecScissors)
   {
      std::shared_ptr<VkPipelineViewportStateCreateInfoRAII> raii_obj(new VkPipelineViewportStateCreateInfoRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.flags = flags;
      raii_obj->nonRaiiObj.viewportCount = static_cast<uint32_t>(vecViewports.size());
      raii_obj->vecViewports = vecViewports;
      if ( raii_obj->vecViewports.size() > 0)
      {
          raii_obj->nonRaiiObj.pViewports = &raii_obj->vecViewports[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pViewports = nullptr;
      }
      raii_obj->nonRaiiObj.scissorCount = static_cast<uint32_t>(vecScissors.size());
      raii_obj->vecScissors = vecScissors;
      if ( raii_obj->vecScissors.size() > 0)
      {
          raii_obj->nonRaiiObj.pScissors = &raii_obj->vecScissors[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pScissors = nullptr;
      }
      return raii_obj;
   }

VkPipelineRasterizationStateCreateInfo PipelineRasterizationStateCreateInfo(
    VkPipelineRasterizationStateCreateFlags     flags,
    VkBool32                                    depthClampEnable,
    VkBool32                                    rasterizerDiscardEnable,
    VkPolygonMode                               polygonMode,
    VkCullModeFlags                             cullMode,
    VkFrontFace                                 frontFace,
    VkBool32                                    depthBiasEnable,
    float                                       depthBiasConstantFactor,
    float                                       depthBiasClamp,
    float                                       depthBiasSlopeFactor,
    float                                       lineWidth)
   {
      VkPipelineRasterizationStateCreateInfo obj;
      obj.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
      obj.pNext = nullptr;
      obj.flags = flags;
      obj.depthClampEnable = depthClampEnable;
      obj.rasterizerDiscardEnable = rasterizerDiscardEnable;
      obj.polygonMode = polygonMode;
      obj.cullMode = cullMode;
      obj.frontFace = frontFace;
      obj.depthBiasEnable = depthBiasEnable;
      obj.depthBiasConstantFactor = depthBiasConstantFactor;
      obj.depthBiasClamp = depthBiasClamp;
      obj.depthBiasSlopeFactor = depthBiasSlopeFactor;
      obj.lineWidth = lineWidth;
      return obj;
   }

VkPipelineMultisampleStateCreateInfo PipelineMultisampleStateCreateInfo(
    VkPipelineMultisampleStateCreateFlags       flags,
    VkSampleCountFlagBits                       rasterizationSamples,
    VkBool32                                    sampleShadingEnable,
    float                                       minSampleShading,
    const VkSampleMask*                         pSampleMask,
    VkBool32                                    alphaToCoverageEnable,
    VkBool32                                    alphaToOneEnable)
   {
      VkPipelineMultisampleStateCreateInfo obj;
      obj.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
      obj.pNext = nullptr;
      obj.flags = flags;
      obj.rasterizationSamples = rasterizationSamples;
      obj.sampleShadingEnable = sampleShadingEnable;
      obj.minSampleShading = minSampleShading;
      obj.pSampleMask = pSampleMask;
      obj.alphaToCoverageEnable = alphaToCoverageEnable;
      obj.alphaToOneEnable = alphaToOneEnable;
      return obj;
   }

VkStencilOpState StencilOpState(
    VkStencilOp                                 failOp,
    VkStencilOp                                 passOp,
    VkStencilOp                                 depthFailOp,
    VkCompareOp                                 compareOp,
    uint32_t                                    compareMask,
    uint32_t                                    writeMask,
    uint32_t                                    reference)
   {
      VkStencilOpState obj;
      obj.failOp = failOp;
      obj.passOp = passOp;
      obj.depthFailOp = depthFailOp;
      obj.compareOp = compareOp;
      obj.compareMask = compareMask;
      obj.writeMask = writeMask;
      obj.reference = reference;
      return obj;
   }

VkPipelineDepthStencilStateCreateInfo PipelineDepthStencilStateCreateInfo(
    VkPipelineDepthStencilStateCreateFlags      flags,
    VkBool32                                    depthTestEnable,
    VkBool32                                    depthWriteEnable,
    VkCompareOp                                 depthCompareOp,
    VkBool32                                    depthBoundsTestEnable,
    VkBool32                                    stencilTestEnable,
    VkStencilOpState                            front,
    VkStencilOpState                            back,
    float                                       minDepthBounds,
    float                                       maxDepthBounds)
   {
      VkPipelineDepthStencilStateCreateInfo obj;
      obj.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
      obj.pNext = nullptr;
      obj.flags = flags;
      obj.depthTestEnable = depthTestEnable;
      obj.depthWriteEnable = depthWriteEnable;
      obj.depthCompareOp = depthCompareOp;
      obj.depthBoundsTestEnable = depthBoundsTestEnable;
      obj.stencilTestEnable = stencilTestEnable;
      obj.front = front;
      obj.back = back;
      obj.minDepthBounds = minDepthBounds;
      obj.maxDepthBounds = maxDepthBounds;
      return obj;
   }

VkPipelineColorBlendAttachmentState PipelineColorBlendAttachmentState(
    VkBool32                                    blendEnable,
    VkBlendFactor                               srcColorBlendFactor,
    VkBlendFactor                               dstColorBlendFactor,
    VkBlendOp                                   colorBlendOp,
    VkBlendFactor                               srcAlphaBlendFactor,
    VkBlendFactor                               dstAlphaBlendFactor,
    VkBlendOp                                   alphaBlendOp,
    VkColorComponentFlags                       colorWriteMask)
   {
      VkPipelineColorBlendAttachmentState obj;
      obj.blendEnable = blendEnable;
      obj.srcColorBlendFactor = srcColorBlendFactor;
      obj.dstColorBlendFactor = dstColorBlendFactor;
      obj.colorBlendOp = colorBlendOp;
      obj.srcAlphaBlendFactor = srcAlphaBlendFactor;
      obj.dstAlphaBlendFactor = dstAlphaBlendFactor;
      obj.alphaBlendOp = alphaBlendOp;
      obj.colorWriteMask = colorWriteMask;
      return obj;
   }

struct VkPipelineColorBlendStateCreateInfoRAII {
   VkPipelineColorBlendStateCreateInfo nonRaiiObj;
    std::vector<VkPipelineColorBlendAttachmentState>vecAttachments;
};

std::shared_ptr<VkPipelineColorBlendStateCreateInfoRAII> PipelineColorBlendStateCreateInfo(
    VkPipelineColorBlendStateCreateFlags        flags,
    VkBool32                                    logicOpEnable,
    VkLogicOp                                   logicOp,
    const std::vector<VkPipelineColorBlendAttachmentState> &vecAttachments,
    float                                       blendConstants[4])
   {
      std::shared_ptr<VkPipelineColorBlendStateCreateInfoRAII> raii_obj(new VkPipelineColorBlendStateCreateInfoRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.flags = flags;
      raii_obj->nonRaiiObj.logicOpEnable = logicOpEnable;
      raii_obj->nonRaiiObj.logicOp = logicOp;
      raii_obj->nonRaiiObj.attachmentCount = static_cast<uint32_t>(vecAttachments.size());
      raii_obj->vecAttachments = vecAttachments;
      if ( raii_obj->vecAttachments.size() > 0)
      {
          raii_obj->nonRaiiObj.pAttachments = &raii_obj->vecAttachments[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pAttachments = nullptr;
      }
      std::copy(blendConstants, blendConstants + 4, raii_obj->nonRaiiObj.blendConstants);
      return raii_obj;
   }

struct VkPipelineDynamicStateCreateInfoRAII {
   VkPipelineDynamicStateCreateInfo nonRaiiObj;
    std::vector<VkDynamicState>                 vecDynamicStates;
};

std::shared_ptr<VkPipelineDynamicStateCreateInfoRAII> PipelineDynamicStateCreateInfo(
    VkPipelineDynamicStateCreateFlags           flags,
    const std::vector<VkDynamicState> &         vecDynamicStates)
   {
      std::shared_ptr<VkPipelineDynamicStateCreateInfoRAII> raii_obj(new VkPipelineDynamicStateCreateInfoRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.flags = flags;
      raii_obj->nonRaiiObj.dynamicStateCount = static_cast<uint32_t>(vecDynamicStates.size());
      raii_obj->vecDynamicStates = vecDynamicStates;
      if ( raii_obj->vecDynamicStates.size() > 0)
      {
          raii_obj->nonRaiiObj.pDynamicStates = &raii_obj->vecDynamicStates[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pDynamicStates = nullptr;
      }
      return raii_obj;
   }

struct VkGraphicsPipelineCreateInfoRAII {
   VkGraphicsPipelineCreateInfo nonRaiiObj;
    std::vector<VkPipelineShaderStageCreateInfo>vecStages;
    std::shared_ptr<VkPipelineVertexInputStateCreateInfoRAII>pVertexInputState;
    std::shared_ptr<VkPipelineInputAssemblyStateCreateInfo>pInputAssemblyState;
    std::shared_ptr<VkPipelineTessellationStateCreateInfo>pTessellationState;
    std::shared_ptr<VkPipelineViewportStateCreateInfoRAII>pViewportState;
    std::shared_ptr<VkPipelineRasterizationStateCreateInfo>pRasterizationState;
    std::shared_ptr<VkPipelineMultisampleStateCreateInfo>pMultisampleState;
    std::shared_ptr<VkPipelineDepthStencilStateCreateInfo>pDepthStencilState;
    std::shared_ptr<VkPipelineColorBlendStateCreateInfoRAII>pColorBlendState;
    std::shared_ptr<VkPipelineDynamicStateCreateInfoRAII>pDynamicState;
};

std::shared_ptr<VkGraphicsPipelineCreateInfoRAII> GraphicsPipelineCreateInfo(
    VkPipelineCreateFlags                       flags,
    const std::vector<VkPipelineShaderStageCreateInfo> &vecStages,
    const std::shared_ptr<VkPipelineVertexInputStateCreateInfoRAII> &pVertexInputState,
    const VkPipelineInputAssemblyStateCreateInfo *pInputAssemblyState,
    const VkPipelineTessellationStateCreateInfo *pTessellationState,
    const std::shared_ptr<VkPipelineViewportStateCreateInfoRAII> &pViewportState,
    const VkPipelineRasterizationStateCreateInfo *pRasterizationState,
    const VkPipelineMultisampleStateCreateInfo *pMultisampleState,
    const VkPipelineDepthStencilStateCreateInfo *pDepthStencilState,
    const std::shared_ptr<VkPipelineColorBlendStateCreateInfoRAII> &pColorBlendState,
    const std::shared_ptr<VkPipelineDynamicStateCreateInfoRAII> &pDynamicState,
    VkPipelineLayout                            layout,
    VkRenderPass                                renderPass,
    uint32_t                                    subpass,
    VkPipeline                                  basePipelineHandle,
    int32_t                                     basePipelineIndex)
   {
      std::shared_ptr<VkGraphicsPipelineCreateInfoRAII> raii_obj(new VkGraphicsPipelineCreateInfoRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.flags = flags;
      raii_obj->nonRaiiObj.stageCount = static_cast<uint32_t>(vecStages.size());
      raii_obj->vecStages = vecStages;
      if ( raii_obj->vecStages.size() > 0)
      {
          raii_obj->nonRaiiObj.pStages = &raii_obj->vecStages[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pStages = nullptr;
      }
      raii_obj->pVertexInputState = pVertexInputState;
      if ( pVertexInputState ) 
      {
          raii_obj->nonRaiiObj.pVertexInputState = &(pVertexInputState->nonRaiiObj);
      }
      else
      {
          raii_obj->nonRaiiObj.pVertexInputState = nullptr;
      }
      raii_obj->nonRaiiObj.pInputAssemblyState = nullptr;
      if ( pInputAssemblyState ) 
      { 
          raii_obj->pInputAssemblyState.reset( new VkPipelineInputAssemblyStateCreateInfo );
          *raii_obj->pInputAssemblyState = *pInputAssemblyState;
          raii_obj->nonRaiiObj.pInputAssemblyState = raii_obj->pInputAssemblyState.get();
      } 
      raii_obj->nonRaiiObj.pTessellationState = nullptr;
      if ( pTessellationState ) 
      { 
          raii_obj->pTessellationState.reset( new VkPipelineTessellationStateCreateInfo );
          *raii_obj->pTessellationState = *pTessellationState;
          raii_obj->nonRaiiObj.pTessellationState = raii_obj->pTessellationState.get();
      } 
      raii_obj->pViewportState = pViewportState;
      if ( pViewportState ) 
      {
          raii_obj->nonRaiiObj.pViewportState = &(pViewportState->nonRaiiObj);
      }
      else
      {
          raii_obj->nonRaiiObj.pViewportState = nullptr;
      }
      raii_obj->nonRaiiObj.pRasterizationState = nullptr;
      if ( pRasterizationState ) 
      { 
          raii_obj->pRasterizationState.reset( new VkPipelineRasterizationStateCreateInfo );
          *raii_obj->pRasterizationState = *pRasterizationState;
          raii_obj->nonRaiiObj.pRasterizationState = raii_obj->pRasterizationState.get();
      } 
      raii_obj->nonRaiiObj.pMultisampleState = nullptr;
      if ( pMultisampleState ) 
      { 
          raii_obj->pMultisampleState.reset( new VkPipelineMultisampleStateCreateInfo );
          *raii_obj->pMultisampleState = *pMultisampleState;
          raii_obj->nonRaiiObj.pMultisampleState = raii_obj->pMultisampleState.get();
      } 
      raii_obj->nonRaiiObj.pDepthStencilState = nullptr;
      if ( pDepthStencilState ) 
      { 
          raii_obj->pDepthStencilState.reset( new VkPipelineDepthStencilStateCreateInfo );
          *raii_obj->pDepthStencilState = *pDepthStencilState;
          raii_obj->nonRaiiObj.pDepthStencilState = raii_obj->pDepthStencilState.get();
      } 
      raii_obj->pColorBlendState = pColorBlendState;
      if ( pColorBlendState ) 
      {
          raii_obj->nonRaiiObj.pColorBlendState = &(pColorBlendState->nonRaiiObj);
      }
      else
      {
          raii_obj->nonRaiiObj.pColorBlendState = nullptr;
      }
      raii_obj->pDynamicState = pDynamicState;
      if ( pDynamicState ) 
      {
          raii_obj->nonRaiiObj.pDynamicState = &(pDynamicState->nonRaiiObj);
      }
      else
      {
          raii_obj->nonRaiiObj.pDynamicState = nullptr;
      }
      raii_obj->nonRaiiObj.layout = layout;
      raii_obj->nonRaiiObj.renderPass = renderPass;
      raii_obj->nonRaiiObj.subpass = subpass;
      raii_obj->nonRaiiObj.basePipelineHandle = basePipelineHandle;
      raii_obj->nonRaiiObj.basePipelineIndex = basePipelineIndex;
      return raii_obj;
   }

std::vector< std::shared_ptr<VkPipeline_T> > createGraphicsPipelines(
        VkDevice device,
        VkPipelineCache pipelineCache,
        const std::vector<VkGraphicsPipelineCreateInfo> & pCreateInfos)
   {
      std::vector<VkPipeline> vecpPipelines( pCreateInfos.size(), nullptr ); 
      V( vkCreateGraphicsPipelines(
          device,
          pipelineCache,
          static_cast<uint32_t>(pCreateInfos.size()),
          &pCreateInfos[0],
          nullptr,
          &vecpPipelines[0]  ));
      std::vector< std::shared_ptr<VkPipeline_T> > retval; 
      retval.reserve(vecpPipelines.size()); 
      for (auto allocated_handle : vecpPipelines ) 
      {
          retval.push_back(std::shared_ptr<VkPipeline_T>(allocated_handle, 
              [=](VkPipeline to_free) {vkDestroyPipeline(device, to_free, nullptr);}));
      }
      return retval; 
   }

VkComputePipelineCreateInfo ComputePipelineCreateInfo(
    VkPipelineCreateFlags                       flags,
    VkPipelineShaderStageCreateInfo             stage,
    VkPipelineLayout                            layout,
    VkPipeline                                  basePipelineHandle,
    int32_t                                     basePipelineIndex)
   {
      VkComputePipelineCreateInfo obj;
      obj.sType = VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO;
      obj.pNext = nullptr;
      obj.flags = flags;
      obj.stage = stage;
      obj.layout = layout;
      obj.basePipelineHandle = basePipelineHandle;
      obj.basePipelineIndex = basePipelineIndex;
      return obj;
   }

std::vector< std::shared_ptr<VkPipeline_T> > createComputePipelines(
        VkDevice device,
        VkPipelineCache pipelineCache,
        const std::vector<VkComputePipelineCreateInfo> & pCreateInfos)
   {
      std::vector<VkPipeline> vecpPipelines( pCreateInfos.size(), nullptr ); 
      V( vkCreateComputePipelines(
          device,
          pipelineCache,
          static_cast<uint32_t>(pCreateInfos.size()),
          &pCreateInfos[0],
          nullptr,
          &vecpPipelines[0]  ));
      std::vector< std::shared_ptr<VkPipeline_T> > retval; 
      retval.reserve(vecpPipelines.size()); 
      for (auto allocated_handle : vecpPipelines ) 
      {
          retval.push_back(std::shared_ptr<VkPipeline_T>(allocated_handle, 
              [=](VkPipeline to_free) {vkDestroyPipeline(device, to_free, nullptr);}));
      }
      return retval; 
   }

VkPushConstantRange PushConstantRange(
    VkShaderStageFlags                          stageFlags,
    uint32_t                                    offset,
    uint32_t                                    size)
   {
      VkPushConstantRange obj;
      obj.stageFlags = stageFlags;
      obj.offset = offset;
      obj.size = size;
      return obj;
   }

struct VkPipelineLayoutCreateInfoRAII {
   VkPipelineLayoutCreateInfo nonRaiiObj;
    std::vector<VkDescriptorSetLayout>          vecSetLayouts;
    std::vector<VkPushConstantRange>            vecPushConstantRanges;
};

std::shared_ptr<VkPipelineLayoutCreateInfoRAII> PipelineLayoutCreateInfo(
    VkPipelineLayoutCreateFlags                 flags,
    const std::vector<VkDescriptorSetLayout> &  vecSetLayouts,
    const std::vector<VkPushConstantRange> &    vecPushConstantRanges)
   {
      std::shared_ptr<VkPipelineLayoutCreateInfoRAII> raii_obj(new VkPipelineLayoutCreateInfoRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.flags = flags;
      raii_obj->nonRaiiObj.setLayoutCount = static_cast<uint32_t>(vecSetLayouts.size());
      raii_obj->vecSetLayouts = vecSetLayouts;
      if ( raii_obj->vecSetLayouts.size() > 0)
      {
          raii_obj->nonRaiiObj.pSetLayouts = &raii_obj->vecSetLayouts[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pSetLayouts = nullptr;
      }
      raii_obj->nonRaiiObj.pushConstantRangeCount = static_cast<uint32_t>(vecPushConstantRanges.size());
      raii_obj->vecPushConstantRanges = vecPushConstantRanges;
      if ( raii_obj->vecPushConstantRanges.size() > 0)
      {
          raii_obj->nonRaiiObj.pPushConstantRanges = &raii_obj->vecPushConstantRanges[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pPushConstantRanges = nullptr;
      }
      return raii_obj;
   }

std::shared_ptr<VkPipelineLayout_T> createPipelineLayout(
        VkDevice device,
        const VkPipelineLayoutCreateInfo & pCreateInfo)
   {
      VkPipelineLayout hPipelineLayout; 
      V( vkCreatePipelineLayout(
          device,
          &pCreateInfo,
          nullptr,
          &hPipelineLayout  ));
      return std::shared_ptr<VkPipelineLayout_T>(hPipelineLayout, 
              [=](VkPipelineLayout to_free) {vkDestroyPipelineLayout(device, to_free, nullptr);});
   }

VkSamplerCreateInfo SamplerCreateInfo(
    VkSamplerCreateFlags                        flags,
    VkFilter                                    magFilter,
    VkFilter                                    minFilter,
    VkSamplerMipmapMode                         mipmapMode,
    VkSamplerAddressMode                        addressModeU,
    VkSamplerAddressMode                        addressModeV,
    VkSamplerAddressMode                        addressModeW,
    float                                       mipLodBias,
    VkBool32                                    anisotropyEnable,
    float                                       maxAnisotropy,
    VkBool32                                    compareEnable,
    VkCompareOp                                 compareOp,
    float                                       minLod,
    float                                       maxLod,
    VkBorderColor                               borderColor,
    VkBool32                                    unnormalizedCoordinates)
   {
      VkSamplerCreateInfo obj;
      obj.sType = VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO;
      obj.pNext = nullptr;
      obj.flags = flags;
      obj.magFilter = magFilter;
      obj.minFilter = minFilter;
      obj.mipmapMode = mipmapMode;
      obj.addressModeU = addressModeU;
      obj.addressModeV = addressModeV;
      obj.addressModeW = addressModeW;
      obj.mipLodBias = mipLodBias;
      obj.anisotropyEnable = anisotropyEnable;
      obj.maxAnisotropy = maxAnisotropy;
      obj.compareEnable = compareEnable;
      obj.compareOp = compareOp;
      obj.minLod = minLod;
      obj.maxLod = maxLod;
      obj.borderColor = borderColor;
      obj.unnormalizedCoordinates = unnormalizedCoordinates;
      return obj;
   }

std::shared_ptr<VkSampler_T> createSampler(
        VkDevice device,
        const VkSamplerCreateInfo & pCreateInfo)
   {
      VkSampler hSampler; 
      V( vkCreateSampler(
          device,
          &pCreateInfo,
          nullptr,
          &hSampler  ));
      return std::shared_ptr<VkSampler_T>(hSampler, 
              [=](VkSampler to_free) {vkDestroySampler(device, to_free, nullptr);});
   }

struct VkDescriptorSetLayoutBindingRAII {
   VkDescriptorSetLayoutBinding nonRaiiObj;
    std::vector<VkSampler>                      vecImmutableSamplers;
};

std::shared_ptr<VkDescriptorSetLayoutBindingRAII> DescriptorSetLayoutBinding(
    uint32_t                                    binding,
    VkDescriptorType                            descriptorType,
    uint32_t                                    descriptorCount,
    VkShaderStageFlags                          stageFlags,
    const std::vector<VkSampler> &              vecImmutableSamplers)
   {
      std::shared_ptr<VkDescriptorSetLayoutBindingRAII> raii_obj(new VkDescriptorSetLayoutBindingRAII);
      raii_obj->nonRaiiObj.binding = binding;
      raii_obj->nonRaiiObj.descriptorType = descriptorType;
      raii_obj->nonRaiiObj.descriptorCount = descriptorCount;
      raii_obj->nonRaiiObj.stageFlags = stageFlags;
      raii_obj->vecImmutableSamplers = vecImmutableSamplers;
      if ( raii_obj->vecImmutableSamplers.size() > 0)
      {
          raii_obj->nonRaiiObj.pImmutableSamplers = &raii_obj->vecImmutableSamplers[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pImmutableSamplers = nullptr;
      }
      return raii_obj;
   }

struct VkDescriptorSetLayoutCreateInfoRAII {
   VkDescriptorSetLayoutCreateInfo nonRaiiObj;
    std::vector<VkDescriptorSetLayoutBinding>   vecBindings;
};

std::shared_ptr<VkDescriptorSetLayoutCreateInfoRAII> DescriptorSetLayoutCreateInfo(
    VkDescriptorSetLayoutCreateFlags            flags,
    const std::vector<VkDescriptorSetLayoutBinding> &vecBindings)
   {
      std::shared_ptr<VkDescriptorSetLayoutCreateInfoRAII> raii_obj(new VkDescriptorSetLayoutCreateInfoRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.flags = flags;
      raii_obj->nonRaiiObj.bindingCount = static_cast<uint32_t>(vecBindings.size());
      raii_obj->vecBindings = vecBindings;
      if ( raii_obj->vecBindings.size() > 0)
      {
          raii_obj->nonRaiiObj.pBindings = &raii_obj->vecBindings[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pBindings = nullptr;
      }
      return raii_obj;
   }

std::shared_ptr<VkDescriptorSetLayout_T> createDescriptorSetLayout(
        VkDevice device,
        const VkDescriptorSetLayoutCreateInfo & pCreateInfo)
   {
      VkDescriptorSetLayout hSetLayout; 
      V( vkCreateDescriptorSetLayout(
          device,
          &pCreateInfo,
          nullptr,
          &hSetLayout  ));
      return std::shared_ptr<VkDescriptorSetLayout_T>(hSetLayout, 
              [=](VkDescriptorSetLayout to_free) {vkDestroyDescriptorSetLayout(device, to_free, nullptr);});
   }

VkDescriptorPoolSize DescriptorPoolSize(
    VkDescriptorType                            type,
    uint32_t                                    descriptorCount)
   {
      VkDescriptorPoolSize obj;
      obj.type = type;
      obj.descriptorCount = descriptorCount;
      return obj;
   }

struct VkDescriptorPoolCreateInfoRAII {
   VkDescriptorPoolCreateInfo nonRaiiObj;
    std::vector<VkDescriptorPoolSize>           vecPoolSizes;
};

std::shared_ptr<VkDescriptorPoolCreateInfoRAII> DescriptorPoolCreateInfo(
    VkDescriptorPoolCreateFlags                 flags,
    uint32_t                                    maxSets,
    const std::vector<VkDescriptorPoolSize> &   vecPoolSizes)
   {
      std::shared_ptr<VkDescriptorPoolCreateInfoRAII> raii_obj(new VkDescriptorPoolCreateInfoRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.flags = flags;
      raii_obj->nonRaiiObj.maxSets = maxSets;
      raii_obj->nonRaiiObj.poolSizeCount = static_cast<uint32_t>(vecPoolSizes.size());
      raii_obj->vecPoolSizes = vecPoolSizes;
      if ( raii_obj->vecPoolSizes.size() > 0)
      {
          raii_obj->nonRaiiObj.pPoolSizes = &raii_obj->vecPoolSizes[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pPoolSizes = nullptr;
      }
      return raii_obj;
   }

std::shared_ptr<VkDescriptorPool_T> createDescriptorPool(
        VkDevice device,
        const VkDescriptorPoolCreateInfo & pCreateInfo)
   {
      VkDescriptorPool hDescriptorPool; 
      V( vkCreateDescriptorPool(
          device,
          &pCreateInfo,
          nullptr,
          &hDescriptorPool  ));
      return std::shared_ptr<VkDescriptorPool_T>(hDescriptorPool, 
              [=](VkDescriptorPool to_free) {vkDestroyDescriptorPool(device, to_free, nullptr);});
   }

void  resetDescriptorPool(
        VkDevice device,
        VkDescriptorPool descriptorPool,
        VkDescriptorPoolResetFlags flags)
   {
      V( vkResetDescriptorPool(
          device,
          descriptorPool,
          flags  ));
   }

struct VkDescriptorSetAllocateInfoRAII {
   VkDescriptorSetAllocateInfo nonRaiiObj;
    std::vector<VkDescriptorSetLayout>          vecSetLayouts;
};

std::shared_ptr<VkDescriptorSetAllocateInfoRAII> DescriptorSetAllocateInfo(
    VkDescriptorPool                            descriptorPool,
    const std::vector<VkDescriptorSetLayout> &  vecSetLayouts)
   {
      std::shared_ptr<VkDescriptorSetAllocateInfoRAII> raii_obj(new VkDescriptorSetAllocateInfoRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.descriptorPool = descriptorPool;
      raii_obj->nonRaiiObj.descriptorSetCount = static_cast<uint32_t>(vecSetLayouts.size());
      raii_obj->vecSetLayouts = vecSetLayouts;
      if ( raii_obj->vecSetLayouts.size() > 0)
      {
          raii_obj->nonRaiiObj.pSetLayouts = &raii_obj->vecSetLayouts[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pSetLayouts = nullptr;
      }
      return raii_obj;
   }

VkDescriptorImageInfo DescriptorImageInfo(
    VkSampler                                   sampler,
    VkImageView                                 imageView,
    VkImageLayout                               imageLayout)
   {
      VkDescriptorImageInfo obj;
      obj.sampler = sampler;
      obj.imageView = imageView;
      obj.imageLayout = imageLayout;
      return obj;
   }

VkDescriptorBufferInfo DescriptorBufferInfo(
    VkBuffer                                    buffer,
    VkDeviceSize                                offset,
    VkDeviceSize                                range)
   {
      VkDescriptorBufferInfo obj;
      obj.buffer = buffer;
      obj.offset = offset;
      obj.range = range;
      return obj;
   }

struct VkWriteDescriptorSetRAII {
   VkWriteDescriptorSet nonRaiiObj;
    std::vector<VkDescriptorImageInfo>          vecImageInfo;
    std::vector<VkDescriptorBufferInfo>         vecBufferInfo;
    std::vector<VkBufferView>                   vecTexelBufferView;
};

std::shared_ptr<VkWriteDescriptorSetRAII> WriteDescriptorSet(
    VkDescriptorSet                             dstSet,
    uint32_t                                    dstBinding,
    uint32_t                                    dstArrayElement,
    uint32_t                                    descriptorCount,
    VkDescriptorType                            descriptorType,
    const std::vector<VkDescriptorImageInfo> &  vecImageInfo,
    const std::vector<VkDescriptorBufferInfo> & vecBufferInfo,
    const std::vector<VkBufferView> &           vecTexelBufferView)
   {
      std::shared_ptr<VkWriteDescriptorSetRAII> raii_obj(new VkWriteDescriptorSetRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.dstSet = dstSet;
      raii_obj->nonRaiiObj.dstBinding = dstBinding;
      raii_obj->nonRaiiObj.dstArrayElement = dstArrayElement;
      raii_obj->nonRaiiObj.descriptorCount = descriptorCount;
      raii_obj->nonRaiiObj.descriptorType = descriptorType;
      raii_obj->vecImageInfo = vecImageInfo;
      if ( raii_obj->vecImageInfo.size() > 0)
      {
          raii_obj->nonRaiiObj.pImageInfo = &raii_obj->vecImageInfo[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pImageInfo = nullptr;
      }
      raii_obj->vecBufferInfo = vecBufferInfo;
      if ( raii_obj->vecBufferInfo.size() > 0)
      {
          raii_obj->nonRaiiObj.pBufferInfo = &raii_obj->vecBufferInfo[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pBufferInfo = nullptr;
      }
      raii_obj->vecTexelBufferView = vecTexelBufferView;
      if ( raii_obj->vecTexelBufferView.size() > 0)
      {
          raii_obj->nonRaiiObj.pTexelBufferView = &raii_obj->vecTexelBufferView[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pTexelBufferView = nullptr;
      }
      return raii_obj;
   }

VkCopyDescriptorSet CopyDescriptorSet(
    VkDescriptorSet                             srcSet,
    uint32_t                                    srcBinding,
    uint32_t                                    srcArrayElement,
    VkDescriptorSet                             dstSet,
    uint32_t                                    dstBinding,
    uint32_t                                    dstArrayElement,
    uint32_t                                    descriptorCount)
   {
      VkCopyDescriptorSet obj;
      obj.sType = VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET;
      obj.pNext = nullptr;
      obj.srcSet = srcSet;
      obj.srcBinding = srcBinding;
      obj.srcArrayElement = srcArrayElement;
      obj.dstSet = dstSet;
      obj.dstBinding = dstBinding;
      obj.dstArrayElement = dstArrayElement;
      obj.descriptorCount = descriptorCount;
      return obj;
   }

void  updateDescriptorSets(
        VkDevice device,
        const std::vector<VkWriteDescriptorSet> & pDescriptorWrites,
        const std::vector<VkCopyDescriptorSet> & pDescriptorCopies)
   {
      vkUpdateDescriptorSets(
          device,
          static_cast<uint32_t>(pDescriptorWrites.size()),
          &pDescriptorWrites[0],
          static_cast<uint32_t>(pDescriptorCopies.size()),
          &pDescriptorCopies[0]  );
   }

struct VkFramebufferCreateInfoRAII {
   VkFramebufferCreateInfo nonRaiiObj;
    std::vector<VkImageView>                    vecAttachments;
};

std::shared_ptr<VkFramebufferCreateInfoRAII> FramebufferCreateInfo(
    VkFramebufferCreateFlags                    flags,
    VkRenderPass                                renderPass,
    const std::vector<VkImageView> &            vecAttachments,
    uint32_t                                    width,
    uint32_t                                    height,
    uint32_t                                    layers)
   {
      std::shared_ptr<VkFramebufferCreateInfoRAII> raii_obj(new VkFramebufferCreateInfoRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.flags = flags;
      raii_obj->nonRaiiObj.renderPass = renderPass;
      raii_obj->nonRaiiObj.attachmentCount = static_cast<uint32_t>(vecAttachments.size());
      raii_obj->vecAttachments = vecAttachments;
      if ( raii_obj->vecAttachments.size() > 0)
      {
          raii_obj->nonRaiiObj.pAttachments = &raii_obj->vecAttachments[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pAttachments = nullptr;
      }
      raii_obj->nonRaiiObj.width = width;
      raii_obj->nonRaiiObj.height = height;
      raii_obj->nonRaiiObj.layers = layers;
      return raii_obj;
   }

std::shared_ptr<VkFramebuffer_T> createFramebuffer(
        VkDevice device,
        const VkFramebufferCreateInfo & pCreateInfo)
   {
      VkFramebuffer hFramebuffer; 
      V( vkCreateFramebuffer(
          device,
          &pCreateInfo,
          nullptr,
          &hFramebuffer  ));
      return std::shared_ptr<VkFramebuffer_T>(hFramebuffer, 
              [=](VkFramebuffer to_free) {vkDestroyFramebuffer(device, to_free, nullptr);});
   }

VkAttachmentDescription AttachmentDescription(
    VkAttachmentDescriptionFlags                flags,
    VkFormat                                    format,
    VkSampleCountFlagBits                       samples,
    VkAttachmentLoadOp                          loadOp,
    VkAttachmentStoreOp                         storeOp,
    VkAttachmentLoadOp                          stencilLoadOp,
    VkAttachmentStoreOp                         stencilStoreOp,
    VkImageLayout                               initialLayout,
    VkImageLayout                               finalLayout)
   {
      VkAttachmentDescription obj;
      obj.flags = flags;
      obj.format = format;
      obj.samples = samples;
      obj.loadOp = loadOp;
      obj.storeOp = storeOp;
      obj.stencilLoadOp = stencilLoadOp;
      obj.stencilStoreOp = stencilStoreOp;
      obj.initialLayout = initialLayout;
      obj.finalLayout = finalLayout;
      return obj;
   }

VkAttachmentReference AttachmentReference(
    uint32_t                                    attachment,
    VkImageLayout                               layout)
   {
      VkAttachmentReference obj;
      obj.attachment = attachment;
      obj.layout = layout;
      return obj;
   }

struct VkSubpassDescriptionRAII {
   VkSubpassDescription nonRaiiObj;
    std::vector<VkAttachmentReference>          vecInputAttachments;
    std::vector<VkAttachmentReference>          vecColorAttachments;
    std::vector<VkAttachmentReference>          vecResolveAttachments;
    std::shared_ptr<VkAttachmentReference>      pDepthStencilAttachment;
    std::vector<uint32_t>                       vecPreserveAttachments;
};

std::shared_ptr<VkSubpassDescriptionRAII> SubpassDescription(
    VkSubpassDescriptionFlags                   flags,
    VkPipelineBindPoint                         pipelineBindPoint,
    const std::vector<VkAttachmentReference> &  vecInputAttachments,
    const std::vector<VkAttachmentReference> &  vecColorAttachments,
    const std::vector<VkAttachmentReference> &  vecResolveAttachments,
    const VkAttachmentReference *               pDepthStencilAttachment,
    unsigned int* pPreserveAttachments_in_array1, int pPreserveAttachments_dim1)
   {
      std::shared_ptr<VkSubpassDescriptionRAII> raii_obj(new VkSubpassDescriptionRAII);
      raii_obj->nonRaiiObj.flags = flags;
      raii_obj->nonRaiiObj.pipelineBindPoint = pipelineBindPoint;
      raii_obj->nonRaiiObj.inputAttachmentCount = static_cast<uint32_t>(vecInputAttachments.size());
      raii_obj->vecInputAttachments = vecInputAttachments;
      if ( raii_obj->vecInputAttachments.size() > 0)
      {
          raii_obj->nonRaiiObj.pInputAttachments = &raii_obj->vecInputAttachments[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pInputAttachments = nullptr;
      }
      raii_obj->nonRaiiObj.colorAttachmentCount = static_cast<uint32_t>(vecColorAttachments.size());
      raii_obj->vecColorAttachments = vecColorAttachments;
      if ( raii_obj->vecColorAttachments.size() > 0)
      {
          raii_obj->nonRaiiObj.pColorAttachments = &raii_obj->vecColorAttachments[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pColorAttachments = nullptr;
      }
      raii_obj->vecResolveAttachments = vecResolveAttachments;
      if ( raii_obj->vecResolveAttachments.size() > 0)
      {
          raii_obj->nonRaiiObj.pResolveAttachments = &raii_obj->vecResolveAttachments[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pResolveAttachments = nullptr;
      }
      raii_obj->nonRaiiObj.pDepthStencilAttachment = nullptr;
      if ( pDepthStencilAttachment ) 
      { 
          raii_obj->pDepthStencilAttachment.reset( new VkAttachmentReference );
          *raii_obj->pDepthStencilAttachment = *pDepthStencilAttachment;
          raii_obj->nonRaiiObj.pDepthStencilAttachment = raii_obj->pDepthStencilAttachment.get();
      } 
      raii_obj->nonRaiiObj.preserveAttachmentCount = static_cast<uint32_t>(pPreserveAttachments_dim1);
      raii_obj->vecPreserveAttachments.assign(pPreserveAttachments_in_array1, pPreserveAttachments_in_array1 + pPreserveAttachments_dim1);
      if ( raii_obj->vecPreserveAttachments.size() > 0)
      {
          raii_obj->nonRaiiObj.pPreserveAttachments = &raii_obj->vecPreserveAttachments[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pPreserveAttachments = nullptr;
      }
      return raii_obj;
   }

VkSubpassDependency SubpassDependency(
    uint32_t                                    srcSubpass,
    uint32_t                                    dstSubpass,
    VkPipelineStageFlags                        srcStageMask,
    VkPipelineStageFlags                        dstStageMask,
    VkAccessFlags                               srcAccessMask,
    VkAccessFlags                               dstAccessMask,
    VkDependencyFlags                           dependencyFlags)
   {
      VkSubpassDependency obj;
      obj.srcSubpass = srcSubpass;
      obj.dstSubpass = dstSubpass;
      obj.srcStageMask = srcStageMask;
      obj.dstStageMask = dstStageMask;
      obj.srcAccessMask = srcAccessMask;
      obj.dstAccessMask = dstAccessMask;
      obj.dependencyFlags = dependencyFlags;
      return obj;
   }

struct VkRenderPassCreateInfoRAII {
   VkRenderPassCreateInfo nonRaiiObj;
    std::vector<VkAttachmentDescription>        vecAttachments;
    std::vector<VkSubpassDescription>           vecSubpasses;
    std::vector<VkSubpassDependency>            vecDependencies;
};

std::shared_ptr<VkRenderPassCreateInfoRAII> RenderPassCreateInfo(
    VkRenderPassCreateFlags                     flags,
    const std::vector<VkAttachmentDescription> &vecAttachments,
    const std::vector<VkSubpassDescription> &   vecSubpasses,
    const std::vector<VkSubpassDependency> &    vecDependencies)
   {
      std::shared_ptr<VkRenderPassCreateInfoRAII> raii_obj(new VkRenderPassCreateInfoRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.flags = flags;
      raii_obj->nonRaiiObj.attachmentCount = static_cast<uint32_t>(vecAttachments.size());
      raii_obj->vecAttachments = vecAttachments;
      if ( raii_obj->vecAttachments.size() > 0)
      {
          raii_obj->nonRaiiObj.pAttachments = &raii_obj->vecAttachments[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pAttachments = nullptr;
      }
      raii_obj->nonRaiiObj.subpassCount = static_cast<uint32_t>(vecSubpasses.size());
      raii_obj->vecSubpasses = vecSubpasses;
      if ( raii_obj->vecSubpasses.size() > 0)
      {
          raii_obj->nonRaiiObj.pSubpasses = &raii_obj->vecSubpasses[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pSubpasses = nullptr;
      }
      raii_obj->nonRaiiObj.dependencyCount = static_cast<uint32_t>(vecDependencies.size());
      raii_obj->vecDependencies = vecDependencies;
      if ( raii_obj->vecDependencies.size() > 0)
      {
          raii_obj->nonRaiiObj.pDependencies = &raii_obj->vecDependencies[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pDependencies = nullptr;
      }
      return raii_obj;
   }

std::shared_ptr<VkRenderPass_T> createRenderPass(
        VkDevice device,
        const VkRenderPassCreateInfo & pCreateInfo)
   {
      VkRenderPass hRenderPass; 
      V( vkCreateRenderPass(
          device,
          &pCreateInfo,
          nullptr,
          &hRenderPass  ));
      return std::shared_ptr<VkRenderPass_T>(hRenderPass, 
              [=](VkRenderPass to_free) {vkDestroyRenderPass(device, to_free, nullptr);});
   }

VkExtent2D getRenderAreaGranularity(
        VkDevice device,
        VkRenderPass renderPass)
   {
      VkExtent2D pGranularity; 
      vkGetRenderAreaGranularity(
          device,
          renderPass,
          &pGranularity  );
      return pGranularity; 
   }

VkCommandPoolCreateInfo CommandPoolCreateInfo(
    VkCommandPoolCreateFlags                    flags,
    uint32_t                                    queueFamilyIndex)
   {
      VkCommandPoolCreateInfo obj;
      obj.sType = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO;
      obj.pNext = nullptr;
      obj.flags = flags;
      obj.queueFamilyIndex = queueFamilyIndex;
      return obj;
   }

std::shared_ptr<VkCommandPool_T> createCommandPool(
        VkDevice device,
        const VkCommandPoolCreateInfo & pCreateInfo)
   {
      VkCommandPool hCommandPool; 
      V( vkCreateCommandPool(
          device,
          &pCreateInfo,
          nullptr,
          &hCommandPool  ));
      return std::shared_ptr<VkCommandPool_T>(hCommandPool, 
              [=](VkCommandPool to_free) {vkDestroyCommandPool(device, to_free, nullptr);});
   }

void  resetCommandPool(
        VkDevice device,
        VkCommandPool commandPool,
        VkCommandPoolResetFlags flags)
   {
      V( vkResetCommandPool(
          device,
          commandPool,
          flags  ));
   }

VkCommandBufferAllocateInfo CommandBufferAllocateInfo(
    VkCommandPool                               commandPool,
    VkCommandBufferLevel                        level,
    uint32_t                                    commandBufferCount)
   {
      VkCommandBufferAllocateInfo obj;
      obj.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;
      obj.pNext = nullptr;
      obj.commandPool = commandPool;
      obj.level = level;
      obj.commandBufferCount = commandBufferCount;
      return obj;
   }

VkCommandBufferInheritanceInfo CommandBufferInheritanceInfo(
    VkRenderPass                                renderPass,
    uint32_t                                    subpass,
    VkFramebuffer                               framebuffer,
    VkBool32                                    occlusionQueryEnable,
    VkQueryControlFlags                         queryFlags,
    VkQueryPipelineStatisticFlags               pipelineStatistics)
   {
      VkCommandBufferInheritanceInfo obj;
      obj.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO;
      obj.pNext = nullptr;
      obj.renderPass = renderPass;
      obj.subpass = subpass;
      obj.framebuffer = framebuffer;
      obj.occlusionQueryEnable = occlusionQueryEnable;
      obj.queryFlags = queryFlags;
      obj.pipelineStatistics = pipelineStatistics;
      return obj;
   }

struct VkCommandBufferBeginInfoRAII {
   VkCommandBufferBeginInfo nonRaiiObj;
    std::shared_ptr<VkCommandBufferInheritanceInfo>pInheritanceInfo;
};

std::shared_ptr<VkCommandBufferBeginInfoRAII> CommandBufferBeginInfo(
    VkCommandBufferUsageFlags                   flags,
    const VkCommandBufferInheritanceInfo *      pInheritanceInfo)
   {
      std::shared_ptr<VkCommandBufferBeginInfoRAII> raii_obj(new VkCommandBufferBeginInfoRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.flags = flags;
      raii_obj->nonRaiiObj.pInheritanceInfo = nullptr;
      if ( pInheritanceInfo ) 
      { 
          raii_obj->pInheritanceInfo.reset( new VkCommandBufferInheritanceInfo );
          *raii_obj->pInheritanceInfo = *pInheritanceInfo;
          raii_obj->nonRaiiObj.pInheritanceInfo = raii_obj->pInheritanceInfo.get();
      } 
      return raii_obj;
   }

void  beginCommandBuffer(
        VkCommandBuffer commandBuffer,
        const VkCommandBufferBeginInfo & pBeginInfo)
   {
      V( vkBeginCommandBuffer(
          commandBuffer,
          &pBeginInfo  ));
   }

void  endCommandBuffer(
        VkCommandBuffer commandBuffer)
   {
      V( vkEndCommandBuffer(
          commandBuffer  ));
   }

void  resetCommandBuffer(
        VkCommandBuffer commandBuffer,
        VkCommandBufferResetFlags flags)
   {
      V( vkResetCommandBuffer(
          commandBuffer,
          flags  ));
   }

void  cmdBindPipeline(
        VkCommandBuffer commandBuffer,
        VkPipelineBindPoint pipelineBindPoint,
        VkPipeline pipeline)
   {
      vkCmdBindPipeline(
          commandBuffer,
          pipelineBindPoint,
          pipeline  );
   }

void  cmdSetViewport(
        VkCommandBuffer commandBuffer,
        uint32_t firstViewport,
        const std::vector<VkViewport> & pViewports)
   {
      vkCmdSetViewport(
          commandBuffer,
          firstViewport,
          static_cast<uint32_t>(pViewports.size()),
          &pViewports[0]  );
   }

void  cmdSetScissor(
        VkCommandBuffer commandBuffer,
        uint32_t firstScissor,
        const std::vector<VkRect2D> & pScissors)
   {
      vkCmdSetScissor(
          commandBuffer,
          firstScissor,
          static_cast<uint32_t>(pScissors.size()),
          &pScissors[0]  );
   }

void  cmdSetLineWidth(
        VkCommandBuffer commandBuffer,
        float lineWidth)
   {
      vkCmdSetLineWidth(
          commandBuffer,
          lineWidth  );
   }

void  cmdSetDepthBias(
        VkCommandBuffer commandBuffer,
        float depthBiasConstantFactor,
        float depthBiasClamp,
        float depthBiasSlopeFactor)
   {
      vkCmdSetDepthBias(
          commandBuffer,
          depthBiasConstantFactor,
          depthBiasClamp,
          depthBiasSlopeFactor  );
   }

void  cmdSetBlendConstants(
        VkCommandBuffer commandBuffer,
        const float blendConstants[4])
   {
      vkCmdSetBlendConstants(
          commandBuffer,
          blendConstants  );
   }

void  cmdSetDepthBounds(
        VkCommandBuffer commandBuffer,
        float minDepthBounds,
        float maxDepthBounds)
   {
      vkCmdSetDepthBounds(
          commandBuffer,
          minDepthBounds,
          maxDepthBounds  );
   }

void  cmdSetStencilCompareMask(
        VkCommandBuffer commandBuffer,
        VkStencilFaceFlags faceMask,
        uint32_t compareMask)
   {
      vkCmdSetStencilCompareMask(
          commandBuffer,
          faceMask,
          compareMask  );
   }

void  cmdSetStencilWriteMask(
        VkCommandBuffer commandBuffer,
        VkStencilFaceFlags faceMask,
        uint32_t writeMask)
   {
      vkCmdSetStencilWriteMask(
          commandBuffer,
          faceMask,
          writeMask  );
   }

void  cmdSetStencilReference(
        VkCommandBuffer commandBuffer,
        VkStencilFaceFlags faceMask,
        uint32_t reference)
   {
      vkCmdSetStencilReference(
          commandBuffer,
          faceMask,
          reference  );
   }

void  cmdBindDescriptorSets(
        VkCommandBuffer commandBuffer,
        VkPipelineBindPoint pipelineBindPoint,
        VkPipelineLayout layout,
        uint32_t firstSet,
        const std::vector<VkDescriptorSet> & pDescriptorSets,
        unsigned int* pDynamicOffsets_in_array1, int pDynamicOffsets_dim1)
   {
      vkCmdBindDescriptorSets(
          commandBuffer,
          pipelineBindPoint,
          layout,
          firstSet,
          static_cast<uint32_t>(pDescriptorSets.size()),
          &pDescriptorSets[0],
          static_cast<uint32_t>(pDynamicOffsets_dim1),
          pDynamicOffsets_in_array1  );
   }

void  cmdBindIndexBuffer(
        VkCommandBuffer commandBuffer,
        VkBuffer buffer,
        VkDeviceSize offset,
        VkIndexType indexType)
   {
      vkCmdBindIndexBuffer(
          commandBuffer,
          buffer,
          offset,
          indexType  );
   }

void  cmdBindVertexBuffers(
        VkCommandBuffer commandBuffer,
        uint32_t firstBinding,
        const std::vector<VkBuffer> & pBuffers,
        const std::vector<VkDeviceSize> & pOffsets)
   {
      vkCmdBindVertexBuffers(
          commandBuffer,
          firstBinding,
          static_cast<uint32_t>(pOffsets.size()),
          &pBuffers[0],
          &pOffsets[0]  );
   }

void  cmdDraw(
        VkCommandBuffer commandBuffer,
        uint32_t vertexCount,
        uint32_t instanceCount,
        uint32_t firstVertex,
        uint32_t firstInstance)
   {
      vkCmdDraw(
          commandBuffer,
          vertexCount,
          instanceCount,
          firstVertex,
          firstInstance  );
   }

void  cmdDrawIndexed(
        VkCommandBuffer commandBuffer,
        uint32_t indexCount,
        uint32_t instanceCount,
        uint32_t firstIndex,
        int32_t vertexOffset,
        uint32_t firstInstance)
   {
      vkCmdDrawIndexed(
          commandBuffer,
          indexCount,
          instanceCount,
          firstIndex,
          vertexOffset,
          firstInstance  );
   }

void  cmdDrawIndirect(
        VkCommandBuffer commandBuffer,
        VkBuffer buffer,
        VkDeviceSize offset,
        uint32_t drawCount,
        uint32_t stride)
   {
      vkCmdDrawIndirect(
          commandBuffer,
          buffer,
          offset,
          drawCount,
          stride  );
   }

void  cmdDrawIndexedIndirect(
        VkCommandBuffer commandBuffer,
        VkBuffer buffer,
        VkDeviceSize offset,
        uint32_t drawCount,
        uint32_t stride)
   {
      vkCmdDrawIndexedIndirect(
          commandBuffer,
          buffer,
          offset,
          drawCount,
          stride  );
   }

void  cmdDispatch(
        VkCommandBuffer commandBuffer,
        uint32_t groupCountX,
        uint32_t groupCountY,
        uint32_t groupCountZ)
   {
      vkCmdDispatch(
          commandBuffer,
          groupCountX,
          groupCountY,
          groupCountZ  );
   }

void  cmdDispatchIndirect(
        VkCommandBuffer commandBuffer,
        VkBuffer buffer,
        VkDeviceSize offset)
   {
      vkCmdDispatchIndirect(
          commandBuffer,
          buffer,
          offset  );
   }

VkBufferCopy BufferCopy(
    VkDeviceSize                                srcOffset,
    VkDeviceSize                                dstOffset,
    VkDeviceSize                                size)
   {
      VkBufferCopy obj;
      obj.srcOffset = srcOffset;
      obj.dstOffset = dstOffset;
      obj.size = size;
      return obj;
   }

void  cmdCopyBuffer(
        VkCommandBuffer commandBuffer,
        VkBuffer srcBuffer,
        VkBuffer dstBuffer,
        const std::vector<VkBufferCopy> & pRegions)
   {
      vkCmdCopyBuffer(
          commandBuffer,
          srcBuffer,
          dstBuffer,
          static_cast<uint32_t>(pRegions.size()),
          &pRegions[0]  );
   }

VkImageSubresourceLayers ImageSubresourceLayers(
    VkImageAspectFlags                          aspectMask,
    uint32_t                                    mipLevel,
    uint32_t                                    baseArrayLayer,
    uint32_t                                    layerCount)
   {
      VkImageSubresourceLayers obj;
      obj.aspectMask = aspectMask;
      obj.mipLevel = mipLevel;
      obj.baseArrayLayer = baseArrayLayer;
      obj.layerCount = layerCount;
      return obj;
   }

VkImageCopy ImageCopy(
    VkImageSubresourceLayers                    srcSubresource,
    VkOffset3D                                  srcOffset,
    VkImageSubresourceLayers                    dstSubresource,
    VkOffset3D                                  dstOffset,
    VkExtent3D                                  extent)
   {
      VkImageCopy obj;
      obj.srcSubresource = srcSubresource;
      obj.srcOffset = srcOffset;
      obj.dstSubresource = dstSubresource;
      obj.dstOffset = dstOffset;
      obj.extent = extent;
      return obj;
   }

void  cmdCopyImage(
        VkCommandBuffer commandBuffer,
        VkImage srcImage,
        VkImageLayout srcImageLayout,
        VkImage dstImage,
        VkImageLayout dstImageLayout,
        const std::vector<VkImageCopy> & pRegions)
   {
      vkCmdCopyImage(
          commandBuffer,
          srcImage,
          srcImageLayout,
          dstImage,
          dstImageLayout,
          static_cast<uint32_t>(pRegions.size()),
          &pRegions[0]  );
   }

VkImageBlit ImageBlit(
    VkImageSubresourceLayers                    srcSubresource,
    VkOffset3D                                  srcOffsets[2],
    VkImageSubresourceLayers                    dstSubresource,
    VkOffset3D                                  dstOffsets[2])
   {
      VkImageBlit obj;
      obj.srcSubresource = srcSubresource;
      std::copy(srcOffsets, srcOffsets + 2, obj.srcOffsets);
      obj.dstSubresource = dstSubresource;
      std::copy(dstOffsets, dstOffsets + 2, obj.dstOffsets);
      return obj;
   }

void  cmdBlitImage(
        VkCommandBuffer commandBuffer,
        VkImage srcImage,
        VkImageLayout srcImageLayout,
        VkImage dstImage,
        VkImageLayout dstImageLayout,
        const std::vector<VkImageBlit> & pRegions,
        VkFilter filter)
   {
      vkCmdBlitImage(
          commandBuffer,
          srcImage,
          srcImageLayout,
          dstImage,
          dstImageLayout,
          static_cast<uint32_t>(pRegions.size()),
          &pRegions[0],
          filter  );
   }

VkBufferImageCopy BufferImageCopy(
    VkDeviceSize                                bufferOffset,
    uint32_t                                    bufferRowLength,
    uint32_t                                    bufferImageHeight,
    VkImageSubresourceLayers                    imageSubresource,
    VkOffset3D                                  imageOffset,
    VkExtent3D                                  imageExtent)
   {
      VkBufferImageCopy obj;
      obj.bufferOffset = bufferOffset;
      obj.bufferRowLength = bufferRowLength;
      obj.bufferImageHeight = bufferImageHeight;
      obj.imageSubresource = imageSubresource;
      obj.imageOffset = imageOffset;
      obj.imageExtent = imageExtent;
      return obj;
   }

void  cmdCopyBufferToImage(
        VkCommandBuffer commandBuffer,
        VkBuffer srcBuffer,
        VkImage dstImage,
        VkImageLayout dstImageLayout,
        const std::vector<VkBufferImageCopy> & pRegions)
   {
      vkCmdCopyBufferToImage(
          commandBuffer,
          srcBuffer,
          dstImage,
          dstImageLayout,
          static_cast<uint32_t>(pRegions.size()),
          &pRegions[0]  );
   }

void  cmdCopyImageToBuffer(
        VkCommandBuffer commandBuffer,
        VkImage srcImage,
        VkImageLayout srcImageLayout,
        VkBuffer dstBuffer,
        const std::vector<VkBufferImageCopy> & pRegions)
   {
      vkCmdCopyImageToBuffer(
          commandBuffer,
          srcImage,
          srcImageLayout,
          dstBuffer,
          static_cast<uint32_t>(pRegions.size()),
          &pRegions[0]  );
   }

void  cmdFillBuffer(
        VkCommandBuffer commandBuffer,
        VkBuffer dstBuffer,
        VkDeviceSize dstOffset,
        VkDeviceSize size,
        uint32_t data)
   {
      vkCmdFillBuffer(
          commandBuffer,
          dstBuffer,
          dstOffset,
          size,
          data  );
   }

void  cmdClearColorImage(
        VkCommandBuffer commandBuffer,
        VkImage image,
        VkImageLayout imageLayout,
        const VkClearColorValue & pColor,
        const std::vector<VkImageSubresourceRange> & pRanges)
   {
      vkCmdClearColorImage(
          commandBuffer,
          image,
          imageLayout,
          &pColor,
          static_cast<uint32_t>(pRanges.size()),
          &pRanges[0]  );
   }

VkClearDepthStencilValue ClearDepthStencilValue(
    float                                       depth,
    uint32_t                                    stencil)
   {
      VkClearDepthStencilValue obj;
      obj.depth = depth;
      obj.stencil = stencil;
      return obj;
   }

void  cmdClearDepthStencilImage(
        VkCommandBuffer commandBuffer,
        VkImage image,
        VkImageLayout imageLayout,
        const VkClearDepthStencilValue & pDepthStencil,
        const std::vector<VkImageSubresourceRange> & pRanges)
   {
      vkCmdClearDepthStencilImage(
          commandBuffer,
          image,
          imageLayout,
          &pDepthStencil,
          static_cast<uint32_t>(pRanges.size()),
          &pRanges[0]  );
   }

VkClearAttachment ClearAttachment(
    VkImageAspectFlags                          aspectMask,
    uint32_t                                    colorAttachment,
    VkClearValue                                clearValue)
   {
      VkClearAttachment obj;
      obj.aspectMask = aspectMask;
      obj.colorAttachment = colorAttachment;
      obj.clearValue = clearValue;
      return obj;
   }

VkClearRect ClearRect(
    VkRect2D                                    rect,
    uint32_t                                    baseArrayLayer,
    uint32_t                                    layerCount)
   {
      VkClearRect obj;
      obj.rect = rect;
      obj.baseArrayLayer = baseArrayLayer;
      obj.layerCount = layerCount;
      return obj;
   }

void  cmdClearAttachments(
        VkCommandBuffer commandBuffer,
        const std::vector<VkClearAttachment> & pAttachments,
        const std::vector<VkClearRect> & pRects)
   {
      vkCmdClearAttachments(
          commandBuffer,
          static_cast<uint32_t>(pAttachments.size()),
          &pAttachments[0],
          static_cast<uint32_t>(pRects.size()),
          &pRects[0]  );
   }

VkImageResolve ImageResolve(
    VkImageSubresourceLayers                    srcSubresource,
    VkOffset3D                                  srcOffset,
    VkImageSubresourceLayers                    dstSubresource,
    VkOffset3D                                  dstOffset,
    VkExtent3D                                  extent)
   {
      VkImageResolve obj;
      obj.srcSubresource = srcSubresource;
      obj.srcOffset = srcOffset;
      obj.dstSubresource = dstSubresource;
      obj.dstOffset = dstOffset;
      obj.extent = extent;
      return obj;
   }

void  cmdResolveImage(
        VkCommandBuffer commandBuffer,
        VkImage srcImage,
        VkImageLayout srcImageLayout,
        VkImage dstImage,
        VkImageLayout dstImageLayout,
        const std::vector<VkImageResolve> & pRegions)
   {
      vkCmdResolveImage(
          commandBuffer,
          srcImage,
          srcImageLayout,
          dstImage,
          dstImageLayout,
          static_cast<uint32_t>(pRegions.size()),
          &pRegions[0]  );
   }

void  cmdSetEvent(
        VkCommandBuffer commandBuffer,
        VkEvent event,
        VkPipelineStageFlags stageMask)
   {
      vkCmdSetEvent(
          commandBuffer,
          event,
          stageMask  );
   }

void  cmdResetEvent(
        VkCommandBuffer commandBuffer,
        VkEvent event,
        VkPipelineStageFlags stageMask)
   {
      vkCmdResetEvent(
          commandBuffer,
          event,
          stageMask  );
   }

VkMemoryBarrier MemoryBarrier(
    VkAccessFlags                               srcAccessMask,
    VkAccessFlags                               dstAccessMask)
   {
      VkMemoryBarrier obj;
      obj.sType = VK_STRUCTURE_TYPE_MEMORY_BARRIER;
      obj.pNext = nullptr;
      obj.srcAccessMask = srcAccessMask;
      obj.dstAccessMask = dstAccessMask;
      return obj;
   }

VkBufferMemoryBarrier BufferMemoryBarrier(
    VkAccessFlags                               srcAccessMask,
    VkAccessFlags                               dstAccessMask,
    uint32_t                                    srcQueueFamilyIndex,
    uint32_t                                    dstQueueFamilyIndex,
    VkBuffer                                    buffer,
    VkDeviceSize                                offset,
    VkDeviceSize                                size)
   {
      VkBufferMemoryBarrier obj;
      obj.sType = VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER;
      obj.pNext = nullptr;
      obj.srcAccessMask = srcAccessMask;
      obj.dstAccessMask = dstAccessMask;
      obj.srcQueueFamilyIndex = srcQueueFamilyIndex;
      obj.dstQueueFamilyIndex = dstQueueFamilyIndex;
      obj.buffer = buffer;
      obj.offset = offset;
      obj.size = size;
      return obj;
   }

VkImageMemoryBarrier ImageMemoryBarrier(
    VkAccessFlags                               srcAccessMask,
    VkAccessFlags                               dstAccessMask,
    VkImageLayout                               oldLayout,
    VkImageLayout                               newLayout,
    uint32_t                                    srcQueueFamilyIndex,
    uint32_t                                    dstQueueFamilyIndex,
    VkImage                                     image,
    VkImageSubresourceRange                     subresourceRange)
   {
      VkImageMemoryBarrier obj;
      obj.sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER;
      obj.pNext = nullptr;
      obj.srcAccessMask = srcAccessMask;
      obj.dstAccessMask = dstAccessMask;
      obj.oldLayout = oldLayout;
      obj.newLayout = newLayout;
      obj.srcQueueFamilyIndex = srcQueueFamilyIndex;
      obj.dstQueueFamilyIndex = dstQueueFamilyIndex;
      obj.image = image;
      obj.subresourceRange = subresourceRange;
      return obj;
   }

void  cmdWaitEvents(
        VkCommandBuffer commandBuffer,
        const std::vector<VkEvent> & pEvents,
        VkPipelineStageFlags srcStageMask,
        VkPipelineStageFlags dstStageMask,
        const std::vector<VkMemoryBarrier> & pMemoryBarriers,
        const std::vector<VkBufferMemoryBarrier> & pBufferMemoryBarriers,
        const std::vector<VkImageMemoryBarrier> & pImageMemoryBarriers)
   {
      vkCmdWaitEvents(
          commandBuffer,
          static_cast<uint32_t>(pEvents.size()),
          &pEvents[0],
          srcStageMask,
          dstStageMask,
          static_cast<uint32_t>(pMemoryBarriers.size()),
          &pMemoryBarriers[0],
          static_cast<uint32_t>(pBufferMemoryBarriers.size()),
          &pBufferMemoryBarriers[0],
          static_cast<uint32_t>(pImageMemoryBarriers.size()),
          &pImageMemoryBarriers[0]  );
   }

void  cmdPipelineBarrier(
        VkCommandBuffer commandBuffer,
        VkPipelineStageFlags srcStageMask,
        VkPipelineStageFlags dstStageMask,
        VkDependencyFlags dependencyFlags,
        const std::vector<VkMemoryBarrier> & pMemoryBarriers,
        const std::vector<VkBufferMemoryBarrier> & pBufferMemoryBarriers,
        const std::vector<VkImageMemoryBarrier> & pImageMemoryBarriers)
   {
      vkCmdPipelineBarrier(
          commandBuffer,
          srcStageMask,
          dstStageMask,
          dependencyFlags,
          static_cast<uint32_t>(pMemoryBarriers.size()),
          &pMemoryBarriers[0],
          static_cast<uint32_t>(pBufferMemoryBarriers.size()),
          &pBufferMemoryBarriers[0],
          static_cast<uint32_t>(pImageMemoryBarriers.size()),
          &pImageMemoryBarriers[0]  );
   }

void  cmdBeginQuery(
        VkCommandBuffer commandBuffer,
        VkQueryPool queryPool,
        uint32_t query,
        VkQueryControlFlags flags)
   {
      vkCmdBeginQuery(
          commandBuffer,
          queryPool,
          query,
          flags  );
   }

void  cmdEndQuery(
        VkCommandBuffer commandBuffer,
        VkQueryPool queryPool,
        uint32_t query)
   {
      vkCmdEndQuery(
          commandBuffer,
          queryPool,
          query  );
   }

void  cmdResetQueryPool(
        VkCommandBuffer commandBuffer,
        VkQueryPool queryPool,
        uint32_t firstQuery,
        uint32_t queryCount)
   {
      vkCmdResetQueryPool(
          commandBuffer,
          queryPool,
          firstQuery,
          queryCount  );
   }

void  cmdWriteTimestamp(
        VkCommandBuffer commandBuffer,
        VkPipelineStageFlagBits pipelineStage,
        VkQueryPool queryPool,
        uint32_t query)
   {
      vkCmdWriteTimestamp(
          commandBuffer,
          pipelineStage,
          queryPool,
          query  );
   }

void  cmdCopyQueryPoolResults(
        VkCommandBuffer commandBuffer,
        VkQueryPool queryPool,
        uint32_t firstQuery,
        uint32_t queryCount,
        VkBuffer dstBuffer,
        VkDeviceSize dstOffset,
        VkDeviceSize stride,
        VkQueryResultFlags flags)
   {
      vkCmdCopyQueryPoolResults(
          commandBuffer,
          queryPool,
          firstQuery,
          queryCount,
          dstBuffer,
          dstOffset,
          stride,
          flags  );
   }

struct VkRenderPassBeginInfoRAII {
   VkRenderPassBeginInfo nonRaiiObj;
    std::vector<VkClearValue>                   vecClearValues;
};

std::shared_ptr<VkRenderPassBeginInfoRAII> RenderPassBeginInfo(
    VkRenderPass                                renderPass,
    VkFramebuffer                               framebuffer,
    VkRect2D                                    renderArea,
    const std::vector<VkClearValue> &           vecClearValues)
   {
      std::shared_ptr<VkRenderPassBeginInfoRAII> raii_obj(new VkRenderPassBeginInfoRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.renderPass = renderPass;
      raii_obj->nonRaiiObj.framebuffer = framebuffer;
      raii_obj->nonRaiiObj.renderArea = renderArea;
      raii_obj->nonRaiiObj.clearValueCount = static_cast<uint32_t>(vecClearValues.size());
      raii_obj->vecClearValues = vecClearValues;
      if ( raii_obj->vecClearValues.size() > 0)
      {
          raii_obj->nonRaiiObj.pClearValues = &raii_obj->vecClearValues[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pClearValues = nullptr;
      }
      return raii_obj;
   }

void  cmdBeginRenderPass(
        VkCommandBuffer commandBuffer,
        const VkRenderPassBeginInfo & pRenderPassBegin,
        VkSubpassContents contents)
   {
      vkCmdBeginRenderPass(
          commandBuffer,
          &pRenderPassBegin,
          contents  );
   }

void  cmdNextSubpass(
        VkCommandBuffer commandBuffer,
        VkSubpassContents contents)
   {
      vkCmdNextSubpass(
          commandBuffer,
          contents  );
   }

void  cmdEndRenderPass(
        VkCommandBuffer commandBuffer)
   {
      vkCmdEndRenderPass(
          commandBuffer  );
   }

void  cmdExecuteCommands(
        VkCommandBuffer commandBuffer,
        const std::vector<VkCommandBuffer> & pCommandBuffers)
   {
      vkCmdExecuteCommands(
          commandBuffer,
          static_cast<uint32_t>(pCommandBuffers.size()),
          &pCommandBuffers[0]  );
   }

VkDispatchIndirectCommand DispatchIndirectCommand(
    uint32_t                                    x,
    uint32_t                                    y,
    uint32_t                                    z)
   {
      VkDispatchIndirectCommand obj;
      obj.x = x;
      obj.y = y;
      obj.z = z;
      return obj;
   }

VkDrawIndexedIndirectCommand DrawIndexedIndirectCommand(
    uint32_t                                    indexCount,
    uint32_t                                    instanceCount,
    uint32_t                                    firstIndex,
    int32_t                                     vertexOffset,
    uint32_t                                    firstInstance)
   {
      VkDrawIndexedIndirectCommand obj;
      obj.indexCount = indexCount;
      obj.instanceCount = instanceCount;
      obj.firstIndex = firstIndex;
      obj.vertexOffset = vertexOffset;
      obj.firstInstance = firstInstance;
      return obj;
   }

VkDrawIndirectCommand DrawIndirectCommand(
    uint32_t                                    vertexCount,
    uint32_t                                    instanceCount,
    uint32_t                                    firstVertex,
    uint32_t                                    firstInstance)
   {
      VkDrawIndirectCommand obj;
      obj.vertexCount = vertexCount;
      obj.instanceCount = instanceCount;
      obj.firstVertex = firstVertex;
      obj.firstInstance = firstInstance;
      return obj;
   }

uint32_t enumerateInstanceVersion(void)
   {
      uint32_t pApiVersion; 
      V( vkEnumerateInstanceVersion(
          &pApiVersion  ));
      return pApiVersion; 
   }

VkPhysicalDeviceSubgroupProperties PhysicalDeviceSubgroupProperties(
    uint32_t                                    subgroupSize,
    VkShaderStageFlags                          supportedStages,
    VkSubgroupFeatureFlags                      supportedOperations,
    VkBool32                                    quadOperationsInAllStages)
   {
      VkPhysicalDeviceSubgroupProperties obj;
      obj.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES;
      obj.pNext = nullptr;
      obj.subgroupSize = subgroupSize;
      obj.supportedStages = supportedStages;
      obj.supportedOperations = supportedOperations;
      obj.quadOperationsInAllStages = quadOperationsInAllStages;
      return obj;
   }

VkBindBufferMemoryInfo BindBufferMemoryInfo(
    VkBuffer                                    buffer,
    VkDeviceMemory                              memory,
    VkDeviceSize                                memoryOffset)
   {
      VkBindBufferMemoryInfo obj;
      obj.sType = VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO;
      obj.pNext = nullptr;
      obj.buffer = buffer;
      obj.memory = memory;
      obj.memoryOffset = memoryOffset;
      return obj;
   }

VkBindImageMemoryInfo BindImageMemoryInfo(
    VkImage                                     image,
    VkDeviceMemory                              memory,
    VkDeviceSize                                memoryOffset)
   {
      VkBindImageMemoryInfo obj;
      obj.sType = VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO;
      obj.pNext = nullptr;
      obj.image = image;
      obj.memory = memory;
      obj.memoryOffset = memoryOffset;
      return obj;
   }

void  bindBufferMemory2(
        VkDevice device,
        const std::vector<VkBindBufferMemoryInfo> & pBindInfos)
   {
      V( vkBindBufferMemory2(
          device,
          static_cast<uint32_t>(pBindInfos.size()),
          &pBindInfos[0]  ));
   }

void  bindImageMemory2(
        VkDevice device,
        const std::vector<VkBindImageMemoryInfo> & pBindInfos)
   {
      V( vkBindImageMemory2(
          device,
          static_cast<uint32_t>(pBindInfos.size()),
          &pBindInfos[0]  ));
   }

VkPhysicalDevice16BitStorageFeatures PhysicalDevice16BitStorageFeatures(
    VkBool32                                    storageBuffer16BitAccess,
    VkBool32                                    uniformAndStorageBuffer16BitAccess,
    VkBool32                                    storagePushConstant16,
    VkBool32                                    storageInputOutput16)
   {
      VkPhysicalDevice16BitStorageFeatures obj;
      obj.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES;
      obj.pNext = nullptr;
      obj.storageBuffer16BitAccess = storageBuffer16BitAccess;
      obj.uniformAndStorageBuffer16BitAccess = uniformAndStorageBuffer16BitAccess;
      obj.storagePushConstant16 = storagePushConstant16;
      obj.storageInputOutput16 = storageInputOutput16;
      return obj;
   }

VkMemoryDedicatedRequirements MemoryDedicatedRequirements(
    VkBool32                                    prefersDedicatedAllocation,
    VkBool32                                    requiresDedicatedAllocation)
   {
      VkMemoryDedicatedRequirements obj;
      obj.sType = VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS;
      obj.pNext = nullptr;
      obj.prefersDedicatedAllocation = prefersDedicatedAllocation;
      obj.requiresDedicatedAllocation = requiresDedicatedAllocation;
      return obj;
   }

VkMemoryDedicatedAllocateInfo MemoryDedicatedAllocateInfo(
    VkImage                                     image,
    VkBuffer                                    buffer)
   {
      VkMemoryDedicatedAllocateInfo obj;
      obj.sType = VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO;
      obj.pNext = nullptr;
      obj.image = image;
      obj.buffer = buffer;
      return obj;
   }

VkMemoryAllocateFlagsInfo MemoryAllocateFlagsInfo(
    VkMemoryAllocateFlags                       flags,
    uint32_t                                    deviceMask)
   {
      VkMemoryAllocateFlagsInfo obj;
      obj.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO;
      obj.pNext = nullptr;
      obj.flags = flags;
      obj.deviceMask = deviceMask;
      return obj;
   }

struct VkDeviceGroupRenderPassBeginInfoRAII {
   VkDeviceGroupRenderPassBeginInfo nonRaiiObj;
    std::vector<VkRect2D>                       vecDeviceRenderAreas;
};

std::shared_ptr<VkDeviceGroupRenderPassBeginInfoRAII> DeviceGroupRenderPassBeginInfo(
    uint32_t                                    deviceMask,
    const std::vector<VkRect2D> &               vecDeviceRenderAreas)
   {
      std::shared_ptr<VkDeviceGroupRenderPassBeginInfoRAII> raii_obj(new VkDeviceGroupRenderPassBeginInfoRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.deviceMask = deviceMask;
      raii_obj->nonRaiiObj.deviceRenderAreaCount = static_cast<uint32_t>(vecDeviceRenderAreas.size());
      raii_obj->vecDeviceRenderAreas = vecDeviceRenderAreas;
      if ( raii_obj->vecDeviceRenderAreas.size() > 0)
      {
          raii_obj->nonRaiiObj.pDeviceRenderAreas = &raii_obj->vecDeviceRenderAreas[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pDeviceRenderAreas = nullptr;
      }
      return raii_obj;
   }

VkDeviceGroupCommandBufferBeginInfo DeviceGroupCommandBufferBeginInfo(
    uint32_t                                    deviceMask)
   {
      VkDeviceGroupCommandBufferBeginInfo obj;
      obj.sType = VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO;
      obj.pNext = nullptr;
      obj.deviceMask = deviceMask;
      return obj;
   }

struct VkDeviceGroupSubmitInfoRAII {
   VkDeviceGroupSubmitInfo nonRaiiObj;
    std::vector<uint32_t>                       vecWaitSemaphoreDeviceIndices;
    std::vector<uint32_t>                       vecCommandBufferDeviceMasks;
    std::vector<uint32_t>                       vecSignalSemaphoreDeviceIndices;
};

std::shared_ptr<VkDeviceGroupSubmitInfoRAII> DeviceGroupSubmitInfo(
    unsigned int* pWaitSemaphoreDeviceIndices_in_array1, int pWaitSemaphoreDeviceIndices_dim1,
    unsigned int* pCommandBufferDeviceMasks_in_array1, int pCommandBufferDeviceMasks_dim1,
    unsigned int* pSignalSemaphoreDeviceIndices_in_array1, int pSignalSemaphoreDeviceIndices_dim1)
   {
      std::shared_ptr<VkDeviceGroupSubmitInfoRAII> raii_obj(new VkDeviceGroupSubmitInfoRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.waitSemaphoreCount = static_cast<uint32_t>(pWaitSemaphoreDeviceIndices_dim1);
      raii_obj->vecWaitSemaphoreDeviceIndices.assign(pWaitSemaphoreDeviceIndices_in_array1, pWaitSemaphoreDeviceIndices_in_array1 + pWaitSemaphoreDeviceIndices_dim1);
      if ( raii_obj->vecWaitSemaphoreDeviceIndices.size() > 0)
      {
          raii_obj->nonRaiiObj.pWaitSemaphoreDeviceIndices = &raii_obj->vecWaitSemaphoreDeviceIndices[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pWaitSemaphoreDeviceIndices = nullptr;
      }
      raii_obj->nonRaiiObj.commandBufferCount = static_cast<uint32_t>(pCommandBufferDeviceMasks_dim1);
      raii_obj->vecCommandBufferDeviceMasks.assign(pCommandBufferDeviceMasks_in_array1, pCommandBufferDeviceMasks_in_array1 + pCommandBufferDeviceMasks_dim1);
      if ( raii_obj->vecCommandBufferDeviceMasks.size() > 0)
      {
          raii_obj->nonRaiiObj.pCommandBufferDeviceMasks = &raii_obj->vecCommandBufferDeviceMasks[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pCommandBufferDeviceMasks = nullptr;
      }
      raii_obj->nonRaiiObj.signalSemaphoreCount = static_cast<uint32_t>(pSignalSemaphoreDeviceIndices_dim1);
      raii_obj->vecSignalSemaphoreDeviceIndices.assign(pSignalSemaphoreDeviceIndices_in_array1, pSignalSemaphoreDeviceIndices_in_array1 + pSignalSemaphoreDeviceIndices_dim1);
      if ( raii_obj->vecSignalSemaphoreDeviceIndices.size() > 0)
      {
          raii_obj->nonRaiiObj.pSignalSemaphoreDeviceIndices = &raii_obj->vecSignalSemaphoreDeviceIndices[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pSignalSemaphoreDeviceIndices = nullptr;
      }
      return raii_obj;
   }

VkDeviceGroupBindSparseInfo DeviceGroupBindSparseInfo(
    uint32_t                                    resourceDeviceIndex,
    uint32_t                                    memoryDeviceIndex)
   {
      VkDeviceGroupBindSparseInfo obj;
      obj.sType = VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO;
      obj.pNext = nullptr;
      obj.resourceDeviceIndex = resourceDeviceIndex;
      obj.memoryDeviceIndex = memoryDeviceIndex;
      return obj;
   }

std::shared_ptr< VkPeerMemoryFeatureFlags > getDeviceGroupPeerMemoryFeatures(
        VkDevice device,
        uint32_t heapIndex,
        uint32_t localDeviceIndex,
        uint32_t remoteDeviceIndex)
   {
      std::shared_ptr<VkPeerMemoryFeatureFlags> ptrpPeerMemoryFeatures(new VkPeerMemoryFeatureFlags); 
      vkGetDeviceGroupPeerMemoryFeatures(
          device,
          heapIndex,
          localDeviceIndex,
          remoteDeviceIndex,
          ptrpPeerMemoryFeatures.get()  );
      return ptrpPeerMemoryFeatures; 
   }

void  cmdSetDeviceMask(
        VkCommandBuffer commandBuffer,
        uint32_t deviceMask)
   {
      vkCmdSetDeviceMask(
          commandBuffer,
          deviceMask  );
   }

void  cmdDispatchBase(
        VkCommandBuffer commandBuffer,
        uint32_t baseGroupX,
        uint32_t baseGroupY,
        uint32_t baseGroupZ,
        uint32_t groupCountX,
        uint32_t groupCountY,
        uint32_t groupCountZ)
   {
      vkCmdDispatchBase(
          commandBuffer,
          baseGroupX,
          baseGroupY,
          baseGroupZ,
          groupCountX,
          groupCountY,
          groupCountZ  );
   }

struct VkBindBufferMemoryDeviceGroupInfoRAII {
   VkBindBufferMemoryDeviceGroupInfo nonRaiiObj;
    std::vector<uint32_t>                       vecDeviceIndices;
};

std::shared_ptr<VkBindBufferMemoryDeviceGroupInfoRAII> BindBufferMemoryDeviceGroupInfo(
    unsigned int* pDeviceIndices_in_array1, int pDeviceIndices_dim1)
   {
      std::shared_ptr<VkBindBufferMemoryDeviceGroupInfoRAII> raii_obj(new VkBindBufferMemoryDeviceGroupInfoRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.deviceIndexCount = static_cast<uint32_t>(pDeviceIndices_dim1);
      raii_obj->vecDeviceIndices.assign(pDeviceIndices_in_array1, pDeviceIndices_in_array1 + pDeviceIndices_dim1);
      if ( raii_obj->vecDeviceIndices.size() > 0)
      {
          raii_obj->nonRaiiObj.pDeviceIndices = &raii_obj->vecDeviceIndices[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pDeviceIndices = nullptr;
      }
      return raii_obj;
   }

struct VkBindImageMemoryDeviceGroupInfoRAII {
   VkBindImageMemoryDeviceGroupInfo nonRaiiObj;
    std::vector<uint32_t>                       vecDeviceIndices;
    std::vector<VkRect2D>                       vecSplitInstanceBindRegions;
};

std::shared_ptr<VkBindImageMemoryDeviceGroupInfoRAII> BindImageMemoryDeviceGroupInfo(
    unsigned int* pDeviceIndices_in_array1, int pDeviceIndices_dim1,
    const std::vector<VkRect2D> &               vecSplitInstanceBindRegions)
   {
      std::shared_ptr<VkBindImageMemoryDeviceGroupInfoRAII> raii_obj(new VkBindImageMemoryDeviceGroupInfoRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.deviceIndexCount = static_cast<uint32_t>(pDeviceIndices_dim1);
      raii_obj->vecDeviceIndices.assign(pDeviceIndices_in_array1, pDeviceIndices_in_array1 + pDeviceIndices_dim1);
      if ( raii_obj->vecDeviceIndices.size() > 0)
      {
          raii_obj->nonRaiiObj.pDeviceIndices = &raii_obj->vecDeviceIndices[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pDeviceIndices = nullptr;
      }
      raii_obj->nonRaiiObj.splitInstanceBindRegionCount = static_cast<uint32_t>(vecSplitInstanceBindRegions.size());
      raii_obj->vecSplitInstanceBindRegions = vecSplitInstanceBindRegions;
      if ( raii_obj->vecSplitInstanceBindRegions.size() > 0)
      {
          raii_obj->nonRaiiObj.pSplitInstanceBindRegions = &raii_obj->vecSplitInstanceBindRegions[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pSplitInstanceBindRegions = nullptr;
      }
      return raii_obj;
   }

VkPhysicalDeviceGroupProperties PhysicalDeviceGroupProperties(
    uint32_t                                    physicalDeviceCount,
    VkPhysicalDevice                            physicalDevices[VK_MAX_DEVICE_GROUP_SIZE],
    VkBool32                                    subsetAllocation)
   {
      VkPhysicalDeviceGroupProperties obj;
      obj.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES;
      obj.pNext = nullptr;
      obj.physicalDeviceCount = physicalDeviceCount;
      std::copy(physicalDevices, physicalDevices + VK_MAX_DEVICE_GROUP_SIZE, obj.physicalDevices);
      obj.subsetAllocation = subsetAllocation;
      return obj;
   }

struct VkDeviceGroupDeviceCreateInfoRAII {
   VkDeviceGroupDeviceCreateInfo nonRaiiObj;
    std::vector<VkPhysicalDevice>               vecPhysicalDevices;
};

std::shared_ptr<VkDeviceGroupDeviceCreateInfoRAII> DeviceGroupDeviceCreateInfo(
    const std::vector<VkPhysicalDevice> &       vecPhysicalDevices)
   {
      std::shared_ptr<VkDeviceGroupDeviceCreateInfoRAII> raii_obj(new VkDeviceGroupDeviceCreateInfoRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.physicalDeviceCount = static_cast<uint32_t>(vecPhysicalDevices.size());
      raii_obj->vecPhysicalDevices = vecPhysicalDevices;
      if ( raii_obj->vecPhysicalDevices.size() > 0)
      {
          raii_obj->nonRaiiObj.pPhysicalDevices = &raii_obj->vecPhysicalDevices[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pPhysicalDevices = nullptr;
      }
      return raii_obj;
   }

std::vector< VkPhysicalDeviceGroupProperties > enumeratePhysicalDeviceGroups(
        VkInstance instance)
   {
      std::vector<VkPhysicalDeviceGroupProperties> vecpPhysicalDeviceGroupProperties; 
      uint32_t pPhysicalDeviceGroupPropertiesCount; 
      V( vkEnumeratePhysicalDeviceGroups(
          instance,
          &pPhysicalDeviceGroupPropertiesCount,
          nullptr  ));

      vecpPhysicalDeviceGroupProperties.resize(pPhysicalDeviceGroupPropertiesCount); 

      V( vkEnumeratePhysicalDeviceGroups(
          instance,
          &pPhysicalDeviceGroupPropertiesCount,
          &vecpPhysicalDeviceGroupProperties[0]  ));
      return vecpPhysicalDeviceGroupProperties; 
   }

VkBufferMemoryRequirementsInfo2 BufferMemoryRequirementsInfo2(
    VkBuffer                                    buffer)
   {
      VkBufferMemoryRequirementsInfo2 obj;
      obj.sType = VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2;
      obj.pNext = nullptr;
      obj.buffer = buffer;
      return obj;
   }

VkImageMemoryRequirementsInfo2 ImageMemoryRequirementsInfo2(
    VkImage                                     image)
   {
      VkImageMemoryRequirementsInfo2 obj;
      obj.sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2;
      obj.pNext = nullptr;
      obj.image = image;
      return obj;
   }

VkImageSparseMemoryRequirementsInfo2 ImageSparseMemoryRequirementsInfo2(
    VkImage                                     image)
   {
      VkImageSparseMemoryRequirementsInfo2 obj;
      obj.sType = VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2;
      obj.pNext = nullptr;
      obj.image = image;
      return obj;
   }

VkMemoryRequirements2 MemoryRequirements2(
    VkMemoryRequirements                        memoryRequirements)
   {
      VkMemoryRequirements2 obj;
      obj.sType = VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2;
      obj.pNext = nullptr;
      obj.memoryRequirements = memoryRequirements;
      return obj;
   }

VkSparseImageMemoryRequirements2 SparseImageMemoryRequirements2(
    VkSparseImageMemoryRequirements             memoryRequirements)
   {
      VkSparseImageMemoryRequirements2 obj;
      obj.sType = VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2;
      obj.pNext = nullptr;
      obj.memoryRequirements = memoryRequirements;
      return obj;
   }

VkMemoryRequirements2 getImageMemoryRequirements2(
        VkDevice device,
        const VkImageMemoryRequirementsInfo2 & pInfo)
   {
      VkMemoryRequirements2 pMemoryRequirements; 
      vkGetImageMemoryRequirements2(
          device,
          &pInfo,
          &pMemoryRequirements  );
      return pMemoryRequirements; 
   }

VkMemoryRequirements2 getBufferMemoryRequirements2(
        VkDevice device,
        const VkBufferMemoryRequirementsInfo2 & pInfo)
   {
      VkMemoryRequirements2 pMemoryRequirements; 
      vkGetBufferMemoryRequirements2(
          device,
          &pInfo,
          &pMemoryRequirements  );
      return pMemoryRequirements; 
   }

std::vector< VkSparseImageMemoryRequirements2 > getImageSparseMemoryRequirements2(
        VkDevice device,
        const VkImageSparseMemoryRequirementsInfo2 & pInfo)
   {
      std::vector<VkSparseImageMemoryRequirements2> vecpSparseMemoryRequirements; 
      uint32_t pSparseMemoryRequirementsCount; 
      vkGetImageSparseMemoryRequirements2(
          device,
          &pInfo,
          &pSparseMemoryRequirementsCount,
          nullptr  );

      vecpSparseMemoryRequirements.resize(pSparseMemoryRequirementsCount); 

      vkGetImageSparseMemoryRequirements2(
          device,
          &pInfo,
          &pSparseMemoryRequirementsCount,
          &vecpSparseMemoryRequirements[0]  );
      return vecpSparseMemoryRequirements; 
   }

VkPhysicalDeviceFeatures2 PhysicalDeviceFeatures2(
    VkPhysicalDeviceFeatures                    features)
   {
      VkPhysicalDeviceFeatures2 obj;
      obj.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
      obj.pNext = nullptr;
      obj.features = features;
      return obj;
   }

VkPhysicalDeviceProperties2 PhysicalDeviceProperties2(
    VkPhysicalDeviceProperties                  properties)
   {
      VkPhysicalDeviceProperties2 obj;
      obj.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2;
      obj.pNext = nullptr;
      obj.properties = properties;
      return obj;
   }

VkFormatProperties2 FormatProperties2(
    VkFormatProperties                          formatProperties)
   {
      VkFormatProperties2 obj;
      obj.sType = VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2;
      obj.pNext = nullptr;
      obj.formatProperties = formatProperties;
      return obj;
   }

VkImageFormatProperties2 ImageFormatProperties2(
    VkImageFormatProperties                     imageFormatProperties)
   {
      VkImageFormatProperties2 obj;
      obj.sType = VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2;
      obj.pNext = nullptr;
      obj.imageFormatProperties = imageFormatProperties;
      return obj;
   }

VkPhysicalDeviceImageFormatInfo2 PhysicalDeviceImageFormatInfo2(
    VkFormat                                    format,
    VkImageType                                 type,
    VkImageTiling                               tiling,
    VkImageUsageFlags                           usage,
    VkImageCreateFlags                          flags)
   {
      VkPhysicalDeviceImageFormatInfo2 obj;
      obj.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2;
      obj.pNext = nullptr;
      obj.format = format;
      obj.type = type;
      obj.tiling = tiling;
      obj.usage = usage;
      obj.flags = flags;
      return obj;
   }

VkQueueFamilyProperties2 QueueFamilyProperties2(
    VkQueueFamilyProperties                     queueFamilyProperties)
   {
      VkQueueFamilyProperties2 obj;
      obj.sType = VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2;
      obj.pNext = nullptr;
      obj.queueFamilyProperties = queueFamilyProperties;
      return obj;
   }

VkPhysicalDeviceMemoryProperties2 PhysicalDeviceMemoryProperties2(
    VkPhysicalDeviceMemoryProperties            memoryProperties)
   {
      VkPhysicalDeviceMemoryProperties2 obj;
      obj.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2;
      obj.pNext = nullptr;
      obj.memoryProperties = memoryProperties;
      return obj;
   }

VkSparseImageFormatProperties2 SparseImageFormatProperties2(
    VkSparseImageFormatProperties               properties)
   {
      VkSparseImageFormatProperties2 obj;
      obj.sType = VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2;
      obj.pNext = nullptr;
      obj.properties = properties;
      return obj;
   }

VkPhysicalDeviceSparseImageFormatInfo2 PhysicalDeviceSparseImageFormatInfo2(
    VkFormat                                    format,
    VkImageType                                 type,
    VkSampleCountFlagBits                       samples,
    VkImageUsageFlags                           usage,
    VkImageTiling                               tiling)
   {
      VkPhysicalDeviceSparseImageFormatInfo2 obj;
      obj.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2;
      obj.pNext = nullptr;
      obj.format = format;
      obj.type = type;
      obj.samples = samples;
      obj.usage = usage;
      obj.tiling = tiling;
      return obj;
   }

VkPhysicalDeviceFeatures2 getPhysicalDeviceFeatures2(
        VkPhysicalDevice physicalDevice)
   {
      VkPhysicalDeviceFeatures2 pFeatures; 
      vkGetPhysicalDeviceFeatures2(
          physicalDevice,
          &pFeatures  );
      return pFeatures; 
   }

VkPhysicalDeviceProperties2 getPhysicalDeviceProperties2(
        VkPhysicalDevice physicalDevice)
   {
      VkPhysicalDeviceProperties2 pProperties; 
      vkGetPhysicalDeviceProperties2(
          physicalDevice,
          &pProperties  );
      return pProperties; 
   }

VkFormatProperties2 getPhysicalDeviceFormatProperties2(
        VkPhysicalDevice physicalDevice,
        VkFormat format)
   {
      VkFormatProperties2 pFormatProperties; 
      vkGetPhysicalDeviceFormatProperties2(
          physicalDevice,
          format,
          &pFormatProperties  );
      return pFormatProperties; 
   }

VkImageFormatProperties2 getPhysicalDeviceImageFormatProperties2(
        VkPhysicalDevice physicalDevice,
        const VkPhysicalDeviceImageFormatInfo2 & pImageFormatInfo)
   {
      VkImageFormatProperties2 pImageFormatProperties; 
      V( vkGetPhysicalDeviceImageFormatProperties2(
          physicalDevice,
          &pImageFormatInfo,
          &pImageFormatProperties  ));
      return pImageFormatProperties; 
   }

std::vector< VkQueueFamilyProperties2 > getPhysicalDeviceQueueFamilyProperties2(
        VkPhysicalDevice physicalDevice)
   {
      std::vector<VkQueueFamilyProperties2> vecpQueueFamilyProperties; 
      uint32_t pQueueFamilyPropertiesCount; 
      vkGetPhysicalDeviceQueueFamilyProperties2(
          physicalDevice,
          &pQueueFamilyPropertiesCount,
          nullptr  );

      vecpQueueFamilyProperties.resize(pQueueFamilyPropertiesCount); 

      vkGetPhysicalDeviceQueueFamilyProperties2(
          physicalDevice,
          &pQueueFamilyPropertiesCount,
          &vecpQueueFamilyProperties[0]  );
      return vecpQueueFamilyProperties; 
   }

VkPhysicalDeviceMemoryProperties2 getPhysicalDeviceMemoryProperties2(
        VkPhysicalDevice physicalDevice)
   {
      VkPhysicalDeviceMemoryProperties2 pMemoryProperties; 
      vkGetPhysicalDeviceMemoryProperties2(
          physicalDevice,
          &pMemoryProperties  );
      return pMemoryProperties; 
   }

std::vector< VkSparseImageFormatProperties2 > getPhysicalDeviceSparseImageFormatProperties2(
        VkPhysicalDevice physicalDevice,
        const VkPhysicalDeviceSparseImageFormatInfo2 & pFormatInfo)
   {
      std::vector<VkSparseImageFormatProperties2> vecpProperties; 
      uint32_t pPropertiesCount; 
      vkGetPhysicalDeviceSparseImageFormatProperties2(
          physicalDevice,
          &pFormatInfo,
          &pPropertiesCount,
          nullptr  );

      vecpProperties.resize(pPropertiesCount); 

      vkGetPhysicalDeviceSparseImageFormatProperties2(
          physicalDevice,
          &pFormatInfo,
          &pPropertiesCount,
          &vecpProperties[0]  );
      return vecpProperties; 
   }

void  trimCommandPool(
        VkDevice device,
        VkCommandPool commandPool,
        VkCommandPoolTrimFlags flags)
   {
      vkTrimCommandPool(
          device,
          commandPool,
          flags  );
   }

VkPhysicalDevicePointClippingProperties PhysicalDevicePointClippingProperties(
    VkPointClippingBehavior                     pointClippingBehavior)
   {
      VkPhysicalDevicePointClippingProperties obj;
      obj.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES;
      obj.pNext = nullptr;
      obj.pointClippingBehavior = pointClippingBehavior;
      return obj;
   }

VkInputAttachmentAspectReference InputAttachmentAspectReference(
    uint32_t                                    subpass,
    uint32_t                                    inputAttachmentIndex,
    VkImageAspectFlags                          aspectMask)
   {
      VkInputAttachmentAspectReference obj;
      obj.subpass = subpass;
      obj.inputAttachmentIndex = inputAttachmentIndex;
      obj.aspectMask = aspectMask;
      return obj;
   }

struct VkRenderPassInputAttachmentAspectCreateInfoRAII {
   VkRenderPassInputAttachmentAspectCreateInfo nonRaiiObj;
    std::vector<VkInputAttachmentAspectReference>vecAspectReferences;
};

std::shared_ptr<VkRenderPassInputAttachmentAspectCreateInfoRAII> RenderPassInputAttachmentAspectCreateInfo(
    const std::vector<VkInputAttachmentAspectReference> &vecAspectReferences)
   {
      std::shared_ptr<VkRenderPassInputAttachmentAspectCreateInfoRAII> raii_obj(new VkRenderPassInputAttachmentAspectCreateInfoRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.aspectReferenceCount = static_cast<uint32_t>(vecAspectReferences.size());
      raii_obj->vecAspectReferences = vecAspectReferences;
      if ( raii_obj->vecAspectReferences.size() > 0)
      {
          raii_obj->nonRaiiObj.pAspectReferences = &raii_obj->vecAspectReferences[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pAspectReferences = nullptr;
      }
      return raii_obj;
   }

VkImageViewUsageCreateInfo ImageViewUsageCreateInfo(
    VkImageUsageFlags                           usage)
   {
      VkImageViewUsageCreateInfo obj;
      obj.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO;
      obj.pNext = nullptr;
      obj.usage = usage;
      return obj;
   }

VkPipelineTessellationDomainOriginStateCreateInfo PipelineTessellationDomainOriginStateCreateInfo(
    VkTessellationDomainOrigin                  domainOrigin)
   {
      VkPipelineTessellationDomainOriginStateCreateInfo obj;
      obj.sType = VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO;
      obj.pNext = nullptr;
      obj.domainOrigin = domainOrigin;
      return obj;
   }

struct VkRenderPassMultiviewCreateInfoRAII {
   VkRenderPassMultiviewCreateInfo nonRaiiObj;
    std::vector<uint32_t>                       vecViewMasks;
    std::vector<int32_t>                        vecViewOffsets;
    std::vector<uint32_t>                       vecCorrelationMasks;
};

std::shared_ptr<VkRenderPassMultiviewCreateInfoRAII> RenderPassMultiviewCreateInfo(
    unsigned int* pViewMasks_in_array1, int pViewMasks_dim1,
    int* pViewOffsets_in_array1, int pViewOffsets_dim1,
    unsigned int* pCorrelationMasks_in_array1, int pCorrelationMasks_dim1)
   {
      std::shared_ptr<VkRenderPassMultiviewCreateInfoRAII> raii_obj(new VkRenderPassMultiviewCreateInfoRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.subpassCount = static_cast<uint32_t>(pViewMasks_dim1);
      raii_obj->vecViewMasks.assign(pViewMasks_in_array1, pViewMasks_in_array1 + pViewMasks_dim1);
      if ( raii_obj->vecViewMasks.size() > 0)
      {
          raii_obj->nonRaiiObj.pViewMasks = &raii_obj->vecViewMasks[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pViewMasks = nullptr;
      }
      raii_obj->nonRaiiObj.dependencyCount = static_cast<uint32_t>(pViewOffsets_dim1);
      raii_obj->vecViewOffsets.assign(pViewOffsets_in_array1, pViewOffsets_in_array1 + pViewOffsets_dim1);
      if ( raii_obj->vecViewOffsets.size() > 0)
      {
          raii_obj->nonRaiiObj.pViewOffsets = &raii_obj->vecViewOffsets[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pViewOffsets = nullptr;
      }
      raii_obj->nonRaiiObj.correlationMaskCount = static_cast<uint32_t>(pCorrelationMasks_dim1);
      raii_obj->vecCorrelationMasks.assign(pCorrelationMasks_in_array1, pCorrelationMasks_in_array1 + pCorrelationMasks_dim1);
      if ( raii_obj->vecCorrelationMasks.size() > 0)
      {
          raii_obj->nonRaiiObj.pCorrelationMasks = &raii_obj->vecCorrelationMasks[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pCorrelationMasks = nullptr;
      }
      return raii_obj;
   }

VkPhysicalDeviceMultiviewFeatures PhysicalDeviceMultiviewFeatures(
    VkBool32                                    multiview,
    VkBool32                                    multiviewGeometryShader,
    VkBool32                                    multiviewTessellationShader)
   {
      VkPhysicalDeviceMultiviewFeatures obj;
      obj.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES;
      obj.pNext = nullptr;
      obj.multiview = multiview;
      obj.multiviewGeometryShader = multiviewGeometryShader;
      obj.multiviewTessellationShader = multiviewTessellationShader;
      return obj;
   }

VkPhysicalDeviceMultiviewProperties PhysicalDeviceMultiviewProperties(
    uint32_t                                    maxMultiviewViewCount,
    uint32_t                                    maxMultiviewInstanceIndex)
   {
      VkPhysicalDeviceMultiviewProperties obj;
      obj.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES;
      obj.pNext = nullptr;
      obj.maxMultiviewViewCount = maxMultiviewViewCount;
      obj.maxMultiviewInstanceIndex = maxMultiviewInstanceIndex;
      return obj;
   }

VkPhysicalDeviceVariablePointersFeatures PhysicalDeviceVariablePointersFeatures(
    VkBool32                                    variablePointersStorageBuffer,
    VkBool32                                    variablePointers)
   {
      VkPhysicalDeviceVariablePointersFeatures obj;
      obj.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES;
      obj.pNext = nullptr;
      obj.variablePointersStorageBuffer = variablePointersStorageBuffer;
      obj.variablePointers = variablePointers;
      return obj;
   }

VkPhysicalDeviceProtectedMemoryFeatures PhysicalDeviceProtectedMemoryFeatures(
    VkBool32                                    protectedMemory)
   {
      VkPhysicalDeviceProtectedMemoryFeatures obj;
      obj.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES;
      obj.pNext = nullptr;
      obj.protectedMemory = protectedMemory;
      return obj;
   }

VkPhysicalDeviceProtectedMemoryProperties PhysicalDeviceProtectedMemoryProperties(
    VkBool32                                    protectedNoFault)
   {
      VkPhysicalDeviceProtectedMemoryProperties obj;
      obj.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES;
      obj.pNext = nullptr;
      obj.protectedNoFault = protectedNoFault;
      return obj;
   }

VkDeviceQueueInfo2 DeviceQueueInfo2(
    VkDeviceQueueCreateFlags                    flags,
    uint32_t                                    queueFamilyIndex,
    uint32_t                                    queueIndex)
   {
      VkDeviceQueueInfo2 obj;
      obj.sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2;
      obj.pNext = nullptr;
      obj.flags = flags;
      obj.queueFamilyIndex = queueFamilyIndex;
      obj.queueIndex = queueIndex;
      return obj;
   }

VkProtectedSubmitInfo ProtectedSubmitInfo(
    VkBool32                                    protectedSubmit)
   {
      VkProtectedSubmitInfo obj;
      obj.sType = VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO;
      obj.pNext = nullptr;
      obj.protectedSubmit = protectedSubmit;
      return obj;
   }

VkQueue getDeviceQueue2(
        VkDevice device,
        const VkDeviceQueueInfo2 & pQueueInfo)
   {
      VkQueue hQueue; 
      vkGetDeviceQueue2(
          device,
          &pQueueInfo,
          &hQueue  );
      return hQueue; 
   }

VkSamplerYcbcrConversionCreateInfo SamplerYcbcrConversionCreateInfo(
    VkFormat                                    format,
    VkSamplerYcbcrModelConversion               ycbcrModel,
    VkSamplerYcbcrRange                         ycbcrRange,
    VkComponentMapping                          components,
    VkChromaLocation                            xChromaOffset,
    VkChromaLocation                            yChromaOffset,
    VkFilter                                    chromaFilter,
    VkBool32                                    forceExplicitReconstruction)
   {
      VkSamplerYcbcrConversionCreateInfo obj;
      obj.sType = VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO;
      obj.pNext = nullptr;
      obj.format = format;
      obj.ycbcrModel = ycbcrModel;
      obj.ycbcrRange = ycbcrRange;
      obj.components = components;
      obj.xChromaOffset = xChromaOffset;
      obj.yChromaOffset = yChromaOffset;
      obj.chromaFilter = chromaFilter;
      obj.forceExplicitReconstruction = forceExplicitReconstruction;
      return obj;
   }

VkSamplerYcbcrConversionInfo SamplerYcbcrConversionInfo(
    VkSamplerYcbcrConversion                    conversion)
   {
      VkSamplerYcbcrConversionInfo obj;
      obj.sType = VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO;
      obj.pNext = nullptr;
      obj.conversion = conversion;
      return obj;
   }

VkBindImagePlaneMemoryInfo BindImagePlaneMemoryInfo(
    VkImageAspectFlagBits                       planeAspect)
   {
      VkBindImagePlaneMemoryInfo obj;
      obj.sType = VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO;
      obj.pNext = nullptr;
      obj.planeAspect = planeAspect;
      return obj;
   }

VkImagePlaneMemoryRequirementsInfo ImagePlaneMemoryRequirementsInfo(
    VkImageAspectFlagBits                       planeAspect)
   {
      VkImagePlaneMemoryRequirementsInfo obj;
      obj.sType = VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO;
      obj.pNext = nullptr;
      obj.planeAspect = planeAspect;
      return obj;
   }

VkPhysicalDeviceSamplerYcbcrConversionFeatures PhysicalDeviceSamplerYcbcrConversionFeatures(
    VkBool32                                    samplerYcbcrConversion)
   {
      VkPhysicalDeviceSamplerYcbcrConversionFeatures obj;
      obj.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES;
      obj.pNext = nullptr;
      obj.samplerYcbcrConversion = samplerYcbcrConversion;
      return obj;
   }

VkSamplerYcbcrConversionImageFormatProperties SamplerYcbcrConversionImageFormatProperties(
    uint32_t                                    combinedImageSamplerDescriptorCount)
   {
      VkSamplerYcbcrConversionImageFormatProperties obj;
      obj.sType = VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES;
      obj.pNext = nullptr;
      obj.combinedImageSamplerDescriptorCount = combinedImageSamplerDescriptorCount;
      return obj;
   }

std::shared_ptr<VkSamplerYcbcrConversion_T> createSamplerYcbcrConversion(
        VkDevice device,
        const VkSamplerYcbcrConversionCreateInfo & pCreateInfo)
   {
      VkSamplerYcbcrConversion hYcbcrConversion; 
      V( vkCreateSamplerYcbcrConversion(
          device,
          &pCreateInfo,
          nullptr,
          &hYcbcrConversion  ));
      return std::shared_ptr<VkSamplerYcbcrConversion_T>(hYcbcrConversion, 
              [=](VkSamplerYcbcrConversion to_free) {vkDestroySamplerYcbcrConversion(device, to_free, nullptr);});
   }

VkDescriptorUpdateTemplateEntry DescriptorUpdateTemplateEntry(
    uint32_t                                    dstBinding,
    uint32_t                                    dstArrayElement,
    uint32_t                                    descriptorCount,
    VkDescriptorType                            descriptorType,
    size_t                                      offset,
    size_t                                      stride)
   {
      VkDescriptorUpdateTemplateEntry obj;
      obj.dstBinding = dstBinding;
      obj.dstArrayElement = dstArrayElement;
      obj.descriptorCount = descriptorCount;
      obj.descriptorType = descriptorType;
      obj.offset = offset;
      obj.stride = stride;
      return obj;
   }

struct VkDescriptorUpdateTemplateCreateInfoRAII {
   VkDescriptorUpdateTemplateCreateInfo nonRaiiObj;
    std::vector<VkDescriptorUpdateTemplateEntry>vecDescriptorUpdateEntries;
};

std::shared_ptr<VkDescriptorUpdateTemplateCreateInfoRAII> DescriptorUpdateTemplateCreateInfo(
    VkDescriptorUpdateTemplateCreateFlags       flags,
    const std::vector<VkDescriptorUpdateTemplateEntry> &vecDescriptorUpdateEntries,
    VkDescriptorUpdateTemplateType              templateType,
    VkDescriptorSetLayout                       descriptorSetLayout,
    VkPipelineBindPoint                         pipelineBindPoint,
    VkPipelineLayout                            pipelineLayout,
    uint32_t                                    set)
   {
      std::shared_ptr<VkDescriptorUpdateTemplateCreateInfoRAII> raii_obj(new VkDescriptorUpdateTemplateCreateInfoRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.flags = flags;
      raii_obj->nonRaiiObj.descriptorUpdateEntryCount = static_cast<uint32_t>(vecDescriptorUpdateEntries.size());
      raii_obj->vecDescriptorUpdateEntries = vecDescriptorUpdateEntries;
      if ( raii_obj->vecDescriptorUpdateEntries.size() > 0)
      {
          raii_obj->nonRaiiObj.pDescriptorUpdateEntries = &raii_obj->vecDescriptorUpdateEntries[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pDescriptorUpdateEntries = nullptr;
      }
      raii_obj->nonRaiiObj.templateType = templateType;
      raii_obj->nonRaiiObj.descriptorSetLayout = descriptorSetLayout;
      raii_obj->nonRaiiObj.pipelineBindPoint = pipelineBindPoint;
      raii_obj->nonRaiiObj.pipelineLayout = pipelineLayout;
      raii_obj->nonRaiiObj.set = set;
      return raii_obj;
   }

std::shared_ptr<VkDescriptorUpdateTemplate_T> createDescriptorUpdateTemplate(
        VkDevice device,
        const VkDescriptorUpdateTemplateCreateInfo & pCreateInfo)
   {
      VkDescriptorUpdateTemplate hDescriptorUpdateTemplate; 
      V( vkCreateDescriptorUpdateTemplate(
          device,
          &pCreateInfo,
          nullptr,
          &hDescriptorUpdateTemplate  ));
      return std::shared_ptr<VkDescriptorUpdateTemplate_T>(hDescriptorUpdateTemplate, 
              [=](VkDescriptorUpdateTemplate to_free) {vkDestroyDescriptorUpdateTemplate(device, to_free, nullptr);});
   }

VkExternalMemoryProperties ExternalMemoryProperties(
    VkExternalMemoryFeatureFlags                externalMemoryFeatures,
    VkExternalMemoryHandleTypeFlags             exportFromImportedHandleTypes,
    VkExternalMemoryHandleTypeFlags             compatibleHandleTypes)
   {
      VkExternalMemoryProperties obj;
      obj.externalMemoryFeatures = externalMemoryFeatures;
      obj.exportFromImportedHandleTypes = exportFromImportedHandleTypes;
      obj.compatibleHandleTypes = compatibleHandleTypes;
      return obj;
   }

VkPhysicalDeviceExternalImageFormatInfo PhysicalDeviceExternalImageFormatInfo(
    VkExternalMemoryHandleTypeFlagBits          handleType)
   {
      VkPhysicalDeviceExternalImageFormatInfo obj;
      obj.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO;
      obj.pNext = nullptr;
      obj.handleType = handleType;
      return obj;
   }

VkExternalImageFormatProperties ExternalImageFormatProperties(
    VkExternalMemoryProperties                  externalMemoryProperties)
   {
      VkExternalImageFormatProperties obj;
      obj.sType = VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES;
      obj.pNext = nullptr;
      obj.externalMemoryProperties = externalMemoryProperties;
      return obj;
   }

VkPhysicalDeviceExternalBufferInfo PhysicalDeviceExternalBufferInfo(
    VkBufferCreateFlags                         flags,
    VkBufferUsageFlags                          usage,
    VkExternalMemoryHandleTypeFlagBits          handleType)
   {
      VkPhysicalDeviceExternalBufferInfo obj;
      obj.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO;
      obj.pNext = nullptr;
      obj.flags = flags;
      obj.usage = usage;
      obj.handleType = handleType;
      return obj;
   }

VkExternalBufferProperties ExternalBufferProperties(
    VkExternalMemoryProperties                  externalMemoryProperties)
   {
      VkExternalBufferProperties obj;
      obj.sType = VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES;
      obj.pNext = nullptr;
      obj.externalMemoryProperties = externalMemoryProperties;
      return obj;
   }

VkPhysicalDeviceIDProperties PhysicalDeviceIDProperties(
    uint8_t                                     deviceUUID[VK_UUID_SIZE],
    uint8_t                                     driverUUID[VK_UUID_SIZE],
    uint8_t                                     deviceLUID[VK_LUID_SIZE],
    uint32_t                                    deviceNodeMask,
    VkBool32                                    deviceLUIDValid)
   {
      VkPhysicalDeviceIDProperties obj;
      obj.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES;
      obj.pNext = nullptr;
      std::copy(deviceUUID, deviceUUID + VK_UUID_SIZE, obj.deviceUUID);
      std::copy(driverUUID, driverUUID + VK_UUID_SIZE, obj.driverUUID);
      std::copy(deviceLUID, deviceLUID + VK_LUID_SIZE, obj.deviceLUID);
      obj.deviceNodeMask = deviceNodeMask;
      obj.deviceLUIDValid = deviceLUIDValid;
      return obj;
   }

VkExternalBufferProperties getPhysicalDeviceExternalBufferProperties(
        VkPhysicalDevice physicalDevice,
        const VkPhysicalDeviceExternalBufferInfo & pExternalBufferInfo)
   {
      VkExternalBufferProperties pExternalBufferProperties; 
      vkGetPhysicalDeviceExternalBufferProperties(
          physicalDevice,
          &pExternalBufferInfo,
          &pExternalBufferProperties  );
      return pExternalBufferProperties; 
   }

VkExternalMemoryImageCreateInfo ExternalMemoryImageCreateInfo(
    VkExternalMemoryHandleTypeFlags             handleTypes)
   {
      VkExternalMemoryImageCreateInfo obj;
      obj.sType = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO;
      obj.pNext = nullptr;
      obj.handleTypes = handleTypes;
      return obj;
   }

VkExternalMemoryBufferCreateInfo ExternalMemoryBufferCreateInfo(
    VkExternalMemoryHandleTypeFlags             handleTypes)
   {
      VkExternalMemoryBufferCreateInfo obj;
      obj.sType = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO;
      obj.pNext = nullptr;
      obj.handleTypes = handleTypes;
      return obj;
   }

VkExportMemoryAllocateInfo ExportMemoryAllocateInfo(
    VkExternalMemoryHandleTypeFlags             handleTypes)
   {
      VkExportMemoryAllocateInfo obj;
      obj.sType = VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO;
      obj.pNext = nullptr;
      obj.handleTypes = handleTypes;
      return obj;
   }

VkPhysicalDeviceExternalFenceInfo PhysicalDeviceExternalFenceInfo(
    VkExternalFenceHandleTypeFlagBits           handleType)
   {
      VkPhysicalDeviceExternalFenceInfo obj;
      obj.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO;
      obj.pNext = nullptr;
      obj.handleType = handleType;
      return obj;
   }

VkExternalFenceProperties ExternalFenceProperties(
    VkExternalFenceHandleTypeFlags              exportFromImportedHandleTypes,
    VkExternalFenceHandleTypeFlags              compatibleHandleTypes,
    VkExternalFenceFeatureFlags                 externalFenceFeatures)
   {
      VkExternalFenceProperties obj;
      obj.sType = VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES;
      obj.pNext = nullptr;
      obj.exportFromImportedHandleTypes = exportFromImportedHandleTypes;
      obj.compatibleHandleTypes = compatibleHandleTypes;
      obj.externalFenceFeatures = externalFenceFeatures;
      return obj;
   }

VkExternalFenceProperties getPhysicalDeviceExternalFenceProperties(
        VkPhysicalDevice physicalDevice,
        const VkPhysicalDeviceExternalFenceInfo & pExternalFenceInfo)
   {
      VkExternalFenceProperties pExternalFenceProperties; 
      vkGetPhysicalDeviceExternalFenceProperties(
          physicalDevice,
          &pExternalFenceInfo,
          &pExternalFenceProperties  );
      return pExternalFenceProperties; 
   }

VkExportFenceCreateInfo ExportFenceCreateInfo(
    VkExternalFenceHandleTypeFlags              handleTypes)
   {
      VkExportFenceCreateInfo obj;
      obj.sType = VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO;
      obj.pNext = nullptr;
      obj.handleTypes = handleTypes;
      return obj;
   }

VkExportSemaphoreCreateInfo ExportSemaphoreCreateInfo(
    VkExternalSemaphoreHandleTypeFlags          handleTypes)
   {
      VkExportSemaphoreCreateInfo obj;
      obj.sType = VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO;
      obj.pNext = nullptr;
      obj.handleTypes = handleTypes;
      return obj;
   }

VkPhysicalDeviceExternalSemaphoreInfo PhysicalDeviceExternalSemaphoreInfo(
    VkExternalSemaphoreHandleTypeFlagBits       handleType)
   {
      VkPhysicalDeviceExternalSemaphoreInfo obj;
      obj.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO;
      obj.pNext = nullptr;
      obj.handleType = handleType;
      return obj;
   }

VkExternalSemaphoreProperties ExternalSemaphoreProperties(
    VkExternalSemaphoreHandleTypeFlags          exportFromImportedHandleTypes,
    VkExternalSemaphoreHandleTypeFlags          compatibleHandleTypes,
    VkExternalSemaphoreFeatureFlags             externalSemaphoreFeatures)
   {
      VkExternalSemaphoreProperties obj;
      obj.sType = VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES;
      obj.pNext = nullptr;
      obj.exportFromImportedHandleTypes = exportFromImportedHandleTypes;
      obj.compatibleHandleTypes = compatibleHandleTypes;
      obj.externalSemaphoreFeatures = externalSemaphoreFeatures;
      return obj;
   }

VkExternalSemaphoreProperties getPhysicalDeviceExternalSemaphoreProperties(
        VkPhysicalDevice physicalDevice,
        const VkPhysicalDeviceExternalSemaphoreInfo & pExternalSemaphoreInfo)
   {
      VkExternalSemaphoreProperties pExternalSemaphoreProperties; 
      vkGetPhysicalDeviceExternalSemaphoreProperties(
          physicalDevice,
          &pExternalSemaphoreInfo,
          &pExternalSemaphoreProperties  );
      return pExternalSemaphoreProperties; 
   }

VkPhysicalDeviceMaintenance3Properties PhysicalDeviceMaintenance3Properties(
    uint32_t                                    maxPerSetDescriptors,
    VkDeviceSize                                maxMemoryAllocationSize)
   {
      VkPhysicalDeviceMaintenance3Properties obj;
      obj.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES;
      obj.pNext = nullptr;
      obj.maxPerSetDescriptors = maxPerSetDescriptors;
      obj.maxMemoryAllocationSize = maxMemoryAllocationSize;
      return obj;
   }

VkDescriptorSetLayoutSupport DescriptorSetLayoutSupport(
    VkBool32                                    supported)
   {
      VkDescriptorSetLayoutSupport obj;
      obj.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT;
      obj.pNext = nullptr;
      obj.supported = supported;
      return obj;
   }

VkDescriptorSetLayoutSupport getDescriptorSetLayoutSupport(
        VkDevice device,
        const VkDescriptorSetLayoutCreateInfo & pCreateInfo)
   {
      VkDescriptorSetLayoutSupport pSupport; 
      vkGetDescriptorSetLayoutSupport(
          device,
          &pCreateInfo,
          &pSupport  );
      return pSupport; 
   }

VkPhysicalDeviceShaderDrawParametersFeatures PhysicalDeviceShaderDrawParametersFeatures(
    VkBool32                                    shaderDrawParameters)
   {
      VkPhysicalDeviceShaderDrawParametersFeatures obj;
      obj.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES;
      obj.pNext = nullptr;
      obj.shaderDrawParameters = shaderDrawParameters;
      return obj;
   }

VkBool32 getPhysicalDeviceSurfaceSupportKHR(
        VkPhysicalDevice physicalDevice,
        uint32_t queueFamilyIndex,
        VkSurfaceKHR surface)
   {
      VkBool32 pSupported; 
      V( vkGetPhysicalDeviceSurfaceSupportKHR(
          physicalDevice,
          queueFamilyIndex,
          surface,
          &pSupported  ));
      return pSupported; 
   }

VkSurfaceCapabilitiesKHR SurfaceCapabilitiesKHR(
    uint32_t                                    minImageCount,
    uint32_t                                    maxImageCount,
    VkExtent2D                                  currentExtent,
    VkExtent2D                                  minImageExtent,
    VkExtent2D                                  maxImageExtent,
    uint32_t                                    maxImageArrayLayers,
    VkSurfaceTransformFlagsKHR                  supportedTransforms,
    VkSurfaceTransformFlagBitsKHR               currentTransform,
    VkCompositeAlphaFlagsKHR                    supportedCompositeAlpha,
    VkImageUsageFlags                           supportedUsageFlags)
   {
      VkSurfaceCapabilitiesKHR obj;
      obj.minImageCount = minImageCount;
      obj.maxImageCount = maxImageCount;
      obj.currentExtent = currentExtent;
      obj.minImageExtent = minImageExtent;
      obj.maxImageExtent = maxImageExtent;
      obj.maxImageArrayLayers = maxImageArrayLayers;
      obj.supportedTransforms = supportedTransforms;
      obj.currentTransform = currentTransform;
      obj.supportedCompositeAlpha = supportedCompositeAlpha;
      obj.supportedUsageFlags = supportedUsageFlags;
      return obj;
   }

VkSurfaceCapabilitiesKHR getPhysicalDeviceSurfaceCapabilitiesKHR(
        VkPhysicalDevice physicalDevice,
        VkSurfaceKHR surface)
   {
      VkSurfaceCapabilitiesKHR pSurfaceCapabilities; 
      V( vkGetPhysicalDeviceSurfaceCapabilitiesKHR(
          physicalDevice,
          surface,
          &pSurfaceCapabilities  ));
      return pSurfaceCapabilities; 
   }

VkSurfaceFormatKHR SurfaceFormatKHR(
    VkFormat                                    format,
    VkColorSpaceKHR                             colorSpace)
   {
      VkSurfaceFormatKHR obj;
      obj.format = format;
      obj.colorSpace = colorSpace;
      return obj;
   }

std::vector< VkSurfaceFormatKHR > getPhysicalDeviceSurfaceFormatsKHR(
        VkPhysicalDevice physicalDevice,
        VkSurfaceKHR surface)
   {
      std::vector<VkSurfaceFormatKHR> vecpSurfaceFormats; 
      uint32_t pSurfaceFormatsCount; 
      V( vkGetPhysicalDeviceSurfaceFormatsKHR(
          physicalDevice,
          surface,
          &pSurfaceFormatsCount,
          nullptr  ));

      vecpSurfaceFormats.resize(pSurfaceFormatsCount); 

      V( vkGetPhysicalDeviceSurfaceFormatsKHR(
          physicalDevice,
          surface,
          &pSurfaceFormatsCount,
          &vecpSurfaceFormats[0]  ));
      return vecpSurfaceFormats; 
   }

std::vector< VkPresentModeKHR > getPhysicalDeviceSurfacePresentModesKHR(
        VkPhysicalDevice physicalDevice,
        VkSurfaceKHR surface)
   {
      std::vector<VkPresentModeKHR> vecpPresentModes; 
      uint32_t pPresentModesCount; 
      V( vkGetPhysicalDeviceSurfacePresentModesKHR(
          physicalDevice,
          surface,
          &pPresentModesCount,
          nullptr  ));

      vecpPresentModes.resize(pPresentModesCount); 

      V( vkGetPhysicalDeviceSurfacePresentModesKHR(
          physicalDevice,
          surface,
          &pPresentModesCount,
          &vecpPresentModes[0]  ));
      return vecpPresentModes; 
   }

struct VkSwapchainCreateInfoKHRRAII {
   VkSwapchainCreateInfoKHR nonRaiiObj;
    std::vector<uint32_t>                       vecQueueFamilyIndices;
};

std::shared_ptr<VkSwapchainCreateInfoKHRRAII> SwapchainCreateInfoKHR(
    VkSwapchainCreateFlagsKHR                   flags,
    VkSurfaceKHR                                surface,
    uint32_t                                    minImageCount,
    VkFormat                                    imageFormat,
    VkColorSpaceKHR                             imageColorSpace,
    VkExtent2D                                  imageExtent,
    uint32_t                                    imageArrayLayers,
    VkImageUsageFlags                           imageUsage,
    VkSharingMode                               imageSharingMode,
    unsigned int* pQueueFamilyIndices_in_array1, int pQueueFamilyIndices_dim1,
    VkSurfaceTransformFlagBitsKHR               preTransform,
    VkCompositeAlphaFlagBitsKHR                 compositeAlpha,
    VkPresentModeKHR                            presentMode,
    VkBool32                                    clipped,
    VkSwapchainKHR                              oldSwapchain)
   {
      std::shared_ptr<VkSwapchainCreateInfoKHRRAII> raii_obj(new VkSwapchainCreateInfoKHRRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.flags = flags;
      raii_obj->nonRaiiObj.surface = surface;
      raii_obj->nonRaiiObj.minImageCount = minImageCount;
      raii_obj->nonRaiiObj.imageFormat = imageFormat;
      raii_obj->nonRaiiObj.imageColorSpace = imageColorSpace;
      raii_obj->nonRaiiObj.imageExtent = imageExtent;
      raii_obj->nonRaiiObj.imageArrayLayers = imageArrayLayers;
      raii_obj->nonRaiiObj.imageUsage = imageUsage;
      raii_obj->nonRaiiObj.imageSharingMode = imageSharingMode;
      raii_obj->nonRaiiObj.queueFamilyIndexCount = static_cast<uint32_t>(pQueueFamilyIndices_dim1);
      raii_obj->vecQueueFamilyIndices.assign(pQueueFamilyIndices_in_array1, pQueueFamilyIndices_in_array1 + pQueueFamilyIndices_dim1);
      if ( raii_obj->vecQueueFamilyIndices.size() > 0)
      {
          raii_obj->nonRaiiObj.pQueueFamilyIndices = &raii_obj->vecQueueFamilyIndices[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pQueueFamilyIndices = nullptr;
      }
      raii_obj->nonRaiiObj.preTransform = preTransform;
      raii_obj->nonRaiiObj.compositeAlpha = compositeAlpha;
      raii_obj->nonRaiiObj.presentMode = presentMode;
      raii_obj->nonRaiiObj.clipped = clipped;
      raii_obj->nonRaiiObj.oldSwapchain = oldSwapchain;
      return raii_obj;
   }

std::shared_ptr<VkSwapchainKHR_T> createSwapchainKHR(
        VkDevice device,
        const VkSwapchainCreateInfoKHR & pCreateInfo)
   {
      VkSwapchainKHR hSwapchain; 
      V( vkCreateSwapchainKHR(
          device,
          &pCreateInfo,
          nullptr,
          &hSwapchain  ));
      return std::shared_ptr<VkSwapchainKHR_T>(hSwapchain, 
              [=](VkSwapchainKHR to_free) {vkDestroySwapchainKHR(device, to_free, nullptr);});
   }

std::vector< VkImage > getSwapchainImagesKHR(
        VkDevice device,
        VkSwapchainKHR swapchain)
   {
      std::vector<VkImage> vecpSwapchainImages; 
      uint32_t pSwapchainImagesCount; 
      V( vkGetSwapchainImagesKHR(
          device,
          swapchain,
          &pSwapchainImagesCount,
          nullptr  ));

      vecpSwapchainImages.resize(pSwapchainImagesCount); 

      V( vkGetSwapchainImagesKHR(
          device,
          swapchain,
          &pSwapchainImagesCount,
          &vecpSwapchainImages[0]  ));
      return vecpSwapchainImages; 
   }

uint32_t acquireNextImageKHR(
        VkDevice device,
        VkSwapchainKHR swapchain,
        uint64_t timeout,
        VkSemaphore semaphore,
        VkFence fence)
   {
      uint32_t pImageIndex; 
      V( vkAcquireNextImageKHR(
          device,
          swapchain,
          timeout,
          semaphore,
          fence,
          &pImageIndex  ));
      return pImageIndex; 
   }

struct VkPresentInfoKHRRAII {
   VkPresentInfoKHR nonRaiiObj;
    std::vector<VkSemaphore>                    vecWaitSemaphores;
    std::vector<VkSwapchainKHR>                 vecSwapchains;
    std::vector<uint32_t>                       vecImageIndices;
    std::vector<VkResult>                       vecResults;
};

std::shared_ptr<VkPresentInfoKHRRAII> PresentInfoKHR(
    const std::vector<VkSemaphore> &            vecWaitSemaphores,
    const std::vector<VkSwapchainKHR> &         vecSwapchains,
    unsigned int* pImageIndices_in_array1, int pImageIndices_dim1,
    const std::vector<VkResult> &               vecResults)
   {
      std::shared_ptr<VkPresentInfoKHRRAII> raii_obj(new VkPresentInfoKHRRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.waitSemaphoreCount = static_cast<uint32_t>(vecWaitSemaphores.size());
      raii_obj->vecWaitSemaphores = vecWaitSemaphores;
      if ( raii_obj->vecWaitSemaphores.size() > 0)
      {
          raii_obj->nonRaiiObj.pWaitSemaphores = &raii_obj->vecWaitSemaphores[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pWaitSemaphores = nullptr;
      }
      raii_obj->nonRaiiObj.swapchainCount = static_cast<uint32_t>(vecSwapchains.size());
      raii_obj->vecSwapchains = vecSwapchains;
      if ( raii_obj->vecSwapchains.size() > 0)
      {
          raii_obj->nonRaiiObj.pSwapchains = &raii_obj->vecSwapchains[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pSwapchains = nullptr;
      }
      raii_obj->vecImageIndices.assign(pImageIndices_in_array1, pImageIndices_in_array1 + pImageIndices_dim1);
      if ( raii_obj->vecImageIndices.size() > 0)
      {
          raii_obj->nonRaiiObj.pImageIndices = &raii_obj->vecImageIndices[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pImageIndices = nullptr;
      }
      raii_obj->vecResults = vecResults;
      if ( raii_obj->vecResults.size() > 0)
      {
          raii_obj->nonRaiiObj.pResults = &raii_obj->vecResults[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pResults = nullptr;
      }
      return raii_obj;
   }

void  queuePresentKHR(
        VkQueue queue,
        const VkPresentInfoKHR & pPresentInfo)
   {
      V( vkQueuePresentKHR(
          queue,
          &pPresentInfo  ));
   }

VkImageSwapchainCreateInfoKHR ImageSwapchainCreateInfoKHR(
    VkSwapchainKHR                              swapchain)
   {
      VkImageSwapchainCreateInfoKHR obj;
      obj.sType = VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR;
      obj.pNext = nullptr;
      obj.swapchain = swapchain;
      return obj;
   }

VkBindImageMemorySwapchainInfoKHR BindImageMemorySwapchainInfoKHR(
    VkSwapchainKHR                              swapchain,
    uint32_t                                    imageIndex)
   {
      VkBindImageMemorySwapchainInfoKHR obj;
      obj.sType = VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR;
      obj.pNext = nullptr;
      obj.swapchain = swapchain;
      obj.imageIndex = imageIndex;
      return obj;
   }

VkAcquireNextImageInfoKHR AcquireNextImageInfoKHR(
    VkSwapchainKHR                              swapchain,
    uint64_t                                    timeout,
    VkSemaphore                                 semaphore,
    VkFence                                     fence,
    uint32_t                                    deviceMask)
   {
      VkAcquireNextImageInfoKHR obj;
      obj.sType = VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR;
      obj.pNext = nullptr;
      obj.swapchain = swapchain;
      obj.timeout = timeout;
      obj.semaphore = semaphore;
      obj.fence = fence;
      obj.deviceMask = deviceMask;
      return obj;
   }

VkDeviceGroupPresentCapabilitiesKHR DeviceGroupPresentCapabilitiesKHR(
    uint32_t                                    presentMask[VK_MAX_DEVICE_GROUP_SIZE],
    VkDeviceGroupPresentModeFlagsKHR            modes)
   {
      VkDeviceGroupPresentCapabilitiesKHR obj;
      obj.sType = VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR;
      obj.pNext = nullptr;
      std::copy(presentMask, presentMask + VK_MAX_DEVICE_GROUP_SIZE, obj.presentMask);
      obj.modes = modes;
      return obj;
   }

struct VkDeviceGroupPresentInfoKHRRAII {
   VkDeviceGroupPresentInfoKHR nonRaiiObj;
    std::vector<uint32_t>                       vecDeviceMasks;
};

std::shared_ptr<VkDeviceGroupPresentInfoKHRRAII> DeviceGroupPresentInfoKHR(
    unsigned int* pDeviceMasks_in_array1, int pDeviceMasks_dim1,
    VkDeviceGroupPresentModeFlagBitsKHR         mode)
   {
      std::shared_ptr<VkDeviceGroupPresentInfoKHRRAII> raii_obj(new VkDeviceGroupPresentInfoKHRRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.swapchainCount = static_cast<uint32_t>(pDeviceMasks_dim1);
      raii_obj->vecDeviceMasks.assign(pDeviceMasks_in_array1, pDeviceMasks_in_array1 + pDeviceMasks_dim1);
      if ( raii_obj->vecDeviceMasks.size() > 0)
      {
          raii_obj->nonRaiiObj.pDeviceMasks = &raii_obj->vecDeviceMasks[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pDeviceMasks = nullptr;
      }
      raii_obj->nonRaiiObj.mode = mode;
      return raii_obj;
   }

VkDeviceGroupSwapchainCreateInfoKHR DeviceGroupSwapchainCreateInfoKHR(
    VkDeviceGroupPresentModeFlagsKHR            modes)
   {
      VkDeviceGroupSwapchainCreateInfoKHR obj;
      obj.sType = VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR;
      obj.pNext = nullptr;
      obj.modes = modes;
      return obj;
   }

VkDeviceGroupPresentCapabilitiesKHR getDeviceGroupPresentCapabilitiesKHR(
        VkDevice device)
   {
      VkDeviceGroupPresentCapabilitiesKHR pDeviceGroupPresentCapabilities; 
      V( vkGetDeviceGroupPresentCapabilitiesKHR(
          device,
          &pDeviceGroupPresentCapabilities  ));
      return pDeviceGroupPresentCapabilities; 
   }

std::shared_ptr< VkDeviceGroupPresentModeFlagsKHR > getDeviceGroupSurfacePresentModesKHR(
        VkDevice device,
        VkSurfaceKHR surface)
   {
      std::shared_ptr<VkDeviceGroupPresentModeFlagsKHR> ptrpModes(new VkDeviceGroupPresentModeFlagsKHR); 
      V( vkGetDeviceGroupSurfacePresentModesKHR(
          device,
          surface,
          ptrpModes.get()  ));
      return ptrpModes; 
   }

std::vector< VkRect2D > getPhysicalDevicePresentRectanglesKHR(
        VkPhysicalDevice physicalDevice,
        VkSurfaceKHR surface)
   {
      std::vector<VkRect2D> vecpRects; 
      uint32_t pRectsCount; 
      V( vkGetPhysicalDevicePresentRectanglesKHR(
          physicalDevice,
          surface,
          &pRectsCount,
          nullptr  ));

      vecpRects.resize(pRectsCount); 

      V( vkGetPhysicalDevicePresentRectanglesKHR(
          physicalDevice,
          surface,
          &pRectsCount,
          &vecpRects[0]  ));
      return vecpRects; 
   }

uint32_t acquireNextImage2KHR(
        VkDevice device,
        const VkAcquireNextImageInfoKHR & pAcquireInfo)
   {
      uint32_t pImageIndex; 
      V( vkAcquireNextImage2KHR(
          device,
          &pAcquireInfo,
          &pImageIndex  ));
      return pImageIndex; 
   }

#ifdef VK_KHR_display
struct VkDisplayPropertiesKHRRAII {
   VkDisplayPropertiesKHR nonRaiiObj;
    std::string                                 strisplayName;
};

std::shared_ptr<VkDisplayPropertiesKHRRAII> DisplayPropertiesKHR(
    VkDisplayKHR                                display,
    const std::string &                         strisplayName,
    VkExtent2D                                  physicalDimensions,
    VkExtent2D                                  physicalResolution,
    VkSurfaceTransformFlagsKHR                  supportedTransforms,
    VkBool32                                    planeReorderPossible,
    VkBool32                                    persistentContent)
   {
      std::shared_ptr<VkDisplayPropertiesKHRRAII> raii_obj(new VkDisplayPropertiesKHRRAII);
      raii_obj->nonRaiiObj.display = display;
      raii_obj->strisplayName = strisplayName;
      raii_obj->nonRaiiObj.displayName = &raii_obj->strisplayName[0];
      raii_obj->nonRaiiObj.physicalDimensions = physicalDimensions;
      raii_obj->nonRaiiObj.physicalResolution = physicalResolution;
      raii_obj->nonRaiiObj.supportedTransforms = supportedTransforms;
      raii_obj->nonRaiiObj.planeReorderPossible = planeReorderPossible;
      raii_obj->nonRaiiObj.persistentContent = persistentContent;
      return raii_obj;
   }

VkDisplayModeParametersKHR DisplayModeParametersKHR(
    VkExtent2D                                  visibleRegion,
    uint32_t                                    refreshRate)
   {
      VkDisplayModeParametersKHR obj;
      obj.visibleRegion = visibleRegion;
      obj.refreshRate = refreshRate;
      return obj;
   }

VkDisplayModePropertiesKHR DisplayModePropertiesKHR(
    VkDisplayModeKHR                            displayMode,
    VkDisplayModeParametersKHR                  parameters)
   {
      VkDisplayModePropertiesKHR obj;
      obj.displayMode = displayMode;
      obj.parameters = parameters;
      return obj;
   }

VkDisplayModeCreateInfoKHR DisplayModeCreateInfoKHR(
    VkDisplayModeCreateFlagsKHR                 flags,
    VkDisplayModeParametersKHR                  parameters)
   {
      VkDisplayModeCreateInfoKHR obj;
      obj.sType = VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR;
      obj.pNext = nullptr;
      obj.flags = flags;
      obj.parameters = parameters;
      return obj;
   }

VkDisplayPlaneCapabilitiesKHR DisplayPlaneCapabilitiesKHR(
    VkDisplayPlaneAlphaFlagsKHR                 supportedAlpha,
    VkOffset2D                                  minSrcPosition,
    VkOffset2D                                  maxSrcPosition,
    VkExtent2D                                  minSrcExtent,
    VkExtent2D                                  maxSrcExtent,
    VkOffset2D                                  minDstPosition,
    VkOffset2D                                  maxDstPosition,
    VkExtent2D                                  minDstExtent,
    VkExtent2D                                  maxDstExtent)
   {
      VkDisplayPlaneCapabilitiesKHR obj;
      obj.supportedAlpha = supportedAlpha;
      obj.minSrcPosition = minSrcPosition;
      obj.maxSrcPosition = maxSrcPosition;
      obj.minSrcExtent = minSrcExtent;
      obj.maxSrcExtent = maxSrcExtent;
      obj.minDstPosition = minDstPosition;
      obj.maxDstPosition = maxDstPosition;
      obj.minDstExtent = minDstExtent;
      obj.maxDstExtent = maxDstExtent;
      return obj;
   }

VkDisplayPlanePropertiesKHR DisplayPlanePropertiesKHR(
    VkDisplayKHR                                currentDisplay,
    uint32_t                                    currentStackIndex)
   {
      VkDisplayPlanePropertiesKHR obj;
      obj.currentDisplay = currentDisplay;
      obj.currentStackIndex = currentStackIndex;
      return obj;
   }

VkDisplaySurfaceCreateInfoKHR DisplaySurfaceCreateInfoKHR(
    VkDisplaySurfaceCreateFlagsKHR              flags,
    VkDisplayModeKHR                            displayMode,
    uint32_t                                    planeIndex,
    uint32_t                                    planeStackIndex,
    VkSurfaceTransformFlagBitsKHR               transform,
    float                                       globalAlpha,
    VkDisplayPlaneAlphaFlagBitsKHR              alphaMode,
    VkExtent2D                                  imageExtent)
   {
      VkDisplaySurfaceCreateInfoKHR obj;
      obj.sType = VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR;
      obj.pNext = nullptr;
      obj.flags = flags;
      obj.displayMode = displayMode;
      obj.planeIndex = planeIndex;
      obj.planeStackIndex = planeStackIndex;
      obj.transform = transform;
      obj.globalAlpha = globalAlpha;
      obj.alphaMode = alphaMode;
      obj.imageExtent = imageExtent;
      return obj;
   }

std::vector< VkDisplayPropertiesKHR > getPhysicalDeviceDisplayPropertiesKHR(
        VkPhysicalDevice physicalDevice)
   {
      if ( nullptr == pfvkGetPhysicalDeviceDisplayPropertiesKHR )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      std::vector<VkDisplayPropertiesKHR> vecpProperties; 
      uint32_t pPropertiesCount; 
      V( pfvkGetPhysicalDeviceDisplayPropertiesKHR(
          physicalDevice,
          &pPropertiesCount,
          nullptr  ));

      vecpProperties.resize(pPropertiesCount); 

      V( pfvkGetPhysicalDeviceDisplayPropertiesKHR(
          physicalDevice,
          &pPropertiesCount,
          &vecpProperties[0]  ));
      return vecpProperties; 
   }

std::vector< VkDisplayPlanePropertiesKHR > getPhysicalDeviceDisplayPlanePropertiesKHR(
        VkPhysicalDevice physicalDevice)
   {
      if ( nullptr == pfvkGetPhysicalDeviceDisplayPlanePropertiesKHR )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      std::vector<VkDisplayPlanePropertiesKHR> vecpProperties; 
      uint32_t pPropertiesCount; 
      V( pfvkGetPhysicalDeviceDisplayPlanePropertiesKHR(
          physicalDevice,
          &pPropertiesCount,
          nullptr  ));

      vecpProperties.resize(pPropertiesCount); 

      V( pfvkGetPhysicalDeviceDisplayPlanePropertiesKHR(
          physicalDevice,
          &pPropertiesCount,
          &vecpProperties[0]  ));
      return vecpProperties; 
   }

std::vector< VkDisplayKHR > getDisplayPlaneSupportedDisplaysKHR(
        VkPhysicalDevice physicalDevice,
        uint32_t planeIndex)
   {
      if ( nullptr == pfvkGetDisplayPlaneSupportedDisplaysKHR )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      std::vector<VkDisplayKHR> vecpDisplays; 
      uint32_t pDisplaysCount; 
      V( pfvkGetDisplayPlaneSupportedDisplaysKHR(
          physicalDevice,
          planeIndex,
          &pDisplaysCount,
          nullptr  ));

      vecpDisplays.resize(pDisplaysCount); 

      V( pfvkGetDisplayPlaneSupportedDisplaysKHR(
          physicalDevice,
          planeIndex,
          &pDisplaysCount,
          &vecpDisplays[0]  ));
      return vecpDisplays; 
   }

std::vector< VkDisplayModePropertiesKHR > getDisplayModePropertiesKHR(
        VkPhysicalDevice physicalDevice,
        VkDisplayKHR display)
   {
      if ( nullptr == pfvkGetDisplayModePropertiesKHR )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      std::vector<VkDisplayModePropertiesKHR> vecpProperties; 
      uint32_t pPropertiesCount; 
      V( pfvkGetDisplayModePropertiesKHR(
          physicalDevice,
          display,
          &pPropertiesCount,
          nullptr  ));

      vecpProperties.resize(pPropertiesCount); 

      V( pfvkGetDisplayModePropertiesKHR(
          physicalDevice,
          display,
          &pPropertiesCount,
          &vecpProperties[0]  ));
      return vecpProperties; 
   }

std::shared_ptr<VkDisplayModeKHR_T> createDisplayModeKHR(
        VkPhysicalDevice physicalDevice,
        VkDisplayKHR display,
        const VkDisplayModeCreateInfoKHR & pCreateInfo)
   {
      if ( nullptr == pfvkCreateDisplayModeKHR )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      VkDisplayModeKHR hMode; 
      V( pfvkCreateDisplayModeKHR(
          physicalDevice,
          display,
          &pCreateInfo,
          nullptr,
          &hMode  ));
      return std::shared_ptr<VkDisplayModeKHR_T>(hMode, 
              [](VkDisplayModeKHR) {});
   }

VkDisplayPlaneCapabilitiesKHR getDisplayPlaneCapabilitiesKHR(
        VkPhysicalDevice physicalDevice,
        VkDisplayModeKHR mode,
        uint32_t planeIndex)
   {
      if ( nullptr == pfvkGetDisplayPlaneCapabilitiesKHR )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      VkDisplayPlaneCapabilitiesKHR pCapabilities; 
      V( pfvkGetDisplayPlaneCapabilitiesKHR(
          physicalDevice,
          mode,
          planeIndex,
          &pCapabilities  ));
      return pCapabilities; 
   }

std::shared_ptr<VkSurfaceKHR_T> createDisplayPlaneSurfaceKHR(
        VkInstance instance,
        const VkDisplaySurfaceCreateInfoKHR & pCreateInfo)
   {
      if ( nullptr == pfvkCreateDisplayPlaneSurfaceKHR )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      VkSurfaceKHR hSurface; 
      V( pfvkCreateDisplayPlaneSurfaceKHR(
          instance,
          &pCreateInfo,
          nullptr,
          &hSurface  ));
      return std::shared_ptr<VkSurfaceKHR_T>(hSurface, 
              [=](VkSurfaceKHR to_free) {pfvkDestroySurfaceKHR(instance, to_free, nullptr);});
   }

#endif /* VK_KHR_display*/
#ifdef VK_KHR_display_swapchain
VkDisplayPresentInfoKHR DisplayPresentInfoKHR(
    VkRect2D                                    srcRect,
    VkRect2D                                    dstRect,
    VkBool32                                    persistent)
   {
      VkDisplayPresentInfoKHR obj;
      obj.sType = VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR;
      obj.pNext = nullptr;
      obj.srcRect = srcRect;
      obj.dstRect = dstRect;
      obj.persistent = persistent;
      return obj;
   }

std::vector< std::shared_ptr<VkSwapchainKHR_T> > createSharedSwapchainsKHR(
        VkDevice device,
        const std::vector<VkSwapchainCreateInfoKHR> & pCreateInfos)
   {
      if ( nullptr == pfvkCreateSharedSwapchainsKHR )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      std::vector<VkSwapchainKHR> vecpSwapchains( pCreateInfos.size(), nullptr ); 
      V( pfvkCreateSharedSwapchainsKHR(
          device,
          static_cast<uint32_t>(pCreateInfos.size()),
          &pCreateInfos[0],
          nullptr,
          &vecpSwapchains[0]  ));
      std::vector< std::shared_ptr<VkSwapchainKHR_T> > retval; 
      retval.reserve(vecpSwapchains.size()); 
      for (auto allocated_handle : vecpSwapchains ) 
      {
          retval.push_back(std::shared_ptr<VkSwapchainKHR_T>(allocated_handle, 
              [](VkSwapchainKHR) {}));
      }
      return retval; 
   }

#endif /* VK_KHR_display_swapchain*/
#ifdef VK_KHR_win32_surface
VkWin32SurfaceCreateInfoKHR Win32SurfaceCreateInfoKHR(
    VkWin32SurfaceCreateFlagsKHR                flags,
    HINSTANCE                                   hinstance,
    HWND                                        hwnd)
   {
      VkWin32SurfaceCreateInfoKHR obj;
      obj.sType = VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR;
      obj.pNext = nullptr;
      obj.flags = flags;
      obj.hinstance = hinstance;
      obj.hwnd = hwnd;
      return obj;
   }

std::shared_ptr<VkSurfaceKHR_T> createWin32SurfaceKHR(
        VkInstance instance,
        const VkWin32SurfaceCreateInfoKHR & pCreateInfo)
   {
      VkSurfaceKHR hSurface; 
      V( vkCreateWin32SurfaceKHR(
          instance,
          &pCreateInfo,
          nullptr,
          &hSurface  ));
      return std::shared_ptr<VkSurfaceKHR_T>(hSurface, 
              [=](VkSurfaceKHR to_free) {pfvkDestroySurfaceKHR(instance, to_free, nullptr);});
   }

void  getPhysicalDeviceWin32PresentationSupportKHR(
        VkPhysicalDevice physicalDevice,
        uint32_t queueFamilyIndex)
   {
      vkGetPhysicalDeviceWin32PresentationSupportKHR(
          physicalDevice,
          queueFamilyIndex  );
   }

#endif /* VK_KHR_win32_surface*/
#ifdef VK_KHR_external_memory_capabilities
VkExternalBufferProperties getPhysicalDeviceExternalBufferPropertiesKHR(
        VkPhysicalDevice physicalDevice,
        const VkPhysicalDeviceExternalBufferInfo & pExternalBufferInfo)
   {
      if ( nullptr == pfvkGetPhysicalDeviceExternalBufferPropertiesKHR )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      VkExternalBufferProperties pExternalBufferProperties; 
      pfvkGetPhysicalDeviceExternalBufferPropertiesKHR(
          physicalDevice,
          &pExternalBufferInfo,
          &pExternalBufferProperties  );
      return pExternalBufferProperties; 
   }

#endif /* VK_KHR_external_memory_capabilities*/
#ifdef VK_KHR_external_memory
#endif /* VK_KHR_external_memory*/
#ifdef VK_KHR_external_memory_win32
VkImportMemoryWin32HandleInfoKHR ImportMemoryWin32HandleInfoKHR(
    VkExternalMemoryHandleTypeFlagBits          handleType,
    HANDLE                                      handle,
    LPCWSTR                                     name)
   {
      VkImportMemoryWin32HandleInfoKHR obj;
      obj.sType = VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR;
      obj.pNext = nullptr;
      obj.handleType = handleType;
      obj.handle = handle;
      obj.name = name;
      return obj;
   }

struct VkExportMemoryWin32HandleInfoKHRRAII {
   VkExportMemoryWin32HandleInfoKHR nonRaiiObj;
    std::shared_ptr<SECURITY_ATTRIBUTES>        pAttributes;
};

std::shared_ptr<VkExportMemoryWin32HandleInfoKHRRAII> ExportMemoryWin32HandleInfoKHR(
    const SECURITY_ATTRIBUTES *                 pAttributes,
    DWORD                                       dwAccess,
    LPCWSTR                                     name)
   {
      std::shared_ptr<VkExportMemoryWin32HandleInfoKHRRAII> raii_obj(new VkExportMemoryWin32HandleInfoKHRRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.pAttributes = nullptr;
      if ( pAttributes ) 
      { 
          raii_obj->pAttributes.reset( new SECURITY_ATTRIBUTES );
          *raii_obj->pAttributes = *pAttributes;
          raii_obj->nonRaiiObj.pAttributes = raii_obj->pAttributes.get();
      } 
      raii_obj->nonRaiiObj.dwAccess = dwAccess;
      raii_obj->nonRaiiObj.name = name;
      return raii_obj;
   }

VkMemoryWin32HandlePropertiesKHR MemoryWin32HandlePropertiesKHR(
    uint32_t                                    memoryTypeBits)
   {
      VkMemoryWin32HandlePropertiesKHR obj;
      obj.sType = VK_STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR;
      obj.pNext = nullptr;
      obj.memoryTypeBits = memoryTypeBits;
      return obj;
   }

VkMemoryGetWin32HandleInfoKHR MemoryGetWin32HandleInfoKHR(
    VkDeviceMemory                              memory,
    VkExternalMemoryHandleTypeFlagBits          handleType)
   {
      VkMemoryGetWin32HandleInfoKHR obj;
      obj.sType = VK_STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR;
      obj.pNext = nullptr;
      obj.memory = memory;
      obj.handleType = handleType;
      return obj;
   }

HANDLE getMemoryWin32HandleKHR(
        VkDevice device,
        const VkMemoryGetWin32HandleInfoKHR & pGetWin32HandleInfo)
   {
      if ( nullptr == pfvkGetMemoryWin32HandleKHR )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      HANDLE pHandle; 
      V( pfvkGetMemoryWin32HandleKHR(
          device,
          &pGetWin32HandleInfo,
          &pHandle  ));
      return pHandle; 
   }

VkMemoryWin32HandlePropertiesKHR getMemoryWin32HandlePropertiesKHR(
        VkDevice device,
        VkExternalMemoryHandleTypeFlagBits handleType,
        HANDLE handle)
   {
      if ( nullptr == pfvkGetMemoryWin32HandlePropertiesKHR )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      VkMemoryWin32HandlePropertiesKHR pMemoryWin32HandleProperties; 
      V( pfvkGetMemoryWin32HandlePropertiesKHR(
          device,
          handleType,
          handle,
          &pMemoryWin32HandleProperties  ));
      return pMemoryWin32HandleProperties; 
   }

#endif /* VK_KHR_external_memory_win32*/
#ifdef VK_KHR_external_memory_fd
VkImportMemoryFdInfoKHR ImportMemoryFdInfoKHR(
    VkExternalMemoryHandleTypeFlagBits          handleType,
    int                                         fd)
   {
      VkImportMemoryFdInfoKHR obj;
      obj.sType = VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR;
      obj.pNext = nullptr;
      obj.handleType = handleType;
      obj.fd = fd;
      return obj;
   }

VkMemoryFdPropertiesKHR MemoryFdPropertiesKHR(
    uint32_t                                    memoryTypeBits)
   {
      VkMemoryFdPropertiesKHR obj;
      obj.sType = VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR;
      obj.pNext = nullptr;
      obj.memoryTypeBits = memoryTypeBits;
      return obj;
   }

VkMemoryGetFdInfoKHR MemoryGetFdInfoKHR(
    VkDeviceMemory                              memory,
    VkExternalMemoryHandleTypeFlagBits          handleType)
   {
      VkMemoryGetFdInfoKHR obj;
      obj.sType = VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR;
      obj.pNext = nullptr;
      obj.memory = memory;
      obj.handleType = handleType;
      return obj;
   }

int getMemoryFdKHR(
        VkDevice device,
        const VkMemoryGetFdInfoKHR & pGetFdInfo)
   {
      if ( nullptr == pfvkGetMemoryFdKHR )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      int pFd; 
      V( pfvkGetMemoryFdKHR(
          device,
          &pGetFdInfo,
          &pFd  ));
      return pFd; 
   }

VkMemoryFdPropertiesKHR getMemoryFdPropertiesKHR(
        VkDevice device,
        VkExternalMemoryHandleTypeFlagBits handleType,
        int fd)
   {
      if ( nullptr == pfvkGetMemoryFdPropertiesKHR )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      VkMemoryFdPropertiesKHR pMemoryFdProperties; 
      V( pfvkGetMemoryFdPropertiesKHR(
          device,
          handleType,
          fd,
          &pMemoryFdProperties  ));
      return pMemoryFdProperties; 
   }

#endif /* VK_KHR_external_memory_fd*/
#ifdef VK_KHR_win32_keyed_mutex
struct VkWin32KeyedMutexAcquireReleaseInfoKHRRAII {
   VkWin32KeyedMutexAcquireReleaseInfoKHR nonRaiiObj;
    std::vector<VkDeviceMemory>                 vecAcquireSyncs;
    std::vector<uint64_t>                       vecAcquireKeys;
    std::vector<uint32_t>                       vecAcquireTimeouts;
    std::vector<VkDeviceMemory>                 vecReleaseSyncs;
    std::vector<uint64_t>                       vecReleaseKeys;
};

std::shared_ptr<VkWin32KeyedMutexAcquireReleaseInfoKHRRAII> Win32KeyedMutexAcquireReleaseInfoKHR(
    const std::vector<VkDeviceMemory> &         vecAcquireSyncs,
    const std::vector<uint64_t> &               vecAcquireKeys,
    unsigned int* pAcquireTimeouts_in_array1, int pAcquireTimeouts_dim1,
    const std::vector<VkDeviceMemory> &         vecReleaseSyncs,
    const std::vector<uint64_t> &               vecReleaseKeys)
   {
      std::shared_ptr<VkWin32KeyedMutexAcquireReleaseInfoKHRRAII> raii_obj(new VkWin32KeyedMutexAcquireReleaseInfoKHRRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.acquireCount = static_cast<uint32_t>(vecAcquireSyncs.size());
      raii_obj->vecAcquireSyncs = vecAcquireSyncs;
      if ( raii_obj->vecAcquireSyncs.size() > 0)
      {
          raii_obj->nonRaiiObj.pAcquireSyncs = &raii_obj->vecAcquireSyncs[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pAcquireSyncs = nullptr;
      }
      raii_obj->vecAcquireKeys = vecAcquireKeys;
      if ( raii_obj->vecAcquireKeys.size() > 0)
      {
          raii_obj->nonRaiiObj.pAcquireKeys = &raii_obj->vecAcquireKeys[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pAcquireKeys = nullptr;
      }
      raii_obj->vecAcquireTimeouts.assign(pAcquireTimeouts_in_array1, pAcquireTimeouts_in_array1 + pAcquireTimeouts_dim1);
      if ( raii_obj->vecAcquireTimeouts.size() > 0)
      {
          raii_obj->nonRaiiObj.pAcquireTimeouts = &raii_obj->vecAcquireTimeouts[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pAcquireTimeouts = nullptr;
      }
      raii_obj->nonRaiiObj.releaseCount = static_cast<uint32_t>(vecReleaseSyncs.size());
      raii_obj->vecReleaseSyncs = vecReleaseSyncs;
      if ( raii_obj->vecReleaseSyncs.size() > 0)
      {
          raii_obj->nonRaiiObj.pReleaseSyncs = &raii_obj->vecReleaseSyncs[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pReleaseSyncs = nullptr;
      }
      raii_obj->vecReleaseKeys = vecReleaseKeys;
      if ( raii_obj->vecReleaseKeys.size() > 0)
      {
          raii_obj->nonRaiiObj.pReleaseKeys = &raii_obj->vecReleaseKeys[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pReleaseKeys = nullptr;
      }
      return raii_obj;
   }

#endif /* VK_KHR_win32_keyed_mutex*/
#ifdef VK_KHR_external_semaphore_capabilities
VkExternalSemaphoreProperties getPhysicalDeviceExternalSemaphorePropertiesKHR(
        VkPhysicalDevice physicalDevice,
        const VkPhysicalDeviceExternalSemaphoreInfo & pExternalSemaphoreInfo)
   {
      if ( nullptr == pfvkGetPhysicalDeviceExternalSemaphorePropertiesKHR )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      VkExternalSemaphoreProperties pExternalSemaphoreProperties; 
      pfvkGetPhysicalDeviceExternalSemaphorePropertiesKHR(
          physicalDevice,
          &pExternalSemaphoreInfo,
          &pExternalSemaphoreProperties  );
      return pExternalSemaphoreProperties; 
   }

#endif /* VK_KHR_external_semaphore_capabilities*/
#ifdef VK_KHR_external_semaphore
#endif /* VK_KHR_external_semaphore*/
#ifdef VK_KHR_external_semaphore_win32
VkImportSemaphoreWin32HandleInfoKHR ImportSemaphoreWin32HandleInfoKHR(
    VkSemaphore                                 semaphore,
    VkSemaphoreImportFlags                      flags,
    VkExternalSemaphoreHandleTypeFlagBits       handleType,
    HANDLE                                      handle,
    LPCWSTR                                     name)
   {
      VkImportSemaphoreWin32HandleInfoKHR obj;
      obj.sType = VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR;
      obj.pNext = nullptr;
      obj.semaphore = semaphore;
      obj.flags = flags;
      obj.handleType = handleType;
      obj.handle = handle;
      obj.name = name;
      return obj;
   }

struct VkExportSemaphoreWin32HandleInfoKHRRAII {
   VkExportSemaphoreWin32HandleInfoKHR nonRaiiObj;
    std::shared_ptr<SECURITY_ATTRIBUTES>        pAttributes;
};

std::shared_ptr<VkExportSemaphoreWin32HandleInfoKHRRAII> ExportSemaphoreWin32HandleInfoKHR(
    const SECURITY_ATTRIBUTES *                 pAttributes,
    DWORD                                       dwAccess,
    LPCWSTR                                     name)
   {
      std::shared_ptr<VkExportSemaphoreWin32HandleInfoKHRRAII> raii_obj(new VkExportSemaphoreWin32HandleInfoKHRRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.pAttributes = nullptr;
      if ( pAttributes ) 
      { 
          raii_obj->pAttributes.reset( new SECURITY_ATTRIBUTES );
          *raii_obj->pAttributes = *pAttributes;
          raii_obj->nonRaiiObj.pAttributes = raii_obj->pAttributes.get();
      } 
      raii_obj->nonRaiiObj.dwAccess = dwAccess;
      raii_obj->nonRaiiObj.name = name;
      return raii_obj;
   }

struct VkD3D12FenceSubmitInfoKHRRAII {
   VkD3D12FenceSubmitInfoKHR nonRaiiObj;
    std::vector<uint64_t>                       vecWaitSemaphoreValues;
    std::vector<uint64_t>                       vecSignalSemaphoreValues;
};

std::shared_ptr<VkD3D12FenceSubmitInfoKHRRAII> D3D12FenceSubmitInfoKHR(
    const std::vector<uint64_t> &               vecWaitSemaphoreValues,
    const std::vector<uint64_t> &               vecSignalSemaphoreValues)
   {
      std::shared_ptr<VkD3D12FenceSubmitInfoKHRRAII> raii_obj(new VkD3D12FenceSubmitInfoKHRRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.waitSemaphoreValuesCount = static_cast<uint32_t>(vecWaitSemaphoreValues.size());
      raii_obj->vecWaitSemaphoreValues = vecWaitSemaphoreValues;
      if ( raii_obj->vecWaitSemaphoreValues.size() > 0)
      {
          raii_obj->nonRaiiObj.pWaitSemaphoreValues = &raii_obj->vecWaitSemaphoreValues[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pWaitSemaphoreValues = nullptr;
      }
      raii_obj->nonRaiiObj.signalSemaphoreValuesCount = static_cast<uint32_t>(vecSignalSemaphoreValues.size());
      raii_obj->vecSignalSemaphoreValues = vecSignalSemaphoreValues;
      if ( raii_obj->vecSignalSemaphoreValues.size() > 0)
      {
          raii_obj->nonRaiiObj.pSignalSemaphoreValues = &raii_obj->vecSignalSemaphoreValues[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pSignalSemaphoreValues = nullptr;
      }
      return raii_obj;
   }

VkSemaphoreGetWin32HandleInfoKHR SemaphoreGetWin32HandleInfoKHR(
    VkSemaphore                                 semaphore,
    VkExternalSemaphoreHandleTypeFlagBits       handleType)
   {
      VkSemaphoreGetWin32HandleInfoKHR obj;
      obj.sType = VK_STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR;
      obj.pNext = nullptr;
      obj.semaphore = semaphore;
      obj.handleType = handleType;
      return obj;
   }

void  importSemaphoreWin32HandleKHR(
        VkDevice device,
        const VkImportSemaphoreWin32HandleInfoKHR & pImportSemaphoreWin32HandleInfo)
   {
      if ( nullptr == pfvkImportSemaphoreWin32HandleKHR )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      V( pfvkImportSemaphoreWin32HandleKHR(
          device,
          &pImportSemaphoreWin32HandleInfo  ));
   }

HANDLE getSemaphoreWin32HandleKHR(
        VkDevice device,
        const VkSemaphoreGetWin32HandleInfoKHR & pGetWin32HandleInfo)
   {
      if ( nullptr == pfvkGetSemaphoreWin32HandleKHR )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      HANDLE pHandle; 
      V( pfvkGetSemaphoreWin32HandleKHR(
          device,
          &pGetWin32HandleInfo,
          &pHandle  ));
      return pHandle; 
   }

#endif /* VK_KHR_external_semaphore_win32*/
#ifdef VK_KHR_external_semaphore_fd
VkImportSemaphoreFdInfoKHR ImportSemaphoreFdInfoKHR(
    VkSemaphore                                 semaphore,
    VkSemaphoreImportFlags                      flags,
    VkExternalSemaphoreHandleTypeFlagBits       handleType,
    int                                         fd)
   {
      VkImportSemaphoreFdInfoKHR obj;
      obj.sType = VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR;
      obj.pNext = nullptr;
      obj.semaphore = semaphore;
      obj.flags = flags;
      obj.handleType = handleType;
      obj.fd = fd;
      return obj;
   }

VkSemaphoreGetFdInfoKHR SemaphoreGetFdInfoKHR(
    VkSemaphore                                 semaphore,
    VkExternalSemaphoreHandleTypeFlagBits       handleType)
   {
      VkSemaphoreGetFdInfoKHR obj;
      obj.sType = VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR;
      obj.pNext = nullptr;
      obj.semaphore = semaphore;
      obj.handleType = handleType;
      return obj;
   }

void  importSemaphoreFdKHR(
        VkDevice device,
        const VkImportSemaphoreFdInfoKHR & pImportSemaphoreFdInfo)
   {
      if ( nullptr == pfvkImportSemaphoreFdKHR )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      V( pfvkImportSemaphoreFdKHR(
          device,
          &pImportSemaphoreFdInfo  ));
   }

int getSemaphoreFdKHR(
        VkDevice device,
        const VkSemaphoreGetFdInfoKHR & pGetFdInfo)
   {
      if ( nullptr == pfvkGetSemaphoreFdKHR )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      int pFd; 
      V( pfvkGetSemaphoreFdKHR(
          device,
          &pGetFdInfo,
          &pFd  ));
      return pFd; 
   }

#endif /* VK_KHR_external_semaphore_fd*/
#ifdef VK_KHR_external_fence_win32
VkImportFenceWin32HandleInfoKHR ImportFenceWin32HandleInfoKHR(
    VkFence                                     fence,
    VkFenceImportFlags                          flags,
    VkExternalFenceHandleTypeFlagBits           handleType,
    HANDLE                                      handle,
    LPCWSTR                                     name)
   {
      VkImportFenceWin32HandleInfoKHR obj;
      obj.sType = VK_STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR;
      obj.pNext = nullptr;
      obj.fence = fence;
      obj.flags = flags;
      obj.handleType = handleType;
      obj.handle = handle;
      obj.name = name;
      return obj;
   }

struct VkExportFenceWin32HandleInfoKHRRAII {
   VkExportFenceWin32HandleInfoKHR nonRaiiObj;
    std::shared_ptr<SECURITY_ATTRIBUTES>        pAttributes;
};

std::shared_ptr<VkExportFenceWin32HandleInfoKHRRAII> ExportFenceWin32HandleInfoKHR(
    const SECURITY_ATTRIBUTES *                 pAttributes,
    DWORD                                       dwAccess,
    LPCWSTR                                     name)
   {
      std::shared_ptr<VkExportFenceWin32HandleInfoKHRRAII> raii_obj(new VkExportFenceWin32HandleInfoKHRRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.pAttributes = nullptr;
      if ( pAttributes ) 
      { 
          raii_obj->pAttributes.reset( new SECURITY_ATTRIBUTES );
          *raii_obj->pAttributes = *pAttributes;
          raii_obj->nonRaiiObj.pAttributes = raii_obj->pAttributes.get();
      } 
      raii_obj->nonRaiiObj.dwAccess = dwAccess;
      raii_obj->nonRaiiObj.name = name;
      return raii_obj;
   }

VkFenceGetWin32HandleInfoKHR FenceGetWin32HandleInfoKHR(
    VkFence                                     fence,
    VkExternalFenceHandleTypeFlagBits           handleType)
   {
      VkFenceGetWin32HandleInfoKHR obj;
      obj.sType = VK_STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR;
      obj.pNext = nullptr;
      obj.fence = fence;
      obj.handleType = handleType;
      return obj;
   }

void  importFenceWin32HandleKHR(
        VkDevice device,
        const VkImportFenceWin32HandleInfoKHR & pImportFenceWin32HandleInfo)
   {
      if ( nullptr == pfvkImportFenceWin32HandleKHR )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      V( pfvkImportFenceWin32HandleKHR(
          device,
          &pImportFenceWin32HandleInfo  ));
   }

HANDLE getFenceWin32HandleKHR(
        VkDevice device,
        const VkFenceGetWin32HandleInfoKHR & pGetWin32HandleInfo)
   {
      if ( nullptr == pfvkGetFenceWin32HandleKHR )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      HANDLE pHandle; 
      V( pfvkGetFenceWin32HandleKHR(
          device,
          &pGetWin32HandleInfo,
          &pHandle  ));
      return pHandle; 
   }

#endif /* VK_KHR_external_fence_win32*/
#ifdef VK_KHR_swapchain_mutable_format
#endif /* VK_KHR_swapchain_mutable_format*/
#ifdef VK_KHR_surface_protected_capabilities
VkSurfaceProtectedCapabilitiesKHR SurfaceProtectedCapabilitiesKHR(
    VkBool32                                    supportsProtected)
   {
      VkSurfaceProtectedCapabilitiesKHR obj;
      obj.sType = VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR;
      obj.pNext = nullptr;
      obj.supportsProtected = supportsProtected;
      return obj;
   }

#endif /* VK_KHR_surface_protected_capabilities*/
#ifdef VK_EXT_debug_report
VkDebugReportCallbackCreateInfoEXT DebugReportCallbackCreateInfoEXT(
    VkDebugReportFlagsEXT                       flags,
    PFN_vkDebugReportCallbackEXT                pfnCallback)
   {
      VkDebugReportCallbackCreateInfoEXT obj;
      obj.sType = VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT;
      obj.pNext = nullptr;
      obj.flags = flags;
      obj.pfnCallback = pfnCallback;
      obj.pUserData = nullptr;
      return obj;
   }

std::shared_ptr<VkDebugReportCallbackEXT_T> createDebugReportCallbackEXT(
        VkInstance instance,
        const VkDebugReportCallbackCreateInfoEXT & pCreateInfo)
   {
      if ( nullptr == pfvkCreateDebugReportCallbackEXT )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      VkDebugReportCallbackEXT hCallback; 
      V( pfvkCreateDebugReportCallbackEXT(
          instance,
          &pCreateInfo,
          nullptr,
          &hCallback  ));
      return std::shared_ptr<VkDebugReportCallbackEXT_T>(hCallback, 
              [=](VkDebugReportCallbackEXT to_free) {pfvkDestroyDebugReportCallbackEXT(instance, to_free, nullptr);});
   }

void  debugReportMessageEXT(
        VkInstance instance,
        VkDebugReportFlagsEXT flags,
        VkDebugReportObjectTypeEXT objectType,
        uint64_t object,
        size_t location,
        int32_t messageCode,
        const char* pLayerPrefix,
        const char* pMessage)
   {
      if ( nullptr == pfvkDebugReportMessageEXT )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      pfvkDebugReportMessageEXT(
          instance,
          flags,
          objectType,
          object,
          location,
          messageCode,
          pLayerPrefix,
          pMessage  );
   }

#endif /* VK_EXT_debug_report*/
#ifdef VK_NV_external_memory_win32
VkImportMemoryWin32HandleInfoNV ImportMemoryWin32HandleInfoNV(
    VkExternalMemoryHandleTypeFlagsNV           handleType,
    HANDLE                                      handle)
   {
      VkImportMemoryWin32HandleInfoNV obj;
      obj.sType = VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV;
      obj.pNext = nullptr;
      obj.handleType = handleType;
      obj.handle = handle;
      return obj;
   }

struct VkExportMemoryWin32HandleInfoNVRAII {
   VkExportMemoryWin32HandleInfoNV nonRaiiObj;
    std::shared_ptr<SECURITY_ATTRIBUTES>        pAttributes;
};

std::shared_ptr<VkExportMemoryWin32HandleInfoNVRAII> ExportMemoryWin32HandleInfoNV(
    const SECURITY_ATTRIBUTES *                 pAttributes,
    DWORD                                       dwAccess)
   {
      std::shared_ptr<VkExportMemoryWin32HandleInfoNVRAII> raii_obj(new VkExportMemoryWin32HandleInfoNVRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.pAttributes = nullptr;
      if ( pAttributes ) 
      { 
          raii_obj->pAttributes.reset( new SECURITY_ATTRIBUTES );
          *raii_obj->pAttributes = *pAttributes;
          raii_obj->nonRaiiObj.pAttributes = raii_obj->pAttributes.get();
      } 
      raii_obj->nonRaiiObj.dwAccess = dwAccess;
      return raii_obj;
   }

HANDLE getMemoryWin32HandleNV(
        VkDevice device,
        VkDeviceMemory memory,
        VkExternalMemoryHandleTypeFlagsNV handleType)
   {
      if ( nullptr == pfvkGetMemoryWin32HandleNV )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      HANDLE pHandle; 
      V( pfvkGetMemoryWin32HandleNV(
          device,
          memory,
          handleType,
          &pHandle  ));
      return pHandle; 
   }

#endif /* VK_NV_external_memory_win32*/
#ifdef VK_NV_win32_keyed_mutex
struct VkWin32KeyedMutexAcquireReleaseInfoNVRAII {
   VkWin32KeyedMutexAcquireReleaseInfoNV nonRaiiObj;
    std::vector<VkDeviceMemory>                 vecAcquireSyncs;
    std::vector<uint64_t>                       vecAcquireKeys;
    std::vector<uint32_t>                       vecAcquireTimeoutMilliseconds;
    std::vector<VkDeviceMemory>                 vecReleaseSyncs;
    std::vector<uint64_t>                       vecReleaseKeys;
};

std::shared_ptr<VkWin32KeyedMutexAcquireReleaseInfoNVRAII> Win32KeyedMutexAcquireReleaseInfoNV(
    const std::vector<VkDeviceMemory> &         vecAcquireSyncs,
    const std::vector<uint64_t> &               vecAcquireKeys,
    unsigned int* pAcquireTimeoutMilliseconds_in_array1, int pAcquireTimeoutMilliseconds_dim1,
    const std::vector<VkDeviceMemory> &         vecReleaseSyncs,
    const std::vector<uint64_t> &               vecReleaseKeys)
   {
      std::shared_ptr<VkWin32KeyedMutexAcquireReleaseInfoNVRAII> raii_obj(new VkWin32KeyedMutexAcquireReleaseInfoNVRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.acquireCount = static_cast<uint32_t>(vecAcquireSyncs.size());
      raii_obj->vecAcquireSyncs = vecAcquireSyncs;
      if ( raii_obj->vecAcquireSyncs.size() > 0)
      {
          raii_obj->nonRaiiObj.pAcquireSyncs = &raii_obj->vecAcquireSyncs[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pAcquireSyncs = nullptr;
      }
      raii_obj->vecAcquireKeys = vecAcquireKeys;
      if ( raii_obj->vecAcquireKeys.size() > 0)
      {
          raii_obj->nonRaiiObj.pAcquireKeys = &raii_obj->vecAcquireKeys[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pAcquireKeys = nullptr;
      }
      raii_obj->vecAcquireTimeoutMilliseconds.assign(pAcquireTimeoutMilliseconds_in_array1, pAcquireTimeoutMilliseconds_in_array1 + pAcquireTimeoutMilliseconds_dim1);
      if ( raii_obj->vecAcquireTimeoutMilliseconds.size() > 0)
      {
          raii_obj->nonRaiiObj.pAcquireTimeoutMilliseconds = &raii_obj->vecAcquireTimeoutMilliseconds[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pAcquireTimeoutMilliseconds = nullptr;
      }
      raii_obj->nonRaiiObj.releaseCount = static_cast<uint32_t>(vecReleaseSyncs.size());
      raii_obj->vecReleaseSyncs = vecReleaseSyncs;
      if ( raii_obj->vecReleaseSyncs.size() > 0)
      {
          raii_obj->nonRaiiObj.pReleaseSyncs = &raii_obj->vecReleaseSyncs[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pReleaseSyncs = nullptr;
      }
      raii_obj->vecReleaseKeys = vecReleaseKeys;
      if ( raii_obj->vecReleaseKeys.size() > 0)
      {
          raii_obj->nonRaiiObj.pReleaseKeys = &raii_obj->vecReleaseKeys[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pReleaseKeys = nullptr;
      }
      return raii_obj;
   }

#endif /* VK_NV_win32_keyed_mutex*/%}

%template (VkDescriptorPoolCreateInfoPtr) std::shared_ptr<VkDescriptorPoolCreateInfoRAII>;

%template (VkDescriptorUpdateTemplateCreateInfoPtr) std::shared_ptr<VkDescriptorUpdateTemplateCreateInfoRAII>;

%template (VkDeviceGroupDeviceCreateInfoPtr) std::shared_ptr<VkDeviceGroupDeviceCreateInfoRAII>;

%template (VkSubpassDescriptionPtr) std::shared_ptr<VkSubpassDescriptionRAII>;

#ifdef VK_NV_external_memory_win32

%template (VkExportMemoryWin32HandleInfoNVPtr) std::shared_ptr<VkExportMemoryWin32HandleInfoNVRAII>;

#endif

%template (VkApplicationInfoPtr) std::shared_ptr<VkApplicationInfoRAII>;

%template (VkSparseImageOpaqueMemoryBindInfoPtr) std::shared_ptr<VkSparseImageOpaqueMemoryBindInfoRAII>;

%template (VkFramebufferCreateInfoPtr) std::shared_ptr<VkFramebufferCreateInfoRAII>;

#ifdef VK_KHR_external_semaphore_win32

%template (VkD3D12FenceSubmitInfoKHRPtr) std::shared_ptr<VkD3D12FenceSubmitInfoKHRRAII>;

#endif

#ifdef VK_KHR_win32_keyed_mutex

%template (VkWin32KeyedMutexAcquireReleaseInfoKHRPtr) std::shared_ptr<VkWin32KeyedMutexAcquireReleaseInfoKHRRAII>;

#endif

%template (VkPipelineVertexInputStateCreateInfoPtr) std::shared_ptr<VkPipelineVertexInputStateCreateInfoRAII>;

%template (VkSwapchainCreateInfoKHRPtr) std::shared_ptr<VkSwapchainCreateInfoKHRRAII>;

%template (VkRenderPassCreateInfoPtr) std::shared_ptr<VkRenderPassCreateInfoRAII>;

%template (VkWriteDescriptorSetPtr) std::shared_ptr<VkWriteDescriptorSetRAII>;

%template (VkBindBufferMemoryDeviceGroupInfoPtr) std::shared_ptr<VkBindBufferMemoryDeviceGroupInfoRAII>;

%template (VkRenderPassBeginInfoPtr) std::shared_ptr<VkRenderPassBeginInfoRAII>;

#ifdef VK_KHR_external_memory_win32

%template (VkExportMemoryWin32HandleInfoKHRPtr) std::shared_ptr<VkExportMemoryWin32HandleInfoKHRRAII>;

#endif

%template (VkBindSparseInfoPtr) std::shared_ptr<VkBindSparseInfoRAII>;

#ifdef VK_KHR_display

%template (VkDisplayPropertiesKHRPtr) std::shared_ptr<VkDisplayPropertiesKHRRAII>;

#endif

%template (VkShaderModuleCreateInfoPtr) std::shared_ptr<VkShaderModuleCreateInfoRAII>;

%template (VkDescriptorSetLayoutBindingPtr) std::shared_ptr<VkDescriptorSetLayoutBindingRAII>;

%template (VkDeviceGroupSubmitInfoPtr) std::shared_ptr<VkDeviceGroupSubmitInfoRAII>;

%template (VkRenderPassInputAttachmentAspectCreateInfoPtr) std::shared_ptr<VkRenderPassInputAttachmentAspectCreateInfoRAII>;

%template (VkInstanceCreateInfoPtr) std::shared_ptr<VkInstanceCreateInfoRAII>;

%template (VkPipelineDynamicStateCreateInfoPtr) std::shared_ptr<VkPipelineDynamicStateCreateInfoRAII>;

%template (VkDeviceGroupPresentInfoKHRPtr) std::shared_ptr<VkDeviceGroupPresentInfoKHRRAII>;

%template (VkDescriptorSetLayoutCreateInfoPtr) std::shared_ptr<VkDescriptorSetLayoutCreateInfoRAII>;

%template (VkPipelineShaderStageCreateInfoPtr) std::shared_ptr<VkPipelineShaderStageCreateInfoRAII>;

%template (VkDeviceGroupRenderPassBeginInfoPtr) std::shared_ptr<VkDeviceGroupRenderPassBeginInfoRAII>;

%template (VkPresentInfoKHRPtr) std::shared_ptr<VkPresentInfoKHRRAII>;

%template (VkSpecializationInfoPtr) std::shared_ptr<VkSpecializationInfoRAII>;

%template (VkSparseBufferMemoryBindInfoPtr) std::shared_ptr<VkSparseBufferMemoryBindInfoRAII>;

%template (VkPipelineViewportStateCreateInfoPtr) std::shared_ptr<VkPipelineViewportStateCreateInfoRAII>;

%template (VkBufferCreateInfoPtr) std::shared_ptr<VkBufferCreateInfoRAII>;

%template (VkDeviceQueueCreateInfoPtr) std::shared_ptr<VkDeviceQueueCreateInfoRAII>;

%template (VkGraphicsPipelineCreateInfoPtr) std::shared_ptr<VkGraphicsPipelineCreateInfoRAII>;

#ifdef VK_KHR_external_fence_win32

%template (VkExportFenceWin32HandleInfoKHRPtr) std::shared_ptr<VkExportFenceWin32HandleInfoKHRRAII>;

#endif

%template (VkImageCreateInfoPtr) std::shared_ptr<VkImageCreateInfoRAII>;

%template (VkRenderPassMultiviewCreateInfoPtr) std::shared_ptr<VkRenderPassMultiviewCreateInfoRAII>;

%template (VkPipelineLayoutCreateInfoPtr) std::shared_ptr<VkPipelineLayoutCreateInfoRAII>;

%template (VkDescriptorSetAllocateInfoPtr) std::shared_ptr<VkDescriptorSetAllocateInfoRAII>;

%template (VkCommandBufferBeginInfoPtr) std::shared_ptr<VkCommandBufferBeginInfoRAII>;

#ifdef VK_NV_win32_keyed_mutex

%template (VkWin32KeyedMutexAcquireReleaseInfoNVPtr) std::shared_ptr<VkWin32KeyedMutexAcquireReleaseInfoNVRAII>;

#endif

%template (VkBindImageMemoryDeviceGroupInfoPtr) std::shared_ptr<VkBindImageMemoryDeviceGroupInfoRAII>;

%template (VkPipelineCacheCreateInfoPtr) std::shared_ptr<VkPipelineCacheCreateInfoRAII>;

%template (VkDeviceCreateInfoPtr) std::shared_ptr<VkDeviceCreateInfoRAII>;

%template (VkSparseImageMemoryBindInfoPtr) std::shared_ptr<VkSparseImageMemoryBindInfoRAII>;

%template (VkPipelineColorBlendStateCreateInfoPtr) std::shared_ptr<VkPipelineColorBlendStateCreateInfoRAII>;

%template (VkSubmitInfoPtr) std::shared_ptr<VkSubmitInfoRAII>;

#ifdef VK_KHR_external_semaphore_win32

%template (VkExportSemaphoreWin32HandleInfoKHRPtr) std::shared_ptr<VkExportSemaphoreWin32HandleInfoKHRRAII>;

#endif

%template (VkImageSubresourceRangeVector) std::vector<VkImageSubresourceRange>;

%template (VkDynamicStateVector) std::vector<VkDynamicState>;

%template (VkClearRectVector) std::vector<VkClearRect>;

%template (VkPipelineCacheVector) std::vector<VkPipelineCache>;

%template (VkImageBlitVector) std::vector<VkImageBlit>;

%template (VkSwapchainCreateInfoKHRVector) std::vector< std::shared_ptr<VkSwapchainCreateInfoKHRRAII> >;

%template (VkWriteDescriptorSetVector) std::vector< std::shared_ptr<VkWriteDescriptorSetRAII> >;

%template (VkAttachmentReferenceVector) std::vector<VkAttachmentReference>;

%template (VkBufferCopyVector) std::vector<VkBufferCopy>;

%template (VkMappedMemoryRangeVector) std::vector<VkMappedMemoryRange>;

%template (VkImageCopyVector) std::vector<VkImageCopy>;

%template (VkMemoryBarrierVector) std::vector<VkMemoryBarrier>;

%template (VkExtensionPropertiesVector) std::vector<VkExtensionProperties>;

%template (VkSubpassDependencyVector) std::vector<VkSubpassDependency>;

%template (VkEventVector) std::vector<VkEvent>;

%template (VkBufferImageCopyVector) std::vector<VkBufferImageCopy>;

%template (VkFenceVector) std::vector<VkFence>;

#ifdef VK_KHR_display

%template (VkDisplayPlanePropertiesKHRVector) std::vector<VkDisplayPlanePropertiesKHR>;

#endif

%template (VkDescriptorSetLayoutVector) std::vector<VkDescriptorSetLayout>;

%template (VkQueueFamilyProperties2Vector) std::vector<VkQueueFamilyProperties2>;

%template (VkBindSparseInfoVector) std::vector< std::shared_ptr<VkBindSparseInfoRAII> >;

%template (VkComputePipelineCreateInfoVector) std::vector<VkComputePipelineCreateInfo>;

%template (VkCopyDescriptorSetVector) std::vector<VkCopyDescriptorSet>;

%template (VkDeviceSizeVector) std::vector<VkDeviceSize>;

%template (VkImageResolveVector) std::vector<VkImageResolve>;

%template (VkSubpassDescriptionVector) std::vector< std::shared_ptr<VkSubpassDescriptionRAII> >;

%template (VkSurfaceFormatKHRVector) std::vector<VkSurfaceFormatKHR>;

%template (VkDescriptorUpdateTemplateEntryVector) std::vector<VkDescriptorUpdateTemplateEntry>;

%template (VkPresentModeKHRVector) std::vector<VkPresentModeKHR>;

%template (VkBindImageMemoryInfoVector) std::vector<VkBindImageMemoryInfo>;

%template (VkSpecializationMapEntryVector) std::vector<VkSpecializationMapEntry>;

#ifdef VK_KHR_display

%template (VkDisplayPropertiesKHRVector) std::vector< std::shared_ptr<VkDisplayPropertiesKHRRAII> >;

#endif

%template (VkVertexInputBindingDescriptionVector) std::vector<VkVertexInputBindingDescription>;

%template (VkViewportVector) std::vector<VkViewport>;

%template (VkPushConstantRangeVector) std::vector<VkPushConstantRange>;

%template (VkAttachmentDescriptionVector) std::vector<VkAttachmentDescription>;

%template (VkVertexInputAttributeDescriptionVector) std::vector<VkVertexInputAttributeDescription>;

%template (VkDescriptorSetLayoutBindingVector) std::vector< std::shared_ptr<VkDescriptorSetLayoutBindingRAII> >;

%template (VkBufferVector) std::vector<VkBuffer>;

%template (VkBufferMemoryBarrierVector) std::vector<VkBufferMemoryBarrier>;

%template (VkClearAttachmentVector) std::vector<VkClearAttachment>;

%template (VkClearValueVector) std::vector<VkClearValue>;

%template (VkSparseBufferMemoryBindInfoVector) std::vector< std::shared_ptr<VkSparseBufferMemoryBindInfoRAII> >;

%template (VkResultVector) std::vector<VkResult>;

%template (VkLayerPropertiesVector) std::vector<VkLayerProperties>;

%template (VkSparseImageMemoryBindVector) std::vector<VkSparseImageMemoryBind>;

%template (VkSparseMemoryBindVector) std::vector<VkSparseMemoryBind>;

%template (VkSparseImageFormatProperties2Vector) std::vector<VkSparseImageFormatProperties2>;

%template (VkPhysicalDeviceVector) std::vector<VkPhysicalDevice>;

%template (VkSparseImageOpaqueMemoryBindInfoVector) std::vector< std::shared_ptr<VkSparseImageOpaqueMemoryBindInfoRAII> >;

%template (VkSwapchainKHRVector) std::vector<VkSwapchainKHR>;

%template (VkBindBufferMemoryInfoVector) std::vector<VkBindBufferMemoryInfo>;

%template (VkSparseImageMemoryBindInfoVector) std::vector< std::shared_ptr<VkSparseImageMemoryBindInfoRAII> >;

%template (VkSamplerVector) std::vector<VkSampler>;

%template (VkImageVector) std::vector<VkImage>;

%template (int32Vector) std::vector<int32_t>;

%template (VkSparseImageMemoryRequirements2Vector) std::vector<VkSparseImageMemoryRequirements2>;

%template (VkRect2DVector) std::vector<VkRect2D>;

%template (VkDisplayKHRVector) std::vector<VkDisplayKHR>;

%template (VkDescriptorPoolSizeVector) std::vector<VkDescriptorPoolSize>;

%template (VkDescriptorImageInfoVector) std::vector<VkDescriptorImageInfo>;

%template (VkPipelineColorBlendAttachmentStateVector) std::vector<VkPipelineColorBlendAttachmentState>;

%template (VkDeviceQueueCreateInfoVector) std::vector< std::shared_ptr<VkDeviceQueueCreateInfoRAII> >;

%template (floatVector) std::vector<float>;

%template (VkInputAttachmentAspectReferenceVector) std::vector<VkInputAttachmentAspectReference>;

%template (VkGraphicsPipelineCreateInfoVector) std::vector< std::shared_ptr<VkGraphicsPipelineCreateInfoRAII> >;

%template (VkImageMemoryBarrierVector) std::vector<VkImageMemoryBarrier>;

%template (uint8Vector) std::vector<uint8_t>;

%template (VkSemaphoreVector) std::vector<VkSemaphore>;

%template (VkDescriptorBufferInfoVector) std::vector<VkDescriptorBufferInfo>;

%template (VkQueueFamilyPropertiesVector) std::vector<VkQueueFamilyProperties>;

%template (VkSparseImageFormatPropertiesVector) std::vector<VkSparseImageFormatProperties>;

%template (VkPipelineShaderStageCreateInfoVector) std::vector< std::shared_ptr<VkPipelineShaderStageCreateInfoRAII> >;

%template (VkSparseImageMemoryRequirementsVector) std::vector<VkSparseImageMemoryRequirements>;

%template (VkBufferViewVector) std::vector<VkBufferView>;

%template (VkSubmitInfoVector) std::vector< std::shared_ptr<VkSubmitInfoRAII> >;

%template (VkDeviceMemoryVector) std::vector<VkDeviceMemory>;

%template (VkImageViewVector) std::vector<VkImageView>;

%template (VkPhysicalDeviceGroupPropertiesVector) std::vector<VkPhysicalDeviceGroupProperties>;

%template (VkPipelineVector) std::vector<VkPipeline>;

#ifdef VK_KHR_display

%template (VkDisplayModePropertiesKHRVector) std::vector<VkDisplayModePropertiesKHR>;

#endif

%template (VkPipelineHandleVector) std::vector< std::shared_ptr< VkPipeline_T > >;

%template (VkSwapchainKHRHandleVector) std::vector< std::shared_ptr< VkSwapchainKHR_T > >;

// Skipped commands that must be manually wrapped
//vkGetInstanceProcAddr
//vkGetDeviceProcAddr
//vkMapMemory
//vkAllocateDescriptorSets
//vkAllocateCommandBuffers
//vkCmdUpdateBuffer
//vkCmdPushConstants
//vkUpdateDescriptorSetWithTemplate
// End content generated by genswigi.py
