
/*
*
* THIS FILE IS GENERATED BY genswigi.py
*
* vulkanmitts SWIG interface description file
*
* Copyright (C) 2016 by VLAM3D Software inc. https://www.vlam3d.com
*
* This code is licensed under the MIT license (MIT) (http://opensource.org/licenses/MIT)
*/

/*
** Copyright (c) 2015-2016 The Khronos Group Inc.
**
** Permission is hereby granted, free of charge, to any person obtaining a
** copy of this software and/or associated documentation files (the
** "Materials"), to deal in the Materials without restriction, including
** without limitation the rights to use, copy, modify, merge, publish,
** distribute, sublicense, and/or sell copies of the Materials, and to
** permit persons to whom the Materials are furnished to do so, subject to
** the following conditions:
**
** The above copyright notice and this permission notice shall be included
** in all copies or substantial portions of the Materials.
**
** THE MATERIALS ARE PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
** MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
** TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
** MATERIALS OR THE USE OR OTHER DEALINGS IN THE MATERIALS.
*/

// Begin content generated by genswigi.py
const char* vkGetErrorString(VkResult retval);



#define VK_VERSION_1_1 1
#include "vk_platform.h"
#define VK_MAKE_VERSION(major, minor, patch) \
    (((major) << 22) | ((minor) << 12) | (patch))

// Vulkan 1.1 version number
#define VK_API_VERSION_1_1 VK_MAKE_VERSION(1, 1, 0)// Patch version should always be set to 0


#if !defined(VK_DEFINE_NON_DISPATCHABLE_HANDLE)
#if defined(__LP64__) || defined(_WIN64) || (defined(__x86_64__) && !defined(__ILP32__) ) || defined(_M_X64) || defined(__ia64) || defined (_M_IA64) || defined(__aarch64__) || defined(__powerpc64__)
        #define VK_DEFINE_NON_DISPATCHABLE_HANDLE(object) typedef struct object##_T *object;
#else
        #define VK_DEFINE_NON_DISPATCHABLE_HANDLE(object) typedef uint64_t object;
#endif
#endif


#define VK_DEFINE_HANDLE(object) typedef struct object##_T* object;

typedef uint32_t VkFlags;
typedef uint32_t VkBool32;
typedef uint64_t VkDeviceSize;
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkBuffer)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkDeviceMemory)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkImage)
VK_DEFINE_HANDLE(VkDevice)
VK_DEFINE_HANDLE(VkPhysicalDevice)
VK_DEFINE_HANDLE(VkInstance)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkCommandPool)
VK_DEFINE_HANDLE(VkQueue)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkSamplerYcbcrConversion)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkDescriptorUpdateTemplate)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkDescriptorSetLayout)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkPipelineLayout)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkSampler)
#define VK_MAX_DEVICE_GROUP_SIZE          32
#define VK_MAX_PHYSICAL_DEVICE_NAME_SIZE  256
#define VK_UUID_SIZE                      16
#define VK_MAX_MEMORY_TYPES               32
#define VK_MAX_MEMORY_HEAPS               16
#define VK_LUID_SIZE                      8
#define VK_QUEUE_FAMILY_EXTERNAL          (~0U-1)

typedef enum VkResult {
    VK_SUCCESS = 0,
    VK_NOT_READY = 1,
    VK_TIMEOUT = 2,
    VK_EVENT_SET = 3,
    VK_EVENT_RESET = 4,
    VK_INCOMPLETE = 5,
    VK_ERROR_OUT_OF_HOST_MEMORY = -1,
    VK_ERROR_OUT_OF_DEVICE_MEMORY = -2,
    VK_ERROR_INITIALIZATION_FAILED = -3,
    VK_ERROR_DEVICE_LOST = -4,
    VK_ERROR_MEMORY_MAP_FAILED = -5,
    VK_ERROR_LAYER_NOT_PRESENT = -6,
    VK_ERROR_EXTENSION_NOT_PRESENT = -7,
    VK_ERROR_FEATURE_NOT_PRESENT = -8,
    VK_ERROR_INCOMPATIBLE_DRIVER = -9,
    VK_ERROR_TOO_MANY_OBJECTS = -10,
    VK_ERROR_FORMAT_NOT_SUPPORTED = -11,
    VK_ERROR_FRAGMENTED_POOL = -12,
    VK_ERROR_OUT_OF_POOL_MEMORY = -1000069000,
    VK_ERROR_INVALID_EXTERNAL_HANDLE = -1000072003,
    VK_ERROR_SURFACE_LOST_KHR = -1000000000,
    VK_ERROR_NATIVE_WINDOW_IN_USE_KHR = -1000000001,
    VK_SUBOPTIMAL_KHR = 1000001003,
    VK_ERROR_OUT_OF_DATE_KHR = -1000001004,
    VK_ERROR_INCOMPATIBLE_DISPLAY_KHR = -1000003001,
    VK_ERROR_VALIDATION_FAILED_EXT = -1000011001,
    VK_ERROR_INVALID_SHADER_NV = -1000012000,
    VK_ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT = -1000158000,
    VK_ERROR_FRAGMENTATION_EXT = -1000161000,
    VK_ERROR_NOT_PERMITTED_EXT = -1000174001,
    VK_ERROR_INVALID_DEVICE_ADDRESS_EXT = -1000244000,
    VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT = -1000255000,
    VK_ERROR_OUT_OF_POOL_MEMORY_KHR = VK_ERROR_OUT_OF_POOL_MEMORY,
    VK_ERROR_INVALID_EXTERNAL_HANDLE_KHR = VK_ERROR_INVALID_EXTERNAL_HANDLE,
    VK_RESULT_MAX_ENUM = 0x7FFFFFFF
} VkResult;

typedef enum VkStructureType {
    VK_STRUCTURE_TYPE_APPLICATION_INFO = 0,
    VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO = 1,
    VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO = 2,
    VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO = 3,
    VK_STRUCTURE_TYPE_SUBMIT_INFO = 4,
    VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO = 5,
    VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE = 6,
    VK_STRUCTURE_TYPE_BIND_SPARSE_INFO = 7,
    VK_STRUCTURE_TYPE_FENCE_CREATE_INFO = 8,
    VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO = 9,
    VK_STRUCTURE_TYPE_EVENT_CREATE_INFO = 10,
    VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO = 11,
    VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO = 12,
    VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO = 13,
    VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO = 14,
    VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO = 15,
    VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO = 16,
    VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO = 17,
    VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO = 18,
    VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO = 19,
    VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO = 20,
    VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO = 21,
    VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO = 22,
    VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO = 23,
    VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO = 24,
    VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO = 25,
    VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO = 26,
    VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO = 27,
    VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO = 28,
    VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO = 29,
    VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO = 30,
    VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO = 31,
    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO = 32,
    VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO = 33,
    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO = 34,
    VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET = 35,
    VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET = 36,
    VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO = 37,
    VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO = 38,
    VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO = 39,
    VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO = 40,
    VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO = 41,
    VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO = 42,
    VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO = 43,
    VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER = 44,
    VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER = 45,
    VK_STRUCTURE_TYPE_MEMORY_BARRIER = 46,
    VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO = 47,
    VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO = 48,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES = 1000094000,
    VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO = 1000157000,
    VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO = 1000157001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES = 1000083000,
    VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS = 1000127000,
    VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO = 1000127001,
    VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO = 1000060000,
    VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO = 1000060003,
    VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO = 1000060004,
    VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO = 1000060005,
    VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO = 1000060006,
    VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO = 1000060013,
    VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO = 1000060014,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES = 1000070000,
    VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO = 1000070001,
    VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2 = 1000146000,
    VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2 = 1000146001,
    VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2 = 1000146002,
    VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2 = 1000146003,
    VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2 = 1000146004,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2 = 1000059000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2 = 1000059001,
    VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2 = 1000059002,
    VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2 = 1000059003,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2 = 1000059004,
    VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2 = 1000059005,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2 = 1000059006,
    VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2 = 1000059007,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2 = 1000059008,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES = 1000117000,
    VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO = 1000117001,
    VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO = 1000117002,
    VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO = 1000117003,
    VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO = 1000053000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES = 1000053001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES = 1000053002,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES = 1000120000,
    VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO = 1000145000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES = 1000145001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES = 1000145002,
    VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2 = 1000145003,
    VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO = 1000156000,
    VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO = 1000156001,
    VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO = 1000156002,
    VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO = 1000156003,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES = 1000156004,
    VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES = 1000156005,
    VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO = 1000085000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO = 1000071000,
    VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES = 1000071001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO = 1000071002,
    VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES = 1000071003,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES = 1000071004,
    VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO = 1000072000,
    VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO = 1000072001,
    VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO = 1000072002,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO = 1000112000,
    VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES = 1000112001,
    VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO = 1000113000,
    VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO = 1000077000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO = 1000076000,
    VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES = 1000076001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES = 1000168000,
    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT = 1000168001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES = 1000063000,
    VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR = 1000001000,
    VK_STRUCTURE_TYPE_PRESENT_INFO_KHR = 1000001001,
    VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR = 1000060007,
    VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR = 1000060008,
    VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR = 1000060009,
    VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR = 1000060010,
    VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR = 1000060011,
    VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR = 1000060012,
    VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR = 1000002000,
    VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR = 1000002001,
    VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR = 1000003000,
    VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR = 1000004000,
    VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR = 1000005000,
    VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR = 1000006000,
    VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR = 1000008000,
    VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR = 1000009000,
    VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT = 1000011000,
    VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD = 1000018000,
    VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT = 1000022000,
    VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT = 1000022001,
    VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT = 1000022002,
    VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV = 1000026000,
    VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV = 1000026001,
    VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV = 1000026002,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT = 1000028000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT = 1000028001,
    VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT = 1000028002,
    VK_STRUCTURE_TYPE_IMAGE_VIEW_HANDLE_INFO_NVX = 1000030000,
    VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD = 1000041000,
    VK_STRUCTURE_TYPE_STREAM_DESCRIPTOR_SURFACE_CREATE_INFO_GGP = 1000049000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV = 1000050000,
    VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV = 1000056000,
    VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV = 1000056001,
    VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV = 1000057000,
    VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV = 1000057001,
    VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV = 1000058000,
    VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT = 1000061000,
    VK_STRUCTURE_TYPE_VI_SURFACE_CREATE_INFO_NN = 1000062000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES_EXT = 1000066000,
    VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT = 1000067000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT = 1000067001,
    VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR = 1000073000,
    VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR = 1000073001,
    VK_STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR = 1000073002,
    VK_STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR = 1000073003,
    VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR = 1000074000,
    VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR = 1000074001,
    VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR = 1000074002,
    VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR = 1000075000,
    VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR = 1000078000,
    VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR = 1000078001,
    VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR = 1000078002,
    VK_STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR = 1000078003,
    VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR = 1000079000,
    VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR = 1000079001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR = 1000080000,
    VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT = 1000081000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT = 1000081001,
    VK_STRUCTURE_TYPE_CONDITIONAL_RENDERING_BEGIN_INFO_EXT = 1000081002,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES_KHR = 1000082000,
    VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR = 1000084000,
    VK_STRUCTURE_TYPE_OBJECT_TABLE_CREATE_INFO_NVX = 1000086000,
    VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NVX = 1000086001,
    VK_STRUCTURE_TYPE_CMD_PROCESS_COMMANDS_INFO_NVX = 1000086002,
    VK_STRUCTURE_TYPE_CMD_RESERVE_SPACE_FOR_COMMANDS_INFO_NVX = 1000086003,
    VK_STRUCTURE_TYPE_DEVICE_GENERATED_COMMANDS_LIMITS_NVX = 1000086004,
    VK_STRUCTURE_TYPE_DEVICE_GENERATED_COMMANDS_FEATURES_NVX = 1000086005,
    VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV = 1000087000,
    VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT = 1000090000,
    VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT = 1000091000,
    VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT = 1000091001,
    VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT = 1000091002,
    VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT = 1000091003,
    VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE = 1000092000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX = 1000097000,
    VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV = 1000098000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT = 1000099000,
    VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT = 1000099001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT = 1000101000,
    VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT = 1000101001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT = 1000102000,
    VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT = 1000102001,
    VK_STRUCTURE_TYPE_HDR_METADATA_EXT = 1000105000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES_KHR = 1000108000,
    VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO_KHR = 1000108001,
    VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO_KHR = 1000108002,
    VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO_KHR = 1000108003,
    VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2_KHR = 1000109000,
    VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2_KHR = 1000109001,
    VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2_KHR = 1000109002,
    VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2_KHR = 1000109003,
    VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2_KHR = 1000109004,
    VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO_KHR = 1000109005,
    VK_STRUCTURE_TYPE_SUBPASS_END_INFO_KHR = 1000109006,
    VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR = 1000111000,
    VK_STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR = 1000114000,
    VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR = 1000114001,
    VK_STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR = 1000114002,
    VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR = 1000115000,
    VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR = 1000115001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR = 1000119000,
    VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR = 1000119001,
    VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR = 1000119002,
    VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR = 1000121000,
    VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR = 1000121001,
    VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR = 1000121002,
    VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR = 1000121003,
    VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR = 1000121004,
    VK_STRUCTURE_TYPE_IOS_SURFACE_CREATE_INFO_MVK = 1000122000,
    VK_STRUCTURE_TYPE_MACOS_SURFACE_CREATE_INFO_MVK = 1000123000,
    VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT = 1000128000,
    VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT = 1000128001,
    VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT = 1000128002,
    VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT = 1000128003,
    VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT = 1000128004,
    VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID = 1000129000,
    VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID = 1000129001,
    VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID = 1000129002,
    VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID = 1000129003,
    VK_STRUCTURE_TYPE_MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID = 1000129004,
    VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID = 1000129005,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES_EXT = 1000130000,
    VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT = 1000130001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES_EXT = 1000138000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES_EXT = 1000138001,
    VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK_EXT = 1000138002,
    VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO_EXT = 1000138003,
    VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT = 1000143000,
    VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT = 1000143001,
    VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT = 1000143002,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT = 1000143003,
    VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT = 1000143004,
    VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO_KHR = 1000147000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT = 1000148000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT = 1000148001,
    VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT = 1000148002,
    VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV = 1000149000,
    VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV = 1000152000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV = 1000154000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV = 1000154001,
    VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT = 1000158000,
    VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT = 1000158001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT = 1000158002,
    VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT = 1000158003,
    VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT = 1000158004,
    VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT = 1000158005,
    VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT = 1000160000,
    VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT = 1000160001,
    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO_EXT = 1000161000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES_EXT = 1000161001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES_EXT = 1000161002,
    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO_EXT = 1000161003,
    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT_EXT = 1000161004,
    VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV = 1000164000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV = 1000164001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV = 1000164002,
    VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV = 1000164005,
    VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_NV = 1000165000,
    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_NV = 1000165001,
    VK_STRUCTURE_TYPE_GEOMETRY_NV = 1000165003,
    VK_STRUCTURE_TYPE_GEOMETRY_TRIANGLES_NV = 1000165004,
    VK_STRUCTURE_TYPE_GEOMETRY_AABB_NV = 1000165005,
    VK_STRUCTURE_TYPE_BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV = 1000165006,
    VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV = 1000165007,
    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV = 1000165008,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV = 1000165009,
    VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV = 1000165011,
    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_INFO_NV = 1000165012,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV = 1000166000,
    VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV = 1000166001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT = 1000170000,
    VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT = 1000170001,
    VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT = 1000174000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES_KHR = 1000177000,
    VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT = 1000178000,
    VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT = 1000178001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT = 1000178002,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES_KHR = 1000180000,
    VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD = 1000183000,
    VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_EXT = 1000184000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD = 1000185000,
    VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD = 1000189000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT = 1000190000,
    VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT = 1000190001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT = 1000190002,
    VK_STRUCTURE_TYPE_PRESENT_FRAME_TOKEN_GGP = 1000191000,
    VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO_EXT = 1000192000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES_KHR = 1000196000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES_KHR = 1000197000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES_KHR = 1000199000,
    VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE_KHR = 1000199001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV = 1000201000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV = 1000202000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV = 1000202001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_NV = 1000203000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV = 1000204000,
    VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV = 1000205000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV = 1000205002,
    VK_STRUCTURE_TYPE_CHECKPOINT_DATA_NV = 1000206000,
    VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV = 1000206001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL = 1000209000,
    VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO_INTEL = 1000210000,
    VK_STRUCTURE_TYPE_INITIALIZE_PERFORMANCE_API_INFO_INTEL = 1000210001,
    VK_STRUCTURE_TYPE_PERFORMANCE_MARKER_INFO_INTEL = 1000210002,
    VK_STRUCTURE_TYPE_PERFORMANCE_STREAM_MARKER_INFO_INTEL = 1000210003,
    VK_STRUCTURE_TYPE_PERFORMANCE_OVERRIDE_INFO_INTEL = 1000210004,
    VK_STRUCTURE_TYPE_PERFORMANCE_CONFIGURATION_ACQUIRE_INFO_INTEL = 1000210005,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES_KHR = 1000211000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT = 1000212000,
    VK_STRUCTURE_TYPE_DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD = 1000213000,
    VK_STRUCTURE_TYPE_SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD = 1000213001,
    VK_STRUCTURE_TYPE_IMAGEPIPE_SURFACE_CREATE_INFO_FUCHSIA = 1000214000,
    VK_STRUCTURE_TYPE_METAL_SURFACE_CREATE_INFO_EXT = 1000217000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT = 1000218000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT = 1000218001,
    VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT = 1000218002,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES_EXT = 1000221000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES_EXT = 1000225000,
    VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO_EXT = 1000225001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES_EXT = 1000225002,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD = 1000227000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD = 1000229000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT = 1000237000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT = 1000238000,
    VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT = 1000238001,
    VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR = 1000239000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV = 1000240000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT = 1000244000,
    VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO_EXT = 1000244001,
    VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT = 1000244002,
    VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO_EXT = 1000246000,
    VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT = 1000247000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV = 1000249000,
    VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_NV = 1000249001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV = 1000249002,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV = 1000250000,
    VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV = 1000250001,
    VK_STRUCTURE_TYPE_FRAMEBUFFER_MIXED_SAMPLES_COMBINATION_NV = 1000250002,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT = 1000251000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT = 1000252000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES_KHR = 1000253000,
    VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT = 1000255000,
    VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT = 1000255002,
    VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT = 1000255001,
    VK_STRUCTURE_TYPE_HEADLESS_SURFACE_CREATE_INFO_EXT = 1000256000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT = 1000259000,
    VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_EXT = 1000259001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT = 1000259002,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES_EXT = 1000261000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT = 1000265000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR = 1000269000,
    VK_STRUCTURE_TYPE_PIPELINE_INFO_KHR = 1000269001,
    VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_PROPERTIES_KHR = 1000269002,
    VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INFO_KHR = 1000269003,
    VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_STATISTIC_KHR = 1000269004,
    VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INTERNAL_REPRESENTATION_KHR = 1000269005,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES_EXT = 1000276000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT = 1000281000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES_EXT = 1000281001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETER_FEATURES = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES,
    VK_STRUCTURE_TYPE_DEBUG_REPORT_CREATE_INFO_EXT = VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT,
    VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
    VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2_KHR = VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2,
    VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2_KHR = VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2,
    VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2_KHR = VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2,
    VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2_KHR = VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2,
    VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO_KHR = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO,
    VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO_KHR = VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO,
    VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO_KHR = VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO,
    VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO_KHR = VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO,
    VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO_KHR = VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO,
    VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO_KHR = VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO,
    VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO_KHR = VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES,
    VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO,
    VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES_KHR = VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO,
    VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES_KHR = VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES,
    VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO,
    VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO,
    VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_KHR = VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO,
    VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES_KHR = VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES,
    VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT16_INT8_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES_KHR,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES,
    VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO,
    VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES2_EXT = VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO,
    VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES_KHR = VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES,
    VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES,
    VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO,
    VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO,
    VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES,
    VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS_KHR = VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS,
    VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO_KHR = VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO,
    VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2_KHR = VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2,
    VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2_KHR = VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2,
    VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2_KHR = VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2,
    VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2_KHR = VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2,
    VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2_KHR = VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2,
    VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO,
    VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO_KHR = VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO,
    VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO_KHR = VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO,
    VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO_KHR = VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES,
    VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES_KHR = VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES,
    VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO_KHR = VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO,
    VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO_KHR = VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES,
    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT_KHR = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_ADDRESS_FEATURES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT,
    VK_STRUCTURE_TYPE_MAX_ENUM = 0x7FFFFFFF
} VkStructureType;

typedef enum VkPhysicalDeviceType {
    VK_PHYSICAL_DEVICE_TYPE_OTHER = 0,
    VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU = 1,
    VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU = 2,
    VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU = 3,
    VK_PHYSICAL_DEVICE_TYPE_CPU = 4,
    VK_PHYSICAL_DEVICE_TYPE_MAX_ENUM = 0x7FFFFFFF
} VkPhysicalDeviceType;

typedef enum VkFormat {
    VK_FORMAT_UNDEFINED = 0,
    VK_FORMAT_R4G4_UNORM_PACK8 = 1,
    VK_FORMAT_R4G4B4A4_UNORM_PACK16 = 2,
    VK_FORMAT_B4G4R4A4_UNORM_PACK16 = 3,
    VK_FORMAT_R5G6B5_UNORM_PACK16 = 4,
    VK_FORMAT_B5G6R5_UNORM_PACK16 = 5,
    VK_FORMAT_R5G5B5A1_UNORM_PACK16 = 6,
    VK_FORMAT_B5G5R5A1_UNORM_PACK16 = 7,
    VK_FORMAT_A1R5G5B5_UNORM_PACK16 = 8,
    VK_FORMAT_R8_UNORM = 9,
    VK_FORMAT_R8_SNORM = 10,
    VK_FORMAT_R8_USCALED = 11,
    VK_FORMAT_R8_SSCALED = 12,
    VK_FORMAT_R8_UINT = 13,
    VK_FORMAT_R8_SINT = 14,
    VK_FORMAT_R8_SRGB = 15,
    VK_FORMAT_R8G8_UNORM = 16,
    VK_FORMAT_R8G8_SNORM = 17,
    VK_FORMAT_R8G8_USCALED = 18,
    VK_FORMAT_R8G8_SSCALED = 19,
    VK_FORMAT_R8G8_UINT = 20,
    VK_FORMAT_R8G8_SINT = 21,
    VK_FORMAT_R8G8_SRGB = 22,
    VK_FORMAT_R8G8B8_UNORM = 23,
    VK_FORMAT_R8G8B8_SNORM = 24,
    VK_FORMAT_R8G8B8_USCALED = 25,
    VK_FORMAT_R8G8B8_SSCALED = 26,
    VK_FORMAT_R8G8B8_UINT = 27,
    VK_FORMAT_R8G8B8_SINT = 28,
    VK_FORMAT_R8G8B8_SRGB = 29,
    VK_FORMAT_B8G8R8_UNORM = 30,
    VK_FORMAT_B8G8R8_SNORM = 31,
    VK_FORMAT_B8G8R8_USCALED = 32,
    VK_FORMAT_B8G8R8_SSCALED = 33,
    VK_FORMAT_B8G8R8_UINT = 34,
    VK_FORMAT_B8G8R8_SINT = 35,
    VK_FORMAT_B8G8R8_SRGB = 36,
    VK_FORMAT_R8G8B8A8_UNORM = 37,
    VK_FORMAT_R8G8B8A8_SNORM = 38,
    VK_FORMAT_R8G8B8A8_USCALED = 39,
    VK_FORMAT_R8G8B8A8_SSCALED = 40,
    VK_FORMAT_R8G8B8A8_UINT = 41,
    VK_FORMAT_R8G8B8A8_SINT = 42,
    VK_FORMAT_R8G8B8A8_SRGB = 43,
    VK_FORMAT_B8G8R8A8_UNORM = 44,
    VK_FORMAT_B8G8R8A8_SNORM = 45,
    VK_FORMAT_B8G8R8A8_USCALED = 46,
    VK_FORMAT_B8G8R8A8_SSCALED = 47,
    VK_FORMAT_B8G8R8A8_UINT = 48,
    VK_FORMAT_B8G8R8A8_SINT = 49,
    VK_FORMAT_B8G8R8A8_SRGB = 50,
    VK_FORMAT_A8B8G8R8_UNORM_PACK32 = 51,
    VK_FORMAT_A8B8G8R8_SNORM_PACK32 = 52,
    VK_FORMAT_A8B8G8R8_USCALED_PACK32 = 53,
    VK_FORMAT_A8B8G8R8_SSCALED_PACK32 = 54,
    VK_FORMAT_A8B8G8R8_UINT_PACK32 = 55,
    VK_FORMAT_A8B8G8R8_SINT_PACK32 = 56,
    VK_FORMAT_A8B8G8R8_SRGB_PACK32 = 57,
    VK_FORMAT_A2R10G10B10_UNORM_PACK32 = 58,
    VK_FORMAT_A2R10G10B10_SNORM_PACK32 = 59,
    VK_FORMAT_A2R10G10B10_USCALED_PACK32 = 60,
    VK_FORMAT_A2R10G10B10_SSCALED_PACK32 = 61,
    VK_FORMAT_A2R10G10B10_UINT_PACK32 = 62,
    VK_FORMAT_A2R10G10B10_SINT_PACK32 = 63,
    VK_FORMAT_A2B10G10R10_UNORM_PACK32 = 64,
    VK_FORMAT_A2B10G10R10_SNORM_PACK32 = 65,
    VK_FORMAT_A2B10G10R10_USCALED_PACK32 = 66,
    VK_FORMAT_A2B10G10R10_SSCALED_PACK32 = 67,
    VK_FORMAT_A2B10G10R10_UINT_PACK32 = 68,
    VK_FORMAT_A2B10G10R10_SINT_PACK32 = 69,
    VK_FORMAT_R16_UNORM = 70,
    VK_FORMAT_R16_SNORM = 71,
    VK_FORMAT_R16_USCALED = 72,
    VK_FORMAT_R16_SSCALED = 73,
    VK_FORMAT_R16_UINT = 74,
    VK_FORMAT_R16_SINT = 75,
    VK_FORMAT_R16_SFLOAT = 76,
    VK_FORMAT_R16G16_UNORM = 77,
    VK_FORMAT_R16G16_SNORM = 78,
    VK_FORMAT_R16G16_USCALED = 79,
    VK_FORMAT_R16G16_SSCALED = 80,
    VK_FORMAT_R16G16_UINT = 81,
    VK_FORMAT_R16G16_SINT = 82,
    VK_FORMAT_R16G16_SFLOAT = 83,
    VK_FORMAT_R16G16B16_UNORM = 84,
    VK_FORMAT_R16G16B16_SNORM = 85,
    VK_FORMAT_R16G16B16_USCALED = 86,
    VK_FORMAT_R16G16B16_SSCALED = 87,
    VK_FORMAT_R16G16B16_UINT = 88,
    VK_FORMAT_R16G16B16_SINT = 89,
    VK_FORMAT_R16G16B16_SFLOAT = 90,
    VK_FORMAT_R16G16B16A16_UNORM = 91,
    VK_FORMAT_R16G16B16A16_SNORM = 92,
    VK_FORMAT_R16G16B16A16_USCALED = 93,
    VK_FORMAT_R16G16B16A16_SSCALED = 94,
    VK_FORMAT_R16G16B16A16_UINT = 95,
    VK_FORMAT_R16G16B16A16_SINT = 96,
    VK_FORMAT_R16G16B16A16_SFLOAT = 97,
    VK_FORMAT_R32_UINT = 98,
    VK_FORMAT_R32_SINT = 99,
    VK_FORMAT_R32_SFLOAT = 100,
    VK_FORMAT_R32G32_UINT = 101,
    VK_FORMAT_R32G32_SINT = 102,
    VK_FORMAT_R32G32_SFLOAT = 103,
    VK_FORMAT_R32G32B32_UINT = 104,
    VK_FORMAT_R32G32B32_SINT = 105,
    VK_FORMAT_R32G32B32_SFLOAT = 106,
    VK_FORMAT_R32G32B32A32_UINT = 107,
    VK_FORMAT_R32G32B32A32_SINT = 108,
    VK_FORMAT_R32G32B32A32_SFLOAT = 109,
    VK_FORMAT_R64_UINT = 110,
    VK_FORMAT_R64_SINT = 111,
    VK_FORMAT_R64_SFLOAT = 112,
    VK_FORMAT_R64G64_UINT = 113,
    VK_FORMAT_R64G64_SINT = 114,
    VK_FORMAT_R64G64_SFLOAT = 115,
    VK_FORMAT_R64G64B64_UINT = 116,
    VK_FORMAT_R64G64B64_SINT = 117,
    VK_FORMAT_R64G64B64_SFLOAT = 118,
    VK_FORMAT_R64G64B64A64_UINT = 119,
    VK_FORMAT_R64G64B64A64_SINT = 120,
    VK_FORMAT_R64G64B64A64_SFLOAT = 121,
    VK_FORMAT_B10G11R11_UFLOAT_PACK32 = 122,
    VK_FORMAT_E5B9G9R9_UFLOAT_PACK32 = 123,
    VK_FORMAT_D16_UNORM = 124,
    VK_FORMAT_X8_D24_UNORM_PACK32 = 125,
    VK_FORMAT_D32_SFLOAT = 126,
    VK_FORMAT_S8_UINT = 127,
    VK_FORMAT_D16_UNORM_S8_UINT = 128,
    VK_FORMAT_D24_UNORM_S8_UINT = 129,
    VK_FORMAT_D32_SFLOAT_S8_UINT = 130,
    VK_FORMAT_BC1_RGB_UNORM_BLOCK = 131,
    VK_FORMAT_BC1_RGB_SRGB_BLOCK = 132,
    VK_FORMAT_BC1_RGBA_UNORM_BLOCK = 133,
    VK_FORMAT_BC1_RGBA_SRGB_BLOCK = 134,
    VK_FORMAT_BC2_UNORM_BLOCK = 135,
    VK_FORMAT_BC2_SRGB_BLOCK = 136,
    VK_FORMAT_BC3_UNORM_BLOCK = 137,
    VK_FORMAT_BC3_SRGB_BLOCK = 138,
    VK_FORMAT_BC4_UNORM_BLOCK = 139,
    VK_FORMAT_BC4_SNORM_BLOCK = 140,
    VK_FORMAT_BC5_UNORM_BLOCK = 141,
    VK_FORMAT_BC5_SNORM_BLOCK = 142,
    VK_FORMAT_BC6H_UFLOAT_BLOCK = 143,
    VK_FORMAT_BC6H_SFLOAT_BLOCK = 144,
    VK_FORMAT_BC7_UNORM_BLOCK = 145,
    VK_FORMAT_BC7_SRGB_BLOCK = 146,
    VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK = 147,
    VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK = 148,
    VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK = 149,
    VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK = 150,
    VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK = 151,
    VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK = 152,
    VK_FORMAT_EAC_R11_UNORM_BLOCK = 153,
    VK_FORMAT_EAC_R11_SNORM_BLOCK = 154,
    VK_FORMAT_EAC_R11G11_UNORM_BLOCK = 155,
    VK_FORMAT_EAC_R11G11_SNORM_BLOCK = 156,
    VK_FORMAT_ASTC_4x4_UNORM_BLOCK = 157,
    VK_FORMAT_ASTC_4x4_SRGB_BLOCK = 158,
    VK_FORMAT_ASTC_5x4_UNORM_BLOCK = 159,
    VK_FORMAT_ASTC_5x4_SRGB_BLOCK = 160,
    VK_FORMAT_ASTC_5x5_UNORM_BLOCK = 161,
    VK_FORMAT_ASTC_5x5_SRGB_BLOCK = 162,
    VK_FORMAT_ASTC_6x5_UNORM_BLOCK = 163,
    VK_FORMAT_ASTC_6x5_SRGB_BLOCK = 164,
    VK_FORMAT_ASTC_6x6_UNORM_BLOCK = 165,
    VK_FORMAT_ASTC_6x6_SRGB_BLOCK = 166,
    VK_FORMAT_ASTC_8x5_UNORM_BLOCK = 167,
    VK_FORMAT_ASTC_8x5_SRGB_BLOCK = 168,
    VK_FORMAT_ASTC_8x6_UNORM_BLOCK = 169,
    VK_FORMAT_ASTC_8x6_SRGB_BLOCK = 170,
    VK_FORMAT_ASTC_8x8_UNORM_BLOCK = 171,
    VK_FORMAT_ASTC_8x8_SRGB_BLOCK = 172,
    VK_FORMAT_ASTC_10x5_UNORM_BLOCK = 173,
    VK_FORMAT_ASTC_10x5_SRGB_BLOCK = 174,
    VK_FORMAT_ASTC_10x6_UNORM_BLOCK = 175,
    VK_FORMAT_ASTC_10x6_SRGB_BLOCK = 176,
    VK_FORMAT_ASTC_10x8_UNORM_BLOCK = 177,
    VK_FORMAT_ASTC_10x8_SRGB_BLOCK = 178,
    VK_FORMAT_ASTC_10x10_UNORM_BLOCK = 179,
    VK_FORMAT_ASTC_10x10_SRGB_BLOCK = 180,
    VK_FORMAT_ASTC_12x10_UNORM_BLOCK = 181,
    VK_FORMAT_ASTC_12x10_SRGB_BLOCK = 182,
    VK_FORMAT_ASTC_12x12_UNORM_BLOCK = 183,
    VK_FORMAT_ASTC_12x12_SRGB_BLOCK = 184,
    VK_FORMAT_G8B8G8R8_422_UNORM = 1000156000,
    VK_FORMAT_B8G8R8G8_422_UNORM = 1000156001,
    VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM = 1000156002,
    VK_FORMAT_G8_B8R8_2PLANE_420_UNORM = 1000156003,
    VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM = 1000156004,
    VK_FORMAT_G8_B8R8_2PLANE_422_UNORM = 1000156005,
    VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM = 1000156006,
    VK_FORMAT_R10X6_UNORM_PACK16 = 1000156007,
    VK_FORMAT_R10X6G10X6_UNORM_2PACK16 = 1000156008,
    VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16 = 1000156009,
    VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16 = 1000156010,
    VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16 = 1000156011,
    VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16 = 1000156012,
    VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16 = 1000156013,
    VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16 = 1000156014,
    VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16 = 1000156015,
    VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16 = 1000156016,
    VK_FORMAT_R12X4_UNORM_PACK16 = 1000156017,
    VK_FORMAT_R12X4G12X4_UNORM_2PACK16 = 1000156018,
    VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16 = 1000156019,
    VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16 = 1000156020,
    VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16 = 1000156021,
    VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16 = 1000156022,
    VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16 = 1000156023,
    VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16 = 1000156024,
    VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16 = 1000156025,
    VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16 = 1000156026,
    VK_FORMAT_G16B16G16R16_422_UNORM = 1000156027,
    VK_FORMAT_B16G16R16G16_422_UNORM = 1000156028,
    VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM = 1000156029,
    VK_FORMAT_G16_B16R16_2PLANE_420_UNORM = 1000156030,
    VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM = 1000156031,
    VK_FORMAT_G16_B16R16_2PLANE_422_UNORM = 1000156032,
    VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM = 1000156033,
    VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG = 1000054000,
    VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG = 1000054001,
    VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG = 1000054002,
    VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG = 1000054003,
    VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG = 1000054004,
    VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG = 1000054005,
    VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG = 1000054006,
    VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG = 1000054007,
    VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK_EXT = 1000066000,
    VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK_EXT = 1000066001,
    VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK_EXT = 1000066002,
    VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK_EXT = 1000066003,
    VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK_EXT = 1000066004,
    VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK_EXT = 1000066005,
    VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK_EXT = 1000066006,
    VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK_EXT = 1000066007,
    VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK_EXT = 1000066008,
    VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK_EXT = 1000066009,
    VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK_EXT = 1000066010,
    VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK_EXT = 1000066011,
    VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK_EXT = 1000066012,
    VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK_EXT = 1000066013,
    VK_FORMAT_G8B8G8R8_422_UNORM_KHR = VK_FORMAT_G8B8G8R8_422_UNORM,
    VK_FORMAT_B8G8R8G8_422_UNORM_KHR = VK_FORMAT_B8G8R8G8_422_UNORM,
    VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM_KHR = VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM,
    VK_FORMAT_G8_B8R8_2PLANE_420_UNORM_KHR = VK_FORMAT_G8_B8R8_2PLANE_420_UNORM,
    VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM_KHR = VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM,
    VK_FORMAT_G8_B8R8_2PLANE_422_UNORM_KHR = VK_FORMAT_G8_B8R8_2PLANE_422_UNORM,
    VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM_KHR = VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM,
    VK_FORMAT_R10X6_UNORM_PACK16_KHR = VK_FORMAT_R10X6_UNORM_PACK16,
    VK_FORMAT_R10X6G10X6_UNORM_2PACK16_KHR = VK_FORMAT_R10X6G10X6_UNORM_2PACK16,
    VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16_KHR = VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16,
    VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16_KHR = VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16,
    VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16_KHR = VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16,
    VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16_KHR = VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16,
    VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16_KHR = VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16,
    VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16_KHR = VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16,
    VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16_KHR = VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16,
    VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16_KHR = VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16,
    VK_FORMAT_R12X4_UNORM_PACK16_KHR = VK_FORMAT_R12X4_UNORM_PACK16,
    VK_FORMAT_R12X4G12X4_UNORM_2PACK16_KHR = VK_FORMAT_R12X4G12X4_UNORM_2PACK16,
    VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16_KHR = VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16,
    VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16_KHR = VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16,
    VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16_KHR = VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16,
    VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16_KHR = VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16,
    VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16_KHR = VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16,
    VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16_KHR = VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16,
    VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16_KHR = VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16,
    VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16_KHR = VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16,
    VK_FORMAT_G16B16G16R16_422_UNORM_KHR = VK_FORMAT_G16B16G16R16_422_UNORM,
    VK_FORMAT_B16G16R16G16_422_UNORM_KHR = VK_FORMAT_B16G16R16G16_422_UNORM,
    VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM_KHR = VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM,
    VK_FORMAT_G16_B16R16_2PLANE_420_UNORM_KHR = VK_FORMAT_G16_B16R16_2PLANE_420_UNORM,
    VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM_KHR = VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM,
    VK_FORMAT_G16_B16R16_2PLANE_422_UNORM_KHR = VK_FORMAT_G16_B16R16_2PLANE_422_UNORM,
    VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM_KHR = VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM,
    VK_FORMAT_MAX_ENUM = 0x7FFFFFFF
} VkFormat;

typedef enum VkImageType {
    VK_IMAGE_TYPE_1D = 0,
    VK_IMAGE_TYPE_2D = 1,
    VK_IMAGE_TYPE_3D = 2,
    VK_IMAGE_TYPE_MAX_ENUM = 0x7FFFFFFF
} VkImageType;

typedef enum VkImageTiling {
    VK_IMAGE_TILING_OPTIMAL = 0,
    VK_IMAGE_TILING_LINEAR = 1,
    VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT = 1000158000,
    VK_IMAGE_TILING_MAX_ENUM = 0x7FFFFFFF
} VkImageTiling;

typedef enum VkPointClippingBehavior {
    VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES = 0,
    VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY = 1,
    VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES_KHR = VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES,
    VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY_KHR = VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY,
    VK_POINT_CLIPPING_BEHAVIOR_MAX_ENUM = 0x7FFFFFFF
} VkPointClippingBehavior;

typedef enum VkTessellationDomainOrigin {
    VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT = 0,
    VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT = 1,
    VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT_KHR = VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT,
    VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT_KHR = VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT,
    VK_TESSELLATION_DOMAIN_ORIGIN_MAX_ENUM = 0x7FFFFFFF
} VkTessellationDomainOrigin;

typedef enum VkSamplerYcbcrModelConversion {
    VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY = 0,
    VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY = 1,
    VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709 = 2,
    VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601 = 3,
    VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020 = 4,
    VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY_KHR = VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY,
    VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY_KHR = VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY,
    VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709_KHR = VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709,
    VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601_KHR = VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601,
    VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020_KHR = VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020,
    VK_SAMPLER_YCBCR_MODEL_CONVERSION_MAX_ENUM = 0x7FFFFFFF
} VkSamplerYcbcrModelConversion;

typedef enum VkSamplerYcbcrRange {
    VK_SAMPLER_YCBCR_RANGE_ITU_FULL = 0,
    VK_SAMPLER_YCBCR_RANGE_ITU_NARROW = 1,
    VK_SAMPLER_YCBCR_RANGE_ITU_FULL_KHR = VK_SAMPLER_YCBCR_RANGE_ITU_FULL,
    VK_SAMPLER_YCBCR_RANGE_ITU_NARROW_KHR = VK_SAMPLER_YCBCR_RANGE_ITU_NARROW,
    VK_SAMPLER_YCBCR_RANGE_MAX_ENUM = 0x7FFFFFFF
} VkSamplerYcbcrRange;

typedef enum VkComponentSwizzle {
    VK_COMPONENT_SWIZZLE_IDENTITY = 0,
    VK_COMPONENT_SWIZZLE_ZERO = 1,
    VK_COMPONENT_SWIZZLE_ONE = 2,
    VK_COMPONENT_SWIZZLE_R = 3,
    VK_COMPONENT_SWIZZLE_G = 4,
    VK_COMPONENT_SWIZZLE_B = 5,
    VK_COMPONENT_SWIZZLE_A = 6,
    VK_COMPONENT_SWIZZLE_MAX_ENUM = 0x7FFFFFFF
} VkComponentSwizzle;

typedef enum VkChromaLocation {
    VK_CHROMA_LOCATION_COSITED_EVEN = 0,
    VK_CHROMA_LOCATION_MIDPOINT = 1,
    VK_CHROMA_LOCATION_COSITED_EVEN_KHR = VK_CHROMA_LOCATION_COSITED_EVEN,
    VK_CHROMA_LOCATION_MIDPOINT_KHR = VK_CHROMA_LOCATION_MIDPOINT,
    VK_CHROMA_LOCATION_MAX_ENUM = 0x7FFFFFFF
} VkChromaLocation;

typedef enum VkFilter {
    VK_FILTER_NEAREST = 0,
    VK_FILTER_LINEAR = 1,
    VK_FILTER_CUBIC_IMG = 1000015000,
    VK_FILTER_CUBIC_EXT = VK_FILTER_CUBIC_IMG,
    VK_FILTER_MAX_ENUM = 0x7FFFFFFF
} VkFilter;

typedef enum VkSystemAllocationScope {
    VK_SYSTEM_ALLOCATION_SCOPE_COMMAND = 0,
    VK_SYSTEM_ALLOCATION_SCOPE_OBJECT = 1,
    VK_SYSTEM_ALLOCATION_SCOPE_CACHE = 2,
    VK_SYSTEM_ALLOCATION_SCOPE_DEVICE = 3,
    VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE = 4,
    VK_SYSTEM_ALLOCATION_SCOPE_MAX_ENUM = 0x7FFFFFFF
} VkSystemAllocationScope;

typedef enum VkInternalAllocationType {
    VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE = 0,
    VK_INTERNAL_ALLOCATION_TYPE_MAX_ENUM = 0x7FFFFFFF
} VkInternalAllocationType;

typedef enum VkDescriptorUpdateTemplateType {
    VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET = 0,
    VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR = 1,
    VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET_KHR = VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET,
    VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_MAX_ENUM = 0x7FFFFFFF
} VkDescriptorUpdateTemplateType;

typedef enum VkDescriptorType {
    VK_DESCRIPTOR_TYPE_SAMPLER = 0,
    VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER = 1,
    VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE = 2,
    VK_DESCRIPTOR_TYPE_STORAGE_IMAGE = 3,
    VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER = 4,
    VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER = 5,
    VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER = 6,
    VK_DESCRIPTOR_TYPE_STORAGE_BUFFER = 7,
    VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC = 8,
    VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC = 9,
    VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT = 10,
    VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT = 1000138000,
    VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_NV = 1000165000,
    VK_DESCRIPTOR_TYPE_MAX_ENUM = 0x7FFFFFFF
} VkDescriptorType;

typedef enum VkPipelineBindPoint {
    VK_PIPELINE_BIND_POINT_GRAPHICS = 0,
    VK_PIPELINE_BIND_POINT_COMPUTE = 1,
    VK_PIPELINE_BIND_POINT_RAY_TRACING_NV = 1000165000,
    VK_PIPELINE_BIND_POINT_MAX_ENUM = 0x7FFFFFFF
} VkPipelineBindPoint;

typedef enum VkShaderStageFlagBits {
    VK_SHADER_STAGE_VERTEX_BIT = 0x00000001,
    VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT = 0x00000002,
    VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT = 0x00000004,
    VK_SHADER_STAGE_GEOMETRY_BIT = 0x00000008,
    VK_SHADER_STAGE_FRAGMENT_BIT = 0x00000010,
    VK_SHADER_STAGE_COMPUTE_BIT = 0x00000020,
    VK_SHADER_STAGE_ALL_GRAPHICS = 0x0000001F,
    VK_SHADER_STAGE_ALL = 0x7FFFFFFF,
    VK_SHADER_STAGE_RAYGEN_BIT_NV = 0x00000100,
    VK_SHADER_STAGE_ANY_HIT_BIT_NV = 0x00000200,
    VK_SHADER_STAGE_CLOSEST_HIT_BIT_NV = 0x00000400,
    VK_SHADER_STAGE_MISS_BIT_NV = 0x00000800,
    VK_SHADER_STAGE_INTERSECTION_BIT_NV = 0x00001000,
    VK_SHADER_STAGE_CALLABLE_BIT_NV = 0x00002000,
    VK_SHADER_STAGE_TASK_BIT_NV = 0x00000040,
    VK_SHADER_STAGE_MESH_BIT_NV = 0x00000080,
    VK_SHADER_STAGE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkShaderStageFlagBits;
typedef VkFlags VkShaderStageFlags;

typedef enum VkSubgroupFeatureFlagBits {
    VK_SUBGROUP_FEATURE_BASIC_BIT = 0x00000001,
    VK_SUBGROUP_FEATURE_VOTE_BIT = 0x00000002,
    VK_SUBGROUP_FEATURE_ARITHMETIC_BIT = 0x00000004,
    VK_SUBGROUP_FEATURE_BALLOT_BIT = 0x00000008,
    VK_SUBGROUP_FEATURE_SHUFFLE_BIT = 0x00000010,
    VK_SUBGROUP_FEATURE_SHUFFLE_RELATIVE_BIT = 0x00000020,
    VK_SUBGROUP_FEATURE_CLUSTERED_BIT = 0x00000040,
    VK_SUBGROUP_FEATURE_QUAD_BIT = 0x00000080,
    VK_SUBGROUP_FEATURE_PARTITIONED_BIT_NV = 0x00000100,
    VK_SUBGROUP_FEATURE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkSubgroupFeatureFlagBits;
typedef VkFlags VkSubgroupFeatureFlags;

typedef enum VkPeerMemoryFeatureFlagBits {
    VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT = 0x00000001,
    VK_PEER_MEMORY_FEATURE_COPY_DST_BIT = 0x00000002,
    VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT = 0x00000004,
    VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT = 0x00000008,
    VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT_KHR = VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT,
    VK_PEER_MEMORY_FEATURE_COPY_DST_BIT_KHR = VK_PEER_MEMORY_FEATURE_COPY_DST_BIT,
    VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT_KHR = VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT,
    VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT_KHR = VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT,
    VK_PEER_MEMORY_FEATURE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkPeerMemoryFeatureFlagBits;
typedef VkFlags VkPeerMemoryFeatureFlags;

typedef enum VkMemoryAllocateFlagBits {
    VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT = 0x00000001,
    VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT_KHR = VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT,
    VK_MEMORY_ALLOCATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkMemoryAllocateFlagBits;
typedef VkFlags VkMemoryAllocateFlags;

typedef enum VkImageAspectFlagBits {
    VK_IMAGE_ASPECT_COLOR_BIT = 0x00000001,
    VK_IMAGE_ASPECT_DEPTH_BIT = 0x00000002,
    VK_IMAGE_ASPECT_STENCIL_BIT = 0x00000004,
    VK_IMAGE_ASPECT_METADATA_BIT = 0x00000008,
    VK_IMAGE_ASPECT_PLANE_0_BIT = 0x00000010,
    VK_IMAGE_ASPECT_PLANE_1_BIT = 0x00000020,
    VK_IMAGE_ASPECT_PLANE_2_BIT = 0x00000040,
    VK_IMAGE_ASPECT_MEMORY_PLANE_0_BIT_EXT = 0x00000080,
    VK_IMAGE_ASPECT_MEMORY_PLANE_1_BIT_EXT = 0x00000100,
    VK_IMAGE_ASPECT_MEMORY_PLANE_2_BIT_EXT = 0x00000200,
    VK_IMAGE_ASPECT_MEMORY_PLANE_3_BIT_EXT = 0x00000400,
    VK_IMAGE_ASPECT_PLANE_0_BIT_KHR = VK_IMAGE_ASPECT_PLANE_0_BIT,
    VK_IMAGE_ASPECT_PLANE_1_BIT_KHR = VK_IMAGE_ASPECT_PLANE_1_BIT,
    VK_IMAGE_ASPECT_PLANE_2_BIT_KHR = VK_IMAGE_ASPECT_PLANE_2_BIT,
    VK_IMAGE_ASPECT_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkImageAspectFlagBits;
typedef VkFlags VkImageAspectFlags;

typedef enum VkSparseImageFormatFlagBits {
    VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT = 0x00000001,
    VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT = 0x00000002,
    VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT = 0x00000004,
    VK_SPARSE_IMAGE_FORMAT_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkSparseImageFormatFlagBits;
typedef VkFlags VkSparseImageFormatFlags;

typedef enum VkSampleCountFlagBits {
    VK_SAMPLE_COUNT_1_BIT = 0x00000001,
    VK_SAMPLE_COUNT_2_BIT = 0x00000002,
    VK_SAMPLE_COUNT_4_BIT = 0x00000004,
    VK_SAMPLE_COUNT_8_BIT = 0x00000008,
    VK_SAMPLE_COUNT_16_BIT = 0x00000010,
    VK_SAMPLE_COUNT_32_BIT = 0x00000020,
    VK_SAMPLE_COUNT_64_BIT = 0x00000040,
    VK_SAMPLE_COUNT_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkSampleCountFlagBits;
typedef VkFlags VkSampleCountFlags;

typedef enum VkFormatFeatureFlagBits {
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT = 0x00000001,
    VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT = 0x00000002,
    VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT = 0x00000004,
    VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT = 0x00000008,
    VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT = 0x00000010,
    VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT = 0x00000020,
    VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT = 0x00000040,
    VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT = 0x00000080,
    VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT = 0x00000100,
    VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT = 0x00000200,
    VK_FORMAT_FEATURE_BLIT_SRC_BIT = 0x00000400,
    VK_FORMAT_FEATURE_BLIT_DST_BIT = 0x00000800,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT = 0x00001000,
    VK_FORMAT_FEATURE_TRANSFER_SRC_BIT = 0x00004000,
    VK_FORMAT_FEATURE_TRANSFER_DST_BIT = 0x00008000,
    VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT = 0x00020000,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT = 0x00040000,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT = 0x00080000,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT = 0x00100000,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT = 0x00200000,
    VK_FORMAT_FEATURE_DISJOINT_BIT = 0x00400000,
    VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT = 0x00800000,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG = 0x00002000,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT_EXT = 0x00010000,
    VK_FORMAT_FEATURE_FRAGMENT_DENSITY_MAP_BIT_EXT = 0x01000000,
    VK_FORMAT_FEATURE_TRANSFER_SRC_BIT_KHR = VK_FORMAT_FEATURE_TRANSFER_SRC_BIT,
    VK_FORMAT_FEATURE_TRANSFER_DST_BIT_KHR = VK_FORMAT_FEATURE_TRANSFER_DST_BIT,
    VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT_KHR = VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT_KHR = VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT_KHR = VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT_KHR = VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT_KHR = VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT,
    VK_FORMAT_FEATURE_DISJOINT_BIT_KHR = VK_FORMAT_FEATURE_DISJOINT_BIT,
    VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT_KHR = VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT = VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG,
    VK_FORMAT_FEATURE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkFormatFeatureFlagBits;
typedef VkFlags VkFormatFeatureFlags;

typedef enum VkImageUsageFlagBits {
    VK_IMAGE_USAGE_TRANSFER_SRC_BIT = 0x00000001,
    VK_IMAGE_USAGE_TRANSFER_DST_BIT = 0x00000002,
    VK_IMAGE_USAGE_SAMPLED_BIT = 0x00000004,
    VK_IMAGE_USAGE_STORAGE_BIT = 0x00000008,
    VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT = 0x00000010,
    VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT = 0x00000020,
    VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT = 0x00000040,
    VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT = 0x00000080,
    VK_IMAGE_USAGE_SHADING_RATE_IMAGE_BIT_NV = 0x00000100,
    VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT = 0x00000200,
    VK_IMAGE_USAGE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkImageUsageFlagBits;
typedef VkFlags VkImageUsageFlags;

typedef enum VkImageCreateFlagBits {
    VK_IMAGE_CREATE_SPARSE_BINDING_BIT = 0x00000001,
    VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT = 0x00000002,
    VK_IMAGE_CREATE_SPARSE_ALIASED_BIT = 0x00000004,
    VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT = 0x00000008,
    VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT = 0x00000010,
    VK_IMAGE_CREATE_ALIAS_BIT = 0x00000400,
    VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT = 0x00000040,
    VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT = 0x00000020,
    VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT = 0x00000080,
    VK_IMAGE_CREATE_EXTENDED_USAGE_BIT = 0x00000100,
    VK_IMAGE_CREATE_PROTECTED_BIT = 0x00000800,
    VK_IMAGE_CREATE_DISJOINT_BIT = 0x00000200,
    VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV = 0x00002000,
    VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT = 0x00001000,
    VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT = 0x00004000,
    VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR = VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT,
    VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT_KHR = VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT,
    VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT_KHR = VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT,
    VK_IMAGE_CREATE_EXTENDED_USAGE_BIT_KHR = VK_IMAGE_CREATE_EXTENDED_USAGE_BIT,
    VK_IMAGE_CREATE_DISJOINT_BIT_KHR = VK_IMAGE_CREATE_DISJOINT_BIT,
    VK_IMAGE_CREATE_ALIAS_BIT_KHR = VK_IMAGE_CREATE_ALIAS_BIT,
    VK_IMAGE_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkImageCreateFlagBits;
typedef VkFlags VkImageCreateFlags;

typedef enum VkQueueFlagBits {
    VK_QUEUE_GRAPHICS_BIT = 0x00000001,
    VK_QUEUE_COMPUTE_BIT = 0x00000002,
    VK_QUEUE_TRANSFER_BIT = 0x00000004,
    VK_QUEUE_SPARSE_BINDING_BIT = 0x00000008,
    VK_QUEUE_PROTECTED_BIT = 0x00000010,
    VK_QUEUE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkQueueFlagBits;
typedef VkFlags VkQueueFlags;

typedef enum VkMemoryPropertyFlagBits {
    VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT = 0x00000001,
    VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT = 0x00000002,
    VK_MEMORY_PROPERTY_HOST_COHERENT_BIT = 0x00000004,
    VK_MEMORY_PROPERTY_HOST_CACHED_BIT = 0x00000008,
    VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT = 0x00000010,
    VK_MEMORY_PROPERTY_PROTECTED_BIT = 0x00000020,
    VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD = 0x00000040,
    VK_MEMORY_PROPERTY_DEVICE_UNCACHED_BIT_AMD = 0x00000080,
    VK_MEMORY_PROPERTY_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkMemoryPropertyFlagBits;
typedef VkFlags VkMemoryPropertyFlags;

typedef enum VkMemoryHeapFlagBits {
    VK_MEMORY_HEAP_DEVICE_LOCAL_BIT = 0x00000001,
    VK_MEMORY_HEAP_MULTI_INSTANCE_BIT = 0x00000002,
    VK_MEMORY_HEAP_MULTI_INSTANCE_BIT_KHR = VK_MEMORY_HEAP_MULTI_INSTANCE_BIT,
    VK_MEMORY_HEAP_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkMemoryHeapFlagBits;
typedef VkFlags VkMemoryHeapFlags;
typedef VkFlags VkCommandPoolTrimFlags;

typedef enum VkDeviceQueueCreateFlagBits {
    VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT = 0x00000001,
    VK_DEVICE_QUEUE_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkDeviceQueueCreateFlagBits;
typedef VkFlags VkDeviceQueueCreateFlags;
typedef VkFlags VkDescriptorUpdateTemplateCreateFlags;

typedef enum VkExternalMemoryHandleTypeFlagBits {
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT = 0x00000001,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT = 0x00000002,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT = 0x00000004,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT = 0x00000008,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT = 0x00000010,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT = 0x00000020,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT = 0x00000040,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT = 0x00000200,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID = 0x00000400,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT = 0x00000080,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT = 0x00000100,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT_KHR = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT_KHR = VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT_KHR = VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT_KHR = VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT_KHR = VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkExternalMemoryHandleTypeFlagBits;
typedef VkFlags VkExternalMemoryHandleTypeFlags;

typedef enum VkExternalMemoryFeatureFlagBits {
    VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT = 0x00000001,
    VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT = 0x00000002,
    VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT = 0x00000004,
    VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_KHR = VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT,
    VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_KHR = VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT,
    VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_KHR = VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT,
    VK_EXTERNAL_MEMORY_FEATURE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkExternalMemoryFeatureFlagBits;
typedef VkFlags VkExternalMemoryFeatureFlags;

typedef enum VkBufferCreateFlagBits {
    VK_BUFFER_CREATE_SPARSE_BINDING_BIT = 0x00000001,
    VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT = 0x00000002,
    VK_BUFFER_CREATE_SPARSE_ALIASED_BIT = 0x00000004,
    VK_BUFFER_CREATE_PROTECTED_BIT = 0x00000008,
    VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_EXT = 0x00000010,
    VK_BUFFER_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkBufferCreateFlagBits;
typedef VkFlags VkBufferCreateFlags;

typedef enum VkBufferUsageFlagBits {
    VK_BUFFER_USAGE_TRANSFER_SRC_BIT = 0x00000001,
    VK_BUFFER_USAGE_TRANSFER_DST_BIT = 0x00000002,
    VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT = 0x00000004,
    VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT = 0x00000008,
    VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT = 0x00000010,
    VK_BUFFER_USAGE_STORAGE_BUFFER_BIT = 0x00000020,
    VK_BUFFER_USAGE_INDEX_BUFFER_BIT = 0x00000040,
    VK_BUFFER_USAGE_VERTEX_BUFFER_BIT = 0x00000080,
    VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT = 0x00000100,
    VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_BUFFER_BIT_EXT = 0x00000800,
    VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT = 0x00001000,
    VK_BUFFER_USAGE_CONDITIONAL_RENDERING_BIT_EXT = 0x00000200,
    VK_BUFFER_USAGE_RAY_TRACING_BIT_NV = 0x00000400,
    VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_EXT = 0x00020000,
    VK_BUFFER_USAGE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkBufferUsageFlagBits;
typedef VkFlags VkBufferUsageFlags;

typedef enum VkExternalFenceHandleTypeFlagBits {
    VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT = 0x00000001,
    VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT = 0x00000002,
    VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT = 0x00000004,
    VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT = 0x00000008,
    VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR = VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT,
    VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR = VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT,
    VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR = VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT,
    VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT_KHR = VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT,
    VK_EXTERNAL_FENCE_HANDLE_TYPE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkExternalFenceHandleTypeFlagBits;
typedef VkFlags VkExternalFenceHandleTypeFlags;

typedef enum VkExternalFenceFeatureFlagBits {
    VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT = 0x00000001,
    VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT = 0x00000002,
    VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT_KHR = VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT,
    VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT_KHR = VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT,
    VK_EXTERNAL_FENCE_FEATURE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkExternalFenceFeatureFlagBits;
typedef VkFlags VkExternalFenceFeatureFlags;

typedef enum VkFenceImportFlagBits {
    VK_FENCE_IMPORT_TEMPORARY_BIT = 0x00000001,
    VK_FENCE_IMPORT_TEMPORARY_BIT_KHR = VK_FENCE_IMPORT_TEMPORARY_BIT,
    VK_FENCE_IMPORT_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkFenceImportFlagBits;
typedef VkFlags VkFenceImportFlags;

typedef enum VkSemaphoreImportFlagBits {
    VK_SEMAPHORE_IMPORT_TEMPORARY_BIT = 0x00000001,
    VK_SEMAPHORE_IMPORT_TEMPORARY_BIT_KHR = VK_SEMAPHORE_IMPORT_TEMPORARY_BIT,
    VK_SEMAPHORE_IMPORT_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkSemaphoreImportFlagBits;
typedef VkFlags VkSemaphoreImportFlags;

typedef enum VkExternalSemaphoreHandleTypeFlagBits {
    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT = 0x00000001,
    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT = 0x00000002,
    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT = 0x00000004,
    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT = 0x00000008,
    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT = 0x00000010,
    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT,
    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT,
    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT,
    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT_KHR = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT,
    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT_KHR = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT,
    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkExternalSemaphoreHandleTypeFlagBits;
typedef VkFlags VkExternalSemaphoreHandleTypeFlags;

typedef enum VkExternalSemaphoreFeatureFlagBits {
    VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT = 0x00000001,
    VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT = 0x00000002,
    VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT_KHR = VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT,
    VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT_KHR = VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT,
    VK_EXTERNAL_SEMAPHORE_FEATURE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkExternalSemaphoreFeatureFlagBits;
typedef VkFlags VkExternalSemaphoreFeatureFlags;

typedef enum VkDescriptorSetLayoutCreateFlagBits {
    VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR = 0x00000001,
    VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT = 0x00000002,
    VK_DESCRIPTOR_SET_LAYOUT_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkDescriptorSetLayoutCreateFlagBits;
typedef VkFlags VkDescriptorSetLayoutCreateFlags;
typedef struct VkPhysicalDeviceSubgroupProperties {
    VkStructureType           sType;
    void*                     pNext;
    uint32_t                  subgroupSize;
    VkShaderStageFlags        supportedStages;
    VkSubgroupFeatureFlags    supportedOperations;
    VkBool32                  quadOperationsInAllStages;
} VkPhysicalDeviceSubgroupProperties;

typedef struct VkBindBufferMemoryInfo {
    VkStructureType    sType;
    const void*        pNext;
    VkBuffer           buffer;
    VkDeviceMemory     memory;
    VkDeviceSize       memoryOffset;
} VkBindBufferMemoryInfo;

typedef struct VkBindImageMemoryInfo {
    VkStructureType    sType;
    const void*        pNext;
    VkImage            image;
    VkDeviceMemory     memory;
    VkDeviceSize       memoryOffset;
} VkBindImageMemoryInfo;

typedef struct VkPhysicalDevice16BitStorageFeatures {
    VkStructureType    sType;
    void*              pNext;
    VkBool32           storageBuffer16BitAccess;
    VkBool32           uniformAndStorageBuffer16BitAccess;
    VkBool32           storagePushConstant16;
    VkBool32           storageInputOutput16;
} VkPhysicalDevice16BitStorageFeatures;

typedef struct VkMemoryDedicatedRequirements {
    VkStructureType    sType;
    void*              pNext;
    VkBool32           prefersDedicatedAllocation;
    VkBool32           requiresDedicatedAllocation;
} VkMemoryDedicatedRequirements;

typedef struct VkMemoryDedicatedAllocateInfo {
    VkStructureType    sType;
    const void*        pNext;
    VkImage            image;
    VkBuffer           buffer;
} VkMemoryDedicatedAllocateInfo;

typedef struct VkMemoryAllocateFlagsInfo {
    VkStructureType          sType;
    const void*              pNext;
    VkMemoryAllocateFlags    flags;
    uint32_t                 deviceMask;
} VkMemoryAllocateFlagsInfo;

typedef struct VkOffset2D {
    int32_t    x;
    int32_t    y;
} VkOffset2D;

typedef struct VkExtent2D {
    uint32_t    width;
    uint32_t    height;
} VkExtent2D;

typedef struct VkRect2D {
    VkOffset2D    offset;
    VkExtent2D    extent;
} VkRect2D;

typedef struct VkDeviceGroupRenderPassBeginInfo {
    VkStructureType    sType;
    const void*        pNext;
    uint32_t           deviceMask;
    uint32_t           deviceRenderAreaCount;
    const VkRect2D*    pDeviceRenderAreas;
} VkDeviceGroupRenderPassBeginInfo;

struct VkDeviceGroupRenderPassBeginInfoRAII {
   VkDeviceGroupRenderPassBeginInfo nonRaiiObj;
    std::vector<VkRect2D>                       vecDeviceRenderAreas;
};

typedef struct VkDeviceGroupCommandBufferBeginInfo {
    VkStructureType    sType;
    const void*        pNext;
    uint32_t           deviceMask;
} VkDeviceGroupCommandBufferBeginInfo;

typedef struct VkDeviceGroupSubmitInfo {
    VkStructureType    sType;
    const void*        pNext;
    uint32_t           waitSemaphoreCount;
    const uint32_t*    pWaitSemaphoreDeviceIndices;
    uint32_t           commandBufferCount;
    const uint32_t*    pCommandBufferDeviceMasks;
    uint32_t           signalSemaphoreCount;
    const uint32_t*    pSignalSemaphoreDeviceIndices;
} VkDeviceGroupSubmitInfo;

struct VkDeviceGroupSubmitInfoRAII {
   VkDeviceGroupSubmitInfo nonRaiiObj;
    std::vector<uint32_t>                       vecWaitSemaphoreDeviceIndices;
    std::vector<uint32_t>                       vecCommandBufferDeviceMasks;
    std::vector<uint32_t>                       vecSignalSemaphoreDeviceIndices;
};

typedef struct VkDeviceGroupBindSparseInfo {
    VkStructureType    sType;
    const void*        pNext;
    uint32_t           resourceDeviceIndex;
    uint32_t           memoryDeviceIndex;
} VkDeviceGroupBindSparseInfo;

typedef struct VkBindBufferMemoryDeviceGroupInfo {
    VkStructureType    sType;
    const void*        pNext;
    uint32_t           deviceIndexCount;
    const uint32_t*    pDeviceIndices;
} VkBindBufferMemoryDeviceGroupInfo;

struct VkBindBufferMemoryDeviceGroupInfoRAII {
   VkBindBufferMemoryDeviceGroupInfo nonRaiiObj;
    std::vector<uint32_t>                       vecDeviceIndices;
};

typedef struct VkBindImageMemoryDeviceGroupInfo {
    VkStructureType    sType;
    const void*        pNext;
    uint32_t           deviceIndexCount;
    const uint32_t*    pDeviceIndices;
    uint32_t           splitInstanceBindRegionCount;
    const VkRect2D*    pSplitInstanceBindRegions;
} VkBindImageMemoryDeviceGroupInfo;

struct VkBindImageMemoryDeviceGroupInfoRAII {
   VkBindImageMemoryDeviceGroupInfo nonRaiiObj;
    std::vector<uint32_t>                       vecDeviceIndices;
    std::vector<VkRect2D>                       vecSplitInstanceBindRegions;
};

typedef struct VkPhysicalDeviceGroupProperties {
    VkStructureType     sType;
    void*               pNext;
    uint32_t            physicalDeviceCount;
    VkPhysicalDevice    physicalDevices[VK_MAX_DEVICE_GROUP_SIZE];
    VkBool32            subsetAllocation;
} VkPhysicalDeviceGroupProperties;

typedef struct VkDeviceGroupDeviceCreateInfo {
    VkStructureType            sType;
    const void*                pNext;
    uint32_t                   physicalDeviceCount;
    const VkPhysicalDevice*    pPhysicalDevices;
} VkDeviceGroupDeviceCreateInfo;

struct VkDeviceGroupDeviceCreateInfoRAII {
   VkDeviceGroupDeviceCreateInfo nonRaiiObj;
    std::vector<VkPhysicalDevice>               vecPhysicalDevices;
};

typedef struct VkBufferMemoryRequirementsInfo2 {
    VkStructureType    sType;
    const void*        pNext;
    VkBuffer           buffer;
} VkBufferMemoryRequirementsInfo2;

typedef struct VkImageMemoryRequirementsInfo2 {
    VkStructureType    sType;
    const void*        pNext;
    VkImage            image;
} VkImageMemoryRequirementsInfo2;

typedef struct VkImageSparseMemoryRequirementsInfo2 {
    VkStructureType    sType;
    const void*        pNext;
    VkImage            image;
} VkImageSparseMemoryRequirementsInfo2;

typedef struct VkMemoryRequirements {
    VkDeviceSize    size;
    VkDeviceSize    alignment;
    uint32_t        memoryTypeBits;
} VkMemoryRequirements;

typedef struct VkMemoryRequirements2 {
    VkStructureType         sType;
    void*                   pNext;
    VkMemoryRequirements    memoryRequirements;
} VkMemoryRequirements2;

typedef VkMemoryRequirements2 VkMemoryRequirements2KHR;

typedef struct VkExtent3D {
    uint32_t    width;
    uint32_t    height;
    uint32_t    depth;
} VkExtent3D;

typedef struct VkSparseImageFormatProperties {
    VkImageAspectFlags          aspectMask;
    VkExtent3D                  imageGranularity;
    VkSparseImageFormatFlags    flags;
} VkSparseImageFormatProperties;

typedef struct VkSparseImageMemoryRequirements {
    VkSparseImageFormatProperties    formatProperties;
    uint32_t                         imageMipTailFirstLod;
    VkDeviceSize                     imageMipTailSize;
    VkDeviceSize                     imageMipTailOffset;
    VkDeviceSize                     imageMipTailStride;
} VkSparseImageMemoryRequirements;

typedef struct VkSparseImageMemoryRequirements2 {
    VkStructureType                    sType;
    void*                              pNext;
    VkSparseImageMemoryRequirements    memoryRequirements;
} VkSparseImageMemoryRequirements2;

typedef struct VkPhysicalDeviceFeatures {
    VkBool32    robustBufferAccess;
    VkBool32    fullDrawIndexUint32;
    VkBool32    imageCubeArray;
    VkBool32    independentBlend;
    VkBool32    geometryShader;
    VkBool32    tessellationShader;
    VkBool32    sampleRateShading;
    VkBool32    dualSrcBlend;
    VkBool32    logicOp;
    VkBool32    multiDrawIndirect;
    VkBool32    drawIndirectFirstInstance;
    VkBool32    depthClamp;
    VkBool32    depthBiasClamp;
    VkBool32    fillModeNonSolid;
    VkBool32    depthBounds;
    VkBool32    wideLines;
    VkBool32    largePoints;
    VkBool32    alphaToOne;
    VkBool32    multiViewport;
    VkBool32    samplerAnisotropy;
    VkBool32    textureCompressionETC2;
    VkBool32    textureCompressionASTC_LDR;
    VkBool32    textureCompressionBC;
    VkBool32    occlusionQueryPrecise;
    VkBool32    pipelineStatisticsQuery;
    VkBool32    vertexPipelineStoresAndAtomics;
    VkBool32    fragmentStoresAndAtomics;
    VkBool32    shaderTessellationAndGeometryPointSize;
    VkBool32    shaderImageGatherExtended;
    VkBool32    shaderStorageImageExtendedFormats;
    VkBool32    shaderStorageImageMultisample;
    VkBool32    shaderStorageImageReadWithoutFormat;
    VkBool32    shaderStorageImageWriteWithoutFormat;
    VkBool32    shaderUniformBufferArrayDynamicIndexing;
    VkBool32    shaderSampledImageArrayDynamicIndexing;
    VkBool32    shaderStorageBufferArrayDynamicIndexing;
    VkBool32    shaderStorageImageArrayDynamicIndexing;
    VkBool32    shaderClipDistance;
    VkBool32    shaderCullDistance;
    VkBool32    shaderFloat64;
    VkBool32    shaderInt64;
    VkBool32    shaderInt16;
    VkBool32    shaderResourceResidency;
    VkBool32    shaderResourceMinLod;
    VkBool32    sparseBinding;
    VkBool32    sparseResidencyBuffer;
    VkBool32    sparseResidencyImage2D;
    VkBool32    sparseResidencyImage3D;
    VkBool32    sparseResidency2Samples;
    VkBool32    sparseResidency4Samples;
    VkBool32    sparseResidency8Samples;
    VkBool32    sparseResidency16Samples;
    VkBool32    sparseResidencyAliased;
    VkBool32    variableMultisampleRate;
    VkBool32    inheritedQueries;
} VkPhysicalDeviceFeatures;

typedef struct VkPhysicalDeviceFeatures2 {
    VkStructureType             sType;
    void*                       pNext;
    VkPhysicalDeviceFeatures    features;
} VkPhysicalDeviceFeatures2;

typedef struct VkPhysicalDeviceLimits {
    uint32_t              maxImageDimension1D;
    uint32_t              maxImageDimension2D;
    uint32_t              maxImageDimension3D;
    uint32_t              maxImageDimensionCube;
    uint32_t              maxImageArrayLayers;
    uint32_t              maxTexelBufferElements;
    uint32_t              maxUniformBufferRange;
    uint32_t              maxStorageBufferRange;
    uint32_t              maxPushConstantsSize;
    uint32_t              maxMemoryAllocationCount;
    uint32_t              maxSamplerAllocationCount;
    VkDeviceSize          bufferImageGranularity;
    VkDeviceSize          sparseAddressSpaceSize;
    uint32_t              maxBoundDescriptorSets;
    uint32_t              maxPerStageDescriptorSamplers;
    uint32_t              maxPerStageDescriptorUniformBuffers;
    uint32_t              maxPerStageDescriptorStorageBuffers;
    uint32_t              maxPerStageDescriptorSampledImages;
    uint32_t              maxPerStageDescriptorStorageImages;
    uint32_t              maxPerStageDescriptorInputAttachments;
    uint32_t              maxPerStageResources;
    uint32_t              maxDescriptorSetSamplers;
    uint32_t              maxDescriptorSetUniformBuffers;
    uint32_t              maxDescriptorSetUniformBuffersDynamic;
    uint32_t              maxDescriptorSetStorageBuffers;
    uint32_t              maxDescriptorSetStorageBuffersDynamic;
    uint32_t              maxDescriptorSetSampledImages;
    uint32_t              maxDescriptorSetStorageImages;
    uint32_t              maxDescriptorSetInputAttachments;
    uint32_t              maxVertexInputAttributes;
    uint32_t              maxVertexInputBindings;
    uint32_t              maxVertexInputAttributeOffset;
    uint32_t              maxVertexInputBindingStride;
    uint32_t              maxVertexOutputComponents;
    uint32_t              maxTessellationGenerationLevel;
    uint32_t              maxTessellationPatchSize;
    uint32_t              maxTessellationControlPerVertexInputComponents;
    uint32_t              maxTessellationControlPerVertexOutputComponents;
    uint32_t              maxTessellationControlPerPatchOutputComponents;
    uint32_t              maxTessellationControlTotalOutputComponents;
    uint32_t              maxTessellationEvaluationInputComponents;
    uint32_t              maxTessellationEvaluationOutputComponents;
    uint32_t              maxGeometryShaderInvocations;
    uint32_t              maxGeometryInputComponents;
    uint32_t              maxGeometryOutputComponents;
    uint32_t              maxGeometryOutputVertices;
    uint32_t              maxGeometryTotalOutputComponents;
    uint32_t              maxFragmentInputComponents;
    uint32_t              maxFragmentOutputAttachments;
    uint32_t              maxFragmentDualSrcAttachments;
    uint32_t              maxFragmentCombinedOutputResources;
    uint32_t              maxComputeSharedMemorySize;
    uint32_t              maxComputeWorkGroupCount[3];
    uint32_t              maxComputeWorkGroupInvocations;
    uint32_t              maxComputeWorkGroupSize[3];
    uint32_t              subPixelPrecisionBits;
    uint32_t              subTexelPrecisionBits;
    uint32_t              mipmapPrecisionBits;
    uint32_t              maxDrawIndexedIndexValue;
    uint32_t              maxDrawIndirectCount;
    float                 maxSamplerLodBias;
    float                 maxSamplerAnisotropy;
    uint32_t              maxViewports;
    uint32_t              maxViewportDimensions[2];
    float                 viewportBoundsRange[2];
    uint32_t              viewportSubPixelBits;
    size_t                minMemoryMapAlignment;
    VkDeviceSize          minTexelBufferOffsetAlignment;
    VkDeviceSize          minUniformBufferOffsetAlignment;
    VkDeviceSize          minStorageBufferOffsetAlignment;
    int32_t               minTexelOffset;
    uint32_t              maxTexelOffset;
    int32_t               minTexelGatherOffset;
    uint32_t              maxTexelGatherOffset;
    float                 minInterpolationOffset;
    float                 maxInterpolationOffset;
    uint32_t              subPixelInterpolationOffsetBits;
    uint32_t              maxFramebufferWidth;
    uint32_t              maxFramebufferHeight;
    uint32_t              maxFramebufferLayers;
    VkSampleCountFlags    framebufferColorSampleCounts;
    VkSampleCountFlags    framebufferDepthSampleCounts;
    VkSampleCountFlags    framebufferStencilSampleCounts;
    VkSampleCountFlags    framebufferNoAttachmentsSampleCounts;
    uint32_t              maxColorAttachments;
    VkSampleCountFlags    sampledImageColorSampleCounts;
    VkSampleCountFlags    sampledImageIntegerSampleCounts;
    VkSampleCountFlags    sampledImageDepthSampleCounts;
    VkSampleCountFlags    sampledImageStencilSampleCounts;
    VkSampleCountFlags    storageImageSampleCounts;
    uint32_t              maxSampleMaskWords;
    VkBool32              timestampComputeAndGraphics;
    float                 timestampPeriod;
    uint32_t              maxClipDistances;
    uint32_t              maxCullDistances;
    uint32_t              maxCombinedClipAndCullDistances;
    uint32_t              discreteQueuePriorities;
    float                 pointSizeRange[2];
    float                 lineWidthRange[2];
    float                 pointSizeGranularity;
    float                 lineWidthGranularity;
    VkBool32              strictLines;
    VkBool32              standardSampleLocations;
    VkDeviceSize          optimalBufferCopyOffsetAlignment;
    VkDeviceSize          optimalBufferCopyRowPitchAlignment;
    VkDeviceSize          nonCoherentAtomSize;
} VkPhysicalDeviceLimits;

typedef struct VkPhysicalDeviceSparseProperties {
    VkBool32    residencyStandard2DBlockShape;
    VkBool32    residencyStandard2DMultisampleBlockShape;
    VkBool32    residencyStandard3DBlockShape;
    VkBool32    residencyAlignedMipSize;
    VkBool32    residencyNonResidentStrict;
} VkPhysicalDeviceSparseProperties;

typedef struct VkPhysicalDeviceProperties {
    uint32_t                            apiVersion;
    uint32_t                            driverVersion;
    uint32_t                            vendorID;
    uint32_t                            deviceID;
    VkPhysicalDeviceType                deviceType;
    char                                deviceName[VK_MAX_PHYSICAL_DEVICE_NAME_SIZE];
    uint8_t                             pipelineCacheUUID[VK_UUID_SIZE];
    VkPhysicalDeviceLimits              limits;
    VkPhysicalDeviceSparseProperties    sparseProperties;
} VkPhysicalDeviceProperties;

typedef struct VkPhysicalDeviceProperties2 {
    VkStructureType               sType;
    void*                         pNext;
    VkPhysicalDeviceProperties    properties;
} VkPhysicalDeviceProperties2;

typedef struct VkFormatProperties {
    VkFormatFeatureFlags    linearTilingFeatures;
    VkFormatFeatureFlags    optimalTilingFeatures;
    VkFormatFeatureFlags    bufferFeatures;
} VkFormatProperties;

typedef struct VkFormatProperties2 {
    VkStructureType       sType;
    void*                 pNext;
    VkFormatProperties    formatProperties;
} VkFormatProperties2;

typedef struct VkImageFormatProperties {
    VkExtent3D            maxExtent;
    uint32_t              maxMipLevels;
    uint32_t              maxArrayLayers;
    VkSampleCountFlags    sampleCounts;
    VkDeviceSize          maxResourceSize;
} VkImageFormatProperties;

typedef struct VkImageFormatProperties2 {
    VkStructureType            sType;
    void*                      pNext;
    VkImageFormatProperties    imageFormatProperties;
} VkImageFormatProperties2;

typedef struct VkPhysicalDeviceImageFormatInfo2 {
    VkStructureType       sType;
    const void*           pNext;
    VkFormat              format;
    VkImageType           type;
    VkImageTiling         tiling;
    VkImageUsageFlags     usage;
    VkImageCreateFlags    flags;
} VkPhysicalDeviceImageFormatInfo2;

typedef struct VkQueueFamilyProperties {
    VkQueueFlags    queueFlags;
    uint32_t        queueCount;
    uint32_t        timestampValidBits;
    VkExtent3D      minImageTransferGranularity;
} VkQueueFamilyProperties;

typedef struct VkQueueFamilyProperties2 {
    VkStructureType            sType;
    void*                      pNext;
    VkQueueFamilyProperties    queueFamilyProperties;
} VkQueueFamilyProperties2;

typedef struct VkMemoryType {
    VkMemoryPropertyFlags    propertyFlags;
    uint32_t                 heapIndex;
} VkMemoryType;

typedef struct VkMemoryHeap {
    VkDeviceSize         size;
    VkMemoryHeapFlags    flags;
} VkMemoryHeap;

typedef struct VkPhysicalDeviceMemoryProperties {
    uint32_t        memoryTypeCount;
    VkMemoryType    memoryTypes[VK_MAX_MEMORY_TYPES];
    uint32_t        memoryHeapCount;
    VkMemoryHeap    memoryHeaps[VK_MAX_MEMORY_HEAPS];
} VkPhysicalDeviceMemoryProperties;

typedef struct VkPhysicalDeviceMemoryProperties2 {
    VkStructureType                     sType;
    void*                               pNext;
    VkPhysicalDeviceMemoryProperties    memoryProperties;
} VkPhysicalDeviceMemoryProperties2;

typedef struct VkSparseImageFormatProperties2 {
    VkStructureType                  sType;
    void*                            pNext;
    VkSparseImageFormatProperties    properties;
} VkSparseImageFormatProperties2;

typedef struct VkPhysicalDeviceSparseImageFormatInfo2 {
    VkStructureType          sType;
    const void*              pNext;
    VkFormat                 format;
    VkImageType              type;
    VkSampleCountFlagBits    samples;
    VkImageUsageFlags        usage;
    VkImageTiling            tiling;
} VkPhysicalDeviceSparseImageFormatInfo2;

typedef struct VkPhysicalDevicePointClippingProperties {
    VkStructureType            sType;
    void*                      pNext;
    VkPointClippingBehavior    pointClippingBehavior;
} VkPhysicalDevicePointClippingProperties;

typedef struct VkInputAttachmentAspectReference {
    uint32_t              subpass;
    uint32_t              inputAttachmentIndex;
    VkImageAspectFlags    aspectMask;
} VkInputAttachmentAspectReference;

typedef struct VkRenderPassInputAttachmentAspectCreateInfo {
    VkStructureType                            sType;
    const void*                                pNext;
    uint32_t                                   aspectReferenceCount;
    const VkInputAttachmentAspectReference*    pAspectReferences;
} VkRenderPassInputAttachmentAspectCreateInfo;

struct VkRenderPassInputAttachmentAspectCreateInfoRAII {
   VkRenderPassInputAttachmentAspectCreateInfo nonRaiiObj;
    std::vector<VkInputAttachmentAspectReference>vecAspectReferences;
};

typedef struct VkImageViewUsageCreateInfo {
    VkStructureType      sType;
    const void*          pNext;
    VkImageUsageFlags    usage;
} VkImageViewUsageCreateInfo;

typedef struct VkPipelineTessellationDomainOriginStateCreateInfo {
    VkStructureType               sType;
    const void*                   pNext;
    VkTessellationDomainOrigin    domainOrigin;
} VkPipelineTessellationDomainOriginStateCreateInfo;

typedef struct VkRenderPassMultiviewCreateInfo {
    VkStructureType    sType;
    const void*        pNext;
    uint32_t           subpassCount;
    const uint32_t*    pViewMasks;
    uint32_t           dependencyCount;
    const int32_t*     pViewOffsets;
    uint32_t           correlationMaskCount;
    const uint32_t*    pCorrelationMasks;
} VkRenderPassMultiviewCreateInfo;

struct VkRenderPassMultiviewCreateInfoRAII {
   VkRenderPassMultiviewCreateInfo nonRaiiObj;
    std::vector<uint32_t>                       vecViewMasks;
    std::vector<int32_t>                        vecViewOffsets;
    std::vector<uint32_t>                       vecCorrelationMasks;
};

typedef struct VkPhysicalDeviceMultiviewFeatures {
    VkStructureType    sType;
    void*              pNext;
    VkBool32           multiview;
    VkBool32           multiviewGeometryShader;
    VkBool32           multiviewTessellationShader;
} VkPhysicalDeviceMultiviewFeatures;

typedef struct VkPhysicalDeviceMultiviewProperties {
    VkStructureType    sType;
    void*              pNext;
    uint32_t           maxMultiviewViewCount;
    uint32_t           maxMultiviewInstanceIndex;
} VkPhysicalDeviceMultiviewProperties;

typedef struct VkPhysicalDeviceVariablePointersFeatures {
    VkStructureType    sType;
    void*              pNext;
    VkBool32           variablePointersStorageBuffer;
    VkBool32           variablePointers;
} VkPhysicalDeviceVariablePointersFeatures;

typedef VkPhysicalDeviceVariablePointersFeatures VkPhysicalDeviceVariablePointerFeatures;

typedef struct VkPhysicalDeviceProtectedMemoryFeatures {
    VkStructureType    sType;
    void*              pNext;
    VkBool32           protectedMemory;
} VkPhysicalDeviceProtectedMemoryFeatures;

typedef struct VkPhysicalDeviceProtectedMemoryProperties {
    VkStructureType    sType;
    void*              pNext;
    VkBool32           protectedNoFault;
} VkPhysicalDeviceProtectedMemoryProperties;

typedef struct VkDeviceQueueInfo2 {
    VkStructureType             sType;
    const void*                 pNext;
    VkDeviceQueueCreateFlags    flags;
    uint32_t                    queueFamilyIndex;
    uint32_t                    queueIndex;
} VkDeviceQueueInfo2;

typedef struct VkProtectedSubmitInfo {
    VkStructureType    sType;
    const void*        pNext;
    VkBool32           protectedSubmit;
} VkProtectedSubmitInfo;

typedef struct VkComponentMapping {
    VkComponentSwizzle    r;
    VkComponentSwizzle    g;
    VkComponentSwizzle    b;
    VkComponentSwizzle    a;
} VkComponentMapping;

typedef struct VkSamplerYcbcrConversionCreateInfo {
    VkStructureType                  sType;
    const void*                      pNext;
    VkFormat                         format;
    VkSamplerYcbcrModelConversion    ycbcrModel;
    VkSamplerYcbcrRange              ycbcrRange;
    VkComponentMapping               components;
    VkChromaLocation                 xChromaOffset;
    VkChromaLocation                 yChromaOffset;
    VkFilter                         chromaFilter;
    VkBool32                         forceExplicitReconstruction;
} VkSamplerYcbcrConversionCreateInfo;

typedef struct VkSamplerYcbcrConversionInfo {
    VkStructureType             sType;
    const void*                 pNext;
    VkSamplerYcbcrConversion    conversion;
} VkSamplerYcbcrConversionInfo;

typedef struct VkBindImagePlaneMemoryInfo {
    VkStructureType          sType;
    const void*              pNext;
    VkImageAspectFlagBits    planeAspect;
} VkBindImagePlaneMemoryInfo;

typedef struct VkImagePlaneMemoryRequirementsInfo {
    VkStructureType          sType;
    const void*              pNext;
    VkImageAspectFlagBits    planeAspect;
} VkImagePlaneMemoryRequirementsInfo;

typedef struct VkPhysicalDeviceSamplerYcbcrConversionFeatures {
    VkStructureType    sType;
    void*              pNext;
    VkBool32           samplerYcbcrConversion;
} VkPhysicalDeviceSamplerYcbcrConversionFeatures;

typedef struct VkSamplerYcbcrConversionImageFormatProperties {
    VkStructureType    sType;
    void*              pNext;
    uint32_t           combinedImageSamplerDescriptorCount;
} VkSamplerYcbcrConversionImageFormatProperties;

typedef void* (VKAPI_PTR *PFN_vkAllocationFunction)(
    void*                                       pUserData,
    size_t                                      size,
    size_t                                      alignment,
    VkSystemAllocationScope                     allocationScope);

typedef void* (VKAPI_PTR *PFN_vkReallocationFunction)(
    void*                                       pUserData,
    void*                                       pOriginal,
    size_t                                      size,
    size_t                                      alignment,
    VkSystemAllocationScope                     allocationScope);

typedef void (VKAPI_PTR *PFN_vkFreeFunction)(
    void*                                       pUserData,
    void*                                       pMemory);

typedef void (VKAPI_PTR *PFN_vkInternalAllocationNotification)(
    void*                                       pUserData,
    size_t                                      size,
    VkInternalAllocationType                    allocationType,
    VkSystemAllocationScope                     allocationScope);

typedef void (VKAPI_PTR *PFN_vkInternalFreeNotification)(
    void*                                       pUserData,
    size_t                                      size,
    VkInternalAllocationType                    allocationType,
    VkSystemAllocationScope                     allocationScope);

typedef struct VkAllocationCallbacks {
    void*                                   pUserData;
    PFN_vkAllocationFunction                pfnAllocation;
    PFN_vkReallocationFunction              pfnReallocation;
    PFN_vkFreeFunction                      pfnFree;
    PFN_vkInternalAllocationNotification    pfnInternalAllocation;
    PFN_vkInternalFreeNotification          pfnInternalFree;
} VkAllocationCallbacks;

typedef struct VkDescriptorUpdateTemplateEntry {
    uint32_t            dstBinding;
    uint32_t            dstArrayElement;
    uint32_t            descriptorCount;
    VkDescriptorType    descriptorType;
    size_t              offset;
    size_t              stride;
} VkDescriptorUpdateTemplateEntry;

typedef struct VkDescriptorUpdateTemplateCreateInfo {
    VkStructureType                           sType;
    const void*                               pNext;
    VkDescriptorUpdateTemplateCreateFlags     flags;
    uint32_t                                  descriptorUpdateEntryCount;
    const VkDescriptorUpdateTemplateEntry*    pDescriptorUpdateEntries;
    VkDescriptorUpdateTemplateType            templateType;
    VkDescriptorSetLayout                     descriptorSetLayout;
    VkPipelineBindPoint                       pipelineBindPoint;
    VkPipelineLayout                          pipelineLayout;
    uint32_t                                  set;
} VkDescriptorUpdateTemplateCreateInfo;

struct VkDescriptorUpdateTemplateCreateInfoRAII {
   VkDescriptorUpdateTemplateCreateInfo nonRaiiObj;
    std::vector<VkDescriptorUpdateTemplateEntry>vecDescriptorUpdateEntries;
};

typedef struct VkExternalMemoryProperties {
    VkExternalMemoryFeatureFlags       externalMemoryFeatures;
    VkExternalMemoryHandleTypeFlags    exportFromImportedHandleTypes;
    VkExternalMemoryHandleTypeFlags    compatibleHandleTypes;
} VkExternalMemoryProperties;

typedef struct VkPhysicalDeviceExternalImageFormatInfo {
    VkStructureType                       sType;
    const void*                           pNext;
    VkExternalMemoryHandleTypeFlagBits    handleType;
} VkPhysicalDeviceExternalImageFormatInfo;

typedef struct VkExternalImageFormatProperties {
    VkStructureType               sType;
    void*                         pNext;
    VkExternalMemoryProperties    externalMemoryProperties;
} VkExternalImageFormatProperties;

typedef struct VkPhysicalDeviceExternalBufferInfo {
    VkStructureType                       sType;
    const void*                           pNext;
    VkBufferCreateFlags                   flags;
    VkBufferUsageFlags                    usage;
    VkExternalMemoryHandleTypeFlagBits    handleType;
} VkPhysicalDeviceExternalBufferInfo;

typedef struct VkExternalBufferProperties {
    VkStructureType               sType;
    void*                         pNext;
    VkExternalMemoryProperties    externalMemoryProperties;
} VkExternalBufferProperties;

typedef struct VkPhysicalDeviceIDProperties {
    VkStructureType    sType;
    void*              pNext;
    uint8_t            deviceUUID[VK_UUID_SIZE];
    uint8_t            driverUUID[VK_UUID_SIZE];
    uint8_t            deviceLUID[VK_LUID_SIZE];
    uint32_t           deviceNodeMask;
    VkBool32           deviceLUIDValid;
} VkPhysicalDeviceIDProperties;

typedef struct VkExternalMemoryImageCreateInfo {
    VkStructureType                    sType;
    const void*                        pNext;
    VkExternalMemoryHandleTypeFlags    handleTypes;
} VkExternalMemoryImageCreateInfo;

typedef struct VkExternalMemoryBufferCreateInfo {
    VkStructureType                    sType;
    const void*                        pNext;
    VkExternalMemoryHandleTypeFlags    handleTypes;
} VkExternalMemoryBufferCreateInfo;

typedef struct VkExportMemoryAllocateInfo {
    VkStructureType                    sType;
    const void*                        pNext;
    VkExternalMemoryHandleTypeFlags    handleTypes;
} VkExportMemoryAllocateInfo;

typedef struct VkPhysicalDeviceExternalFenceInfo {
    VkStructureType                      sType;
    const void*                          pNext;
    VkExternalFenceHandleTypeFlagBits    handleType;
} VkPhysicalDeviceExternalFenceInfo;

typedef struct VkExternalFenceProperties {
    VkStructureType                   sType;
    void*                             pNext;
    VkExternalFenceHandleTypeFlags    exportFromImportedHandleTypes;
    VkExternalFenceHandleTypeFlags    compatibleHandleTypes;
    VkExternalFenceFeatureFlags       externalFenceFeatures;
} VkExternalFenceProperties;

typedef struct VkExportFenceCreateInfo {
    VkStructureType                   sType;
    const void*                       pNext;
    VkExternalFenceHandleTypeFlags    handleTypes;
} VkExportFenceCreateInfo;

typedef struct VkExportSemaphoreCreateInfo {
    VkStructureType                       sType;
    const void*                           pNext;
    VkExternalSemaphoreHandleTypeFlags    handleTypes;
} VkExportSemaphoreCreateInfo;

typedef struct VkPhysicalDeviceExternalSemaphoreInfo {
    VkStructureType                          sType;
    const void*                              pNext;
    VkExternalSemaphoreHandleTypeFlagBits    handleType;
} VkPhysicalDeviceExternalSemaphoreInfo;

typedef struct VkExternalSemaphoreProperties {
    VkStructureType                       sType;
    void*                                 pNext;
    VkExternalSemaphoreHandleTypeFlags    exportFromImportedHandleTypes;
    VkExternalSemaphoreHandleTypeFlags    compatibleHandleTypes;
    VkExternalSemaphoreFeatureFlags       externalSemaphoreFeatures;
} VkExternalSemaphoreProperties;

typedef struct VkPhysicalDeviceMaintenance3Properties {
    VkStructureType    sType;
    void*              pNext;
    uint32_t           maxPerSetDescriptors;
    VkDeviceSize       maxMemoryAllocationSize;
} VkPhysicalDeviceMaintenance3Properties;

typedef struct VkDescriptorSetLayoutSupport {
    VkStructureType    sType;
    void*              pNext;
    VkBool32           supported;
} VkDescriptorSetLayoutSupport;

typedef struct VkDescriptorSetLayoutBinding {
    uint32_t              binding;
    VkDescriptorType      descriptorType;
    uint32_t              descriptorCount;
    VkShaderStageFlags    stageFlags;
    const VkSampler*      pImmutableSamplers;
} VkDescriptorSetLayoutBinding;

struct VkDescriptorSetLayoutBindingRAII {
   VkDescriptorSetLayoutBinding nonRaiiObj;
    std::vector<VkSampler>                      vecImmutableSamplers;
};

typedef struct VkDescriptorSetLayoutCreateInfo {
    VkStructureType                        sType;
    const void*                            pNext;
    VkDescriptorSetLayoutCreateFlags       flags;
    uint32_t                               bindingCount;
    const VkDescriptorSetLayoutBinding*    pBindings;
} VkDescriptorSetLayoutCreateInfo;

struct VkDescriptorSetLayoutCreateInfoRAII {
   VkDescriptorSetLayoutCreateInfo nonRaiiObj;
    std::vector<VkDescriptorSetLayoutBinding>   vecBindings;
};

typedef struct VkPhysicalDeviceShaderDrawParametersFeatures {
    VkStructureType    sType;
    void*              pNext;
    VkBool32           shaderDrawParameters;
} VkPhysicalDeviceShaderDrawParametersFeatures;

typedef VkPhysicalDeviceShaderDrawParametersFeatures VkPhysicalDeviceShaderDrawParameterFeatures;

typedef VkResult (VKAPI_PTR *PFN_vkEnumerateInstanceVersion)(uint32_t* pApiVersion);
typedef VkResult (VKAPI_PTR *PFN_vkBindBufferMemory2)(VkDevice device, uint32_t bindInfoCount, const VkBindBufferMemoryInfo* pBindInfos);
typedef VkResult (VKAPI_PTR *PFN_vkBindImageMemory2)(VkDevice device, uint32_t bindInfoCount, const VkBindImageMemoryInfo* pBindInfos);
typedef void (VKAPI_PTR *PFN_vkGetDeviceGroupPeerMemoryFeatures)(VkDevice device, uint32_t heapIndex, uint32_t localDeviceIndex, uint32_t remoteDeviceIndex, VkPeerMemoryFeatureFlags* pPeerMemoryFeatures);
typedef void (VKAPI_PTR *PFN_vkCmdSetDeviceMask)(VkCommandBuffer commandBuffer, uint32_t deviceMask);
typedef void (VKAPI_PTR *PFN_vkCmdDispatchBase)(VkCommandBuffer commandBuffer, uint32_t baseGroupX, uint32_t baseGroupY, uint32_t baseGroupZ, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ);
typedef VkResult (VKAPI_PTR *PFN_vkEnumeratePhysicalDeviceGroups)(VkInstance instance, uint32_t* pPhysicalDeviceGroupCount, VkPhysicalDeviceGroupProperties* pPhysicalDeviceGroupProperties);
typedef void (VKAPI_PTR *PFN_vkGetImageMemoryRequirements2)(VkDevice device, const VkImageMemoryRequirementsInfo2* pInfo, VkMemoryRequirements2* pMemoryRequirements);
typedef void (VKAPI_PTR *PFN_vkGetBufferMemoryRequirements2)(VkDevice device, const VkBufferMemoryRequirementsInfo2* pInfo, VkMemoryRequirements2* pMemoryRequirements);
typedef void (VKAPI_PTR *PFN_vkGetImageSparseMemoryRequirements2)(VkDevice device, const VkImageSparseMemoryRequirementsInfo2* pInfo, uint32_t* pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements2* pSparseMemoryRequirements);
typedef void (VKAPI_PTR *PFN_vkGetPhysicalDeviceFeatures2)(VkPhysicalDevice physicalDevice, VkPhysicalDeviceFeatures2* pFeatures);
typedef void (VKAPI_PTR *PFN_vkGetPhysicalDeviceProperties2)(VkPhysicalDevice physicalDevice, VkPhysicalDeviceProperties2* pProperties);
typedef void (VKAPI_PTR *PFN_vkGetPhysicalDeviceFormatProperties2)(VkPhysicalDevice physicalDevice, VkFormat format, VkFormatProperties2* pFormatProperties);
typedef VkResult (VKAPI_PTR *PFN_vkGetPhysicalDeviceImageFormatProperties2)(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceImageFormatInfo2* pImageFormatInfo, VkImageFormatProperties2* pImageFormatProperties);
typedef void (VKAPI_PTR *PFN_vkGetPhysicalDeviceQueueFamilyProperties2)(VkPhysicalDevice physicalDevice, uint32_t* pQueueFamilyPropertyCount, VkQueueFamilyProperties2* pQueueFamilyProperties);
typedef void (VKAPI_PTR *PFN_vkGetPhysicalDeviceMemoryProperties2)(VkPhysicalDevice physicalDevice, VkPhysicalDeviceMemoryProperties2* pMemoryProperties);
typedef void (VKAPI_PTR *PFN_vkGetPhysicalDeviceSparseImageFormatProperties2)(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSparseImageFormatInfo2* pFormatInfo, uint32_t* pPropertyCount, VkSparseImageFormatProperties2* pProperties);
typedef void (VKAPI_PTR *PFN_vkTrimCommandPool)(VkDevice device, VkCommandPool commandPool, VkCommandPoolTrimFlags flags);
typedef void (VKAPI_PTR *PFN_vkGetDeviceQueue2)(VkDevice device, const VkDeviceQueueInfo2* pQueueInfo, VkQueue* pQueue);
typedef VkResult (VKAPI_PTR *PFN_vkCreateSamplerYcbcrConversion)(VkDevice device, const VkSamplerYcbcrConversionCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSamplerYcbcrConversion* pYcbcrConversion);
typedef void (VKAPI_PTR *PFN_vkDestroySamplerYcbcrConversion)(VkDevice device, VkSamplerYcbcrConversion ycbcrConversion, const VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkCreateDescriptorUpdateTemplate)(VkDevice device, const VkDescriptorUpdateTemplateCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkDescriptorUpdateTemplate* pDescriptorUpdateTemplate);
typedef void (VKAPI_PTR *PFN_vkDestroyDescriptorUpdateTemplate)(VkDevice device, VkDescriptorUpdateTemplate descriptorUpdateTemplate, const VkAllocationCallbacks* pAllocator);
typedef void (VKAPI_PTR *PFN_vkGetPhysicalDeviceExternalBufferProperties)(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalBufferInfo* pExternalBufferInfo, VkExternalBufferProperties* pExternalBufferProperties);
typedef void (VKAPI_PTR *PFN_vkGetPhysicalDeviceExternalFenceProperties)(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalFenceInfo* pExternalFenceInfo, VkExternalFenceProperties* pExternalFenceProperties);
typedef void (VKAPI_PTR *PFN_vkGetPhysicalDeviceExternalSemaphoreProperties)(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalSemaphoreInfo* pExternalSemaphoreInfo, VkExternalSemaphoreProperties* pExternalSemaphoreProperties);
typedef void (VKAPI_PTR *PFN_vkGetDescriptorSetLayoutSupport)(VkDevice device, const VkDescriptorSetLayoutCreateInfo* pCreateInfo, VkDescriptorSetLayoutSupport* pSupport);

uint32_t enumerateInstanceVersion(void);

VkPhysicalDeviceSubgroupProperties PhysicalDeviceSubgroupProperties(
    uint32_t                                    subgroupSize,
    VkShaderStageFlags                          supportedStages,
    VkSubgroupFeatureFlags                      supportedOperations,
    VkBool32                                    quadOperationsInAllStages);


VkBindBufferMemoryInfo BindBufferMemoryInfo(
    VkBuffer                                    buffer,
    VkDeviceMemory                              memory,
    VkDeviceSize                                memoryOffset);


VkBindImageMemoryInfo BindImageMemoryInfo(
    VkImage                                     image,
    VkDeviceMemory                              memory,
    VkDeviceSize                                memoryOffset);


void  bindBufferMemory2(
        VkDevice device,
        const std::vector<VkBindBufferMemoryInfo> & pBindInfos);

void  bindImageMemory2(
        VkDevice device,
        const std::vector<VkBindImageMemoryInfo> & pBindInfos);

VkPhysicalDevice16BitStorageFeatures PhysicalDevice16BitStorageFeatures(
    VkBool32                                    storageBuffer16BitAccess,
    VkBool32                                    uniformAndStorageBuffer16BitAccess,
    VkBool32                                    storagePushConstant16,
    VkBool32                                    storageInputOutput16);


VkMemoryDedicatedRequirements MemoryDedicatedRequirements(
    VkBool32                                    prefersDedicatedAllocation,
    VkBool32                                    requiresDedicatedAllocation);


VkMemoryDedicatedAllocateInfo MemoryDedicatedAllocateInfo(
    VkImage                                     image,
    VkBuffer                                    buffer);


VkMemoryAllocateFlagsInfo MemoryAllocateFlagsInfo(
    VkMemoryAllocateFlags                       flags,
    uint32_t                                    deviceMask);


VkOffset2D Offset2D(
    int32_t                                     x,
    int32_t                                     y);


VkExtent2D Extent2D(
    uint32_t                                    width,
    uint32_t                                    height);


VkRect2D Rect2D(
    VkOffset2D                                  offset,
    VkExtent2D                                  extent);


std::shared_ptr<VkDeviceGroupRenderPassBeginInfoRAII> DeviceGroupRenderPassBeginInfo(
    uint32_t                                    deviceMask,
    const std::vector<VkRect2D> &               vecDeviceRenderAreas);


VkDeviceGroupCommandBufferBeginInfo DeviceGroupCommandBufferBeginInfo(
    uint32_t                                    deviceMask);


std::shared_ptr<VkDeviceGroupSubmitInfoRAII> DeviceGroupSubmitInfo(
    unsigned int* pWaitSemaphoreDeviceIndices_in_array1, int pWaitSemaphoreDeviceIndices_dim1,
    unsigned int* pCommandBufferDeviceMasks_in_array1, int pCommandBufferDeviceMasks_dim1,
    unsigned int* pSignalSemaphoreDeviceIndices_in_array1, int pSignalSemaphoreDeviceIndices_dim1);


VkDeviceGroupBindSparseInfo DeviceGroupBindSparseInfo(
    uint32_t                                    resourceDeviceIndex,
    uint32_t                                    memoryDeviceIndex);


std::shared_ptr< VkPeerMemoryFeatureFlags > getDeviceGroupPeerMemoryFeatures(
        VkDevice device,
        uint32_t heapIndex,
        uint32_t localDeviceIndex,
        uint32_t remoteDeviceIndex);

void  cmdSetDeviceMask(
        VkCommandBuffer commandBuffer,
        uint32_t deviceMask);

void  cmdDispatchBase(
        VkCommandBuffer commandBuffer,
        uint32_t baseGroupX,
        uint32_t baseGroupY,
        uint32_t baseGroupZ,
        uint32_t groupCountX,
        uint32_t groupCountY,
        uint32_t groupCountZ);

std::shared_ptr<VkBindBufferMemoryDeviceGroupInfoRAII> BindBufferMemoryDeviceGroupInfo(
    unsigned int* pDeviceIndices_in_array1, int pDeviceIndices_dim1);


std::shared_ptr<VkBindImageMemoryDeviceGroupInfoRAII> BindImageMemoryDeviceGroupInfo(
    unsigned int* pDeviceIndices_in_array1, int pDeviceIndices_dim1,
    const std::vector<VkRect2D> &               vecSplitInstanceBindRegions);


VkPhysicalDeviceGroupProperties PhysicalDeviceGroupProperties(
    uint32_t                                    physicalDeviceCount,
    VkPhysicalDevice                            physicalDevices[VK_MAX_DEVICE_GROUP_SIZE],
    VkBool32                                    subsetAllocation);


std::shared_ptr<VkDeviceGroupDeviceCreateInfoRAII> DeviceGroupDeviceCreateInfo(
    const std::vector<VkPhysicalDevice> &       vecPhysicalDevices);


std::vector< VkPhysicalDeviceGroupProperties > enumeratePhysicalDeviceGroups(
        VkInstance instance);

VkBufferMemoryRequirementsInfo2 BufferMemoryRequirementsInfo2(
    VkBuffer                                    buffer);


VkImageMemoryRequirementsInfo2 ImageMemoryRequirementsInfo2(
    VkImage                                     image);


VkImageSparseMemoryRequirementsInfo2 ImageSparseMemoryRequirementsInfo2(
    VkImage                                     image);


VkMemoryRequirements MemoryRequirements(
    VkDeviceSize                                size,
    VkDeviceSize                                alignment,
    uint32_t                                    memoryTypeBits);


VkMemoryRequirements2 MemoryRequirements2(
    VkMemoryRequirements                        memoryRequirements);


VkMemoryRequirements2KHR MemoryRequirements2KHR(void);


VkExtent3D Extent3D(
    uint32_t                                    width,
    uint32_t                                    height,
    uint32_t                                    depth);


VkSparseImageFormatProperties SparseImageFormatProperties(
    VkImageAspectFlags                          aspectMask,
    VkExtent3D                                  imageGranularity,
    VkSparseImageFormatFlags                    flags);


VkSparseImageMemoryRequirements SparseImageMemoryRequirements(
    VkSparseImageFormatProperties               formatProperties,
    uint32_t                                    imageMipTailFirstLod,
    VkDeviceSize                                imageMipTailSize,
    VkDeviceSize                                imageMipTailOffset,
    VkDeviceSize                                imageMipTailStride);


VkSparseImageMemoryRequirements2 SparseImageMemoryRequirements2(
    VkSparseImageMemoryRequirements             memoryRequirements);


VkMemoryRequirements2 getImageMemoryRequirements2(
        VkDevice device,
        const VkImageMemoryRequirementsInfo2 & pInfo);

VkMemoryRequirements2 getBufferMemoryRequirements2(
        VkDevice device,
        const VkBufferMemoryRequirementsInfo2 & pInfo);

std::vector< VkSparseImageMemoryRequirements2 > getImageSparseMemoryRequirements2(
        VkDevice device,
        const VkImageSparseMemoryRequirementsInfo2 & pInfo);

VkPhysicalDeviceFeatures PhysicalDeviceFeatures(
    VkBool32                                    robustBufferAccess,
    VkBool32                                    fullDrawIndexUint32,
    VkBool32                                    imageCubeArray,
    VkBool32                                    independentBlend,
    VkBool32                                    geometryShader,
    VkBool32                                    tessellationShader,
    VkBool32                                    sampleRateShading,
    VkBool32                                    dualSrcBlend,
    VkBool32                                    logicOp,
    VkBool32                                    multiDrawIndirect,
    VkBool32                                    drawIndirectFirstInstance,
    VkBool32                                    depthClamp,
    VkBool32                                    depthBiasClamp,
    VkBool32                                    fillModeNonSolid,
    VkBool32                                    depthBounds,
    VkBool32                                    wideLines,
    VkBool32                                    largePoints,
    VkBool32                                    alphaToOne,
    VkBool32                                    multiViewport,
    VkBool32                                    samplerAnisotropy,
    VkBool32                                    textureCompressionETC2,
    VkBool32                                    textureCompressionASTC_LDR,
    VkBool32                                    textureCompressionBC,
    VkBool32                                    occlusionQueryPrecise,
    VkBool32                                    pipelineStatisticsQuery,
    VkBool32                                    vertexPipelineStoresAndAtomics,
    VkBool32                                    fragmentStoresAndAtomics,
    VkBool32                                    shaderTessellationAndGeometryPointSize,
    VkBool32                                    shaderImageGatherExtended,
    VkBool32                                    shaderStorageImageExtendedFormats,
    VkBool32                                    shaderStorageImageMultisample,
    VkBool32                                    shaderStorageImageReadWithoutFormat,
    VkBool32                                    shaderStorageImageWriteWithoutFormat,
    VkBool32                                    shaderUniformBufferArrayDynamicIndexing,
    VkBool32                                    shaderSampledImageArrayDynamicIndexing,
    VkBool32                                    shaderStorageBufferArrayDynamicIndexing,
    VkBool32                                    shaderStorageImageArrayDynamicIndexing,
    VkBool32                                    shaderClipDistance,
    VkBool32                                    shaderCullDistance,
    VkBool32                                    shaderFloat64,
    VkBool32                                    shaderInt64,
    VkBool32                                    shaderInt16,
    VkBool32                                    shaderResourceResidency,
    VkBool32                                    shaderResourceMinLod,
    VkBool32                                    sparseBinding,
    VkBool32                                    sparseResidencyBuffer,
    VkBool32                                    sparseResidencyImage2D,
    VkBool32                                    sparseResidencyImage3D,
    VkBool32                                    sparseResidency2Samples,
    VkBool32                                    sparseResidency4Samples,
    VkBool32                                    sparseResidency8Samples,
    VkBool32                                    sparseResidency16Samples,
    VkBool32                                    sparseResidencyAliased,
    VkBool32                                    variableMultisampleRate,
    VkBool32                                    inheritedQueries);


VkPhysicalDeviceFeatures2 PhysicalDeviceFeatures2(
    VkPhysicalDeviceFeatures                    features);


VkPhysicalDeviceLimits PhysicalDeviceLimits(
    uint32_t                                    maxImageDimension1D,
    uint32_t                                    maxImageDimension2D,
    uint32_t                                    maxImageDimension3D,
    uint32_t                                    maxImageDimensionCube,
    uint32_t                                    maxImageArrayLayers,
    uint32_t                                    maxTexelBufferElements,
    uint32_t                                    maxUniformBufferRange,
    uint32_t                                    maxStorageBufferRange,
    uint32_t                                    maxPushConstantsSize,
    uint32_t                                    maxMemoryAllocationCount,
    uint32_t                                    maxSamplerAllocationCount,
    VkDeviceSize                                bufferImageGranularity,
    VkDeviceSize                                sparseAddressSpaceSize,
    uint32_t                                    maxBoundDescriptorSets,
    uint32_t                                    maxPerStageDescriptorSamplers,
    uint32_t                                    maxPerStageDescriptorUniformBuffers,
    uint32_t                                    maxPerStageDescriptorStorageBuffers,
    uint32_t                                    maxPerStageDescriptorSampledImages,
    uint32_t                                    maxPerStageDescriptorStorageImages,
    uint32_t                                    maxPerStageDescriptorInputAttachments,
    uint32_t                                    maxPerStageResources,
    uint32_t                                    maxDescriptorSetSamplers,
    uint32_t                                    maxDescriptorSetUniformBuffers,
    uint32_t                                    maxDescriptorSetUniformBuffersDynamic,
    uint32_t                                    maxDescriptorSetStorageBuffers,
    uint32_t                                    maxDescriptorSetStorageBuffersDynamic,
    uint32_t                                    maxDescriptorSetSampledImages,
    uint32_t                                    maxDescriptorSetStorageImages,
    uint32_t                                    maxDescriptorSetInputAttachments,
    uint32_t                                    maxVertexInputAttributes,
    uint32_t                                    maxVertexInputBindings,
    uint32_t                                    maxVertexInputAttributeOffset,
    uint32_t                                    maxVertexInputBindingStride,
    uint32_t                                    maxVertexOutputComponents,
    uint32_t                                    maxTessellationGenerationLevel,
    uint32_t                                    maxTessellationPatchSize,
    uint32_t                                    maxTessellationControlPerVertexInputComponents,
    uint32_t                                    maxTessellationControlPerVertexOutputComponents,
    uint32_t                                    maxTessellationControlPerPatchOutputComponents,
    uint32_t                                    maxTessellationControlTotalOutputComponents,
    uint32_t                                    maxTessellationEvaluationInputComponents,
    uint32_t                                    maxTessellationEvaluationOutputComponents,
    uint32_t                                    maxGeometryShaderInvocations,
    uint32_t                                    maxGeometryInputComponents,
    uint32_t                                    maxGeometryOutputComponents,
    uint32_t                                    maxGeometryOutputVertices,
    uint32_t                                    maxGeometryTotalOutputComponents,
    uint32_t                                    maxFragmentInputComponents,
    uint32_t                                    maxFragmentOutputAttachments,
    uint32_t                                    maxFragmentDualSrcAttachments,
    uint32_t                                    maxFragmentCombinedOutputResources,
    uint32_t                                    maxComputeSharedMemorySize,
    uint32_t                                    maxComputeWorkGroupCount[3],
    uint32_t                                    maxComputeWorkGroupInvocations,
    uint32_t                                    maxComputeWorkGroupSize[3],
    uint32_t                                    subPixelPrecisionBits,
    uint32_t                                    subTexelPrecisionBits,
    uint32_t                                    mipmapPrecisionBits,
    uint32_t                                    maxDrawIndexedIndexValue,
    uint32_t                                    maxDrawIndirectCount,
    float                                       maxSamplerLodBias,
    float                                       maxSamplerAnisotropy,
    uint32_t                                    maxViewports,
    uint32_t                                    maxViewportDimensions[2],
    float                                       viewportBoundsRange[2],
    uint32_t                                    viewportSubPixelBits,
    size_t                                      minMemoryMapAlignment,
    VkDeviceSize                                minTexelBufferOffsetAlignment,
    VkDeviceSize                                minUniformBufferOffsetAlignment,
    VkDeviceSize                                minStorageBufferOffsetAlignment,
    int32_t                                     minTexelOffset,
    uint32_t                                    maxTexelOffset,
    int32_t                                     minTexelGatherOffset,
    uint32_t                                    maxTexelGatherOffset,
    float                                       minInterpolationOffset,
    float                                       maxInterpolationOffset,
    uint32_t                                    subPixelInterpolationOffsetBits,
    uint32_t                                    maxFramebufferWidth,
    uint32_t                                    maxFramebufferHeight,
    uint32_t                                    maxFramebufferLayers,
    VkSampleCountFlags                          framebufferColorSampleCounts,
    VkSampleCountFlags                          framebufferDepthSampleCounts,
    VkSampleCountFlags                          framebufferStencilSampleCounts,
    VkSampleCountFlags                          framebufferNoAttachmentsSampleCounts,
    uint32_t                                    maxColorAttachments,
    VkSampleCountFlags                          sampledImageColorSampleCounts,
    VkSampleCountFlags                          sampledImageIntegerSampleCounts,
    VkSampleCountFlags                          sampledImageDepthSampleCounts,
    VkSampleCountFlags                          sampledImageStencilSampleCounts,
    VkSampleCountFlags                          storageImageSampleCounts,
    uint32_t                                    maxSampleMaskWords,
    VkBool32                                    timestampComputeAndGraphics,
    float                                       timestampPeriod,
    uint32_t                                    maxClipDistances,
    uint32_t                                    maxCullDistances,
    uint32_t                                    maxCombinedClipAndCullDistances,
    uint32_t                                    discreteQueuePriorities,
    float                                       pointSizeRange[2],
    float                                       lineWidthRange[2],
    float                                       pointSizeGranularity,
    float                                       lineWidthGranularity,
    VkBool32                                    strictLines,
    VkBool32                                    standardSampleLocations,
    VkDeviceSize                                optimalBufferCopyOffsetAlignment,
    VkDeviceSize                                optimalBufferCopyRowPitchAlignment,
    VkDeviceSize                                nonCoherentAtomSize);


VkPhysicalDeviceSparseProperties PhysicalDeviceSparseProperties(
    VkBool32                                    residencyStandard2DBlockShape,
    VkBool32                                    residencyStandard2DMultisampleBlockShape,
    VkBool32                                    residencyStandard3DBlockShape,
    VkBool32                                    residencyAlignedMipSize,
    VkBool32                                    residencyNonResidentStrict);


VkPhysicalDeviceProperties PhysicalDeviceProperties(
    uint32_t                                    apiVersion,
    uint32_t                                    driverVersion,
    uint32_t                                    vendorID,
    uint32_t                                    deviceID,
    VkPhysicalDeviceType                        deviceType,
    char                                        deviceName[VK_MAX_PHYSICAL_DEVICE_NAME_SIZE],
    uint8_t                                     pipelineCacheUUID[VK_UUID_SIZE],
    VkPhysicalDeviceLimits                      limits,
    VkPhysicalDeviceSparseProperties            sparseProperties);


VkPhysicalDeviceProperties2 PhysicalDeviceProperties2(
    VkPhysicalDeviceProperties                  properties);


VkFormatProperties FormatProperties(
    VkFormatFeatureFlags                        linearTilingFeatures,
    VkFormatFeatureFlags                        optimalTilingFeatures,
    VkFormatFeatureFlags                        bufferFeatures);


VkFormatProperties2 FormatProperties2(
    VkFormatProperties                          formatProperties);


VkImageFormatProperties ImageFormatProperties(
    VkExtent3D                                  maxExtent,
    uint32_t                                    maxMipLevels,
    uint32_t                                    maxArrayLayers,
    VkSampleCountFlags                          sampleCounts,
    VkDeviceSize                                maxResourceSize);


VkImageFormatProperties2 ImageFormatProperties2(
    VkImageFormatProperties                     imageFormatProperties);


VkPhysicalDeviceImageFormatInfo2 PhysicalDeviceImageFormatInfo2(
    VkFormat                                    format,
    VkImageType                                 type,
    VkImageTiling                               tiling,
    VkImageUsageFlags                           usage,
    VkImageCreateFlags                          flags);


VkQueueFamilyProperties QueueFamilyProperties(
    VkQueueFlags                                queueFlags,
    uint32_t                                    queueCount,
    uint32_t                                    timestampValidBits,
    VkExtent3D                                  minImageTransferGranularity);


VkQueueFamilyProperties2 QueueFamilyProperties2(
    VkQueueFamilyProperties                     queueFamilyProperties);


VkMemoryType MemoryType(
    VkMemoryPropertyFlags                       propertyFlags,
    uint32_t                                    heapIndex);


VkMemoryHeap MemoryHeap(
    VkDeviceSize                                size,
    VkMemoryHeapFlags                           flags);


VkPhysicalDeviceMemoryProperties PhysicalDeviceMemoryProperties(
    uint32_t                                    memoryTypeCount,
    VkMemoryType                                memoryTypes[VK_MAX_MEMORY_TYPES],
    uint32_t                                    memoryHeapCount,
    VkMemoryHeap                                memoryHeaps[VK_MAX_MEMORY_HEAPS]);


VkPhysicalDeviceMemoryProperties2 PhysicalDeviceMemoryProperties2(
    VkPhysicalDeviceMemoryProperties            memoryProperties);


VkSparseImageFormatProperties2 SparseImageFormatProperties2(
    VkSparseImageFormatProperties               properties);


VkPhysicalDeviceSparseImageFormatInfo2 PhysicalDeviceSparseImageFormatInfo2(
    VkFormat                                    format,
    VkImageType                                 type,
    VkSampleCountFlagBits                       samples,
    VkImageUsageFlags                           usage,
    VkImageTiling                               tiling);


VkPhysicalDeviceFeatures2 getPhysicalDeviceFeatures2(
        VkPhysicalDevice physicalDevice);

VkPhysicalDeviceProperties2 getPhysicalDeviceProperties2(
        VkPhysicalDevice physicalDevice);

VkFormatProperties2 getPhysicalDeviceFormatProperties2(
        VkPhysicalDevice physicalDevice,
        VkFormat format);

VkImageFormatProperties2 getPhysicalDeviceImageFormatProperties2(
        VkPhysicalDevice physicalDevice,
        const VkPhysicalDeviceImageFormatInfo2 & pImageFormatInfo);

std::vector< VkQueueFamilyProperties2 > getPhysicalDeviceQueueFamilyProperties2(
        VkPhysicalDevice physicalDevice);

VkPhysicalDeviceMemoryProperties2 getPhysicalDeviceMemoryProperties2(
        VkPhysicalDevice physicalDevice);

std::vector< VkSparseImageFormatProperties2 > getPhysicalDeviceSparseImageFormatProperties2(
        VkPhysicalDevice physicalDevice,
        const VkPhysicalDeviceSparseImageFormatInfo2 & pFormatInfo);

void  trimCommandPool(
        VkDevice device,
        VkCommandPool commandPool,
        VkCommandPoolTrimFlags flags);

VkPhysicalDevicePointClippingProperties PhysicalDevicePointClippingProperties(
    VkPointClippingBehavior                     pointClippingBehavior);


VkInputAttachmentAspectReference InputAttachmentAspectReference(
    uint32_t                                    subpass,
    uint32_t                                    inputAttachmentIndex,
    VkImageAspectFlags                          aspectMask);


std::shared_ptr<VkRenderPassInputAttachmentAspectCreateInfoRAII> RenderPassInputAttachmentAspectCreateInfo(
    const std::vector<VkInputAttachmentAspectReference> &vecAspectReferences);


VkImageViewUsageCreateInfo ImageViewUsageCreateInfo(
    VkImageUsageFlags                           usage);


VkPipelineTessellationDomainOriginStateCreateInfo PipelineTessellationDomainOriginStateCreateInfo(
    VkTessellationDomainOrigin                  domainOrigin);


std::shared_ptr<VkRenderPassMultiviewCreateInfoRAII> RenderPassMultiviewCreateInfo(
    unsigned int* pViewMasks_in_array1, int pViewMasks_dim1,
    int* pViewOffsets_in_array1, int pViewOffsets_dim1,
    unsigned int* pCorrelationMasks_in_array1, int pCorrelationMasks_dim1);


VkPhysicalDeviceMultiviewFeatures PhysicalDeviceMultiviewFeatures(
    VkBool32                                    multiview,
    VkBool32                                    multiviewGeometryShader,
    VkBool32                                    multiviewTessellationShader);


VkPhysicalDeviceMultiviewProperties PhysicalDeviceMultiviewProperties(
    uint32_t                                    maxMultiviewViewCount,
    uint32_t                                    maxMultiviewInstanceIndex);


VkPhysicalDeviceVariablePointersFeatures PhysicalDeviceVariablePointersFeatures(
    VkBool32                                    variablePointersStorageBuffer,
    VkBool32                                    variablePointers);


VkPhysicalDeviceVariablePointerFeatures PhysicalDeviceVariablePointerFeatures(void);


VkPhysicalDeviceProtectedMemoryFeatures PhysicalDeviceProtectedMemoryFeatures(
    VkBool32                                    protectedMemory);


VkPhysicalDeviceProtectedMemoryProperties PhysicalDeviceProtectedMemoryProperties(
    VkBool32                                    protectedNoFault);


VkDeviceQueueInfo2 DeviceQueueInfo2(
    VkDeviceQueueCreateFlags                    flags,
    uint32_t                                    queueFamilyIndex,
    uint32_t                                    queueIndex);


VkProtectedSubmitInfo ProtectedSubmitInfo(
    VkBool32                                    protectedSubmit);


VkQueue getDeviceQueue2(
        VkDevice device,
        const VkDeviceQueueInfo2 & pQueueInfo);

VkComponentMapping ComponentMapping(
    VkComponentSwizzle                          r,
    VkComponentSwizzle                          g,
    VkComponentSwizzle                          b,
    VkComponentSwizzle                          a);


VkSamplerYcbcrConversionCreateInfo SamplerYcbcrConversionCreateInfo(
    VkFormat                                    format,
    VkSamplerYcbcrModelConversion               ycbcrModel,
    VkSamplerYcbcrRange                         ycbcrRange,
    VkComponentMapping                          components,
    VkChromaLocation                            xChromaOffset,
    VkChromaLocation                            yChromaOffset,
    VkFilter                                    chromaFilter,
    VkBool32                                    forceExplicitReconstruction);


VkSamplerYcbcrConversionInfo SamplerYcbcrConversionInfo(
    VkSamplerYcbcrConversion                    conversion);


VkBindImagePlaneMemoryInfo BindImagePlaneMemoryInfo(
    VkImageAspectFlagBits                       planeAspect);


VkImagePlaneMemoryRequirementsInfo ImagePlaneMemoryRequirementsInfo(
    VkImageAspectFlagBits                       planeAspect);


VkPhysicalDeviceSamplerYcbcrConversionFeatures PhysicalDeviceSamplerYcbcrConversionFeatures(
    VkBool32                                    samplerYcbcrConversion);


VkSamplerYcbcrConversionImageFormatProperties SamplerYcbcrConversionImageFormatProperties(
    uint32_t                                    combinedImageSamplerDescriptorCount);


VkAllocationCallbacks AllocationCallbacks(
    PFN_vkAllocationFunction                    pfnAllocation,
    PFN_vkReallocationFunction                  pfnReallocation,
    PFN_vkFreeFunction                          pfnFree,
    PFN_vkInternalAllocationNotification        pfnInternalAllocation,
    PFN_vkInternalFreeNotification              pfnInternalFree);


std::shared_ptr<VkSamplerYcbcrConversion_T> createSamplerYcbcrConversion(
        VkDevice device,
        const VkSamplerYcbcrConversionCreateInfo & pCreateInfo);

VkDescriptorUpdateTemplateEntry DescriptorUpdateTemplateEntry(
    uint32_t                                    dstBinding,
    uint32_t                                    dstArrayElement,
    uint32_t                                    descriptorCount,
    VkDescriptorType                            descriptorType,
    size_t                                      offset,
    size_t                                      stride);


std::shared_ptr<VkDescriptorUpdateTemplateCreateInfoRAII> DescriptorUpdateTemplateCreateInfo(
    VkDescriptorUpdateTemplateCreateFlags       flags,
    const std::vector<VkDescriptorUpdateTemplateEntry> &vecDescriptorUpdateEntries,
    VkDescriptorUpdateTemplateType              templateType,
    VkDescriptorSetLayout                       descriptorSetLayout,
    VkPipelineBindPoint                         pipelineBindPoint,
    VkPipelineLayout                            pipelineLayout,
    uint32_t                                    set);


std::shared_ptr<VkDescriptorUpdateTemplate_T> createDescriptorUpdateTemplate(
        VkDevice device,
        const VkDescriptorUpdateTemplateCreateInfo & pCreateInfo);

VkExternalMemoryProperties ExternalMemoryProperties(
    VkExternalMemoryFeatureFlags                externalMemoryFeatures,
    VkExternalMemoryHandleTypeFlags             exportFromImportedHandleTypes,
    VkExternalMemoryHandleTypeFlags             compatibleHandleTypes);


VkPhysicalDeviceExternalImageFormatInfo PhysicalDeviceExternalImageFormatInfo(
    VkExternalMemoryHandleTypeFlagBits          handleType);


VkExternalImageFormatProperties ExternalImageFormatProperties(
    VkExternalMemoryProperties                  externalMemoryProperties);


VkPhysicalDeviceExternalBufferInfo PhysicalDeviceExternalBufferInfo(
    VkBufferCreateFlags                         flags,
    VkBufferUsageFlags                          usage,
    VkExternalMemoryHandleTypeFlagBits          handleType);


VkExternalBufferProperties ExternalBufferProperties(
    VkExternalMemoryProperties                  externalMemoryProperties);


VkPhysicalDeviceIDProperties PhysicalDeviceIDProperties(
    uint8_t                                     deviceUUID[VK_UUID_SIZE],
    uint8_t                                     driverUUID[VK_UUID_SIZE],
    uint8_t                                     deviceLUID[VK_LUID_SIZE],
    uint32_t                                    deviceNodeMask,
    VkBool32                                    deviceLUIDValid);


VkExternalBufferProperties getPhysicalDeviceExternalBufferProperties(
        VkPhysicalDevice physicalDevice,
        const VkPhysicalDeviceExternalBufferInfo & pExternalBufferInfo);

VkExternalMemoryImageCreateInfo ExternalMemoryImageCreateInfo(
    VkExternalMemoryHandleTypeFlags             handleTypes);


VkExternalMemoryBufferCreateInfo ExternalMemoryBufferCreateInfo(
    VkExternalMemoryHandleTypeFlags             handleTypes);


VkExportMemoryAllocateInfo ExportMemoryAllocateInfo(
    VkExternalMemoryHandleTypeFlags             handleTypes);


VkPhysicalDeviceExternalFenceInfo PhysicalDeviceExternalFenceInfo(
    VkExternalFenceHandleTypeFlagBits           handleType);


VkExternalFenceProperties ExternalFenceProperties(
    VkExternalFenceHandleTypeFlags              exportFromImportedHandleTypes,
    VkExternalFenceHandleTypeFlags              compatibleHandleTypes,
    VkExternalFenceFeatureFlags                 externalFenceFeatures);


VkExternalFenceProperties getPhysicalDeviceExternalFenceProperties(
        VkPhysicalDevice physicalDevice,
        const VkPhysicalDeviceExternalFenceInfo & pExternalFenceInfo);

VkExportFenceCreateInfo ExportFenceCreateInfo(
    VkExternalFenceHandleTypeFlags              handleTypes);


VkExportSemaphoreCreateInfo ExportSemaphoreCreateInfo(
    VkExternalSemaphoreHandleTypeFlags          handleTypes);


VkPhysicalDeviceExternalSemaphoreInfo PhysicalDeviceExternalSemaphoreInfo(
    VkExternalSemaphoreHandleTypeFlagBits       handleType);


VkExternalSemaphoreProperties ExternalSemaphoreProperties(
    VkExternalSemaphoreHandleTypeFlags          exportFromImportedHandleTypes,
    VkExternalSemaphoreHandleTypeFlags          compatibleHandleTypes,
    VkExternalSemaphoreFeatureFlags             externalSemaphoreFeatures);


VkExternalSemaphoreProperties getPhysicalDeviceExternalSemaphoreProperties(
        VkPhysicalDevice physicalDevice,
        const VkPhysicalDeviceExternalSemaphoreInfo & pExternalSemaphoreInfo);

VkPhysicalDeviceMaintenance3Properties PhysicalDeviceMaintenance3Properties(
    uint32_t                                    maxPerSetDescriptors,
    VkDeviceSize                                maxMemoryAllocationSize);


VkDescriptorSetLayoutSupport DescriptorSetLayoutSupport(
    VkBool32                                    supported);


std::shared_ptr<VkDescriptorSetLayoutBindingRAII> DescriptorSetLayoutBinding(
    uint32_t                                    binding,
    VkDescriptorType                            descriptorType,
    uint32_t                                    descriptorCount,
    VkShaderStageFlags                          stageFlags,
    const std::vector<VkSampler> &              vecImmutableSamplers);


std::shared_ptr<VkDescriptorSetLayoutCreateInfoRAII> DescriptorSetLayoutCreateInfo(
    VkDescriptorSetLayoutCreateFlags            flags,
    const std::vector<VkDescriptorSetLayoutBinding> &vecBindings);


VkDescriptorSetLayoutSupport getDescriptorSetLayoutSupport(
        VkDevice device,
        const VkDescriptorSetLayoutCreateInfo & pCreateInfo);

VkPhysicalDeviceShaderDrawParametersFeatures PhysicalDeviceShaderDrawParametersFeatures(
    VkBool32                                    shaderDrawParameters);


VkPhysicalDeviceShaderDrawParameterFeatures PhysicalDeviceShaderDrawParameterFeatures(void);


void load_vulkan_fct_ptrs(VkInstance instance);

%{

     const char* vkGetErrorString(VkResult retval)
     {
         static const char vk_err_messages[34][123] = {
             "Vulkan error (VK_SUCCESS) : Command completed successfully",
             "Vulkan error (VK_NOT_READY) : A fence or query has not yet completed",
             "Vulkan error (VK_TIMEOUT) : A wait operation has not completed in the specified time",
             "Vulkan error (VK_EVENT_SET) : An event is signaled",
             "Vulkan error (VK_EVENT_RESET) : An event is unsignaled",
             "Vulkan error (VK_INCOMPLETE) : A return array was too small for the result",
             "Vulkan error (VK_ERROR_OUT_OF_HOST_MEMORY) : A host memory allocation has failed",
             "Vulkan error (VK_ERROR_OUT_OF_DEVICE_MEMORY) : A device memory allocation has failed",
             "Vulkan error (VK_ERROR_INITIALIZATION_FAILED) : Initialization of a object has failed",
             "Vulkan error (VK_ERROR_DEVICE_LOST) : The logical device has been lost. See <<devsandqueues-lost-device>>",
             "Vulkan error (VK_ERROR_MEMORY_MAP_FAILED) : Mapping of a memory object has failed",
             "Vulkan error (VK_ERROR_LAYER_NOT_PRESENT) : Layer specified does not exist",
             "Vulkan error (VK_ERROR_EXTENSION_NOT_PRESENT) : Extension specified does not exist",
             "Vulkan error (VK_ERROR_FEATURE_NOT_PRESENT) : Requested feature is not available on this device",
             "Vulkan error (VK_ERROR_INCOMPATIBLE_DRIVER) : Unable to find a Vulkan driver",
             "Vulkan error (VK_ERROR_TOO_MANY_OBJECTS) : Too many objects of the type have already been created",
             "Vulkan error (VK_ERROR_FORMAT_NOT_SUPPORTED) : Requested format is not supported on this device",
             "Vulkan error (VK_ERROR_FRAGMENTED_POOL) : A requested pool allocation has failed due to fragmentation of the pool's memory",
             "Vulkan error: VK_ERROR_OUT_OF_POOL_MEMORY",
             "Vulkan error: VK_ERROR_INVALID_EXTERNAL_HANDLE",
             "Vulkan error: VK_ERROR_SURFACE_LOST_KHR",
             "Vulkan error: VK_ERROR_NATIVE_WINDOW_IN_USE_KHR",
             "Vulkan error: VK_SUBOPTIMAL_KHR",
             "Vulkan error: VK_ERROR_OUT_OF_DATE_KHR",
             "Vulkan error: VK_ERROR_INCOMPATIBLE_DISPLAY_KHR",
             "Vulkan error: VK_ERROR_VALIDATION_FAILED_EXT",
             "Vulkan error: VK_ERROR_INVALID_SHADER_NV",
             "Vulkan error: VK_ERROR_OUT_OF_POOL_MEMORY_KHR",
             "Vulkan error: VK_ERROR_INVALID_EXTERNAL_HANDLE_KHR",
             "Vulkan error: VK_ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT",
             "Vulkan error: VK_ERROR_FRAGMENTATION_EXT",
             "Vulkan error: VK_ERROR_NOT_PERMITTED_EXT",
             "Vulkan error: VK_ERROR_INVALID_DEVICE_ADDRESS_EXT",
             "Vulkan error: VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT",
         };
         switch (retval) {
             case VK_SUCCESS : return vk_err_messages[0];
             case VK_NOT_READY : return vk_err_messages[1];
             case VK_TIMEOUT : return vk_err_messages[2];
             case VK_EVENT_SET : return vk_err_messages[3];
             case VK_EVENT_RESET : return vk_err_messages[4];
             case VK_INCOMPLETE : return vk_err_messages[5];
             case VK_ERROR_OUT_OF_HOST_MEMORY : return vk_err_messages[6];
             case VK_ERROR_OUT_OF_DEVICE_MEMORY : return vk_err_messages[7];
             case VK_ERROR_INITIALIZATION_FAILED : return vk_err_messages[8];
             case VK_ERROR_DEVICE_LOST : return vk_err_messages[9];
             case VK_ERROR_MEMORY_MAP_FAILED : return vk_err_messages[10];
             case VK_ERROR_LAYER_NOT_PRESENT : return vk_err_messages[11];
             case VK_ERROR_EXTENSION_NOT_PRESENT : return vk_err_messages[12];
             case VK_ERROR_FEATURE_NOT_PRESENT : return vk_err_messages[13];
             case VK_ERROR_INCOMPATIBLE_DRIVER : return vk_err_messages[14];
             case VK_ERROR_TOO_MANY_OBJECTS : return vk_err_messages[15];
             case VK_ERROR_FORMAT_NOT_SUPPORTED : return vk_err_messages[16];
             case VK_ERROR_FRAGMENTED_POOL : return vk_err_messages[17];
             case VK_ERROR_OUT_OF_POOL_MEMORY : return vk_err_messages[18];
             case VK_ERROR_INVALID_EXTERNAL_HANDLE : return vk_err_messages[19];
             case VK_ERROR_SURFACE_LOST_KHR : return vk_err_messages[20];
             case VK_ERROR_NATIVE_WINDOW_IN_USE_KHR : return vk_err_messages[21];
             case VK_SUBOPTIMAL_KHR : return vk_err_messages[22];
             case VK_ERROR_OUT_OF_DATE_KHR : return vk_err_messages[23];
             case VK_ERROR_INCOMPATIBLE_DISPLAY_KHR : return vk_err_messages[24];
             case VK_ERROR_VALIDATION_FAILED_EXT : return vk_err_messages[25];
             case VK_ERROR_INVALID_SHADER_NV : return vk_err_messages[26];
             case VK_ERROR_OUT_OF_POOL_MEMORY_KHR : return vk_err_messages[27];
             case VK_ERROR_INVALID_EXTERNAL_HANDLE_KHR : return vk_err_messages[28];
             case VK_ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT : return vk_err_messages[29];
             case VK_ERROR_FRAGMENTATION_EXT : return vk_err_messages[30];
             case VK_ERROR_NOT_PERMITTED_EXT : return vk_err_messages[31];
             case VK_ERROR_INVALID_DEVICE_ADDRESS_EXT : return vk_err_messages[32];
             case VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT : return vk_err_messages[33];
         }
         return nullptr;
     }

#ifdef VK_VERSION_1_1
    PFN_vkEnumerateInstanceVersion pfvkEnumerateInstanceVersion;
    #endif //VK_VERSION_1_1
    #ifdef VK_VERSION_1_1
    PFN_vkBindBufferMemory2 pfvkBindBufferMemory2;
    #endif //VK_VERSION_1_1
    #ifdef VK_VERSION_1_1
    PFN_vkBindImageMemory2 pfvkBindImageMemory2;
    #endif //VK_VERSION_1_1
    #ifdef VK_VERSION_1_1
    PFN_vkGetDeviceGroupPeerMemoryFeatures pfvkGetDeviceGroupPeerMemoryFeatures;
    #endif //VK_VERSION_1_1
    #ifdef VK_VERSION_1_1
    PFN_vkCmdSetDeviceMask pfvkCmdSetDeviceMask;
    #endif //VK_VERSION_1_1
    #ifdef VK_VERSION_1_1
    PFN_vkCmdDispatchBase pfvkCmdDispatchBase;
    #endif //VK_VERSION_1_1
    #ifdef VK_VERSION_1_1
    PFN_vkEnumeratePhysicalDeviceGroups pfvkEnumeratePhysicalDeviceGroups;
    #endif //VK_VERSION_1_1
    #ifdef VK_VERSION_1_1
    PFN_vkGetImageMemoryRequirements2 pfvkGetImageMemoryRequirements2;
    #endif //VK_VERSION_1_1
    #ifdef VK_VERSION_1_1
    PFN_vkGetBufferMemoryRequirements2 pfvkGetBufferMemoryRequirements2;
    #endif //VK_VERSION_1_1
    #ifdef VK_VERSION_1_1
    PFN_vkGetImageSparseMemoryRequirements2 pfvkGetImageSparseMemoryRequirements2;
    #endif //VK_VERSION_1_1
    #ifdef VK_VERSION_1_1
    PFN_vkGetPhysicalDeviceFeatures2 pfvkGetPhysicalDeviceFeatures2;
    #endif //VK_VERSION_1_1
    #ifdef VK_VERSION_1_1
    PFN_vkGetPhysicalDeviceProperties2 pfvkGetPhysicalDeviceProperties2;
    #endif //VK_VERSION_1_1
    #ifdef VK_VERSION_1_1
    PFN_vkGetPhysicalDeviceFormatProperties2 pfvkGetPhysicalDeviceFormatProperties2;
    #endif //VK_VERSION_1_1
    #ifdef VK_VERSION_1_1
    PFN_vkGetPhysicalDeviceImageFormatProperties2 pfvkGetPhysicalDeviceImageFormatProperties2;
    #endif //VK_VERSION_1_1
    #ifdef VK_VERSION_1_1
    PFN_vkGetPhysicalDeviceQueueFamilyProperties2 pfvkGetPhysicalDeviceQueueFamilyProperties2;
    #endif //VK_VERSION_1_1
    #ifdef VK_VERSION_1_1
    PFN_vkGetPhysicalDeviceMemoryProperties2 pfvkGetPhysicalDeviceMemoryProperties2;
    #endif //VK_VERSION_1_1
    #ifdef VK_VERSION_1_1
    PFN_vkGetPhysicalDeviceSparseImageFormatProperties2 pfvkGetPhysicalDeviceSparseImageFormatProperties2;
    #endif //VK_VERSION_1_1
    #ifdef VK_VERSION_1_1
    PFN_vkTrimCommandPool pfvkTrimCommandPool;
    #endif //VK_VERSION_1_1
    #ifdef VK_VERSION_1_1
    PFN_vkGetDeviceQueue2 pfvkGetDeviceQueue2;
    #endif //VK_VERSION_1_1
    #ifdef VK_VERSION_1_1
    PFN_vkCreateSamplerYcbcrConversion pfvkCreateSamplerYcbcrConversion;
    #endif //VK_VERSION_1_1
    #ifdef VK_VERSION_1_1
    PFN_vkDestroySamplerYcbcrConversion pfvkDestroySamplerYcbcrConversion;
    #endif //VK_VERSION_1_1
    #ifdef VK_VERSION_1_1
    PFN_vkCreateDescriptorUpdateTemplate pfvkCreateDescriptorUpdateTemplate;
    #endif //VK_VERSION_1_1
    #ifdef VK_VERSION_1_1
    PFN_vkDestroyDescriptorUpdateTemplate pfvkDestroyDescriptorUpdateTemplate;
    #endif //VK_VERSION_1_1
    #ifdef VK_VERSION_1_1
    PFN_vkUpdateDescriptorSetWithTemplate pfvkUpdateDescriptorSetWithTemplate;
    #endif //VK_VERSION_1_1
    #ifdef VK_VERSION_1_1
    PFN_vkGetPhysicalDeviceExternalBufferProperties pfvkGetPhysicalDeviceExternalBufferProperties;
    #endif //VK_VERSION_1_1
    #ifdef VK_VERSION_1_1
    PFN_vkGetPhysicalDeviceExternalFenceProperties pfvkGetPhysicalDeviceExternalFenceProperties;
    #endif //VK_VERSION_1_1
    #ifdef VK_VERSION_1_1
    PFN_vkGetPhysicalDeviceExternalSemaphoreProperties pfvkGetPhysicalDeviceExternalSemaphoreProperties;
    #endif //VK_VERSION_1_1
    #ifdef VK_VERSION_1_1
    PFN_vkGetDescriptorSetLayoutSupport pfvkGetDescriptorSetLayoutSupport;
    #endif //VK_VERSION_1_1

    void load_vulkan_fct_ptrs(VkInstance instance)
    {
#ifdef VK_VERSION_1_1
	    pfvkEnumerateInstanceVersion = reinterpret_cast<PFN_vkEnumerateInstanceVersion>(vkGetInstanceProcAddr(instance, "vkEnumerateInstanceVersion"));
#endif
#ifdef VK_VERSION_1_1
	    pfvkBindBufferMemory2 = reinterpret_cast<PFN_vkBindBufferMemory2>(vkGetInstanceProcAddr(instance, "vkBindBufferMemory2"));
#endif
#ifdef VK_VERSION_1_1
	    pfvkBindImageMemory2 = reinterpret_cast<PFN_vkBindImageMemory2>(vkGetInstanceProcAddr(instance, "vkBindImageMemory2"));
#endif
#ifdef VK_VERSION_1_1
	    pfvkGetDeviceGroupPeerMemoryFeatures = reinterpret_cast<PFN_vkGetDeviceGroupPeerMemoryFeatures>(vkGetInstanceProcAddr(instance, "vkGetDeviceGroupPeerMemoryFeatures"));
#endif
#ifdef VK_VERSION_1_1
	    pfvkCmdSetDeviceMask = reinterpret_cast<PFN_vkCmdSetDeviceMask>(vkGetInstanceProcAddr(instance, "vkCmdSetDeviceMask"));
#endif
#ifdef VK_VERSION_1_1
	    pfvkCmdDispatchBase = reinterpret_cast<PFN_vkCmdDispatchBase>(vkGetInstanceProcAddr(instance, "vkCmdDispatchBase"));
#endif
#ifdef VK_VERSION_1_1
	    pfvkEnumeratePhysicalDeviceGroups = reinterpret_cast<PFN_vkEnumeratePhysicalDeviceGroups>(vkGetInstanceProcAddr(instance, "vkEnumeratePhysicalDeviceGroups"));
#endif
#ifdef VK_VERSION_1_1
	    pfvkGetImageMemoryRequirements2 = reinterpret_cast<PFN_vkGetImageMemoryRequirements2>(vkGetInstanceProcAddr(instance, "vkGetImageMemoryRequirements2"));
#endif
#ifdef VK_VERSION_1_1
	    pfvkGetBufferMemoryRequirements2 = reinterpret_cast<PFN_vkGetBufferMemoryRequirements2>(vkGetInstanceProcAddr(instance, "vkGetBufferMemoryRequirements2"));
#endif
#ifdef VK_VERSION_1_1
	    pfvkGetImageSparseMemoryRequirements2 = reinterpret_cast<PFN_vkGetImageSparseMemoryRequirements2>(vkGetInstanceProcAddr(instance, "vkGetImageSparseMemoryRequirements2"));
#endif
#ifdef VK_VERSION_1_1
	    pfvkGetPhysicalDeviceFeatures2 = reinterpret_cast<PFN_vkGetPhysicalDeviceFeatures2>(vkGetInstanceProcAddr(instance, "vkGetPhysicalDeviceFeatures2"));
#endif
#ifdef VK_VERSION_1_1
	    pfvkGetPhysicalDeviceProperties2 = reinterpret_cast<PFN_vkGetPhysicalDeviceProperties2>(vkGetInstanceProcAddr(instance, "vkGetPhysicalDeviceProperties2"));
#endif
#ifdef VK_VERSION_1_1
	    pfvkGetPhysicalDeviceFormatProperties2 = reinterpret_cast<PFN_vkGetPhysicalDeviceFormatProperties2>(vkGetInstanceProcAddr(instance, "vkGetPhysicalDeviceFormatProperties2"));
#endif
#ifdef VK_VERSION_1_1
	    pfvkGetPhysicalDeviceImageFormatProperties2 = reinterpret_cast<PFN_vkGetPhysicalDeviceImageFormatProperties2>(vkGetInstanceProcAddr(instance, "vkGetPhysicalDeviceImageFormatProperties2"));
#endif
#ifdef VK_VERSION_1_1
	    pfvkGetPhysicalDeviceQueueFamilyProperties2 = reinterpret_cast<PFN_vkGetPhysicalDeviceQueueFamilyProperties2>(vkGetInstanceProcAddr(instance, "vkGetPhysicalDeviceQueueFamilyProperties2"));
#endif
#ifdef VK_VERSION_1_1
	    pfvkGetPhysicalDeviceMemoryProperties2 = reinterpret_cast<PFN_vkGetPhysicalDeviceMemoryProperties2>(vkGetInstanceProcAddr(instance, "vkGetPhysicalDeviceMemoryProperties2"));
#endif
#ifdef VK_VERSION_1_1
	    pfvkGetPhysicalDeviceSparseImageFormatProperties2 = reinterpret_cast<PFN_vkGetPhysicalDeviceSparseImageFormatProperties2>(vkGetInstanceProcAddr(instance, "vkGetPhysicalDeviceSparseImageFormatProperties2"));
#endif
#ifdef VK_VERSION_1_1
	    pfvkTrimCommandPool = reinterpret_cast<PFN_vkTrimCommandPool>(vkGetInstanceProcAddr(instance, "vkTrimCommandPool"));
#endif
#ifdef VK_VERSION_1_1
	    pfvkGetDeviceQueue2 = reinterpret_cast<PFN_vkGetDeviceQueue2>(vkGetInstanceProcAddr(instance, "vkGetDeviceQueue2"));
#endif
#ifdef VK_VERSION_1_1
	    pfvkCreateSamplerYcbcrConversion = reinterpret_cast<PFN_vkCreateSamplerYcbcrConversion>(vkGetInstanceProcAddr(instance, "vkCreateSamplerYcbcrConversion"));
#endif
#ifdef VK_VERSION_1_1
	    pfvkDestroySamplerYcbcrConversion = reinterpret_cast<PFN_vkDestroySamplerYcbcrConversion>(vkGetInstanceProcAddr(instance, "vkDestroySamplerYcbcrConversion"));
#endif
#ifdef VK_VERSION_1_1
	    pfvkCreateDescriptorUpdateTemplate = reinterpret_cast<PFN_vkCreateDescriptorUpdateTemplate>(vkGetInstanceProcAddr(instance, "vkCreateDescriptorUpdateTemplate"));
#endif
#ifdef VK_VERSION_1_1
	    pfvkDestroyDescriptorUpdateTemplate = reinterpret_cast<PFN_vkDestroyDescriptorUpdateTemplate>(vkGetInstanceProcAddr(instance, "vkDestroyDescriptorUpdateTemplate"));
#endif
#ifdef VK_VERSION_1_1
	    pfvkUpdateDescriptorSetWithTemplate = reinterpret_cast<PFN_vkUpdateDescriptorSetWithTemplate>(vkGetInstanceProcAddr(instance, "vkUpdateDescriptorSetWithTemplate"));
#endif
#ifdef VK_VERSION_1_1
	    pfvkGetPhysicalDeviceExternalBufferProperties = reinterpret_cast<PFN_vkGetPhysicalDeviceExternalBufferProperties>(vkGetInstanceProcAddr(instance, "vkGetPhysicalDeviceExternalBufferProperties"));
#endif
#ifdef VK_VERSION_1_1
	    pfvkGetPhysicalDeviceExternalFenceProperties = reinterpret_cast<PFN_vkGetPhysicalDeviceExternalFenceProperties>(vkGetInstanceProcAddr(instance, "vkGetPhysicalDeviceExternalFenceProperties"));
#endif
#ifdef VK_VERSION_1_1
	    pfvkGetPhysicalDeviceExternalSemaphoreProperties = reinterpret_cast<PFN_vkGetPhysicalDeviceExternalSemaphoreProperties>(vkGetInstanceProcAddr(instance, "vkGetPhysicalDeviceExternalSemaphoreProperties"));
#endif
#ifdef VK_VERSION_1_1
	    pfvkGetDescriptorSetLayoutSupport = reinterpret_cast<PFN_vkGetDescriptorSetLayoutSupport>(vkGetInstanceProcAddr(instance, "vkGetDescriptorSetLayoutSupport"));
#endif
  }
%}

%{

uint32_t enumerateInstanceVersion(void)
   {
      if ( nullptr == pfvkEnumerateInstanceVersion )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      uint32_t pApiVersion; 
      V( pfvkEnumerateInstanceVersion(
          &pApiVersion  ));
      return pApiVersion; 
   }

VkPhysicalDeviceSubgroupProperties PhysicalDeviceSubgroupProperties(
    uint32_t                                    subgroupSize,
    VkShaderStageFlags                          supportedStages,
    VkSubgroupFeatureFlags                      supportedOperations,
    VkBool32                                    quadOperationsInAllStages)
   {
      VkPhysicalDeviceSubgroupProperties obj;
      obj.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES;
      obj.pNext = nullptr;
      obj.subgroupSize = subgroupSize;
      obj.supportedStages = supportedStages;
      obj.supportedOperations = supportedOperations;
      obj.quadOperationsInAllStages = quadOperationsInAllStages;
      return obj;
   }

VkBindBufferMemoryInfo BindBufferMemoryInfo(
    VkBuffer                                    buffer,
    VkDeviceMemory                              memory,
    VkDeviceSize                                memoryOffset)
   {
      VkBindBufferMemoryInfo obj;
      obj.sType = VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO;
      obj.pNext = nullptr;
      obj.buffer = buffer;
      obj.memory = memory;
      obj.memoryOffset = memoryOffset;
      return obj;
   }

VkBindImageMemoryInfo BindImageMemoryInfo(
    VkImage                                     image,
    VkDeviceMemory                              memory,
    VkDeviceSize                                memoryOffset)
   {
      VkBindImageMemoryInfo obj;
      obj.sType = VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO;
      obj.pNext = nullptr;
      obj.image = image;
      obj.memory = memory;
      obj.memoryOffset = memoryOffset;
      return obj;
   }

void  bindBufferMemory2(
        VkDevice device,
        const std::vector<VkBindBufferMemoryInfo> & pBindInfos)
   {
      if ( nullptr == pfvkBindBufferMemory2 )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      V( pfvkBindBufferMemory2(
          device,
          static_cast<uint32_t>(pBindInfos.size()),
          &pBindInfos[0]  ));
   }

void  bindImageMemory2(
        VkDevice device,
        const std::vector<VkBindImageMemoryInfo> & pBindInfos)
   {
      if ( nullptr == pfvkBindImageMemory2 )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      V( pfvkBindImageMemory2(
          device,
          static_cast<uint32_t>(pBindInfos.size()),
          &pBindInfos[0]  ));
   }

VkPhysicalDevice16BitStorageFeatures PhysicalDevice16BitStorageFeatures(
    VkBool32                                    storageBuffer16BitAccess,
    VkBool32                                    uniformAndStorageBuffer16BitAccess,
    VkBool32                                    storagePushConstant16,
    VkBool32                                    storageInputOutput16)
   {
      VkPhysicalDevice16BitStorageFeatures obj;
      obj.sType = VK_STRUCTURE_TYPE_MAX_ENUM;
      obj.pNext = nullptr;
      obj.storageBuffer16BitAccess = storageBuffer16BitAccess;
      obj.uniformAndStorageBuffer16BitAccess = uniformAndStorageBuffer16BitAccess;
      obj.storagePushConstant16 = storagePushConstant16;
      obj.storageInputOutput16 = storageInputOutput16;
      return obj;
   }

VkMemoryDedicatedRequirements MemoryDedicatedRequirements(
    VkBool32                                    prefersDedicatedAllocation,
    VkBool32                                    requiresDedicatedAllocation)
   {
      VkMemoryDedicatedRequirements obj;
      obj.sType = VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS;
      obj.pNext = nullptr;
      obj.prefersDedicatedAllocation = prefersDedicatedAllocation;
      obj.requiresDedicatedAllocation = requiresDedicatedAllocation;
      return obj;
   }

VkMemoryDedicatedAllocateInfo MemoryDedicatedAllocateInfo(
    VkImage                                     image,
    VkBuffer                                    buffer)
   {
      VkMemoryDedicatedAllocateInfo obj;
      obj.sType = VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO;
      obj.pNext = nullptr;
      obj.image = image;
      obj.buffer = buffer;
      return obj;
   }

VkMemoryAllocateFlagsInfo MemoryAllocateFlagsInfo(
    VkMemoryAllocateFlags                       flags,
    uint32_t                                    deviceMask)
   {
      VkMemoryAllocateFlagsInfo obj;
      obj.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO;
      obj.pNext = nullptr;
      obj.flags = flags;
      obj.deviceMask = deviceMask;
      return obj;
   }

VkOffset2D Offset2D(
    int32_t                                     x,
    int32_t                                     y)
   {
      VkOffset2D obj;
      obj.x = x;
      obj.y = y;
      return obj;
   }

VkExtent2D Extent2D(
    uint32_t                                    width,
    uint32_t                                    height)
   {
      VkExtent2D obj;
      obj.width = width;
      obj.height = height;
      return obj;
   }

VkRect2D Rect2D(
    VkOffset2D                                  offset,
    VkExtent2D                                  extent)
   {
      VkRect2D obj;
      obj.offset = offset;
      obj.extent = extent;
      return obj;
   }

struct VkDeviceGroupRenderPassBeginInfoRAII {
   VkDeviceGroupRenderPassBeginInfo nonRaiiObj;
    std::vector<VkRect2D>                       vecDeviceRenderAreas;
};

std::shared_ptr<VkDeviceGroupRenderPassBeginInfoRAII> DeviceGroupRenderPassBeginInfo(
    uint32_t                                    deviceMask,
    const std::vector<VkRect2D> &               vecDeviceRenderAreas)
   {
      std::shared_ptr<VkDeviceGroupRenderPassBeginInfoRAII> raii_obj(new VkDeviceGroupRenderPassBeginInfoRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.deviceMask = deviceMask;
      raii_obj->nonRaiiObj.deviceRenderAreaCount = static_cast<uint32_t>(vecDeviceRenderAreas.size());
      raii_obj->vecDeviceRenderAreas = vecDeviceRenderAreas;
      if ( raii_obj->vecDeviceRenderAreas.size() > 0)
      {
          raii_obj->nonRaiiObj.pDeviceRenderAreas = &raii_obj->vecDeviceRenderAreas[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pDeviceRenderAreas = nullptr;
      }
      return raii_obj;
   }

VkDeviceGroupCommandBufferBeginInfo DeviceGroupCommandBufferBeginInfo(
    uint32_t                                    deviceMask)
   {
      VkDeviceGroupCommandBufferBeginInfo obj;
      obj.sType = VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO;
      obj.pNext = nullptr;
      obj.deviceMask = deviceMask;
      return obj;
   }

struct VkDeviceGroupSubmitInfoRAII {
   VkDeviceGroupSubmitInfo nonRaiiObj;
    std::vector<uint32_t>                       vecWaitSemaphoreDeviceIndices;
    std::vector<uint32_t>                       vecCommandBufferDeviceMasks;
    std::vector<uint32_t>                       vecSignalSemaphoreDeviceIndices;
};

std::shared_ptr<VkDeviceGroupSubmitInfoRAII> DeviceGroupSubmitInfo(
    unsigned int* pWaitSemaphoreDeviceIndices_in_array1, int pWaitSemaphoreDeviceIndices_dim1,
    unsigned int* pCommandBufferDeviceMasks_in_array1, int pCommandBufferDeviceMasks_dim1,
    unsigned int* pSignalSemaphoreDeviceIndices_in_array1, int pSignalSemaphoreDeviceIndices_dim1)
   {
      std::shared_ptr<VkDeviceGroupSubmitInfoRAII> raii_obj(new VkDeviceGroupSubmitInfoRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.waitSemaphoreCount = static_cast<uint32_t>(pWaitSemaphoreDeviceIndices_dim1);
      raii_obj->vecWaitSemaphoreDeviceIndices.assign(pWaitSemaphoreDeviceIndices_in_array1, pWaitSemaphoreDeviceIndices_in_array1 + pWaitSemaphoreDeviceIndices_dim1);
      if ( raii_obj->vecWaitSemaphoreDeviceIndices.size() > 0)
      {
          raii_obj->nonRaiiObj.pWaitSemaphoreDeviceIndices = &raii_obj->vecWaitSemaphoreDeviceIndices[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pWaitSemaphoreDeviceIndices = nullptr;
      }
      raii_obj->nonRaiiObj.commandBufferCount = static_cast<uint32_t>(pCommandBufferDeviceMasks_dim1);
      raii_obj->vecCommandBufferDeviceMasks.assign(pCommandBufferDeviceMasks_in_array1, pCommandBufferDeviceMasks_in_array1 + pCommandBufferDeviceMasks_dim1);
      if ( raii_obj->vecCommandBufferDeviceMasks.size() > 0)
      {
          raii_obj->nonRaiiObj.pCommandBufferDeviceMasks = &raii_obj->vecCommandBufferDeviceMasks[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pCommandBufferDeviceMasks = nullptr;
      }
      raii_obj->nonRaiiObj.signalSemaphoreCount = static_cast<uint32_t>(pSignalSemaphoreDeviceIndices_dim1);
      raii_obj->vecSignalSemaphoreDeviceIndices.assign(pSignalSemaphoreDeviceIndices_in_array1, pSignalSemaphoreDeviceIndices_in_array1 + pSignalSemaphoreDeviceIndices_dim1);
      if ( raii_obj->vecSignalSemaphoreDeviceIndices.size() > 0)
      {
          raii_obj->nonRaiiObj.pSignalSemaphoreDeviceIndices = &raii_obj->vecSignalSemaphoreDeviceIndices[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pSignalSemaphoreDeviceIndices = nullptr;
      }
      return raii_obj;
   }

VkDeviceGroupBindSparseInfo DeviceGroupBindSparseInfo(
    uint32_t                                    resourceDeviceIndex,
    uint32_t                                    memoryDeviceIndex)
   {
      VkDeviceGroupBindSparseInfo obj;
      obj.sType = VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO;
      obj.pNext = nullptr;
      obj.resourceDeviceIndex = resourceDeviceIndex;
      obj.memoryDeviceIndex = memoryDeviceIndex;
      return obj;
   }

std::shared_ptr< VkPeerMemoryFeatureFlags > getDeviceGroupPeerMemoryFeatures(
        VkDevice device,
        uint32_t heapIndex,
        uint32_t localDeviceIndex,
        uint32_t remoteDeviceIndex)
   {
      if ( nullptr == pfvkGetDeviceGroupPeerMemoryFeatures )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      std::shared_ptr<VkPeerMemoryFeatureFlags> ptrpPeerMemoryFeatures(new VkPeerMemoryFeatureFlags); 
      pfvkGetDeviceGroupPeerMemoryFeatures(
          device,
          heapIndex,
          localDeviceIndex,
          remoteDeviceIndex,
          ptrpPeerMemoryFeatures.get()  );
      return ptrpPeerMemoryFeatures; 
   }

void  cmdSetDeviceMask(
        VkCommandBuffer commandBuffer,
        uint32_t deviceMask)
   {
      if ( nullptr == pfvkCmdSetDeviceMask )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      pfvkCmdSetDeviceMask(
          commandBuffer,
          deviceMask  );
   }

void  cmdDispatchBase(
        VkCommandBuffer commandBuffer,
        uint32_t baseGroupX,
        uint32_t baseGroupY,
        uint32_t baseGroupZ,
        uint32_t groupCountX,
        uint32_t groupCountY,
        uint32_t groupCountZ)
   {
      if ( nullptr == pfvkCmdDispatchBase )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      pfvkCmdDispatchBase(
          commandBuffer,
          baseGroupX,
          baseGroupY,
          baseGroupZ,
          groupCountX,
          groupCountY,
          groupCountZ  );
   }

struct VkBindBufferMemoryDeviceGroupInfoRAII {
   VkBindBufferMemoryDeviceGroupInfo nonRaiiObj;
    std::vector<uint32_t>                       vecDeviceIndices;
};

std::shared_ptr<VkBindBufferMemoryDeviceGroupInfoRAII> BindBufferMemoryDeviceGroupInfo(
    unsigned int* pDeviceIndices_in_array1, int pDeviceIndices_dim1)
   {
      std::shared_ptr<VkBindBufferMemoryDeviceGroupInfoRAII> raii_obj(new VkBindBufferMemoryDeviceGroupInfoRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.deviceIndexCount = static_cast<uint32_t>(pDeviceIndices_dim1);
      raii_obj->vecDeviceIndices.assign(pDeviceIndices_in_array1, pDeviceIndices_in_array1 + pDeviceIndices_dim1);
      if ( raii_obj->vecDeviceIndices.size() > 0)
      {
          raii_obj->nonRaiiObj.pDeviceIndices = &raii_obj->vecDeviceIndices[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pDeviceIndices = nullptr;
      }
      return raii_obj;
   }

struct VkBindImageMemoryDeviceGroupInfoRAII {
   VkBindImageMemoryDeviceGroupInfo nonRaiiObj;
    std::vector<uint32_t>                       vecDeviceIndices;
    std::vector<VkRect2D>                       vecSplitInstanceBindRegions;
};

std::shared_ptr<VkBindImageMemoryDeviceGroupInfoRAII> BindImageMemoryDeviceGroupInfo(
    unsigned int* pDeviceIndices_in_array1, int pDeviceIndices_dim1,
    const std::vector<VkRect2D> &               vecSplitInstanceBindRegions)
   {
      std::shared_ptr<VkBindImageMemoryDeviceGroupInfoRAII> raii_obj(new VkBindImageMemoryDeviceGroupInfoRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.deviceIndexCount = static_cast<uint32_t>(pDeviceIndices_dim1);
      raii_obj->vecDeviceIndices.assign(pDeviceIndices_in_array1, pDeviceIndices_in_array1 + pDeviceIndices_dim1);
      if ( raii_obj->vecDeviceIndices.size() > 0)
      {
          raii_obj->nonRaiiObj.pDeviceIndices = &raii_obj->vecDeviceIndices[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pDeviceIndices = nullptr;
      }
      raii_obj->nonRaiiObj.splitInstanceBindRegionCount = static_cast<uint32_t>(vecSplitInstanceBindRegions.size());
      raii_obj->vecSplitInstanceBindRegions = vecSplitInstanceBindRegions;
      if ( raii_obj->vecSplitInstanceBindRegions.size() > 0)
      {
          raii_obj->nonRaiiObj.pSplitInstanceBindRegions = &raii_obj->vecSplitInstanceBindRegions[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pSplitInstanceBindRegions = nullptr;
      }
      return raii_obj;
   }

VkPhysicalDeviceGroupProperties PhysicalDeviceGroupProperties(
    uint32_t                                    physicalDeviceCount,
    VkPhysicalDevice                            physicalDevices[VK_MAX_DEVICE_GROUP_SIZE],
    VkBool32                                    subsetAllocation)
   {
      VkPhysicalDeviceGroupProperties obj;
      obj.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES;
      obj.pNext = nullptr;
      obj.physicalDeviceCount = physicalDeviceCount;
      std::copy(physicalDevices, physicalDevices + VK_MAX_DEVICE_GROUP_SIZE, obj.physicalDevices);
      obj.subsetAllocation = subsetAllocation;
      return obj;
   }

struct VkDeviceGroupDeviceCreateInfoRAII {
   VkDeviceGroupDeviceCreateInfo nonRaiiObj;
    std::vector<VkPhysicalDevice>               vecPhysicalDevices;
};

std::shared_ptr<VkDeviceGroupDeviceCreateInfoRAII> DeviceGroupDeviceCreateInfo(
    const std::vector<VkPhysicalDevice> &       vecPhysicalDevices)
   {
      std::shared_ptr<VkDeviceGroupDeviceCreateInfoRAII> raii_obj(new VkDeviceGroupDeviceCreateInfoRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.physicalDeviceCount = static_cast<uint32_t>(vecPhysicalDevices.size());
      raii_obj->vecPhysicalDevices = vecPhysicalDevices;
      if ( raii_obj->vecPhysicalDevices.size() > 0)
      {
          raii_obj->nonRaiiObj.pPhysicalDevices = &raii_obj->vecPhysicalDevices[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pPhysicalDevices = nullptr;
      }
      return raii_obj;
   }

std::vector< VkPhysicalDeviceGroupProperties > enumeratePhysicalDeviceGroups(
        VkInstance instance)
   {
      if ( nullptr == pfvkEnumeratePhysicalDeviceGroups )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      std::vector<VkPhysicalDeviceGroupProperties> vecpPhysicalDeviceGroupProperties; 
      uint32_t pPhysicalDeviceGroupPropertiesCount; 
      V( pfvkEnumeratePhysicalDeviceGroups(
          instance,
          &pPhysicalDeviceGroupPropertiesCount,
          nullptr  ));

      vecpPhysicalDeviceGroupProperties.resize(pPhysicalDeviceGroupPropertiesCount); 

      V( pfvkEnumeratePhysicalDeviceGroups(
          instance,
          &pPhysicalDeviceGroupPropertiesCount,
          &vecpPhysicalDeviceGroupProperties[0]  ));
      return vecpPhysicalDeviceGroupProperties; 
   }

VkBufferMemoryRequirementsInfo2 BufferMemoryRequirementsInfo2(
    VkBuffer                                    buffer)
   {
      VkBufferMemoryRequirementsInfo2 obj;
      obj.sType = VK_STRUCTURE_TYPE_MAX_ENUM;
      obj.pNext = nullptr;
      obj.buffer = buffer;
      return obj;
   }

VkImageMemoryRequirementsInfo2 ImageMemoryRequirementsInfo2(
    VkImage                                     image)
   {
      VkImageMemoryRequirementsInfo2 obj;
      obj.sType = VK_STRUCTURE_TYPE_MAX_ENUM;
      obj.pNext = nullptr;
      obj.image = image;
      return obj;
   }

VkImageSparseMemoryRequirementsInfo2 ImageSparseMemoryRequirementsInfo2(
    VkImage                                     image)
   {
      VkImageSparseMemoryRequirementsInfo2 obj;
      obj.sType = VK_STRUCTURE_TYPE_MAX_ENUM;
      obj.pNext = nullptr;
      obj.image = image;
      return obj;
   }

VkMemoryRequirements MemoryRequirements(
    VkDeviceSize                                size,
    VkDeviceSize                                alignment,
    uint32_t                                    memoryTypeBits)
   {
      VkMemoryRequirements obj;
      obj.size = size;
      obj.alignment = alignment;
      obj.memoryTypeBits = memoryTypeBits;
      return obj;
   }

VkMemoryRequirements2 MemoryRequirements2(
    VkMemoryRequirements                        memoryRequirements)
   {
      VkMemoryRequirements2 obj;
      obj.sType = VK_STRUCTURE_TYPE_MAX_ENUM;
      obj.pNext = nullptr;
      obj.memoryRequirements = memoryRequirements;
      return obj;
   }

VkMemoryRequirements2KHR MemoryRequirements2KHR(void)
   {
      VkMemoryRequirements2KHR obj;
      return obj;
   }

VkExtent3D Extent3D(
    uint32_t                                    width,
    uint32_t                                    height,
    uint32_t                                    depth)
   {
      VkExtent3D obj;
      obj.width = width;
      obj.height = height;
      obj.depth = depth;
      return obj;
   }

VkSparseImageFormatProperties SparseImageFormatProperties(
    VkImageAspectFlags                          aspectMask,
    VkExtent3D                                  imageGranularity,
    VkSparseImageFormatFlags                    flags)
   {
      VkSparseImageFormatProperties obj;
      obj.aspectMask = aspectMask;
      obj.imageGranularity = imageGranularity;
      obj.flags = flags;
      return obj;
   }

VkSparseImageMemoryRequirements SparseImageMemoryRequirements(
    VkSparseImageFormatProperties               formatProperties,
    uint32_t                                    imageMipTailFirstLod,
    VkDeviceSize                                imageMipTailSize,
    VkDeviceSize                                imageMipTailOffset,
    VkDeviceSize                                imageMipTailStride)
   {
      VkSparseImageMemoryRequirements obj;
      obj.formatProperties = formatProperties;
      obj.imageMipTailFirstLod = imageMipTailFirstLod;
      obj.imageMipTailSize = imageMipTailSize;
      obj.imageMipTailOffset = imageMipTailOffset;
      obj.imageMipTailStride = imageMipTailStride;
      return obj;
   }

VkSparseImageMemoryRequirements2 SparseImageMemoryRequirements2(
    VkSparseImageMemoryRequirements             memoryRequirements)
   {
      VkSparseImageMemoryRequirements2 obj;
      obj.sType = VK_STRUCTURE_TYPE_MAX_ENUM;
      obj.pNext = nullptr;
      obj.memoryRequirements = memoryRequirements;
      return obj;
   }

VkMemoryRequirements2 getImageMemoryRequirements2(
        VkDevice device,
        const VkImageMemoryRequirementsInfo2 & pInfo)
   {
      if ( nullptr == pfvkGetImageMemoryRequirements2 )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      VkMemoryRequirements2 pMemoryRequirements; 
      pfvkGetImageMemoryRequirements2(
          device,
          &pInfo,
          &pMemoryRequirements  );
      return pMemoryRequirements; 
   }

VkMemoryRequirements2 getBufferMemoryRequirements2(
        VkDevice device,
        const VkBufferMemoryRequirementsInfo2 & pInfo)
   {
      if ( nullptr == pfvkGetBufferMemoryRequirements2 )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      VkMemoryRequirements2 pMemoryRequirements; 
      pfvkGetBufferMemoryRequirements2(
          device,
          &pInfo,
          &pMemoryRequirements  );
      return pMemoryRequirements; 
   }

std::vector< VkSparseImageMemoryRequirements2 > getImageSparseMemoryRequirements2(
        VkDevice device,
        const VkImageSparseMemoryRequirementsInfo2 & pInfo)
   {
      if ( nullptr == pfvkGetImageSparseMemoryRequirements2 )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      std::vector<VkSparseImageMemoryRequirements2> vecpSparseMemoryRequirements; 
      uint32_t pSparseMemoryRequirementsCount; 
      pfvkGetImageSparseMemoryRequirements2(
          device,
          &pInfo,
          &pSparseMemoryRequirementsCount,
          nullptr  );

      vecpSparseMemoryRequirements.resize(pSparseMemoryRequirementsCount); 

      pfvkGetImageSparseMemoryRequirements2(
          device,
          &pInfo,
          &pSparseMemoryRequirementsCount,
          &vecpSparseMemoryRequirements[0]  );
      return vecpSparseMemoryRequirements; 
   }

VkPhysicalDeviceFeatures PhysicalDeviceFeatures(
    VkBool32                                    robustBufferAccess,
    VkBool32                                    fullDrawIndexUint32,
    VkBool32                                    imageCubeArray,
    VkBool32                                    independentBlend,
    VkBool32                                    geometryShader,
    VkBool32                                    tessellationShader,
    VkBool32                                    sampleRateShading,
    VkBool32                                    dualSrcBlend,
    VkBool32                                    logicOp,
    VkBool32                                    multiDrawIndirect,
    VkBool32                                    drawIndirectFirstInstance,
    VkBool32                                    depthClamp,
    VkBool32                                    depthBiasClamp,
    VkBool32                                    fillModeNonSolid,
    VkBool32                                    depthBounds,
    VkBool32                                    wideLines,
    VkBool32                                    largePoints,
    VkBool32                                    alphaToOne,
    VkBool32                                    multiViewport,
    VkBool32                                    samplerAnisotropy,
    VkBool32                                    textureCompressionETC2,
    VkBool32                                    textureCompressionASTC_LDR,
    VkBool32                                    textureCompressionBC,
    VkBool32                                    occlusionQueryPrecise,
    VkBool32                                    pipelineStatisticsQuery,
    VkBool32                                    vertexPipelineStoresAndAtomics,
    VkBool32                                    fragmentStoresAndAtomics,
    VkBool32                                    shaderTessellationAndGeometryPointSize,
    VkBool32                                    shaderImageGatherExtended,
    VkBool32                                    shaderStorageImageExtendedFormats,
    VkBool32                                    shaderStorageImageMultisample,
    VkBool32                                    shaderStorageImageReadWithoutFormat,
    VkBool32                                    shaderStorageImageWriteWithoutFormat,
    VkBool32                                    shaderUniformBufferArrayDynamicIndexing,
    VkBool32                                    shaderSampledImageArrayDynamicIndexing,
    VkBool32                                    shaderStorageBufferArrayDynamicIndexing,
    VkBool32                                    shaderStorageImageArrayDynamicIndexing,
    VkBool32                                    shaderClipDistance,
    VkBool32                                    shaderCullDistance,
    VkBool32                                    shaderFloat64,
    VkBool32                                    shaderInt64,
    VkBool32                                    shaderInt16,
    VkBool32                                    shaderResourceResidency,
    VkBool32                                    shaderResourceMinLod,
    VkBool32                                    sparseBinding,
    VkBool32                                    sparseResidencyBuffer,
    VkBool32                                    sparseResidencyImage2D,
    VkBool32                                    sparseResidencyImage3D,
    VkBool32                                    sparseResidency2Samples,
    VkBool32                                    sparseResidency4Samples,
    VkBool32                                    sparseResidency8Samples,
    VkBool32                                    sparseResidency16Samples,
    VkBool32                                    sparseResidencyAliased,
    VkBool32                                    variableMultisampleRate,
    VkBool32                                    inheritedQueries)
   {
      VkPhysicalDeviceFeatures obj;
      obj.robustBufferAccess = robustBufferAccess;
      obj.fullDrawIndexUint32 = fullDrawIndexUint32;
      obj.imageCubeArray = imageCubeArray;
      obj.independentBlend = independentBlend;
      obj.geometryShader = geometryShader;
      obj.tessellationShader = tessellationShader;
      obj.sampleRateShading = sampleRateShading;
      obj.dualSrcBlend = dualSrcBlend;
      obj.logicOp = logicOp;
      obj.multiDrawIndirect = multiDrawIndirect;
      obj.drawIndirectFirstInstance = drawIndirectFirstInstance;
      obj.depthClamp = depthClamp;
      obj.depthBiasClamp = depthBiasClamp;
      obj.fillModeNonSolid = fillModeNonSolid;
      obj.depthBounds = depthBounds;
      obj.wideLines = wideLines;
      obj.largePoints = largePoints;
      obj.alphaToOne = alphaToOne;
      obj.multiViewport = multiViewport;
      obj.samplerAnisotropy = samplerAnisotropy;
      obj.textureCompressionETC2 = textureCompressionETC2;
      obj.textureCompressionASTC_LDR = textureCompressionASTC_LDR;
      obj.textureCompressionBC = textureCompressionBC;
      obj.occlusionQueryPrecise = occlusionQueryPrecise;
      obj.pipelineStatisticsQuery = pipelineStatisticsQuery;
      obj.vertexPipelineStoresAndAtomics = vertexPipelineStoresAndAtomics;
      obj.fragmentStoresAndAtomics = fragmentStoresAndAtomics;
      obj.shaderTessellationAndGeometryPointSize = shaderTessellationAndGeometryPointSize;
      obj.shaderImageGatherExtended = shaderImageGatherExtended;
      obj.shaderStorageImageExtendedFormats = shaderStorageImageExtendedFormats;
      obj.shaderStorageImageMultisample = shaderStorageImageMultisample;
      obj.shaderStorageImageReadWithoutFormat = shaderStorageImageReadWithoutFormat;
      obj.shaderStorageImageWriteWithoutFormat = shaderStorageImageWriteWithoutFormat;
      obj.shaderUniformBufferArrayDynamicIndexing = shaderUniformBufferArrayDynamicIndexing;
      obj.shaderSampledImageArrayDynamicIndexing = shaderSampledImageArrayDynamicIndexing;
      obj.shaderStorageBufferArrayDynamicIndexing = shaderStorageBufferArrayDynamicIndexing;
      obj.shaderStorageImageArrayDynamicIndexing = shaderStorageImageArrayDynamicIndexing;
      obj.shaderClipDistance = shaderClipDistance;
      obj.shaderCullDistance = shaderCullDistance;
      obj.shaderFloat64 = shaderFloat64;
      obj.shaderInt64 = shaderInt64;
      obj.shaderInt16 = shaderInt16;
      obj.shaderResourceResidency = shaderResourceResidency;
      obj.shaderResourceMinLod = shaderResourceMinLod;
      obj.sparseBinding = sparseBinding;
      obj.sparseResidencyBuffer = sparseResidencyBuffer;
      obj.sparseResidencyImage2D = sparseResidencyImage2D;
      obj.sparseResidencyImage3D = sparseResidencyImage3D;
      obj.sparseResidency2Samples = sparseResidency2Samples;
      obj.sparseResidency4Samples = sparseResidency4Samples;
      obj.sparseResidency8Samples = sparseResidency8Samples;
      obj.sparseResidency16Samples = sparseResidency16Samples;
      obj.sparseResidencyAliased = sparseResidencyAliased;
      obj.variableMultisampleRate = variableMultisampleRate;
      obj.inheritedQueries = inheritedQueries;
      return obj;
   }

VkPhysicalDeviceFeatures2 PhysicalDeviceFeatures2(
    VkPhysicalDeviceFeatures                    features)
   {
      VkPhysicalDeviceFeatures2 obj;
      obj.sType = VK_STRUCTURE_TYPE_MAX_ENUM;
      obj.pNext = nullptr;
      obj.features = features;
      return obj;
   }

VkPhysicalDeviceLimits PhysicalDeviceLimits(
    uint32_t                                    maxImageDimension1D,
    uint32_t                                    maxImageDimension2D,
    uint32_t                                    maxImageDimension3D,
    uint32_t                                    maxImageDimensionCube,
    uint32_t                                    maxImageArrayLayers,
    uint32_t                                    maxTexelBufferElements,
    uint32_t                                    maxUniformBufferRange,
    uint32_t                                    maxStorageBufferRange,
    uint32_t                                    maxPushConstantsSize,
    uint32_t                                    maxMemoryAllocationCount,
    uint32_t                                    maxSamplerAllocationCount,
    VkDeviceSize                                bufferImageGranularity,
    VkDeviceSize                                sparseAddressSpaceSize,
    uint32_t                                    maxBoundDescriptorSets,
    uint32_t                                    maxPerStageDescriptorSamplers,
    uint32_t                                    maxPerStageDescriptorUniformBuffers,
    uint32_t                                    maxPerStageDescriptorStorageBuffers,
    uint32_t                                    maxPerStageDescriptorSampledImages,
    uint32_t                                    maxPerStageDescriptorStorageImages,
    uint32_t                                    maxPerStageDescriptorInputAttachments,
    uint32_t                                    maxPerStageResources,
    uint32_t                                    maxDescriptorSetSamplers,
    uint32_t                                    maxDescriptorSetUniformBuffers,
    uint32_t                                    maxDescriptorSetUniformBuffersDynamic,
    uint32_t                                    maxDescriptorSetStorageBuffers,
    uint32_t                                    maxDescriptorSetStorageBuffersDynamic,
    uint32_t                                    maxDescriptorSetSampledImages,
    uint32_t                                    maxDescriptorSetStorageImages,
    uint32_t                                    maxDescriptorSetInputAttachments,
    uint32_t                                    maxVertexInputAttributes,
    uint32_t                                    maxVertexInputBindings,
    uint32_t                                    maxVertexInputAttributeOffset,
    uint32_t                                    maxVertexInputBindingStride,
    uint32_t                                    maxVertexOutputComponents,
    uint32_t                                    maxTessellationGenerationLevel,
    uint32_t                                    maxTessellationPatchSize,
    uint32_t                                    maxTessellationControlPerVertexInputComponents,
    uint32_t                                    maxTessellationControlPerVertexOutputComponents,
    uint32_t                                    maxTessellationControlPerPatchOutputComponents,
    uint32_t                                    maxTessellationControlTotalOutputComponents,
    uint32_t                                    maxTessellationEvaluationInputComponents,
    uint32_t                                    maxTessellationEvaluationOutputComponents,
    uint32_t                                    maxGeometryShaderInvocations,
    uint32_t                                    maxGeometryInputComponents,
    uint32_t                                    maxGeometryOutputComponents,
    uint32_t                                    maxGeometryOutputVertices,
    uint32_t                                    maxGeometryTotalOutputComponents,
    uint32_t                                    maxFragmentInputComponents,
    uint32_t                                    maxFragmentOutputAttachments,
    uint32_t                                    maxFragmentDualSrcAttachments,
    uint32_t                                    maxFragmentCombinedOutputResources,
    uint32_t                                    maxComputeSharedMemorySize,
    uint32_t                                    maxComputeWorkGroupCount[3],
    uint32_t                                    maxComputeWorkGroupInvocations,
    uint32_t                                    maxComputeWorkGroupSize[3],
    uint32_t                                    subPixelPrecisionBits,
    uint32_t                                    subTexelPrecisionBits,
    uint32_t                                    mipmapPrecisionBits,
    uint32_t                                    maxDrawIndexedIndexValue,
    uint32_t                                    maxDrawIndirectCount,
    float                                       maxSamplerLodBias,
    float                                       maxSamplerAnisotropy,
    uint32_t                                    maxViewports,
    uint32_t                                    maxViewportDimensions[2],
    float                                       viewportBoundsRange[2],
    uint32_t                                    viewportSubPixelBits,
    size_t                                      minMemoryMapAlignment,
    VkDeviceSize                                minTexelBufferOffsetAlignment,
    VkDeviceSize                                minUniformBufferOffsetAlignment,
    VkDeviceSize                                minStorageBufferOffsetAlignment,
    int32_t                                     minTexelOffset,
    uint32_t                                    maxTexelOffset,
    int32_t                                     minTexelGatherOffset,
    uint32_t                                    maxTexelGatherOffset,
    float                                       minInterpolationOffset,
    float                                       maxInterpolationOffset,
    uint32_t                                    subPixelInterpolationOffsetBits,
    uint32_t                                    maxFramebufferWidth,
    uint32_t                                    maxFramebufferHeight,
    uint32_t                                    maxFramebufferLayers,
    VkSampleCountFlags                          framebufferColorSampleCounts,
    VkSampleCountFlags                          framebufferDepthSampleCounts,
    VkSampleCountFlags                          framebufferStencilSampleCounts,
    VkSampleCountFlags                          framebufferNoAttachmentsSampleCounts,
    uint32_t                                    maxColorAttachments,
    VkSampleCountFlags                          sampledImageColorSampleCounts,
    VkSampleCountFlags                          sampledImageIntegerSampleCounts,
    VkSampleCountFlags                          sampledImageDepthSampleCounts,
    VkSampleCountFlags                          sampledImageStencilSampleCounts,
    VkSampleCountFlags                          storageImageSampleCounts,
    uint32_t                                    maxSampleMaskWords,
    VkBool32                                    timestampComputeAndGraphics,
    float                                       timestampPeriod,
    uint32_t                                    maxClipDistances,
    uint32_t                                    maxCullDistances,
    uint32_t                                    maxCombinedClipAndCullDistances,
    uint32_t                                    discreteQueuePriorities,
    float                                       pointSizeRange[2],
    float                                       lineWidthRange[2],
    float                                       pointSizeGranularity,
    float                                       lineWidthGranularity,
    VkBool32                                    strictLines,
    VkBool32                                    standardSampleLocations,
    VkDeviceSize                                optimalBufferCopyOffsetAlignment,
    VkDeviceSize                                optimalBufferCopyRowPitchAlignment,
    VkDeviceSize                                nonCoherentAtomSize)
   {
      VkPhysicalDeviceLimits obj;
      obj.maxImageDimension1D = maxImageDimension1D;
      obj.maxImageDimension2D = maxImageDimension2D;
      obj.maxImageDimension3D = maxImageDimension3D;
      obj.maxImageDimensionCube = maxImageDimensionCube;
      obj.maxImageArrayLayers = maxImageArrayLayers;
      obj.maxTexelBufferElements = maxTexelBufferElements;
      obj.maxUniformBufferRange = maxUniformBufferRange;
      obj.maxStorageBufferRange = maxStorageBufferRange;
      obj.maxPushConstantsSize = maxPushConstantsSize;
      obj.maxMemoryAllocationCount = maxMemoryAllocationCount;
      obj.maxSamplerAllocationCount = maxSamplerAllocationCount;
      obj.bufferImageGranularity = bufferImageGranularity;
      obj.sparseAddressSpaceSize = sparseAddressSpaceSize;
      obj.maxBoundDescriptorSets = maxBoundDescriptorSets;
      obj.maxPerStageDescriptorSamplers = maxPerStageDescriptorSamplers;
      obj.maxPerStageDescriptorUniformBuffers = maxPerStageDescriptorUniformBuffers;
      obj.maxPerStageDescriptorStorageBuffers = maxPerStageDescriptorStorageBuffers;
      obj.maxPerStageDescriptorSampledImages = maxPerStageDescriptorSampledImages;
      obj.maxPerStageDescriptorStorageImages = maxPerStageDescriptorStorageImages;
      obj.maxPerStageDescriptorInputAttachments = maxPerStageDescriptorInputAttachments;
      obj.maxPerStageResources = maxPerStageResources;
      obj.maxDescriptorSetSamplers = maxDescriptorSetSamplers;
      obj.maxDescriptorSetUniformBuffers = maxDescriptorSetUniformBuffers;
      obj.maxDescriptorSetUniformBuffersDynamic = maxDescriptorSetUniformBuffersDynamic;
      obj.maxDescriptorSetStorageBuffers = maxDescriptorSetStorageBuffers;
      obj.maxDescriptorSetStorageBuffersDynamic = maxDescriptorSetStorageBuffersDynamic;
      obj.maxDescriptorSetSampledImages = maxDescriptorSetSampledImages;
      obj.maxDescriptorSetStorageImages = maxDescriptorSetStorageImages;
      obj.maxDescriptorSetInputAttachments = maxDescriptorSetInputAttachments;
      obj.maxVertexInputAttributes = maxVertexInputAttributes;
      obj.maxVertexInputBindings = maxVertexInputBindings;
      obj.maxVertexInputAttributeOffset = maxVertexInputAttributeOffset;
      obj.maxVertexInputBindingStride = maxVertexInputBindingStride;
      obj.maxVertexOutputComponents = maxVertexOutputComponents;
      obj.maxTessellationGenerationLevel = maxTessellationGenerationLevel;
      obj.maxTessellationPatchSize = maxTessellationPatchSize;
      obj.maxTessellationControlPerVertexInputComponents = maxTessellationControlPerVertexInputComponents;
      obj.maxTessellationControlPerVertexOutputComponents = maxTessellationControlPerVertexOutputComponents;
      obj.maxTessellationControlPerPatchOutputComponents = maxTessellationControlPerPatchOutputComponents;
      obj.maxTessellationControlTotalOutputComponents = maxTessellationControlTotalOutputComponents;
      obj.maxTessellationEvaluationInputComponents = maxTessellationEvaluationInputComponents;
      obj.maxTessellationEvaluationOutputComponents = maxTessellationEvaluationOutputComponents;
      obj.maxGeometryShaderInvocations = maxGeometryShaderInvocations;
      obj.maxGeometryInputComponents = maxGeometryInputComponents;
      obj.maxGeometryOutputComponents = maxGeometryOutputComponents;
      obj.maxGeometryOutputVertices = maxGeometryOutputVertices;
      obj.maxGeometryTotalOutputComponents = maxGeometryTotalOutputComponents;
      obj.maxFragmentInputComponents = maxFragmentInputComponents;
      obj.maxFragmentOutputAttachments = maxFragmentOutputAttachments;
      obj.maxFragmentDualSrcAttachments = maxFragmentDualSrcAttachments;
      obj.maxFragmentCombinedOutputResources = maxFragmentCombinedOutputResources;
      obj.maxComputeSharedMemorySize = maxComputeSharedMemorySize;
      std::copy(maxComputeWorkGroupCount, maxComputeWorkGroupCount + 3, obj.maxComputeWorkGroupCount);
      obj.maxComputeWorkGroupInvocations = maxComputeWorkGroupInvocations;
      std::copy(maxComputeWorkGroupSize, maxComputeWorkGroupSize + 3, obj.maxComputeWorkGroupSize);
      obj.subPixelPrecisionBits = subPixelPrecisionBits;
      obj.subTexelPrecisionBits = subTexelPrecisionBits;
      obj.mipmapPrecisionBits = mipmapPrecisionBits;
      obj.maxDrawIndexedIndexValue = maxDrawIndexedIndexValue;
      obj.maxDrawIndirectCount = maxDrawIndirectCount;
      obj.maxSamplerLodBias = maxSamplerLodBias;
      obj.maxSamplerAnisotropy = maxSamplerAnisotropy;
      obj.maxViewports = maxViewports;
      std::copy(maxViewportDimensions, maxViewportDimensions + 2, obj.maxViewportDimensions);
      std::copy(viewportBoundsRange, viewportBoundsRange + 2, obj.viewportBoundsRange);
      obj.viewportSubPixelBits = viewportSubPixelBits;
      obj.minMemoryMapAlignment = minMemoryMapAlignment;
      obj.minTexelBufferOffsetAlignment = minTexelBufferOffsetAlignment;
      obj.minUniformBufferOffsetAlignment = minUniformBufferOffsetAlignment;
      obj.minStorageBufferOffsetAlignment = minStorageBufferOffsetAlignment;
      obj.minTexelOffset = minTexelOffset;
      obj.maxTexelOffset = maxTexelOffset;
      obj.minTexelGatherOffset = minTexelGatherOffset;
      obj.maxTexelGatherOffset = maxTexelGatherOffset;
      obj.minInterpolationOffset = minInterpolationOffset;
      obj.maxInterpolationOffset = maxInterpolationOffset;
      obj.subPixelInterpolationOffsetBits = subPixelInterpolationOffsetBits;
      obj.maxFramebufferWidth = maxFramebufferWidth;
      obj.maxFramebufferHeight = maxFramebufferHeight;
      obj.maxFramebufferLayers = maxFramebufferLayers;
      obj.framebufferColorSampleCounts = framebufferColorSampleCounts;
      obj.framebufferDepthSampleCounts = framebufferDepthSampleCounts;
      obj.framebufferStencilSampleCounts = framebufferStencilSampleCounts;
      obj.framebufferNoAttachmentsSampleCounts = framebufferNoAttachmentsSampleCounts;
      obj.maxColorAttachments = maxColorAttachments;
      obj.sampledImageColorSampleCounts = sampledImageColorSampleCounts;
      obj.sampledImageIntegerSampleCounts = sampledImageIntegerSampleCounts;
      obj.sampledImageDepthSampleCounts = sampledImageDepthSampleCounts;
      obj.sampledImageStencilSampleCounts = sampledImageStencilSampleCounts;
      obj.storageImageSampleCounts = storageImageSampleCounts;
      obj.maxSampleMaskWords = maxSampleMaskWords;
      obj.timestampComputeAndGraphics = timestampComputeAndGraphics;
      obj.timestampPeriod = timestampPeriod;
      obj.maxClipDistances = maxClipDistances;
      obj.maxCullDistances = maxCullDistances;
      obj.maxCombinedClipAndCullDistances = maxCombinedClipAndCullDistances;
      obj.discreteQueuePriorities = discreteQueuePriorities;
      std::copy(pointSizeRange, pointSizeRange + 2, obj.pointSizeRange);
      std::copy(lineWidthRange, lineWidthRange + 2, obj.lineWidthRange);
      obj.pointSizeGranularity = pointSizeGranularity;
      obj.lineWidthGranularity = lineWidthGranularity;
      obj.strictLines = strictLines;
      obj.standardSampleLocations = standardSampleLocations;
      obj.optimalBufferCopyOffsetAlignment = optimalBufferCopyOffsetAlignment;
      obj.optimalBufferCopyRowPitchAlignment = optimalBufferCopyRowPitchAlignment;
      obj.nonCoherentAtomSize = nonCoherentAtomSize;
      return obj;
   }

VkPhysicalDeviceSparseProperties PhysicalDeviceSparseProperties(
    VkBool32                                    residencyStandard2DBlockShape,
    VkBool32                                    residencyStandard2DMultisampleBlockShape,
    VkBool32                                    residencyStandard3DBlockShape,
    VkBool32                                    residencyAlignedMipSize,
    VkBool32                                    residencyNonResidentStrict)
   {
      VkPhysicalDeviceSparseProperties obj;
      obj.residencyStandard2DBlockShape = residencyStandard2DBlockShape;
      obj.residencyStandard2DMultisampleBlockShape = residencyStandard2DMultisampleBlockShape;
      obj.residencyStandard3DBlockShape = residencyStandard3DBlockShape;
      obj.residencyAlignedMipSize = residencyAlignedMipSize;
      obj.residencyNonResidentStrict = residencyNonResidentStrict;
      return obj;
   }

VkPhysicalDeviceProperties PhysicalDeviceProperties(
    uint32_t                                    apiVersion,
    uint32_t                                    driverVersion,
    uint32_t                                    vendorID,
    uint32_t                                    deviceID,
    VkPhysicalDeviceType                        deviceType,
    char                                        deviceName[VK_MAX_PHYSICAL_DEVICE_NAME_SIZE],
    uint8_t                                     pipelineCacheUUID[VK_UUID_SIZE],
    VkPhysicalDeviceLimits                      limits,
    VkPhysicalDeviceSparseProperties            sparseProperties)
   {
      VkPhysicalDeviceProperties obj;
      obj.apiVersion = apiVersion;
      obj.driverVersion = driverVersion;
      obj.vendorID = vendorID;
      obj.deviceID = deviceID;
      obj.deviceType = deviceType;
      std::copy(deviceName, deviceName + VK_MAX_PHYSICAL_DEVICE_NAME_SIZE, obj.deviceName);
      std::copy(pipelineCacheUUID, pipelineCacheUUID + VK_UUID_SIZE, obj.pipelineCacheUUID);
      obj.limits = limits;
      obj.sparseProperties = sparseProperties;
      return obj;
   }

VkPhysicalDeviceProperties2 PhysicalDeviceProperties2(
    VkPhysicalDeviceProperties                  properties)
   {
      VkPhysicalDeviceProperties2 obj;
      obj.sType = VK_STRUCTURE_TYPE_MAX_ENUM;
      obj.pNext = nullptr;
      obj.properties = properties;
      return obj;
   }

VkFormatProperties FormatProperties(
    VkFormatFeatureFlags                        linearTilingFeatures,
    VkFormatFeatureFlags                        optimalTilingFeatures,
    VkFormatFeatureFlags                        bufferFeatures)
   {
      VkFormatProperties obj;
      obj.linearTilingFeatures = linearTilingFeatures;
      obj.optimalTilingFeatures = optimalTilingFeatures;
      obj.bufferFeatures = bufferFeatures;
      return obj;
   }

VkFormatProperties2 FormatProperties2(
    VkFormatProperties                          formatProperties)
   {
      VkFormatProperties2 obj;
      obj.sType = VK_STRUCTURE_TYPE_MAX_ENUM;
      obj.pNext = nullptr;
      obj.formatProperties = formatProperties;
      return obj;
   }

VkImageFormatProperties ImageFormatProperties(
    VkExtent3D                                  maxExtent,
    uint32_t                                    maxMipLevels,
    uint32_t                                    maxArrayLayers,
    VkSampleCountFlags                          sampleCounts,
    VkDeviceSize                                maxResourceSize)
   {
      VkImageFormatProperties obj;
      obj.maxExtent = maxExtent;
      obj.maxMipLevels = maxMipLevels;
      obj.maxArrayLayers = maxArrayLayers;
      obj.sampleCounts = sampleCounts;
      obj.maxResourceSize = maxResourceSize;
      return obj;
   }

VkImageFormatProperties2 ImageFormatProperties2(
    VkImageFormatProperties                     imageFormatProperties)
   {
      VkImageFormatProperties2 obj;
      obj.sType = VK_STRUCTURE_TYPE_MAX_ENUM;
      obj.pNext = nullptr;
      obj.imageFormatProperties = imageFormatProperties;
      return obj;
   }

VkPhysicalDeviceImageFormatInfo2 PhysicalDeviceImageFormatInfo2(
    VkFormat                                    format,
    VkImageType                                 type,
    VkImageTiling                               tiling,
    VkImageUsageFlags                           usage,
    VkImageCreateFlags                          flags)
   {
      VkPhysicalDeviceImageFormatInfo2 obj;
      obj.sType = VK_STRUCTURE_TYPE_MAX_ENUM;
      obj.pNext = nullptr;
      obj.format = format;
      obj.type = type;
      obj.tiling = tiling;
      obj.usage = usage;
      obj.flags = flags;
      return obj;
   }

VkQueueFamilyProperties QueueFamilyProperties(
    VkQueueFlags                                queueFlags,
    uint32_t                                    queueCount,
    uint32_t                                    timestampValidBits,
    VkExtent3D                                  minImageTransferGranularity)
   {
      VkQueueFamilyProperties obj;
      obj.queueFlags = queueFlags;
      obj.queueCount = queueCount;
      obj.timestampValidBits = timestampValidBits;
      obj.minImageTransferGranularity = minImageTransferGranularity;
      return obj;
   }

VkQueueFamilyProperties2 QueueFamilyProperties2(
    VkQueueFamilyProperties                     queueFamilyProperties)
   {
      VkQueueFamilyProperties2 obj;
      obj.sType = VK_STRUCTURE_TYPE_MAX_ENUM;
      obj.pNext = nullptr;
      obj.queueFamilyProperties = queueFamilyProperties;
      return obj;
   }

VkMemoryType MemoryType(
    VkMemoryPropertyFlags                       propertyFlags,
    uint32_t                                    heapIndex)
   {
      VkMemoryType obj;
      obj.propertyFlags = propertyFlags;
      obj.heapIndex = heapIndex;
      return obj;
   }

VkMemoryHeap MemoryHeap(
    VkDeviceSize                                size,
    VkMemoryHeapFlags                           flags)
   {
      VkMemoryHeap obj;
      obj.size = size;
      obj.flags = flags;
      return obj;
   }

VkPhysicalDeviceMemoryProperties PhysicalDeviceMemoryProperties(
    uint32_t                                    memoryTypeCount,
    VkMemoryType                                memoryTypes[VK_MAX_MEMORY_TYPES],
    uint32_t                                    memoryHeapCount,
    VkMemoryHeap                                memoryHeaps[VK_MAX_MEMORY_HEAPS])
   {
      VkPhysicalDeviceMemoryProperties obj;
      obj.memoryTypeCount = memoryTypeCount;
      std::copy(memoryTypes, memoryTypes + VK_MAX_MEMORY_TYPES, obj.memoryTypes);
      obj.memoryHeapCount = memoryHeapCount;
      std::copy(memoryHeaps, memoryHeaps + VK_MAX_MEMORY_HEAPS, obj.memoryHeaps);
      return obj;
   }

VkPhysicalDeviceMemoryProperties2 PhysicalDeviceMemoryProperties2(
    VkPhysicalDeviceMemoryProperties            memoryProperties)
   {
      VkPhysicalDeviceMemoryProperties2 obj;
      obj.sType = VK_STRUCTURE_TYPE_MAX_ENUM;
      obj.pNext = nullptr;
      obj.memoryProperties = memoryProperties;
      return obj;
   }

VkSparseImageFormatProperties2 SparseImageFormatProperties2(
    VkSparseImageFormatProperties               properties)
   {
      VkSparseImageFormatProperties2 obj;
      obj.sType = VK_STRUCTURE_TYPE_MAX_ENUM;
      obj.pNext = nullptr;
      obj.properties = properties;
      return obj;
   }

VkPhysicalDeviceSparseImageFormatInfo2 PhysicalDeviceSparseImageFormatInfo2(
    VkFormat                                    format,
    VkImageType                                 type,
    VkSampleCountFlagBits                       samples,
    VkImageUsageFlags                           usage,
    VkImageTiling                               tiling)
   {
      VkPhysicalDeviceSparseImageFormatInfo2 obj;
      obj.sType = VK_STRUCTURE_TYPE_MAX_ENUM;
      obj.pNext = nullptr;
      obj.format = format;
      obj.type = type;
      obj.samples = samples;
      obj.usage = usage;
      obj.tiling = tiling;
      return obj;
   }

VkPhysicalDeviceFeatures2 getPhysicalDeviceFeatures2(
        VkPhysicalDevice physicalDevice)
   {
      if ( nullptr == pfvkGetPhysicalDeviceFeatures2 )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      VkPhysicalDeviceFeatures2 pFeatures; 
      pfvkGetPhysicalDeviceFeatures2(
          physicalDevice,
          &pFeatures  );
      return pFeatures; 
   }

VkPhysicalDeviceProperties2 getPhysicalDeviceProperties2(
        VkPhysicalDevice physicalDevice)
   {
      if ( nullptr == pfvkGetPhysicalDeviceProperties2 )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      VkPhysicalDeviceProperties2 pProperties; 
      pfvkGetPhysicalDeviceProperties2(
          physicalDevice,
          &pProperties  );
      return pProperties; 
   }

VkFormatProperties2 getPhysicalDeviceFormatProperties2(
        VkPhysicalDevice physicalDevice,
        VkFormat format)
   {
      if ( nullptr == pfvkGetPhysicalDeviceFormatProperties2 )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      VkFormatProperties2 pFormatProperties; 
      pfvkGetPhysicalDeviceFormatProperties2(
          physicalDevice,
          format,
          &pFormatProperties  );
      return pFormatProperties; 
   }

VkImageFormatProperties2 getPhysicalDeviceImageFormatProperties2(
        VkPhysicalDevice physicalDevice,
        const VkPhysicalDeviceImageFormatInfo2 & pImageFormatInfo)
   {
      if ( nullptr == pfvkGetPhysicalDeviceImageFormatProperties2 )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      VkImageFormatProperties2 pImageFormatProperties; 
      V( pfvkGetPhysicalDeviceImageFormatProperties2(
          physicalDevice,
          &pImageFormatInfo,
          &pImageFormatProperties  ));
      return pImageFormatProperties; 
   }

std::vector< VkQueueFamilyProperties2 > getPhysicalDeviceQueueFamilyProperties2(
        VkPhysicalDevice physicalDevice)
   {
      if ( nullptr == pfvkGetPhysicalDeviceQueueFamilyProperties2 )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      std::vector<VkQueueFamilyProperties2> vecpQueueFamilyProperties; 
      uint32_t pQueueFamilyPropertiesCount; 
      pfvkGetPhysicalDeviceQueueFamilyProperties2(
          physicalDevice,
          &pQueueFamilyPropertiesCount,
          nullptr  );

      vecpQueueFamilyProperties.resize(pQueueFamilyPropertiesCount); 

      pfvkGetPhysicalDeviceQueueFamilyProperties2(
          physicalDevice,
          &pQueueFamilyPropertiesCount,
          &vecpQueueFamilyProperties[0]  );
      return vecpQueueFamilyProperties; 
   }

VkPhysicalDeviceMemoryProperties2 getPhysicalDeviceMemoryProperties2(
        VkPhysicalDevice physicalDevice)
   {
      if ( nullptr == pfvkGetPhysicalDeviceMemoryProperties2 )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      VkPhysicalDeviceMemoryProperties2 pMemoryProperties; 
      pfvkGetPhysicalDeviceMemoryProperties2(
          physicalDevice,
          &pMemoryProperties  );
      return pMemoryProperties; 
   }

std::vector< VkSparseImageFormatProperties2 > getPhysicalDeviceSparseImageFormatProperties2(
        VkPhysicalDevice physicalDevice,
        const VkPhysicalDeviceSparseImageFormatInfo2 & pFormatInfo)
   {
      if ( nullptr == pfvkGetPhysicalDeviceSparseImageFormatProperties2 )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      std::vector<VkSparseImageFormatProperties2> vecpProperties; 
      uint32_t pPropertiesCount; 
      pfvkGetPhysicalDeviceSparseImageFormatProperties2(
          physicalDevice,
          &pFormatInfo,
          &pPropertiesCount,
          nullptr  );

      vecpProperties.resize(pPropertiesCount); 

      pfvkGetPhysicalDeviceSparseImageFormatProperties2(
          physicalDevice,
          &pFormatInfo,
          &pPropertiesCount,
          &vecpProperties[0]  );
      return vecpProperties; 
   }

void  trimCommandPool(
        VkDevice device,
        VkCommandPool commandPool,
        VkCommandPoolTrimFlags flags)
   {
      if ( nullptr == pfvkTrimCommandPool )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      pfvkTrimCommandPool(
          device,
          commandPool,
          flags  );
   }

VkPhysicalDevicePointClippingProperties PhysicalDevicePointClippingProperties(
    VkPointClippingBehavior                     pointClippingBehavior)
   {
      VkPhysicalDevicePointClippingProperties obj;
      obj.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES;
      obj.pNext = nullptr;
      obj.pointClippingBehavior = pointClippingBehavior;
      return obj;
   }

VkInputAttachmentAspectReference InputAttachmentAspectReference(
    uint32_t                                    subpass,
    uint32_t                                    inputAttachmentIndex,
    VkImageAspectFlags                          aspectMask)
   {
      VkInputAttachmentAspectReference obj;
      obj.subpass = subpass;
      obj.inputAttachmentIndex = inputAttachmentIndex;
      obj.aspectMask = aspectMask;
      return obj;
   }

struct VkRenderPassInputAttachmentAspectCreateInfoRAII {
   VkRenderPassInputAttachmentAspectCreateInfo nonRaiiObj;
    std::vector<VkInputAttachmentAspectReference>vecAspectReferences;
};

std::shared_ptr<VkRenderPassInputAttachmentAspectCreateInfoRAII> RenderPassInputAttachmentAspectCreateInfo(
    const std::vector<VkInputAttachmentAspectReference> &vecAspectReferences)
   {
      std::shared_ptr<VkRenderPassInputAttachmentAspectCreateInfoRAII> raii_obj(new VkRenderPassInputAttachmentAspectCreateInfoRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.aspectReferenceCount = static_cast<uint32_t>(vecAspectReferences.size());
      raii_obj->vecAspectReferences = vecAspectReferences;
      if ( raii_obj->vecAspectReferences.size() > 0)
      {
          raii_obj->nonRaiiObj.pAspectReferences = &raii_obj->vecAspectReferences[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pAspectReferences = nullptr;
      }
      return raii_obj;
   }

VkImageViewUsageCreateInfo ImageViewUsageCreateInfo(
    VkImageUsageFlags                           usage)
   {
      VkImageViewUsageCreateInfo obj;
      obj.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO;
      obj.pNext = nullptr;
      obj.usage = usage;
      return obj;
   }

VkPipelineTessellationDomainOriginStateCreateInfo PipelineTessellationDomainOriginStateCreateInfo(
    VkTessellationDomainOrigin                  domainOrigin)
   {
      VkPipelineTessellationDomainOriginStateCreateInfo obj;
      obj.sType = VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO;
      obj.pNext = nullptr;
      obj.domainOrigin = domainOrigin;
      return obj;
   }

struct VkRenderPassMultiviewCreateInfoRAII {
   VkRenderPassMultiviewCreateInfo nonRaiiObj;
    std::vector<uint32_t>                       vecViewMasks;
    std::vector<int32_t>                        vecViewOffsets;
    std::vector<uint32_t>                       vecCorrelationMasks;
};

std::shared_ptr<VkRenderPassMultiviewCreateInfoRAII> RenderPassMultiviewCreateInfo(
    unsigned int* pViewMasks_in_array1, int pViewMasks_dim1,
    int* pViewOffsets_in_array1, int pViewOffsets_dim1,
    unsigned int* pCorrelationMasks_in_array1, int pCorrelationMasks_dim1)
   {
      std::shared_ptr<VkRenderPassMultiviewCreateInfoRAII> raii_obj(new VkRenderPassMultiviewCreateInfoRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.subpassCount = static_cast<uint32_t>(pViewMasks_dim1);
      raii_obj->vecViewMasks.assign(pViewMasks_in_array1, pViewMasks_in_array1 + pViewMasks_dim1);
      if ( raii_obj->vecViewMasks.size() > 0)
      {
          raii_obj->nonRaiiObj.pViewMasks = &raii_obj->vecViewMasks[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pViewMasks = nullptr;
      }
      raii_obj->nonRaiiObj.dependencyCount = static_cast<uint32_t>(pViewOffsets_dim1);
      raii_obj->vecViewOffsets.assign(pViewOffsets_in_array1, pViewOffsets_in_array1 + pViewOffsets_dim1);
      if ( raii_obj->vecViewOffsets.size() > 0)
      {
          raii_obj->nonRaiiObj.pViewOffsets = &raii_obj->vecViewOffsets[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pViewOffsets = nullptr;
      }
      raii_obj->nonRaiiObj.correlationMaskCount = static_cast<uint32_t>(pCorrelationMasks_dim1);
      raii_obj->vecCorrelationMasks.assign(pCorrelationMasks_in_array1, pCorrelationMasks_in_array1 + pCorrelationMasks_dim1);
      if ( raii_obj->vecCorrelationMasks.size() > 0)
      {
          raii_obj->nonRaiiObj.pCorrelationMasks = &raii_obj->vecCorrelationMasks[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pCorrelationMasks = nullptr;
      }
      return raii_obj;
   }

VkPhysicalDeviceMultiviewFeatures PhysicalDeviceMultiviewFeatures(
    VkBool32                                    multiview,
    VkBool32                                    multiviewGeometryShader,
    VkBool32                                    multiviewTessellationShader)
   {
      VkPhysicalDeviceMultiviewFeatures obj;
      obj.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES;
      obj.pNext = nullptr;
      obj.multiview = multiview;
      obj.multiviewGeometryShader = multiviewGeometryShader;
      obj.multiviewTessellationShader = multiviewTessellationShader;
      return obj;
   }

VkPhysicalDeviceMultiviewProperties PhysicalDeviceMultiviewProperties(
    uint32_t                                    maxMultiviewViewCount,
    uint32_t                                    maxMultiviewInstanceIndex)
   {
      VkPhysicalDeviceMultiviewProperties obj;
      obj.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES;
      obj.pNext = nullptr;
      obj.maxMultiviewViewCount = maxMultiviewViewCount;
      obj.maxMultiviewInstanceIndex = maxMultiviewInstanceIndex;
      return obj;
   }

VkPhysicalDeviceVariablePointersFeatures PhysicalDeviceVariablePointersFeatures(
    VkBool32                                    variablePointersStorageBuffer,
    VkBool32                                    variablePointers)
   {
      VkPhysicalDeviceVariablePointersFeatures obj;
      obj.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES;
      obj.pNext = nullptr;
      obj.variablePointersStorageBuffer = variablePointersStorageBuffer;
      obj.variablePointers = variablePointers;
      return obj;
   }

VkPhysicalDeviceVariablePointerFeatures PhysicalDeviceVariablePointerFeatures(void)
   {
      VkPhysicalDeviceVariablePointerFeatures obj;
      return obj;
   }

VkPhysicalDeviceProtectedMemoryFeatures PhysicalDeviceProtectedMemoryFeatures(
    VkBool32                                    protectedMemory)
   {
      VkPhysicalDeviceProtectedMemoryFeatures obj;
      obj.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES;
      obj.pNext = nullptr;
      obj.protectedMemory = protectedMemory;
      return obj;
   }

VkPhysicalDeviceProtectedMemoryProperties PhysicalDeviceProtectedMemoryProperties(
    VkBool32                                    protectedNoFault)
   {
      VkPhysicalDeviceProtectedMemoryProperties obj;
      obj.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES;
      obj.pNext = nullptr;
      obj.protectedNoFault = protectedNoFault;
      return obj;
   }

VkDeviceQueueInfo2 DeviceQueueInfo2(
    VkDeviceQueueCreateFlags                    flags,
    uint32_t                                    queueFamilyIndex,
    uint32_t                                    queueIndex)
   {
      VkDeviceQueueInfo2 obj;
      obj.sType = VK_STRUCTURE_TYPE_MAX_ENUM;
      obj.pNext = nullptr;
      obj.flags = flags;
      obj.queueFamilyIndex = queueFamilyIndex;
      obj.queueIndex = queueIndex;
      return obj;
   }

VkProtectedSubmitInfo ProtectedSubmitInfo(
    VkBool32                                    protectedSubmit)
   {
      VkProtectedSubmitInfo obj;
      obj.sType = VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO;
      obj.pNext = nullptr;
      obj.protectedSubmit = protectedSubmit;
      return obj;
   }

VkQueue getDeviceQueue2(
        VkDevice device,
        const VkDeviceQueueInfo2 & pQueueInfo)
   {
      if ( nullptr == pfvkGetDeviceQueue2 )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      VkQueue hQueue; 
      pfvkGetDeviceQueue2(
          device,
          &pQueueInfo,
          &hQueue  );
      return hQueue; 
   }

VkComponentMapping ComponentMapping(
    VkComponentSwizzle                          r,
    VkComponentSwizzle                          g,
    VkComponentSwizzle                          b,
    VkComponentSwizzle                          a)
   {
      VkComponentMapping obj;
      obj.r = r;
      obj.g = g;
      obj.b = b;
      obj.a = a;
      return obj;
   }

VkSamplerYcbcrConversionCreateInfo SamplerYcbcrConversionCreateInfo(
    VkFormat                                    format,
    VkSamplerYcbcrModelConversion               ycbcrModel,
    VkSamplerYcbcrRange                         ycbcrRange,
    VkComponentMapping                          components,
    VkChromaLocation                            xChromaOffset,
    VkChromaLocation                            yChromaOffset,
    VkFilter                                    chromaFilter,
    VkBool32                                    forceExplicitReconstruction)
   {
      VkSamplerYcbcrConversionCreateInfo obj;
      obj.sType = VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO;
      obj.pNext = nullptr;
      obj.format = format;
      obj.ycbcrModel = ycbcrModel;
      obj.ycbcrRange = ycbcrRange;
      obj.components = components;
      obj.xChromaOffset = xChromaOffset;
      obj.yChromaOffset = yChromaOffset;
      obj.chromaFilter = chromaFilter;
      obj.forceExplicitReconstruction = forceExplicitReconstruction;
      return obj;
   }

VkSamplerYcbcrConversionInfo SamplerYcbcrConversionInfo(
    VkSamplerYcbcrConversion                    conversion)
   {
      VkSamplerYcbcrConversionInfo obj;
      obj.sType = VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO;
      obj.pNext = nullptr;
      obj.conversion = conversion;
      return obj;
   }

VkBindImagePlaneMemoryInfo BindImagePlaneMemoryInfo(
    VkImageAspectFlagBits                       planeAspect)
   {
      VkBindImagePlaneMemoryInfo obj;
      obj.sType = VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO;
      obj.pNext = nullptr;
      obj.planeAspect = planeAspect;
      return obj;
   }

VkImagePlaneMemoryRequirementsInfo ImagePlaneMemoryRequirementsInfo(
    VkImageAspectFlagBits                       planeAspect)
   {
      VkImagePlaneMemoryRequirementsInfo obj;
      obj.sType = VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO;
      obj.pNext = nullptr;
      obj.planeAspect = planeAspect;
      return obj;
   }

VkPhysicalDeviceSamplerYcbcrConversionFeatures PhysicalDeviceSamplerYcbcrConversionFeatures(
    VkBool32                                    samplerYcbcrConversion)
   {
      VkPhysicalDeviceSamplerYcbcrConversionFeatures obj;
      obj.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES;
      obj.pNext = nullptr;
      obj.samplerYcbcrConversion = samplerYcbcrConversion;
      return obj;
   }

VkSamplerYcbcrConversionImageFormatProperties SamplerYcbcrConversionImageFormatProperties(
    uint32_t                                    combinedImageSamplerDescriptorCount)
   {
      VkSamplerYcbcrConversionImageFormatProperties obj;
      obj.sType = VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES;
      obj.pNext = nullptr;
      obj.combinedImageSamplerDescriptorCount = combinedImageSamplerDescriptorCount;
      return obj;
   }

VkAllocationCallbacks AllocationCallbacks(
    PFN_vkAllocationFunction                    pfnAllocation,
    PFN_vkReallocationFunction                  pfnReallocation,
    PFN_vkFreeFunction                          pfnFree,
    PFN_vkInternalAllocationNotification        pfnInternalAllocation,
    PFN_vkInternalFreeNotification              pfnInternalFree)
   {
      VkAllocationCallbacks obj;
      obj.pUserData = nullptr;
      obj.pfnAllocation = pfnAllocation;
      obj.pfnReallocation = pfnReallocation;
      obj.pfnFree = pfnFree;
      obj.pfnInternalAllocation = pfnInternalAllocation;
      obj.pfnInternalFree = pfnInternalFree;
      return obj;
   }

std::shared_ptr<VkSamplerYcbcrConversion_T> createSamplerYcbcrConversion(
        VkDevice device,
        const VkSamplerYcbcrConversionCreateInfo & pCreateInfo)
   {
      if ( nullptr == pfvkCreateSamplerYcbcrConversion )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      VkSamplerYcbcrConversion hYcbcrConversion; 
      V( pfvkCreateSamplerYcbcrConversion(
          device,
          &pCreateInfo,
          nullptr,
          &hYcbcrConversion  ));
      return std::shared_ptr<VkSamplerYcbcrConversion_T>(hYcbcrConversion, 
              [=](VkSamplerYcbcrConversion to_free) {pfvkDestroySamplerYcbcrConversion(device, to_free, nullptr);});
   }

VkDescriptorUpdateTemplateEntry DescriptorUpdateTemplateEntry(
    uint32_t                                    dstBinding,
    uint32_t                                    dstArrayElement,
    uint32_t                                    descriptorCount,
    VkDescriptorType                            descriptorType,
    size_t                                      offset,
    size_t                                      stride)
   {
      VkDescriptorUpdateTemplateEntry obj;
      obj.dstBinding = dstBinding;
      obj.dstArrayElement = dstArrayElement;
      obj.descriptorCount = descriptorCount;
      obj.descriptorType = descriptorType;
      obj.offset = offset;
      obj.stride = stride;
      return obj;
   }

struct VkDescriptorUpdateTemplateCreateInfoRAII {
   VkDescriptorUpdateTemplateCreateInfo nonRaiiObj;
    std::vector<VkDescriptorUpdateTemplateEntry>vecDescriptorUpdateEntries;
};

std::shared_ptr<VkDescriptorUpdateTemplateCreateInfoRAII> DescriptorUpdateTemplateCreateInfo(
    VkDescriptorUpdateTemplateCreateFlags       flags,
    const std::vector<VkDescriptorUpdateTemplateEntry> &vecDescriptorUpdateEntries,
    VkDescriptorUpdateTemplateType              templateType,
    VkDescriptorSetLayout                       descriptorSetLayout,
    VkPipelineBindPoint                         pipelineBindPoint,
    VkPipelineLayout                            pipelineLayout,
    uint32_t                                    set)
   {
      std::shared_ptr<VkDescriptorUpdateTemplateCreateInfoRAII> raii_obj(new VkDescriptorUpdateTemplateCreateInfoRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.flags = flags;
      raii_obj->nonRaiiObj.descriptorUpdateEntryCount = static_cast<uint32_t>(vecDescriptorUpdateEntries.size());
      raii_obj->vecDescriptorUpdateEntries = vecDescriptorUpdateEntries;
      if ( raii_obj->vecDescriptorUpdateEntries.size() > 0)
      {
          raii_obj->nonRaiiObj.pDescriptorUpdateEntries = &raii_obj->vecDescriptorUpdateEntries[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pDescriptorUpdateEntries = nullptr;
      }
      raii_obj->nonRaiiObj.templateType = templateType;
      raii_obj->nonRaiiObj.descriptorSetLayout = descriptorSetLayout;
      raii_obj->nonRaiiObj.pipelineBindPoint = pipelineBindPoint;
      raii_obj->nonRaiiObj.pipelineLayout = pipelineLayout;
      raii_obj->nonRaiiObj.set = set;
      return raii_obj;
   }

std::shared_ptr<VkDescriptorUpdateTemplate_T> createDescriptorUpdateTemplate(
        VkDevice device,
        const VkDescriptorUpdateTemplateCreateInfo & pCreateInfo)
   {
      if ( nullptr == pfvkCreateDescriptorUpdateTemplate )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      VkDescriptorUpdateTemplate hDescriptorUpdateTemplate; 
      V( pfvkCreateDescriptorUpdateTemplate(
          device,
          &pCreateInfo,
          nullptr,
          &hDescriptorUpdateTemplate  ));
      return std::shared_ptr<VkDescriptorUpdateTemplate_T>(hDescriptorUpdateTemplate, 
              [=](VkDescriptorUpdateTemplate to_free) {pfvkDestroyDescriptorUpdateTemplate(device, to_free, nullptr);});
   }

VkExternalMemoryProperties ExternalMemoryProperties(
    VkExternalMemoryFeatureFlags                externalMemoryFeatures,
    VkExternalMemoryHandleTypeFlags             exportFromImportedHandleTypes,
    VkExternalMemoryHandleTypeFlags             compatibleHandleTypes)
   {
      VkExternalMemoryProperties obj;
      obj.externalMemoryFeatures = externalMemoryFeatures;
      obj.exportFromImportedHandleTypes = exportFromImportedHandleTypes;
      obj.compatibleHandleTypes = compatibleHandleTypes;
      return obj;
   }

VkPhysicalDeviceExternalImageFormatInfo PhysicalDeviceExternalImageFormatInfo(
    VkExternalMemoryHandleTypeFlagBits          handleType)
   {
      VkPhysicalDeviceExternalImageFormatInfo obj;
      obj.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO;
      obj.pNext = nullptr;
      obj.handleType = handleType;
      return obj;
   }

VkExternalImageFormatProperties ExternalImageFormatProperties(
    VkExternalMemoryProperties                  externalMemoryProperties)
   {
      VkExternalImageFormatProperties obj;
      obj.sType = VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES;
      obj.pNext = nullptr;
      obj.externalMemoryProperties = externalMemoryProperties;
      return obj;
   }

VkPhysicalDeviceExternalBufferInfo PhysicalDeviceExternalBufferInfo(
    VkBufferCreateFlags                         flags,
    VkBufferUsageFlags                          usage,
    VkExternalMemoryHandleTypeFlagBits          handleType)
   {
      VkPhysicalDeviceExternalBufferInfo obj;
      obj.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO;
      obj.pNext = nullptr;
      obj.flags = flags;
      obj.usage = usage;
      obj.handleType = handleType;
      return obj;
   }

VkExternalBufferProperties ExternalBufferProperties(
    VkExternalMemoryProperties                  externalMemoryProperties)
   {
      VkExternalBufferProperties obj;
      obj.sType = VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES;
      obj.pNext = nullptr;
      obj.externalMemoryProperties = externalMemoryProperties;
      return obj;
   }

VkPhysicalDeviceIDProperties PhysicalDeviceIDProperties(
    uint8_t                                     deviceUUID[VK_UUID_SIZE],
    uint8_t                                     driverUUID[VK_UUID_SIZE],
    uint8_t                                     deviceLUID[VK_LUID_SIZE],
    uint32_t                                    deviceNodeMask,
    VkBool32                                    deviceLUIDValid)
   {
      VkPhysicalDeviceIDProperties obj;
      obj.sType = VK_STRUCTURE_TYPE_MAX_ENUM;
      obj.pNext = nullptr;
      std::copy(deviceUUID, deviceUUID + VK_UUID_SIZE, obj.deviceUUID);
      std::copy(driverUUID, driverUUID + VK_UUID_SIZE, obj.driverUUID);
      std::copy(deviceLUID, deviceLUID + VK_LUID_SIZE, obj.deviceLUID);
      obj.deviceNodeMask = deviceNodeMask;
      obj.deviceLUIDValid = deviceLUIDValid;
      return obj;
   }

VkExternalBufferProperties getPhysicalDeviceExternalBufferProperties(
        VkPhysicalDevice physicalDevice,
        const VkPhysicalDeviceExternalBufferInfo & pExternalBufferInfo)
   {
      if ( nullptr == pfvkGetPhysicalDeviceExternalBufferProperties )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      VkExternalBufferProperties pExternalBufferProperties; 
      pfvkGetPhysicalDeviceExternalBufferProperties(
          physicalDevice,
          &pExternalBufferInfo,
          &pExternalBufferProperties  );
      return pExternalBufferProperties; 
   }

VkExternalMemoryImageCreateInfo ExternalMemoryImageCreateInfo(
    VkExternalMemoryHandleTypeFlags             handleTypes)
   {
      VkExternalMemoryImageCreateInfo obj;
      obj.sType = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO;
      obj.pNext = nullptr;
      obj.handleTypes = handleTypes;
      return obj;
   }

VkExternalMemoryBufferCreateInfo ExternalMemoryBufferCreateInfo(
    VkExternalMemoryHandleTypeFlags             handleTypes)
   {
      VkExternalMemoryBufferCreateInfo obj;
      obj.sType = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO;
      obj.pNext = nullptr;
      obj.handleTypes = handleTypes;
      return obj;
   }

VkExportMemoryAllocateInfo ExportMemoryAllocateInfo(
    VkExternalMemoryHandleTypeFlags             handleTypes)
   {
      VkExportMemoryAllocateInfo obj;
      obj.sType = VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO;
      obj.pNext = nullptr;
      obj.handleTypes = handleTypes;
      return obj;
   }

VkPhysicalDeviceExternalFenceInfo PhysicalDeviceExternalFenceInfo(
    VkExternalFenceHandleTypeFlagBits           handleType)
   {
      VkPhysicalDeviceExternalFenceInfo obj;
      obj.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO;
      obj.pNext = nullptr;
      obj.handleType = handleType;
      return obj;
   }

VkExternalFenceProperties ExternalFenceProperties(
    VkExternalFenceHandleTypeFlags              exportFromImportedHandleTypes,
    VkExternalFenceHandleTypeFlags              compatibleHandleTypes,
    VkExternalFenceFeatureFlags                 externalFenceFeatures)
   {
      VkExternalFenceProperties obj;
      obj.sType = VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES;
      obj.pNext = nullptr;
      obj.exportFromImportedHandleTypes = exportFromImportedHandleTypes;
      obj.compatibleHandleTypes = compatibleHandleTypes;
      obj.externalFenceFeatures = externalFenceFeatures;
      return obj;
   }

VkExternalFenceProperties getPhysicalDeviceExternalFenceProperties(
        VkPhysicalDevice physicalDevice,
        const VkPhysicalDeviceExternalFenceInfo & pExternalFenceInfo)
   {
      if ( nullptr == pfvkGetPhysicalDeviceExternalFenceProperties )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      VkExternalFenceProperties pExternalFenceProperties; 
      pfvkGetPhysicalDeviceExternalFenceProperties(
          physicalDevice,
          &pExternalFenceInfo,
          &pExternalFenceProperties  );
      return pExternalFenceProperties; 
   }

VkExportFenceCreateInfo ExportFenceCreateInfo(
    VkExternalFenceHandleTypeFlags              handleTypes)
   {
      VkExportFenceCreateInfo obj;
      obj.sType = VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO;
      obj.pNext = nullptr;
      obj.handleTypes = handleTypes;
      return obj;
   }

VkExportSemaphoreCreateInfo ExportSemaphoreCreateInfo(
    VkExternalSemaphoreHandleTypeFlags          handleTypes)
   {
      VkExportSemaphoreCreateInfo obj;
      obj.sType = VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO;
      obj.pNext = nullptr;
      obj.handleTypes = handleTypes;
      return obj;
   }

VkPhysicalDeviceExternalSemaphoreInfo PhysicalDeviceExternalSemaphoreInfo(
    VkExternalSemaphoreHandleTypeFlagBits       handleType)
   {
      VkPhysicalDeviceExternalSemaphoreInfo obj;
      obj.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO;
      obj.pNext = nullptr;
      obj.handleType = handleType;
      return obj;
   }

VkExternalSemaphoreProperties ExternalSemaphoreProperties(
    VkExternalSemaphoreHandleTypeFlags          exportFromImportedHandleTypes,
    VkExternalSemaphoreHandleTypeFlags          compatibleHandleTypes,
    VkExternalSemaphoreFeatureFlags             externalSemaphoreFeatures)
   {
      VkExternalSemaphoreProperties obj;
      obj.sType = VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES;
      obj.pNext = nullptr;
      obj.exportFromImportedHandleTypes = exportFromImportedHandleTypes;
      obj.compatibleHandleTypes = compatibleHandleTypes;
      obj.externalSemaphoreFeatures = externalSemaphoreFeatures;
      return obj;
   }

VkExternalSemaphoreProperties getPhysicalDeviceExternalSemaphoreProperties(
        VkPhysicalDevice physicalDevice,
        const VkPhysicalDeviceExternalSemaphoreInfo & pExternalSemaphoreInfo)
   {
      if ( nullptr == pfvkGetPhysicalDeviceExternalSemaphoreProperties )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      VkExternalSemaphoreProperties pExternalSemaphoreProperties; 
      pfvkGetPhysicalDeviceExternalSemaphoreProperties(
          physicalDevice,
          &pExternalSemaphoreInfo,
          &pExternalSemaphoreProperties  );
      return pExternalSemaphoreProperties; 
   }

VkPhysicalDeviceMaintenance3Properties PhysicalDeviceMaintenance3Properties(
    uint32_t                                    maxPerSetDescriptors,
    VkDeviceSize                                maxMemoryAllocationSize)
   {
      VkPhysicalDeviceMaintenance3Properties obj;
      obj.sType = VK_STRUCTURE_TYPE_MAX_ENUM;
      obj.pNext = nullptr;
      obj.maxPerSetDescriptors = maxPerSetDescriptors;
      obj.maxMemoryAllocationSize = maxMemoryAllocationSize;
      return obj;
   }

VkDescriptorSetLayoutSupport DescriptorSetLayoutSupport(
    VkBool32                                    supported)
   {
      VkDescriptorSetLayoutSupport obj;
      obj.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT;
      obj.pNext = nullptr;
      obj.supported = supported;
      return obj;
   }

struct VkDescriptorSetLayoutBindingRAII {
   VkDescriptorSetLayoutBinding nonRaiiObj;
    std::vector<VkSampler>                      vecImmutableSamplers;
};

std::shared_ptr<VkDescriptorSetLayoutBindingRAII> DescriptorSetLayoutBinding(
    uint32_t                                    binding,
    VkDescriptorType                            descriptorType,
    uint32_t                                    descriptorCount,
    VkShaderStageFlags                          stageFlags,
    const std::vector<VkSampler> &              vecImmutableSamplers)
   {
      std::shared_ptr<VkDescriptorSetLayoutBindingRAII> raii_obj(new VkDescriptorSetLayoutBindingRAII);
      raii_obj->nonRaiiObj.binding = binding;
      raii_obj->nonRaiiObj.descriptorType = descriptorType;
      raii_obj->nonRaiiObj.descriptorCount = descriptorCount;
      raii_obj->nonRaiiObj.stageFlags = stageFlags;
      raii_obj->vecImmutableSamplers = vecImmutableSamplers;
      if ( raii_obj->vecImmutableSamplers.size() > 0)
      {
          raii_obj->nonRaiiObj.pImmutableSamplers = &raii_obj->vecImmutableSamplers[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pImmutableSamplers = nullptr;
      }
      return raii_obj;
   }

struct VkDescriptorSetLayoutCreateInfoRAII {
   VkDescriptorSetLayoutCreateInfo nonRaiiObj;
    std::vector<VkDescriptorSetLayoutBinding>   vecBindings;
};

std::shared_ptr<VkDescriptorSetLayoutCreateInfoRAII> DescriptorSetLayoutCreateInfo(
    VkDescriptorSetLayoutCreateFlags            flags,
    const std::vector<VkDescriptorSetLayoutBinding> &vecBindings)
   {
      std::shared_ptr<VkDescriptorSetLayoutCreateInfoRAII> raii_obj(new VkDescriptorSetLayoutCreateInfoRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.flags = flags;
      raii_obj->nonRaiiObj.bindingCount = static_cast<uint32_t>(vecBindings.size());
      raii_obj->vecBindings = vecBindings;
      if ( raii_obj->vecBindings.size() > 0)
      {
          raii_obj->nonRaiiObj.pBindings = &raii_obj->vecBindings[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pBindings = nullptr;
      }
      return raii_obj;
   }

VkDescriptorSetLayoutSupport getDescriptorSetLayoutSupport(
        VkDevice device,
        const VkDescriptorSetLayoutCreateInfo & pCreateInfo)
   {
      if ( nullptr == pfvkGetDescriptorSetLayoutSupport )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      VkDescriptorSetLayoutSupport pSupport; 
      pfvkGetDescriptorSetLayoutSupport(
          device,
          &pCreateInfo,
          &pSupport  );
      return pSupport; 
   }

VkPhysicalDeviceShaderDrawParametersFeatures PhysicalDeviceShaderDrawParametersFeatures(
    VkBool32                                    shaderDrawParameters)
   {
      VkPhysicalDeviceShaderDrawParametersFeatures obj;
      obj.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES;
      obj.pNext = nullptr;
      obj.shaderDrawParameters = shaderDrawParameters;
      return obj;
   }

VkPhysicalDeviceShaderDrawParameterFeatures PhysicalDeviceShaderDrawParameterFeatures(void)
   {
      VkPhysicalDeviceShaderDrawParameterFeatures obj;
      return obj;
   }
%}

%template (VkSubpassDescriptionPtr) std::shared_ptr<VkSubpassDescriptionRAII>;

#ifdef VK_VERSION_1_1

%template (VkRenderPassInputAttachmentAspectCreateInfoPtr) std::shared_ptr<VkRenderPassInputAttachmentAspectCreateInfoRAII>;

#endif

%template (VkDebugMarkerObjectTagInfoEXTPtr) std::shared_ptr<VkDebugMarkerObjectTagInfoEXTRAII>;

%template (VkImageDrmFormatModifierListCreateInfoEXTPtr) std::shared_ptr<VkImageDrmFormatModifierListCreateInfoEXTRAII>;

%template (VkSubpassDescription2KHRPtr) std::shared_ptr<VkSubpassDescription2KHRRAII>;

%template (VkPipelineCreationFeedbackCreateInfoEXTPtr) std::shared_ptr<VkPipelineCreationFeedbackCreateInfoEXTRAII>;

%template (VkWriteDescriptorSetInlineUniformBlockEXTPtr) std::shared_ptr<VkWriteDescriptorSetInlineUniformBlockEXTRAII>;

%template (VkApplicationInfoPtr) std::shared_ptr<VkApplicationInfoRAII>;

%template (VkExportMemoryWin32HandleInfoNVPtr) std::shared_ptr<VkExportMemoryWin32HandleInfoNVRAII>;

%template (VkRenderPassCreateInfo2KHRPtr) std::shared_ptr<VkRenderPassCreateInfo2KHRRAII>;

%template (VkPresentRegionKHRPtr) std::shared_ptr<VkPresentRegionKHRRAII>;

%template (VkSparseImageOpaqueMemoryBindInfoPtr) std::shared_ptr<VkSparseImageOpaqueMemoryBindInfoRAII>;

%template (VkBindAccelerationStructureMemoryInfoNVPtr) std::shared_ptr<VkBindAccelerationStructureMemoryInfoNVRAII>;

%template (VkPipelineCacheCreateInfoPtr) std::shared_ptr<VkPipelineCacheCreateInfoRAII>;

%template (VkBaseInStructurePtr) std::shared_ptr<VkBaseInStructureRAII>;

%template (VkDescriptorSetAllocateInfoPtr) std::shared_ptr<VkDescriptorSetAllocateInfoRAII>;

%template (VkRenderPassCreateInfoPtr) std::shared_ptr<VkRenderPassCreateInfoRAII>;

%template (VkPipelineColorBlendStateCreateInfoPtr) std::shared_ptr<VkPipelineColorBlendStateCreateInfoRAII>;

%template (VkShadingRatePaletteNVPtr) std::shared_ptr<VkShadingRatePaletteNVRAII>;

#ifdef VK_VERSION_1_1

%template (VkDescriptorUpdateTemplateCreateInfoPtr) std::shared_ptr<VkDescriptorUpdateTemplateCreateInfoRAII>;

#endif

%template (VkImageDrmFormatModifierExplicitCreateInfoEXTPtr) std::shared_ptr<VkImageDrmFormatModifierExplicitCreateInfoEXTRAII>;

%template (VkCoarseSampleOrderCustomNVPtr) std::shared_ptr<VkCoarseSampleOrderCustomNVRAII>;

%template (VkPipelineViewportWScalingStateCreateInfoNVPtr) std::shared_ptr<VkPipelineViewportWScalingStateCreateInfoNVRAII>;

%template (VkSampleLocationsInfoEXTPtr) std::shared_ptr<VkSampleLocationsInfoEXTRAII>;

%template (VkPipelineCoverageModulationStateCreateInfoNVPtr) std::shared_ptr<VkPipelineCoverageModulationStateCreateInfoNVRAII>;

%template (VkPipelineViewportStateCreateInfoPtr) std::shared_ptr<VkPipelineViewportStateCreateInfoRAII>;

%template (VkShaderModuleCreateInfoPtr) std::shared_ptr<VkShaderModuleCreateInfoRAII>;

%template (VkBindSparseInfoPtr) std::shared_ptr<VkBindSparseInfoRAII>;

%template (VkInstanceCreateInfoPtr) std::shared_ptr<VkInstanceCreateInfoRAII>;

%template (VkPipelineLayoutCreateInfoPtr) std::shared_ptr<VkPipelineLayoutCreateInfoRAII>;

#ifdef VK_VERSION_1_1

%template (VkDescriptorSetLayoutCreateInfoPtr) std::shared_ptr<VkDescriptorSetLayoutCreateInfoRAII>;

#endif

%template (VkCmdProcessCommandsInfoNVXPtr) std::shared_ptr<VkCmdProcessCommandsInfoNVXRAII>;

%template (VkWriteDescriptorSetPtr) std::shared_ptr<VkWriteDescriptorSetRAII>;

%template (VkRenderPassBeginInfoPtr) std::shared_ptr<VkRenderPassBeginInfoRAII>;

%template (VkPipelineShaderStageCreateInfoPtr) std::shared_ptr<VkPipelineShaderStageCreateInfoRAII>;

%template (VkExportSemaphoreWin32HandleInfoKHRPtr) std::shared_ptr<VkExportSemaphoreWin32HandleInfoKHRRAII>;

%template (VkImageCreateInfoPtr) std::shared_ptr<VkImageCreateInfoRAII>;

%template (VkPipelineViewportExclusiveScissorStateCreateInfoNVPtr) std::shared_ptr<VkPipelineViewportExclusiveScissorStateCreateInfoNVRAII>;

%template (VkWriteDescriptorSetAccelerationStructureNVPtr) std::shared_ptr<VkWriteDescriptorSetAccelerationStructureNVRAII>;

%template (VkFramebufferAttachmentsCreateInfoKHRPtr) std::shared_ptr<VkFramebufferAttachmentsCreateInfoKHRRAII>;

%template (VkSparseBufferMemoryBindInfoPtr) std::shared_ptr<VkSparseBufferMemoryBindInfoRAII>;

%template (VkPresentRegionsKHRPtr) std::shared_ptr<VkPresentRegionsKHRRAII>;

%template (VkSubpassDescriptionDepthStencilResolveKHRPtr) std::shared_ptr<VkSubpassDescriptionDepthStencilResolveKHRRAII>;

%template (VkDescriptorSetVariableDescriptorCountAllocateInfoEXTPtr) std::shared_ptr<VkDescriptorSetVariableDescriptorCountAllocateInfoEXTRAII>;

#ifdef VK_VERSION_1_1

%template (VkBindImageMemoryDeviceGroupInfoPtr) std::shared_ptr<VkBindImageMemoryDeviceGroupInfoRAII>;

#endif

%template (VkGraphicsPipelineCreateInfoPtr) std::shared_ptr<VkGraphicsPipelineCreateInfoRAII>;

%template (VkBufferCreateInfoPtr) std::shared_ptr<VkBufferCreateInfoRAII>;

%template (VkPipelineVertexInputStateCreateInfoPtr) std::shared_ptr<VkPipelineVertexInputStateCreateInfoRAII>;

%template (VkPipelineDiscardRectangleStateCreateInfoEXTPtr) std::shared_ptr<VkPipelineDiscardRectangleStateCreateInfoEXTRAII>;

%template (VkDeviceQueueCreateInfoPtr) std::shared_ptr<VkDeviceQueueCreateInfoRAII>;

%template (VkExportMemoryWin32HandleInfoKHRPtr) std::shared_ptr<VkExportMemoryWin32HandleInfoKHRRAII>;

%template (VkDebugMarkerObjectNameInfoEXTPtr) std::shared_ptr<VkDebugMarkerObjectNameInfoEXTRAII>;

%template (VkSubmitInfoPtr) std::shared_ptr<VkSubmitInfoRAII>;

%template (VkPipelineViewportShadingRateImageStateCreateInfoNVPtr) std::shared_ptr<VkPipelineViewportShadingRateImageStateCreateInfoNVRAII>;

%template (VkFramebufferCreateInfoPtr) std::shared_ptr<VkFramebufferCreateInfoRAII>;

%template (VkDeviceGroupPresentInfoKHRPtr) std::shared_ptr<VkDeviceGroupPresentInfoKHRRAII>;

%template (VkDebugUtilsMessengerCallbackDataEXTPtr) std::shared_ptr<VkDebugUtilsMessengerCallbackDataEXTRAII>;

%template (VkObjectTableCreateInfoNVXPtr) std::shared_ptr<VkObjectTableCreateInfoNVXRAII>;

%template (VkPresentTimesInfoGOOGLEPtr) std::shared_ptr<VkPresentTimesInfoGOOGLERAII>;

%template (VkFramebufferAttachmentImageInfoKHRPtr) std::shared_ptr<VkFramebufferAttachmentImageInfoKHRRAII>;

%template (VkImageFormatListCreateInfoKHRPtr) std::shared_ptr<VkImageFormatListCreateInfoKHRRAII>;

%template (VkExportFenceWin32HandleInfoKHRPtr) std::shared_ptr<VkExportFenceWin32HandleInfoKHRRAII>;

%template (VkCommandBufferBeginInfoPtr) std::shared_ptr<VkCommandBufferBeginInfoRAII>;

%template (VkWin32KeyedMutexAcquireReleaseInfoNVPtr) std::shared_ptr<VkWin32KeyedMutexAcquireReleaseInfoNVRAII>;

%template (VkSwapchainCreateInfoKHRPtr) std::shared_ptr<VkSwapchainCreateInfoKHRRAII>;

%template (VkDeviceCreateInfoPtr) std::shared_ptr<VkDeviceCreateInfoRAII>;

#ifdef VK_VERSION_1_1

%template (VkDeviceGroupDeviceCreateInfoPtr) std::shared_ptr<VkDeviceGroupDeviceCreateInfoRAII>;

#endif

%template (VkRayTracingPipelineCreateInfoNVPtr) std::shared_ptr<VkRayTracingPipelineCreateInfoNVRAII>;

%template (VkIndirectCommandsLayoutCreateInfoNVXPtr) std::shared_ptr<VkIndirectCommandsLayoutCreateInfoNVXRAII>;

%template (VkRenderPassSampleLocationsBeginInfoEXTPtr) std::shared_ptr<VkRenderPassSampleLocationsBeginInfoEXTRAII>;

%template (VkValidationCacheCreateInfoEXTPtr) std::shared_ptr<VkValidationCacheCreateInfoEXTRAII>;

%template (VkPipelineViewportCoarseSampleOrderStateCreateInfoNVPtr) std::shared_ptr<VkPipelineViewportCoarseSampleOrderStateCreateInfoNVRAII>;

%template (VkDebugUtilsObjectNameInfoEXTPtr) std::shared_ptr<VkDebugUtilsObjectNameInfoEXTRAII>;

%template (VkSparseImageMemoryBindInfoPtr) std::shared_ptr<VkSparseImageMemoryBindInfoRAII>;

#ifdef VK_VERSION_1_1

%template (VkBindBufferMemoryDeviceGroupInfoPtr) std::shared_ptr<VkBindBufferMemoryDeviceGroupInfoRAII>;

#endif

%template (VkRenderPassAttachmentBeginInfoKHRPtr) std::shared_ptr<VkRenderPassAttachmentBeginInfoKHRRAII>;

%template (VkPresentInfoKHRPtr) std::shared_ptr<VkPresentInfoKHRRAII>;

%template (VkPipelineDynamicStateCreateInfoPtr) std::shared_ptr<VkPipelineDynamicStateCreateInfoRAII>;

%template (VkD3D12FenceSubmitInfoKHRPtr) std::shared_ptr<VkD3D12FenceSubmitInfoKHRRAII>;

%template (VkDebugMarkerMarkerInfoEXTPtr) std::shared_ptr<VkDebugMarkerMarkerInfoEXTRAII>;

%template (VkValidationFeaturesEXTPtr) std::shared_ptr<VkValidationFeaturesEXTRAII>;

%template (VkDebugUtilsLabelEXTPtr) std::shared_ptr<VkDebugUtilsLabelEXTRAII>;

%template (VkPipelineViewportSwizzleStateCreateInfoNVPtr) std::shared_ptr<VkPipelineViewportSwizzleStateCreateInfoNVRAII>;

%template (VkDescriptorSetLayoutBindingFlagsCreateInfoEXTPtr) std::shared_ptr<VkDescriptorSetLayoutBindingFlagsCreateInfoEXTRAII>;

%template (VkPipelineExecutableInternalRepresentationKHRPtr) std::shared_ptr<VkPipelineExecutableInternalRepresentationKHRRAII>;

#ifdef VK_VERSION_1_1

%template (VkDescriptorSetLayoutBindingPtr) std::shared_ptr<VkDescriptorSetLayoutBindingRAII>;

#endif

%template (VkMetalSurfaceCreateInfoEXTPtr) std::shared_ptr<VkMetalSurfaceCreateInfoEXTRAII>;

#ifdef VK_VERSION_1_1

%template (VkDeviceGroupRenderPassBeginInfoPtr) std::shared_ptr<VkDeviceGroupRenderPassBeginInfoRAII>;

#endif

%template (VkPipelineVertexInputDivisorStateCreateInfoEXTPtr) std::shared_ptr<VkPipelineVertexInputDivisorStateCreateInfoEXTRAII>;

%template (VkDescriptorPoolCreateInfoPtr) std::shared_ptr<VkDescriptorPoolCreateInfoRAII>;

%template (VkDrmFormatModifierPropertiesListEXTPtr) std::shared_ptr<VkDrmFormatModifierPropertiesListEXTRAII>;

%template (VkWin32KeyedMutexAcquireReleaseInfoKHRPtr) std::shared_ptr<VkWin32KeyedMutexAcquireReleaseInfoKHRRAII>;

%template (VkPhysicalDeviceImageDrmFormatModifierInfoEXTPtr) std::shared_ptr<VkPhysicalDeviceImageDrmFormatModifierInfoEXTRAII>;

%template (VkDisplayPropertiesKHRPtr) std::shared_ptr<VkDisplayPropertiesKHRRAII>;

%template (VkDebugUtilsObjectTagInfoEXTPtr) std::shared_ptr<VkDebugUtilsObjectTagInfoEXTRAII>;

%template (VkAccelerationStructureInfoNVPtr) std::shared_ptr<VkAccelerationStructureInfoNVRAII>;

%template (VkValidationFlagsEXTPtr) std::shared_ptr<VkValidationFlagsEXTRAII>;

#ifdef VK_VERSION_1_1

%template (VkRenderPassMultiviewCreateInfoPtr) std::shared_ptr<VkRenderPassMultiviewCreateInfoRAII>;

#endif

%template (VkSpecializationInfoPtr) std::shared_ptr<VkSpecializationInfoRAII>;

#ifdef VK_VERSION_1_1

%template (VkDeviceGroupSubmitInfoPtr) std::shared_ptr<VkDeviceGroupSubmitInfoRAII>;

#endif

#ifdef VK_VERSION_1_1

%template (VkSparseImageMemoryRequirements2Vector) std::vector<VkSparseImageMemoryRequirements2>;

#endif

#ifdef VK_VERSION_1_1

%template (VkBindBufferMemoryInfoVector) std::vector<VkBindBufferMemoryInfo>;

#endif

#ifdef VK_VERSION_1_1

%template (VkRect2DVector) std::vector<VkRect2D>;

#endif

#ifdef VK_VERSION_1_1

%template (VkQueueFamilyProperties2Vector) std::vector<VkQueueFamilyProperties2>;

#endif

%template (int32Vector) std::vector<int32_t>;

#ifdef VK_VERSION_1_1

%template (VkDescriptorSetLayoutBindingVector) std::vector< std::shared_ptr<VkDescriptorSetLayoutBindingRAII> >;

#endif

#ifdef VK_VERSION_1_1

%template (VkDescriptorUpdateTemplateEntryVector) std::vector<VkDescriptorUpdateTemplateEntry>;

#endif

#ifdef VK_VERSION_1_1

%template (VkBindImageMemoryInfoVector) std::vector<VkBindImageMemoryInfo>;

#endif

#ifdef VK_VERSION_1_1

%template (VkPhysicalDeviceGroupPropertiesVector) std::vector<VkPhysicalDeviceGroupProperties>;

#endif

#ifdef VK_VERSION_1_1

%template (VkInputAttachmentAspectReferenceVector) std::vector<VkInputAttachmentAspectReference>;

#endif

%template (VkSamplerVector) std::vector<VkSampler>;

#ifdef VK_VERSION_1_1

%template (VkSparseImageFormatProperties2Vector) std::vector<VkSparseImageFormatProperties2>;

#endif

%template (VkPhysicalDeviceVector) std::vector<VkPhysicalDevice>;

// Skipped commands that must be manually wrapped
//vkUpdateDescriptorSetWithTemplate
// End content generated by genswigi.py
