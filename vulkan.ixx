
/*
* 
* THIS FILE IS GENERATED BY genswigi.py 
*
* pyvulkan SWIG interface description file
*
* Copyright (C) 2016 by VLAM3D Software inc. https://www.vlam3d.com
*
* This code is licensed under the MIT license (MIT) (http://opensource.org/licenses/MIT)
*/

/*
** Copyright (c) 2015-2016 The Khronos Group Inc.
**
** Permission is hereby granted, free of charge, to any person obtaining a
** copy of this software and/or associated documentation files (the
** "Materials"), to deal in the Materials without restriction, including
** without limitation the rights to use, copy, modify, merge, publish,
** distribute, sublicense, and/or sell copies of the Materials, and to
** permit persons to whom the Materials are furnished to do so, subject to
** the following conditions:
**
** The above copyright notice and this permission notice shall be included
** in all copies or substantial portions of the Materials.
**
** THE MATERIALS ARE PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
** MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
** TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
** MATERIALS OR THE USE OR OTHER DEALINGS IN THE MATERIALS.
*/

// Begin content generated by genswigi.py
const char* vkGetErrorString(VkResult retval);


#define VK_VERSION_1_0 1
#include "vk_platform.h"

#define VK_MAKE_VERSION(major, minor, patch) \
    (((major) << 22) | ((minor) << 12) | (patch))

// DEPRECATED: This define has been removed. Specific version defines (e.g. VK_API_VERSION_1_0), or the VK_MAKE_VERSION macro, should be used instead.
//#define VK_API_VERSION VK_MAKE_VERSION(1, 0, 0) // Patch version should always be set to 0

// Vulkan 1.0 version number
#define VK_API_VERSION_1_0 VK_MAKE_VERSION(1, 0, 0)// Patch version should always be set to 0

#define VK_VERSION_MAJOR(version) ((uint32_t)(version) >> 22)
#define VK_VERSION_MINOR(version) (((uint32_t)(version) >> 12) & 0x3ff)
#define VK_VERSION_PATCH(version) ((uint32_t)(version) & 0xfff)
// Version of this file
#define VK_HEADER_VERSION 65


#define VK_NULL_HANDLE 0
        


#define VK_DEFINE_HANDLE(object) typedef struct object##_T* object;


#if !defined(VK_DEFINE_NON_DISPATCHABLE_HANDLE)
#if defined(__LP64__) || defined(_WIN64) || (defined(__x86_64__) && !defined(__ILP32__) ) || defined(_M_X64) || defined(__ia64) || defined (_M_IA64) || defined(__aarch64__) || defined(__powerpc64__)
        #define VK_DEFINE_NON_DISPATCHABLE_HANDLE(object) typedef struct object##_T *object;
#else
        #define VK_DEFINE_NON_DISPATCHABLE_HANDLE(object) typedef uint64_t object;
#endif
#endif
        


typedef uint32_t VkFlags;
typedef uint32_t VkBool32;
typedef uint64_t VkDeviceSize;
typedef uint32_t VkSampleMask;

VK_DEFINE_HANDLE(VkInstance)
VK_DEFINE_HANDLE(VkPhysicalDevice)
VK_DEFINE_HANDLE(VkDevice)
VK_DEFINE_HANDLE(VkQueue)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkSemaphore)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkFence)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkDeviceMemory)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkBuffer)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkImage)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkEvent)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkQueryPool)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkBufferView)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkImageView)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkShaderModule)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkPipelineCache)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkPipelineLayout)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkRenderPass)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkPipeline)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkDescriptorSetLayout)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkSampler)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkDescriptorPool)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkFramebuffer)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkCommandPool)

#define VK_LOD_CLAMP_NONE                 1000.0f
#define VK_REMAINING_MIP_LEVELS           (~0U)
#define VK_REMAINING_ARRAY_LAYERS         (~0U)
#define VK_WHOLE_SIZE                     (~0ULL)
#define VK_ATTACHMENT_UNUSED              (~0U)
#define VK_TRUE                           1
#define VK_FALSE                          0
#define VK_QUEUE_FAMILY_IGNORED           (~0U)
#define VK_SUBPASS_EXTERNAL               (~0U)
#define VK_MAX_PHYSICAL_DEVICE_NAME_SIZE  256
#define VK_UUID_SIZE                      16
#define VK_MAX_MEMORY_TYPES               32
#define VK_MAX_MEMORY_HEAPS               16
#define VK_MAX_EXTENSION_NAME_SIZE        256
#define VK_MAX_DESCRIPTION_SIZE           256


typedef enum VkPipelineCacheHeaderVersion {
    VK_PIPELINE_CACHE_HEADER_VERSION_ONE = 1,
    VK_PIPELINE_CACHE_HEADER_VERSION_BEGIN_RANGE = VK_PIPELINE_CACHE_HEADER_VERSION_ONE,
    VK_PIPELINE_CACHE_HEADER_VERSION_END_RANGE = VK_PIPELINE_CACHE_HEADER_VERSION_ONE,
    VK_PIPELINE_CACHE_HEADER_VERSION_RANGE_SIZE = (VK_PIPELINE_CACHE_HEADER_VERSION_ONE - VK_PIPELINE_CACHE_HEADER_VERSION_ONE + 1),
    VK_PIPELINE_CACHE_HEADER_VERSION_MAX_ENUM = 0x7FFFFFFF
} VkPipelineCacheHeaderVersion;

typedef enum VkResult {
    VK_SUCCESS = 0,
    VK_NOT_READY = 1,
    VK_TIMEOUT = 2,
    VK_EVENT_SET = 3,
    VK_EVENT_RESET = 4,
    VK_INCOMPLETE = 5,
    VK_ERROR_OUT_OF_HOST_MEMORY = -1,
    VK_ERROR_OUT_OF_DEVICE_MEMORY = -2,
    VK_ERROR_INITIALIZATION_FAILED = -3,
    VK_ERROR_DEVICE_LOST = -4,
    VK_ERROR_MEMORY_MAP_FAILED = -5,
    VK_ERROR_LAYER_NOT_PRESENT = -6,
    VK_ERROR_EXTENSION_NOT_PRESENT = -7,
    VK_ERROR_FEATURE_NOT_PRESENT = -8,
    VK_ERROR_INCOMPATIBLE_DRIVER = -9,
    VK_ERROR_TOO_MANY_OBJECTS = -10,
    VK_ERROR_FORMAT_NOT_SUPPORTED = -11,
    VK_ERROR_FRAGMENTED_POOL = -12,
    VK_ERROR_SURFACE_LOST_KHR = -1000000000,
    VK_ERROR_NATIVE_WINDOW_IN_USE_KHR = -1000000001,
    VK_SUBOPTIMAL_KHR = 1000001003,
    VK_ERROR_OUT_OF_DATE_KHR = -1000001004,
    VK_ERROR_INCOMPATIBLE_DISPLAY_KHR = -1000003001,
    VK_ERROR_VALIDATION_FAILED_EXT = -1000011001,
    VK_ERROR_INVALID_SHADER_NV = -1000012000,
    VK_ERROR_OUT_OF_POOL_MEMORY_KHR = -1000069000,
    VK_ERROR_INVALID_EXTERNAL_HANDLE_KHR = -1000072003,
    VK_ERROR_NOT_PERMITTED_EXT = -1000174001,
    VK_RESULT_BEGIN_RANGE = VK_ERROR_FRAGMENTED_POOL,
    VK_RESULT_END_RANGE = VK_INCOMPLETE,
    VK_RESULT_RANGE_SIZE = (VK_INCOMPLETE - VK_ERROR_FRAGMENTED_POOL + 1),
    VK_RESULT_MAX_ENUM = 0x7FFFFFFF
} VkResult;

typedef enum VkStructureType {
    VK_STRUCTURE_TYPE_APPLICATION_INFO = 0,
    VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO = 1,
    VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO = 2,
    VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO = 3,
    VK_STRUCTURE_TYPE_SUBMIT_INFO = 4,
    VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO = 5,
    VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE = 6,
    VK_STRUCTURE_TYPE_BIND_SPARSE_INFO = 7,
    VK_STRUCTURE_TYPE_FENCE_CREATE_INFO = 8,
    VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO = 9,
    VK_STRUCTURE_TYPE_EVENT_CREATE_INFO = 10,
    VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO = 11,
    VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO = 12,
    VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO = 13,
    VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO = 14,
    VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO = 15,
    VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO = 16,
    VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO = 17,
    VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO = 18,
    VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO = 19,
    VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO = 20,
    VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO = 21,
    VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO = 22,
    VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO = 23,
    VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO = 24,
    VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO = 25,
    VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO = 26,
    VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO = 27,
    VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO = 28,
    VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO = 29,
    VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO = 30,
    VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO = 31,
    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO = 32,
    VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO = 33,
    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO = 34,
    VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET = 35,
    VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET = 36,
    VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO = 37,
    VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO = 38,
    VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO = 39,
    VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO = 40,
    VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO = 41,
    VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO = 42,
    VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO = 43,
    VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER = 44,
    VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER = 45,
    VK_STRUCTURE_TYPE_MEMORY_BARRIER = 46,
    VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO = 47,
    VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO = 48,
    VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR = 1000001000,
    VK_STRUCTURE_TYPE_PRESENT_INFO_KHR = 1000001001,
    VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR = 1000002000,
    VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR = 1000002001,
    VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR = 1000003000,
    VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR = 1000004000,
    VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR = 1000005000,
    VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR = 1000006000,
    VK_STRUCTURE_TYPE_MIR_SURFACE_CREATE_INFO_KHR = 1000007000,
    VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR = 1000008000,
    VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR = 1000009000,
    VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT = 1000011000,
    VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD = 1000018000,
    VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT = 1000022000,
    VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT = 1000022001,
    VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT = 1000022002,
    VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV = 1000026000,
    VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV = 1000026001,
    VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV = 1000026002,
    VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD = 1000041000,
    VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO_KHX = 1000053000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES_KHX = 1000053001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES_KHX = 1000053002,
    VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV = 1000056000,
    VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV = 1000056001,
    VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV = 1000057000,
    VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV = 1000057001,
    VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV = 1000058000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2_KHR = 1000059000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2_KHR = 1000059001,
    VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2_KHR = 1000059002,
    VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2_KHR = 1000059003,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2_KHR = 1000059004,
    VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2_KHR = 1000059005,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2_KHR = 1000059006,
    VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2_KHR = 1000059007,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2_KHR = 1000059008,
    VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO_KHX = 1000060000,
    VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO_KHX = 1000060003,
    VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO_KHX = 1000060004,
    VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO_KHX = 1000060005,
    VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO_KHX = 1000060006,
    VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHX = 1000060010,
    VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO_KHX = 1000060013,
    VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO_KHX = 1000060014,
    VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHX = 1000060007,
    VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHX = 1000060008,
    VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHX = 1000060009,
    VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHX = 1000060011,
    VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHX = 1000060012,
    VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT = 1000061000,
    VK_STRUCTURE_TYPE_VI_SURFACE_CREATE_INFO_NN = 1000062000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES_KHX = 1000070000,
    VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO_KHX = 1000070001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO_KHR = 1000071000,
    VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES_KHR = 1000071001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO_KHR = 1000071002,
    VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES_KHR = 1000071003,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES_KHR = 1000071004,
    VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO_KHR = 1000072000,
    VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_KHR = 1000072001,
    VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_KHR = 1000072002,
    VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR = 1000073000,
    VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR = 1000073001,
    VK_STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR = 1000073002,
    VK_STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR = 1000073003,
    VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR = 1000074000,
    VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR = 1000074001,
    VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR = 1000074002,
    VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR = 1000075000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO_KHR = 1000076000,
    VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES_KHR = 1000076001,
    VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO_KHR = 1000077000,
    VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR = 1000078000,
    VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR = 1000078001,
    VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR = 1000078002,
    VK_STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR = 1000078003,
    VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR = 1000079000,
    VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR = 1000079001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR = 1000080000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES_KHR = 1000083000,
    VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR = 1000084000,
    VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO_KHR = 1000085000,
    VK_STRUCTURE_TYPE_OBJECT_TABLE_CREATE_INFO_NVX = 1000086000,
    VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NVX = 1000086001,
    VK_STRUCTURE_TYPE_CMD_PROCESS_COMMANDS_INFO_NVX = 1000086002,
    VK_STRUCTURE_TYPE_CMD_RESERVE_SPACE_FOR_COMMANDS_INFO_NVX = 1000086003,
    VK_STRUCTURE_TYPE_DEVICE_GENERATED_COMMANDS_LIMITS_NVX = 1000086004,
    VK_STRUCTURE_TYPE_DEVICE_GENERATED_COMMANDS_FEATURES_NVX = 1000086005,
    VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV = 1000087000,
    VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT = 1000090000,
    VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT = 1000091000,
    VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT = 1000091001,
    VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT = 1000091002,
    VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT = 1000091003,
    VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE = 1000092000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX = 1000097000,
    VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV = 1000098000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT = 1000099000,
    VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT = 1000099001,
    VK_STRUCTURE_TYPE_HDR_METADATA_EXT = 1000105000,
    VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR = 1000111000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO_KHR = 1000112000,
    VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES_KHR = 1000112001,
    VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO_KHR = 1000113000,
    VK_STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR = 1000114000,
    VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR = 1000114001,
    VK_STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR = 1000114002,
    VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR = 1000115000,
    VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR = 1000115001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES_KHR = 1000117000,
    VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO_KHR = 1000117001,
    VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO_KHR = 1000117002,
    VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO_KHR = 1000117003,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR = 1000119000,
    VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR = 1000119001,
    VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR = 1000119002,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES_KHR = 1000120000,
    VK_STRUCTURE_TYPE_IOS_SURFACE_CREATE_INFO_MVK = 1000122000,
    VK_STRUCTURE_TYPE_MACOS_SURFACE_CREATE_INFO_MVK = 1000123000,
    VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS_KHR = 1000127000,
    VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO_KHR = 1000127001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES_EXT = 1000130000,
    VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT = 1000130001,
    VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT = 1000143000,
    VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT = 1000143001,
    VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT = 1000143002,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT = 1000143003,
    VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT = 1000143004,
    VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2_KHR = 1000146000,
    VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2_KHR = 1000146001,
    VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2_KHR = 1000146002,
    VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2_KHR = 1000146003,
    VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2_KHR = 1000146004,
    VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO_KHR = 1000147000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT = 1000148000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT = 1000148001,
    VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT = 1000148002,
    VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV = 1000149000,
    VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV = 1000152000,
    VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO_KHR = 1000156000,
    VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO_KHR = 1000156001,
    VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO_KHR = 1000156002,
    VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO_KHR = 1000156003,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES_KHR = 1000156004,
    VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES_KHR = 1000156005,
    VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO_KHR = 1000157000,
    VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO_KHR = 1000157001,
    VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT = 1000160000,
    VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT = 1000160001,
    VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT = 1000174000,
    VK_STRUCTURE_TYPE_BEGIN_RANGE = VK_STRUCTURE_TYPE_APPLICATION_INFO,
    VK_STRUCTURE_TYPE_END_RANGE = VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO,
    VK_STRUCTURE_TYPE_RANGE_SIZE = (VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO - VK_STRUCTURE_TYPE_APPLICATION_INFO + 1),
    VK_STRUCTURE_TYPE_MAX_ENUM = 0x7FFFFFFF
} VkStructureType;

typedef enum VkSystemAllocationScope {
    VK_SYSTEM_ALLOCATION_SCOPE_COMMAND = 0,
    VK_SYSTEM_ALLOCATION_SCOPE_OBJECT = 1,
    VK_SYSTEM_ALLOCATION_SCOPE_CACHE = 2,
    VK_SYSTEM_ALLOCATION_SCOPE_DEVICE = 3,
    VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE = 4,
    VK_SYSTEM_ALLOCATION_SCOPE_BEGIN_RANGE = VK_SYSTEM_ALLOCATION_SCOPE_COMMAND,
    VK_SYSTEM_ALLOCATION_SCOPE_END_RANGE = VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE,
    VK_SYSTEM_ALLOCATION_SCOPE_RANGE_SIZE = (VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE - VK_SYSTEM_ALLOCATION_SCOPE_COMMAND + 1),
    VK_SYSTEM_ALLOCATION_SCOPE_MAX_ENUM = 0x7FFFFFFF
} VkSystemAllocationScope;

typedef enum VkInternalAllocationType {
    VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE = 0,
    VK_INTERNAL_ALLOCATION_TYPE_BEGIN_RANGE = VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE,
    VK_INTERNAL_ALLOCATION_TYPE_END_RANGE = VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE,
    VK_INTERNAL_ALLOCATION_TYPE_RANGE_SIZE = (VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE - VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE + 1),
    VK_INTERNAL_ALLOCATION_TYPE_MAX_ENUM = 0x7FFFFFFF
} VkInternalAllocationType;

typedef enum VkFormat {
    VK_FORMAT_UNDEFINED = 0,
    VK_FORMAT_R4G4_UNORM_PACK8 = 1,
    VK_FORMAT_R4G4B4A4_UNORM_PACK16 = 2,
    VK_FORMAT_B4G4R4A4_UNORM_PACK16 = 3,
    VK_FORMAT_R5G6B5_UNORM_PACK16 = 4,
    VK_FORMAT_B5G6R5_UNORM_PACK16 = 5,
    VK_FORMAT_R5G5B5A1_UNORM_PACK16 = 6,
    VK_FORMAT_B5G5R5A1_UNORM_PACK16 = 7,
    VK_FORMAT_A1R5G5B5_UNORM_PACK16 = 8,
    VK_FORMAT_R8_UNORM = 9,
    VK_FORMAT_R8_SNORM = 10,
    VK_FORMAT_R8_USCALED = 11,
    VK_FORMAT_R8_SSCALED = 12,
    VK_FORMAT_R8_UINT = 13,
    VK_FORMAT_R8_SINT = 14,
    VK_FORMAT_R8_SRGB = 15,
    VK_FORMAT_R8G8_UNORM = 16,
    VK_FORMAT_R8G8_SNORM = 17,
    VK_FORMAT_R8G8_USCALED = 18,
    VK_FORMAT_R8G8_SSCALED = 19,
    VK_FORMAT_R8G8_UINT = 20,
    VK_FORMAT_R8G8_SINT = 21,
    VK_FORMAT_R8G8_SRGB = 22,
    VK_FORMAT_R8G8B8_UNORM = 23,
    VK_FORMAT_R8G8B8_SNORM = 24,
    VK_FORMAT_R8G8B8_USCALED = 25,
    VK_FORMAT_R8G8B8_SSCALED = 26,
    VK_FORMAT_R8G8B8_UINT = 27,
    VK_FORMAT_R8G8B8_SINT = 28,
    VK_FORMAT_R8G8B8_SRGB = 29,
    VK_FORMAT_B8G8R8_UNORM = 30,
    VK_FORMAT_B8G8R8_SNORM = 31,
    VK_FORMAT_B8G8R8_USCALED = 32,
    VK_FORMAT_B8G8R8_SSCALED = 33,
    VK_FORMAT_B8G8R8_UINT = 34,
    VK_FORMAT_B8G8R8_SINT = 35,
    VK_FORMAT_B8G8R8_SRGB = 36,
    VK_FORMAT_R8G8B8A8_UNORM = 37,
    VK_FORMAT_R8G8B8A8_SNORM = 38,
    VK_FORMAT_R8G8B8A8_USCALED = 39,
    VK_FORMAT_R8G8B8A8_SSCALED = 40,
    VK_FORMAT_R8G8B8A8_UINT = 41,
    VK_FORMAT_R8G8B8A8_SINT = 42,
    VK_FORMAT_R8G8B8A8_SRGB = 43,
    VK_FORMAT_B8G8R8A8_UNORM = 44,
    VK_FORMAT_B8G8R8A8_SNORM = 45,
    VK_FORMAT_B8G8R8A8_USCALED = 46,
    VK_FORMAT_B8G8R8A8_SSCALED = 47,
    VK_FORMAT_B8G8R8A8_UINT = 48,
    VK_FORMAT_B8G8R8A8_SINT = 49,
    VK_FORMAT_B8G8R8A8_SRGB = 50,
    VK_FORMAT_A8B8G8R8_UNORM_PACK32 = 51,
    VK_FORMAT_A8B8G8R8_SNORM_PACK32 = 52,
    VK_FORMAT_A8B8G8R8_USCALED_PACK32 = 53,
    VK_FORMAT_A8B8G8R8_SSCALED_PACK32 = 54,
    VK_FORMAT_A8B8G8R8_UINT_PACK32 = 55,
    VK_FORMAT_A8B8G8R8_SINT_PACK32 = 56,
    VK_FORMAT_A8B8G8R8_SRGB_PACK32 = 57,
    VK_FORMAT_A2R10G10B10_UNORM_PACK32 = 58,
    VK_FORMAT_A2R10G10B10_SNORM_PACK32 = 59,
    VK_FORMAT_A2R10G10B10_USCALED_PACK32 = 60,
    VK_FORMAT_A2R10G10B10_SSCALED_PACK32 = 61,
    VK_FORMAT_A2R10G10B10_UINT_PACK32 = 62,
    VK_FORMAT_A2R10G10B10_SINT_PACK32 = 63,
    VK_FORMAT_A2B10G10R10_UNORM_PACK32 = 64,
    VK_FORMAT_A2B10G10R10_SNORM_PACK32 = 65,
    VK_FORMAT_A2B10G10R10_USCALED_PACK32 = 66,
    VK_FORMAT_A2B10G10R10_SSCALED_PACK32 = 67,
    VK_FORMAT_A2B10G10R10_UINT_PACK32 = 68,
    VK_FORMAT_A2B10G10R10_SINT_PACK32 = 69,
    VK_FORMAT_R16_UNORM = 70,
    VK_FORMAT_R16_SNORM = 71,
    VK_FORMAT_R16_USCALED = 72,
    VK_FORMAT_R16_SSCALED = 73,
    VK_FORMAT_R16_UINT = 74,
    VK_FORMAT_R16_SINT = 75,
    VK_FORMAT_R16_SFLOAT = 76,
    VK_FORMAT_R16G16_UNORM = 77,
    VK_FORMAT_R16G16_SNORM = 78,
    VK_FORMAT_R16G16_USCALED = 79,
    VK_FORMAT_R16G16_SSCALED = 80,
    VK_FORMAT_R16G16_UINT = 81,
    VK_FORMAT_R16G16_SINT = 82,
    VK_FORMAT_R16G16_SFLOAT = 83,
    VK_FORMAT_R16G16B16_UNORM = 84,
    VK_FORMAT_R16G16B16_SNORM = 85,
    VK_FORMAT_R16G16B16_USCALED = 86,
    VK_FORMAT_R16G16B16_SSCALED = 87,
    VK_FORMAT_R16G16B16_UINT = 88,
    VK_FORMAT_R16G16B16_SINT = 89,
    VK_FORMAT_R16G16B16_SFLOAT = 90,
    VK_FORMAT_R16G16B16A16_UNORM = 91,
    VK_FORMAT_R16G16B16A16_SNORM = 92,
    VK_FORMAT_R16G16B16A16_USCALED = 93,
    VK_FORMAT_R16G16B16A16_SSCALED = 94,
    VK_FORMAT_R16G16B16A16_UINT = 95,
    VK_FORMAT_R16G16B16A16_SINT = 96,
    VK_FORMAT_R16G16B16A16_SFLOAT = 97,
    VK_FORMAT_R32_UINT = 98,
    VK_FORMAT_R32_SINT = 99,
    VK_FORMAT_R32_SFLOAT = 100,
    VK_FORMAT_R32G32_UINT = 101,
    VK_FORMAT_R32G32_SINT = 102,
    VK_FORMAT_R32G32_SFLOAT = 103,
    VK_FORMAT_R32G32B32_UINT = 104,
    VK_FORMAT_R32G32B32_SINT = 105,
    VK_FORMAT_R32G32B32_SFLOAT = 106,
    VK_FORMAT_R32G32B32A32_UINT = 107,
    VK_FORMAT_R32G32B32A32_SINT = 108,
    VK_FORMAT_R32G32B32A32_SFLOAT = 109,
    VK_FORMAT_R64_UINT = 110,
    VK_FORMAT_R64_SINT = 111,
    VK_FORMAT_R64_SFLOAT = 112,
    VK_FORMAT_R64G64_UINT = 113,
    VK_FORMAT_R64G64_SINT = 114,
    VK_FORMAT_R64G64_SFLOAT = 115,
    VK_FORMAT_R64G64B64_UINT = 116,
    VK_FORMAT_R64G64B64_SINT = 117,
    VK_FORMAT_R64G64B64_SFLOAT = 118,
    VK_FORMAT_R64G64B64A64_UINT = 119,
    VK_FORMAT_R64G64B64A64_SINT = 120,
    VK_FORMAT_R64G64B64A64_SFLOAT = 121,
    VK_FORMAT_B10G11R11_UFLOAT_PACK32 = 122,
    VK_FORMAT_E5B9G9R9_UFLOAT_PACK32 = 123,
    VK_FORMAT_D16_UNORM = 124,
    VK_FORMAT_X8_D24_UNORM_PACK32 = 125,
    VK_FORMAT_D32_SFLOAT = 126,
    VK_FORMAT_S8_UINT = 127,
    VK_FORMAT_D16_UNORM_S8_UINT = 128,
    VK_FORMAT_D24_UNORM_S8_UINT = 129,
    VK_FORMAT_D32_SFLOAT_S8_UINT = 130,
    VK_FORMAT_BC1_RGB_UNORM_BLOCK = 131,
    VK_FORMAT_BC1_RGB_SRGB_BLOCK = 132,
    VK_FORMAT_BC1_RGBA_UNORM_BLOCK = 133,
    VK_FORMAT_BC1_RGBA_SRGB_BLOCK = 134,
    VK_FORMAT_BC2_UNORM_BLOCK = 135,
    VK_FORMAT_BC2_SRGB_BLOCK = 136,
    VK_FORMAT_BC3_UNORM_BLOCK = 137,
    VK_FORMAT_BC3_SRGB_BLOCK = 138,
    VK_FORMAT_BC4_UNORM_BLOCK = 139,
    VK_FORMAT_BC4_SNORM_BLOCK = 140,
    VK_FORMAT_BC5_UNORM_BLOCK = 141,
    VK_FORMAT_BC5_SNORM_BLOCK = 142,
    VK_FORMAT_BC6H_UFLOAT_BLOCK = 143,
    VK_FORMAT_BC6H_SFLOAT_BLOCK = 144,
    VK_FORMAT_BC7_UNORM_BLOCK = 145,
    VK_FORMAT_BC7_SRGB_BLOCK = 146,
    VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK = 147,
    VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK = 148,
    VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK = 149,
    VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK = 150,
    VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK = 151,
    VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK = 152,
    VK_FORMAT_EAC_R11_UNORM_BLOCK = 153,
    VK_FORMAT_EAC_R11_SNORM_BLOCK = 154,
    VK_FORMAT_EAC_R11G11_UNORM_BLOCK = 155,
    VK_FORMAT_EAC_R11G11_SNORM_BLOCK = 156,
    VK_FORMAT_ASTC_4x4_UNORM_BLOCK = 157,
    VK_FORMAT_ASTC_4x4_SRGB_BLOCK = 158,
    VK_FORMAT_ASTC_5x4_UNORM_BLOCK = 159,
    VK_FORMAT_ASTC_5x4_SRGB_BLOCK = 160,
    VK_FORMAT_ASTC_5x5_UNORM_BLOCK = 161,
    VK_FORMAT_ASTC_5x5_SRGB_BLOCK = 162,
    VK_FORMAT_ASTC_6x5_UNORM_BLOCK = 163,
    VK_FORMAT_ASTC_6x5_SRGB_BLOCK = 164,
    VK_FORMAT_ASTC_6x6_UNORM_BLOCK = 165,
    VK_FORMAT_ASTC_6x6_SRGB_BLOCK = 166,
    VK_FORMAT_ASTC_8x5_UNORM_BLOCK = 167,
    VK_FORMAT_ASTC_8x5_SRGB_BLOCK = 168,
    VK_FORMAT_ASTC_8x6_UNORM_BLOCK = 169,
    VK_FORMAT_ASTC_8x6_SRGB_BLOCK = 170,
    VK_FORMAT_ASTC_8x8_UNORM_BLOCK = 171,
    VK_FORMAT_ASTC_8x8_SRGB_BLOCK = 172,
    VK_FORMAT_ASTC_10x5_UNORM_BLOCK = 173,
    VK_FORMAT_ASTC_10x5_SRGB_BLOCK = 174,
    VK_FORMAT_ASTC_10x6_UNORM_BLOCK = 175,
    VK_FORMAT_ASTC_10x6_SRGB_BLOCK = 176,
    VK_FORMAT_ASTC_10x8_UNORM_BLOCK = 177,
    VK_FORMAT_ASTC_10x8_SRGB_BLOCK = 178,
    VK_FORMAT_ASTC_10x10_UNORM_BLOCK = 179,
    VK_FORMAT_ASTC_10x10_SRGB_BLOCK = 180,
    VK_FORMAT_ASTC_12x10_UNORM_BLOCK = 181,
    VK_FORMAT_ASTC_12x10_SRGB_BLOCK = 182,
    VK_FORMAT_ASTC_12x12_UNORM_BLOCK = 183,
    VK_FORMAT_ASTC_12x12_SRGB_BLOCK = 184,
    VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG = 1000054000,
    VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG = 1000054001,
    VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG = 1000054002,
    VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG = 1000054003,
    VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG = 1000054004,
    VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG = 1000054005,
    VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG = 1000054006,
    VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG = 1000054007,
    VK_FORMAT_G8B8G8R8_422_UNORM_KHR = 1000156000,
    VK_FORMAT_B8G8R8G8_422_UNORM_KHR = 1000156001,
    VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM_KHR = 1000156002,
    VK_FORMAT_G8_B8R8_2PLANE_420_UNORM_KHR = 1000156003,
    VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM_KHR = 1000156004,
    VK_FORMAT_G8_B8R8_2PLANE_422_UNORM_KHR = 1000156005,
    VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM_KHR = 1000156006,
    VK_FORMAT_R10X6_UNORM_PACK16_KHR = 1000156007,
    VK_FORMAT_R10X6G10X6_UNORM_2PACK16_KHR = 1000156008,
    VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16_KHR = 1000156009,
    VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16_KHR = 1000156010,
    VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16_KHR = 1000156011,
    VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16_KHR = 1000156012,
    VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16_KHR = 1000156013,
    VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16_KHR = 1000156014,
    VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16_KHR = 1000156015,
    VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16_KHR = 1000156016,
    VK_FORMAT_R12X4_UNORM_PACK16_KHR = 1000156017,
    VK_FORMAT_R12X4G12X4_UNORM_2PACK16_KHR = 1000156018,
    VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16_KHR = 1000156019,
    VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16_KHR = 1000156020,
    VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16_KHR = 1000156021,
    VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16_KHR = 1000156022,
    VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16_KHR = 1000156023,
    VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16_KHR = 1000156024,
    VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16_KHR = 1000156025,
    VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16_KHR = 1000156026,
    VK_FORMAT_G16B16G16R16_422_UNORM_KHR = 1000156027,
    VK_FORMAT_B16G16R16G16_422_UNORM_KHR = 1000156028,
    VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM_KHR = 1000156029,
    VK_FORMAT_G16_B16R16_2PLANE_420_UNORM_KHR = 1000156030,
    VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM_KHR = 1000156031,
    VK_FORMAT_G16_B16R16_2PLANE_422_UNORM_KHR = 1000156032,
    VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM_KHR = 1000156033,
    VK_FORMAT_BEGIN_RANGE = VK_FORMAT_UNDEFINED,
    VK_FORMAT_END_RANGE = VK_FORMAT_ASTC_12x12_SRGB_BLOCK,
    VK_FORMAT_RANGE_SIZE = (VK_FORMAT_ASTC_12x12_SRGB_BLOCK - VK_FORMAT_UNDEFINED + 1),
    VK_FORMAT_MAX_ENUM = 0x7FFFFFFF
} VkFormat;

typedef enum VkImageType {
    VK_IMAGE_TYPE_1D = 0,
    VK_IMAGE_TYPE_2D = 1,
    VK_IMAGE_TYPE_3D = 2,
    VK_IMAGE_TYPE_BEGIN_RANGE = VK_IMAGE_TYPE_1D,
    VK_IMAGE_TYPE_END_RANGE = VK_IMAGE_TYPE_3D,
    VK_IMAGE_TYPE_RANGE_SIZE = (VK_IMAGE_TYPE_3D - VK_IMAGE_TYPE_1D + 1),
    VK_IMAGE_TYPE_MAX_ENUM = 0x7FFFFFFF
} VkImageType;

typedef enum VkImageTiling {
    VK_IMAGE_TILING_OPTIMAL = 0,
    VK_IMAGE_TILING_LINEAR = 1,
    VK_IMAGE_TILING_BEGIN_RANGE = VK_IMAGE_TILING_OPTIMAL,
    VK_IMAGE_TILING_END_RANGE = VK_IMAGE_TILING_LINEAR,
    VK_IMAGE_TILING_RANGE_SIZE = (VK_IMAGE_TILING_LINEAR - VK_IMAGE_TILING_OPTIMAL + 1),
    VK_IMAGE_TILING_MAX_ENUM = 0x7FFFFFFF
} VkImageTiling;

typedef enum VkPhysicalDeviceType {
    VK_PHYSICAL_DEVICE_TYPE_OTHER = 0,
    VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU = 1,
    VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU = 2,
    VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU = 3,
    VK_PHYSICAL_DEVICE_TYPE_CPU = 4,
    VK_PHYSICAL_DEVICE_TYPE_BEGIN_RANGE = VK_PHYSICAL_DEVICE_TYPE_OTHER,
    VK_PHYSICAL_DEVICE_TYPE_END_RANGE = VK_PHYSICAL_DEVICE_TYPE_CPU,
    VK_PHYSICAL_DEVICE_TYPE_RANGE_SIZE = (VK_PHYSICAL_DEVICE_TYPE_CPU - VK_PHYSICAL_DEVICE_TYPE_OTHER + 1),
    VK_PHYSICAL_DEVICE_TYPE_MAX_ENUM = 0x7FFFFFFF
} VkPhysicalDeviceType;

typedef enum VkQueryType {
    VK_QUERY_TYPE_OCCLUSION = 0,
    VK_QUERY_TYPE_PIPELINE_STATISTICS = 1,
    VK_QUERY_TYPE_TIMESTAMP = 2,
    VK_QUERY_TYPE_BEGIN_RANGE = VK_QUERY_TYPE_OCCLUSION,
    VK_QUERY_TYPE_END_RANGE = VK_QUERY_TYPE_TIMESTAMP,
    VK_QUERY_TYPE_RANGE_SIZE = (VK_QUERY_TYPE_TIMESTAMP - VK_QUERY_TYPE_OCCLUSION + 1),
    VK_QUERY_TYPE_MAX_ENUM = 0x7FFFFFFF
} VkQueryType;

typedef enum VkSharingMode {
    VK_SHARING_MODE_EXCLUSIVE = 0,
    VK_SHARING_MODE_CONCURRENT = 1,
    VK_SHARING_MODE_BEGIN_RANGE = VK_SHARING_MODE_EXCLUSIVE,
    VK_SHARING_MODE_END_RANGE = VK_SHARING_MODE_CONCURRENT,
    VK_SHARING_MODE_RANGE_SIZE = (VK_SHARING_MODE_CONCURRENT - VK_SHARING_MODE_EXCLUSIVE + 1),
    VK_SHARING_MODE_MAX_ENUM = 0x7FFFFFFF
} VkSharingMode;

typedef enum VkImageLayout {
    VK_IMAGE_LAYOUT_UNDEFINED = 0,
    VK_IMAGE_LAYOUT_GENERAL = 1,
    VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL = 2,
    VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL = 3,
    VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL = 4,
    VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL = 5,
    VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL = 6,
    VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL = 7,
    VK_IMAGE_LAYOUT_PREINITIALIZED = 8,
    VK_IMAGE_LAYOUT_PRESENT_SRC_KHR = 1000001002,
    VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR = 1000111000,
    VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL_KHR = 1000117000,
    VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL_KHR = 1000117001,
    VK_IMAGE_LAYOUT_BEGIN_RANGE = VK_IMAGE_LAYOUT_UNDEFINED,
    VK_IMAGE_LAYOUT_END_RANGE = VK_IMAGE_LAYOUT_PREINITIALIZED,
    VK_IMAGE_LAYOUT_RANGE_SIZE = (VK_IMAGE_LAYOUT_PREINITIALIZED - VK_IMAGE_LAYOUT_UNDEFINED + 1),
    VK_IMAGE_LAYOUT_MAX_ENUM = 0x7FFFFFFF
} VkImageLayout;

typedef enum VkImageViewType {
    VK_IMAGE_VIEW_TYPE_1D = 0,
    VK_IMAGE_VIEW_TYPE_2D = 1,
    VK_IMAGE_VIEW_TYPE_3D = 2,
    VK_IMAGE_VIEW_TYPE_CUBE = 3,
    VK_IMAGE_VIEW_TYPE_1D_ARRAY = 4,
    VK_IMAGE_VIEW_TYPE_2D_ARRAY = 5,
    VK_IMAGE_VIEW_TYPE_CUBE_ARRAY = 6,
    VK_IMAGE_VIEW_TYPE_BEGIN_RANGE = VK_IMAGE_VIEW_TYPE_1D,
    VK_IMAGE_VIEW_TYPE_END_RANGE = VK_IMAGE_VIEW_TYPE_CUBE_ARRAY,
    VK_IMAGE_VIEW_TYPE_RANGE_SIZE = (VK_IMAGE_VIEW_TYPE_CUBE_ARRAY - VK_IMAGE_VIEW_TYPE_1D + 1),
    VK_IMAGE_VIEW_TYPE_MAX_ENUM = 0x7FFFFFFF
} VkImageViewType;

typedef enum VkComponentSwizzle {
    VK_COMPONENT_SWIZZLE_IDENTITY = 0,
    VK_COMPONENT_SWIZZLE_ZERO = 1,
    VK_COMPONENT_SWIZZLE_ONE = 2,
    VK_COMPONENT_SWIZZLE_R = 3,
    VK_COMPONENT_SWIZZLE_G = 4,
    VK_COMPONENT_SWIZZLE_B = 5,
    VK_COMPONENT_SWIZZLE_A = 6,
    VK_COMPONENT_SWIZZLE_BEGIN_RANGE = VK_COMPONENT_SWIZZLE_IDENTITY,
    VK_COMPONENT_SWIZZLE_END_RANGE = VK_COMPONENT_SWIZZLE_A,
    VK_COMPONENT_SWIZZLE_RANGE_SIZE = (VK_COMPONENT_SWIZZLE_A - VK_COMPONENT_SWIZZLE_IDENTITY + 1),
    VK_COMPONENT_SWIZZLE_MAX_ENUM = 0x7FFFFFFF
} VkComponentSwizzle;

typedef enum VkVertexInputRate {
    VK_VERTEX_INPUT_RATE_VERTEX = 0,
    VK_VERTEX_INPUT_RATE_INSTANCE = 1,
    VK_VERTEX_INPUT_RATE_BEGIN_RANGE = VK_VERTEX_INPUT_RATE_VERTEX,
    VK_VERTEX_INPUT_RATE_END_RANGE = VK_VERTEX_INPUT_RATE_INSTANCE,
    VK_VERTEX_INPUT_RATE_RANGE_SIZE = (VK_VERTEX_INPUT_RATE_INSTANCE - VK_VERTEX_INPUT_RATE_VERTEX + 1),
    VK_VERTEX_INPUT_RATE_MAX_ENUM = 0x7FFFFFFF
} VkVertexInputRate;

typedef enum VkPrimitiveTopology {
    VK_PRIMITIVE_TOPOLOGY_POINT_LIST = 0,
    VK_PRIMITIVE_TOPOLOGY_LINE_LIST = 1,
    VK_PRIMITIVE_TOPOLOGY_LINE_STRIP = 2,
    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST = 3,
    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP = 4,
    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN = 5,
    VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY = 6,
    VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY = 7,
    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY = 8,
    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY = 9,
    VK_PRIMITIVE_TOPOLOGY_PATCH_LIST = 10,
    VK_PRIMITIVE_TOPOLOGY_BEGIN_RANGE = VK_PRIMITIVE_TOPOLOGY_POINT_LIST,
    VK_PRIMITIVE_TOPOLOGY_END_RANGE = VK_PRIMITIVE_TOPOLOGY_PATCH_LIST,
    VK_PRIMITIVE_TOPOLOGY_RANGE_SIZE = (VK_PRIMITIVE_TOPOLOGY_PATCH_LIST - VK_PRIMITIVE_TOPOLOGY_POINT_LIST + 1),
    VK_PRIMITIVE_TOPOLOGY_MAX_ENUM = 0x7FFFFFFF
} VkPrimitiveTopology;

typedef enum VkPolygonMode {
    VK_POLYGON_MODE_FILL = 0,
    VK_POLYGON_MODE_LINE = 1,
    VK_POLYGON_MODE_POINT = 2,
    VK_POLYGON_MODE_FILL_RECTANGLE_NV = 1000153000,
    VK_POLYGON_MODE_BEGIN_RANGE = VK_POLYGON_MODE_FILL,
    VK_POLYGON_MODE_END_RANGE = VK_POLYGON_MODE_POINT,
    VK_POLYGON_MODE_RANGE_SIZE = (VK_POLYGON_MODE_POINT - VK_POLYGON_MODE_FILL + 1),
    VK_POLYGON_MODE_MAX_ENUM = 0x7FFFFFFF
} VkPolygonMode;

typedef enum VkFrontFace {
    VK_FRONT_FACE_COUNTER_CLOCKWISE = 0,
    VK_FRONT_FACE_CLOCKWISE = 1,
    VK_FRONT_FACE_BEGIN_RANGE = VK_FRONT_FACE_COUNTER_CLOCKWISE,
    VK_FRONT_FACE_END_RANGE = VK_FRONT_FACE_CLOCKWISE,
    VK_FRONT_FACE_RANGE_SIZE = (VK_FRONT_FACE_CLOCKWISE - VK_FRONT_FACE_COUNTER_CLOCKWISE + 1),
    VK_FRONT_FACE_MAX_ENUM = 0x7FFFFFFF
} VkFrontFace;

typedef enum VkCompareOp {
    VK_COMPARE_OP_NEVER = 0,
    VK_COMPARE_OP_LESS = 1,
    VK_COMPARE_OP_EQUAL = 2,
    VK_COMPARE_OP_LESS_OR_EQUAL = 3,
    VK_COMPARE_OP_GREATER = 4,
    VK_COMPARE_OP_NOT_EQUAL = 5,
    VK_COMPARE_OP_GREATER_OR_EQUAL = 6,
    VK_COMPARE_OP_ALWAYS = 7,
    VK_COMPARE_OP_BEGIN_RANGE = VK_COMPARE_OP_NEVER,
    VK_COMPARE_OP_END_RANGE = VK_COMPARE_OP_ALWAYS,
    VK_COMPARE_OP_RANGE_SIZE = (VK_COMPARE_OP_ALWAYS - VK_COMPARE_OP_NEVER + 1),
    VK_COMPARE_OP_MAX_ENUM = 0x7FFFFFFF
} VkCompareOp;

typedef enum VkStencilOp {
    VK_STENCIL_OP_KEEP = 0,
    VK_STENCIL_OP_ZERO = 1,
    VK_STENCIL_OP_REPLACE = 2,
    VK_STENCIL_OP_INCREMENT_AND_CLAMP = 3,
    VK_STENCIL_OP_DECREMENT_AND_CLAMP = 4,
    VK_STENCIL_OP_INVERT = 5,
    VK_STENCIL_OP_INCREMENT_AND_WRAP = 6,
    VK_STENCIL_OP_DECREMENT_AND_WRAP = 7,
    VK_STENCIL_OP_BEGIN_RANGE = VK_STENCIL_OP_KEEP,
    VK_STENCIL_OP_END_RANGE = VK_STENCIL_OP_DECREMENT_AND_WRAP,
    VK_STENCIL_OP_RANGE_SIZE = (VK_STENCIL_OP_DECREMENT_AND_WRAP - VK_STENCIL_OP_KEEP + 1),
    VK_STENCIL_OP_MAX_ENUM = 0x7FFFFFFF
} VkStencilOp;

typedef enum VkLogicOp {
    VK_LOGIC_OP_CLEAR = 0,
    VK_LOGIC_OP_AND = 1,
    VK_LOGIC_OP_AND_REVERSE = 2,
    VK_LOGIC_OP_COPY = 3,
    VK_LOGIC_OP_AND_INVERTED = 4,
    VK_LOGIC_OP_NO_OP = 5,
    VK_LOGIC_OP_XOR = 6,
    VK_LOGIC_OP_OR = 7,
    VK_LOGIC_OP_NOR = 8,
    VK_LOGIC_OP_EQUIVALENT = 9,
    VK_LOGIC_OP_INVERT = 10,
    VK_LOGIC_OP_OR_REVERSE = 11,
    VK_LOGIC_OP_COPY_INVERTED = 12,
    VK_LOGIC_OP_OR_INVERTED = 13,
    VK_LOGIC_OP_NAND = 14,
    VK_LOGIC_OP_SET = 15,
    VK_LOGIC_OP_BEGIN_RANGE = VK_LOGIC_OP_CLEAR,
    VK_LOGIC_OP_END_RANGE = VK_LOGIC_OP_SET,
    VK_LOGIC_OP_RANGE_SIZE = (VK_LOGIC_OP_SET - VK_LOGIC_OP_CLEAR + 1),
    VK_LOGIC_OP_MAX_ENUM = 0x7FFFFFFF
} VkLogicOp;

typedef enum VkBlendFactor {
    VK_BLEND_FACTOR_ZERO = 0,
    VK_BLEND_FACTOR_ONE = 1,
    VK_BLEND_FACTOR_SRC_COLOR = 2,
    VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR = 3,
    VK_BLEND_FACTOR_DST_COLOR = 4,
    VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR = 5,
    VK_BLEND_FACTOR_SRC_ALPHA = 6,
    VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA = 7,
    VK_BLEND_FACTOR_DST_ALPHA = 8,
    VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA = 9,
    VK_BLEND_FACTOR_CONSTANT_COLOR = 10,
    VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR = 11,
    VK_BLEND_FACTOR_CONSTANT_ALPHA = 12,
    VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA = 13,
    VK_BLEND_FACTOR_SRC_ALPHA_SATURATE = 14,
    VK_BLEND_FACTOR_SRC1_COLOR = 15,
    VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR = 16,
    VK_BLEND_FACTOR_SRC1_ALPHA = 17,
    VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA = 18,
    VK_BLEND_FACTOR_BEGIN_RANGE = VK_BLEND_FACTOR_ZERO,
    VK_BLEND_FACTOR_END_RANGE = VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA,
    VK_BLEND_FACTOR_RANGE_SIZE = (VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA - VK_BLEND_FACTOR_ZERO + 1),
    VK_BLEND_FACTOR_MAX_ENUM = 0x7FFFFFFF
} VkBlendFactor;

typedef enum VkBlendOp {
    VK_BLEND_OP_ADD = 0,
    VK_BLEND_OP_SUBTRACT = 1,
    VK_BLEND_OP_REVERSE_SUBTRACT = 2,
    VK_BLEND_OP_MIN = 3,
    VK_BLEND_OP_MAX = 4,
    VK_BLEND_OP_ZERO_EXT = 1000148000,
    VK_BLEND_OP_SRC_EXT = 1000148001,
    VK_BLEND_OP_DST_EXT = 1000148002,
    VK_BLEND_OP_SRC_OVER_EXT = 1000148003,
    VK_BLEND_OP_DST_OVER_EXT = 1000148004,
    VK_BLEND_OP_SRC_IN_EXT = 1000148005,
    VK_BLEND_OP_DST_IN_EXT = 1000148006,
    VK_BLEND_OP_SRC_OUT_EXT = 1000148007,
    VK_BLEND_OP_DST_OUT_EXT = 1000148008,
    VK_BLEND_OP_SRC_ATOP_EXT = 1000148009,
    VK_BLEND_OP_DST_ATOP_EXT = 1000148010,
    VK_BLEND_OP_XOR_EXT = 1000148011,
    VK_BLEND_OP_MULTIPLY_EXT = 1000148012,
    VK_BLEND_OP_SCREEN_EXT = 1000148013,
    VK_BLEND_OP_OVERLAY_EXT = 1000148014,
    VK_BLEND_OP_DARKEN_EXT = 1000148015,
    VK_BLEND_OP_LIGHTEN_EXT = 1000148016,
    VK_BLEND_OP_COLORDODGE_EXT = 1000148017,
    VK_BLEND_OP_COLORBURN_EXT = 1000148018,
    VK_BLEND_OP_HARDLIGHT_EXT = 1000148019,
    VK_BLEND_OP_SOFTLIGHT_EXT = 1000148020,
    VK_BLEND_OP_DIFFERENCE_EXT = 1000148021,
    VK_BLEND_OP_EXCLUSION_EXT = 1000148022,
    VK_BLEND_OP_INVERT_EXT = 1000148023,
    VK_BLEND_OP_INVERT_RGB_EXT = 1000148024,
    VK_BLEND_OP_LINEARDODGE_EXT = 1000148025,
    VK_BLEND_OP_LINEARBURN_EXT = 1000148026,
    VK_BLEND_OP_VIVIDLIGHT_EXT = 1000148027,
    VK_BLEND_OP_LINEARLIGHT_EXT = 1000148028,
    VK_BLEND_OP_PINLIGHT_EXT = 1000148029,
    VK_BLEND_OP_HARDMIX_EXT = 1000148030,
    VK_BLEND_OP_HSL_HUE_EXT = 1000148031,
    VK_BLEND_OP_HSL_SATURATION_EXT = 1000148032,
    VK_BLEND_OP_HSL_COLOR_EXT = 1000148033,
    VK_BLEND_OP_HSL_LUMINOSITY_EXT = 1000148034,
    VK_BLEND_OP_PLUS_EXT = 1000148035,
    VK_BLEND_OP_PLUS_CLAMPED_EXT = 1000148036,
    VK_BLEND_OP_PLUS_CLAMPED_ALPHA_EXT = 1000148037,
    VK_BLEND_OP_PLUS_DARKER_EXT = 1000148038,
    VK_BLEND_OP_MINUS_EXT = 1000148039,
    VK_BLEND_OP_MINUS_CLAMPED_EXT = 1000148040,
    VK_BLEND_OP_CONTRAST_EXT = 1000148041,
    VK_BLEND_OP_INVERT_OVG_EXT = 1000148042,
    VK_BLEND_OP_RED_EXT = 1000148043,
    VK_BLEND_OP_GREEN_EXT = 1000148044,
    VK_BLEND_OP_BLUE_EXT = 1000148045,
    VK_BLEND_OP_BEGIN_RANGE = VK_BLEND_OP_ADD,
    VK_BLEND_OP_END_RANGE = VK_BLEND_OP_MAX,
    VK_BLEND_OP_RANGE_SIZE = (VK_BLEND_OP_MAX - VK_BLEND_OP_ADD + 1),
    VK_BLEND_OP_MAX_ENUM = 0x7FFFFFFF
} VkBlendOp;

typedef enum VkDynamicState {
    VK_DYNAMIC_STATE_VIEWPORT = 0,
    VK_DYNAMIC_STATE_SCISSOR = 1,
    VK_DYNAMIC_STATE_LINE_WIDTH = 2,
    VK_DYNAMIC_STATE_DEPTH_BIAS = 3,
    VK_DYNAMIC_STATE_BLEND_CONSTANTS = 4,
    VK_DYNAMIC_STATE_DEPTH_BOUNDS = 5,
    VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK = 6,
    VK_DYNAMIC_STATE_STENCIL_WRITE_MASK = 7,
    VK_DYNAMIC_STATE_STENCIL_REFERENCE = 8,
    VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV = 1000087000,
    VK_DYNAMIC_STATE_DISCARD_RECTANGLE_EXT = 1000099000,
    VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT = 1000143000,
    VK_DYNAMIC_STATE_BEGIN_RANGE = VK_DYNAMIC_STATE_VIEWPORT,
    VK_DYNAMIC_STATE_END_RANGE = VK_DYNAMIC_STATE_STENCIL_REFERENCE,
    VK_DYNAMIC_STATE_RANGE_SIZE = (VK_DYNAMIC_STATE_STENCIL_REFERENCE - VK_DYNAMIC_STATE_VIEWPORT + 1),
    VK_DYNAMIC_STATE_MAX_ENUM = 0x7FFFFFFF
} VkDynamicState;

typedef enum VkFilter {
    VK_FILTER_NEAREST = 0,
    VK_FILTER_LINEAR = 1,
    VK_FILTER_CUBIC_IMG = 1000015000,
    VK_FILTER_BEGIN_RANGE = VK_FILTER_NEAREST,
    VK_FILTER_END_RANGE = VK_FILTER_LINEAR,
    VK_FILTER_RANGE_SIZE = (VK_FILTER_LINEAR - VK_FILTER_NEAREST + 1),
    VK_FILTER_MAX_ENUM = 0x7FFFFFFF
} VkFilter;

typedef enum VkSamplerMipmapMode {
    VK_SAMPLER_MIPMAP_MODE_NEAREST = 0,
    VK_SAMPLER_MIPMAP_MODE_LINEAR = 1,
    VK_SAMPLER_MIPMAP_MODE_BEGIN_RANGE = VK_SAMPLER_MIPMAP_MODE_NEAREST,
    VK_SAMPLER_MIPMAP_MODE_END_RANGE = VK_SAMPLER_MIPMAP_MODE_LINEAR,
    VK_SAMPLER_MIPMAP_MODE_RANGE_SIZE = (VK_SAMPLER_MIPMAP_MODE_LINEAR - VK_SAMPLER_MIPMAP_MODE_NEAREST + 1),
    VK_SAMPLER_MIPMAP_MODE_MAX_ENUM = 0x7FFFFFFF
} VkSamplerMipmapMode;

typedef enum VkSamplerAddressMode {
    VK_SAMPLER_ADDRESS_MODE_REPEAT = 0,
    VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT = 1,
    VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE = 2,
    VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER = 3,
    VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE = 4,
    VK_SAMPLER_ADDRESS_MODE_BEGIN_RANGE = VK_SAMPLER_ADDRESS_MODE_REPEAT,
    VK_SAMPLER_ADDRESS_MODE_END_RANGE = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER,
    VK_SAMPLER_ADDRESS_MODE_RANGE_SIZE = (VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER - VK_SAMPLER_ADDRESS_MODE_REPEAT + 1),
    VK_SAMPLER_ADDRESS_MODE_MAX_ENUM = 0x7FFFFFFF
} VkSamplerAddressMode;

typedef enum VkBorderColor {
    VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK = 0,
    VK_BORDER_COLOR_INT_TRANSPARENT_BLACK = 1,
    VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK = 2,
    VK_BORDER_COLOR_INT_OPAQUE_BLACK = 3,
    VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE = 4,
    VK_BORDER_COLOR_INT_OPAQUE_WHITE = 5,
    VK_BORDER_COLOR_BEGIN_RANGE = VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK,
    VK_BORDER_COLOR_END_RANGE = VK_BORDER_COLOR_INT_OPAQUE_WHITE,
    VK_BORDER_COLOR_RANGE_SIZE = (VK_BORDER_COLOR_INT_OPAQUE_WHITE - VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK + 1),
    VK_BORDER_COLOR_MAX_ENUM = 0x7FFFFFFF
} VkBorderColor;

typedef enum VkDescriptorType {
    VK_DESCRIPTOR_TYPE_SAMPLER = 0,
    VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER = 1,
    VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE = 2,
    VK_DESCRIPTOR_TYPE_STORAGE_IMAGE = 3,
    VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER = 4,
    VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER = 5,
    VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER = 6,
    VK_DESCRIPTOR_TYPE_STORAGE_BUFFER = 7,
    VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC = 8,
    VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC = 9,
    VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT = 10,
    VK_DESCRIPTOR_TYPE_BEGIN_RANGE = VK_DESCRIPTOR_TYPE_SAMPLER,
    VK_DESCRIPTOR_TYPE_END_RANGE = VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT,
    VK_DESCRIPTOR_TYPE_RANGE_SIZE = (VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT - VK_DESCRIPTOR_TYPE_SAMPLER + 1),
    VK_DESCRIPTOR_TYPE_MAX_ENUM = 0x7FFFFFFF
} VkDescriptorType;

typedef enum VkAttachmentLoadOp {
    VK_ATTACHMENT_LOAD_OP_LOAD = 0,
    VK_ATTACHMENT_LOAD_OP_CLEAR = 1,
    VK_ATTACHMENT_LOAD_OP_DONT_CARE = 2,
    VK_ATTACHMENT_LOAD_OP_BEGIN_RANGE = VK_ATTACHMENT_LOAD_OP_LOAD,
    VK_ATTACHMENT_LOAD_OP_END_RANGE = VK_ATTACHMENT_LOAD_OP_DONT_CARE,
    VK_ATTACHMENT_LOAD_OP_RANGE_SIZE = (VK_ATTACHMENT_LOAD_OP_DONT_CARE - VK_ATTACHMENT_LOAD_OP_LOAD + 1),
    VK_ATTACHMENT_LOAD_OP_MAX_ENUM = 0x7FFFFFFF
} VkAttachmentLoadOp;

typedef enum VkAttachmentStoreOp {
    VK_ATTACHMENT_STORE_OP_STORE = 0,
    VK_ATTACHMENT_STORE_OP_DONT_CARE = 1,
    VK_ATTACHMENT_STORE_OP_BEGIN_RANGE = VK_ATTACHMENT_STORE_OP_STORE,
    VK_ATTACHMENT_STORE_OP_END_RANGE = VK_ATTACHMENT_STORE_OP_DONT_CARE,
    VK_ATTACHMENT_STORE_OP_RANGE_SIZE = (VK_ATTACHMENT_STORE_OP_DONT_CARE - VK_ATTACHMENT_STORE_OP_STORE + 1),
    VK_ATTACHMENT_STORE_OP_MAX_ENUM = 0x7FFFFFFF
} VkAttachmentStoreOp;

typedef enum VkPipelineBindPoint {
    VK_PIPELINE_BIND_POINT_GRAPHICS = 0,
    VK_PIPELINE_BIND_POINT_COMPUTE = 1,
    VK_PIPELINE_BIND_POINT_BEGIN_RANGE = VK_PIPELINE_BIND_POINT_GRAPHICS,
    VK_PIPELINE_BIND_POINT_END_RANGE = VK_PIPELINE_BIND_POINT_COMPUTE,
    VK_PIPELINE_BIND_POINT_RANGE_SIZE = (VK_PIPELINE_BIND_POINT_COMPUTE - VK_PIPELINE_BIND_POINT_GRAPHICS + 1),
    VK_PIPELINE_BIND_POINT_MAX_ENUM = 0x7FFFFFFF
} VkPipelineBindPoint;

typedef enum VkCommandBufferLevel {
    VK_COMMAND_BUFFER_LEVEL_PRIMARY = 0,
    VK_COMMAND_BUFFER_LEVEL_SECONDARY = 1,
    VK_COMMAND_BUFFER_LEVEL_BEGIN_RANGE = VK_COMMAND_BUFFER_LEVEL_PRIMARY,
    VK_COMMAND_BUFFER_LEVEL_END_RANGE = VK_COMMAND_BUFFER_LEVEL_SECONDARY,
    VK_COMMAND_BUFFER_LEVEL_RANGE_SIZE = (VK_COMMAND_BUFFER_LEVEL_SECONDARY - VK_COMMAND_BUFFER_LEVEL_PRIMARY + 1),
    VK_COMMAND_BUFFER_LEVEL_MAX_ENUM = 0x7FFFFFFF
} VkCommandBufferLevel;

typedef enum VkIndexType {
    VK_INDEX_TYPE_UINT16 = 0,
    VK_INDEX_TYPE_UINT32 = 1,
    VK_INDEX_TYPE_BEGIN_RANGE = VK_INDEX_TYPE_UINT16,
    VK_INDEX_TYPE_END_RANGE = VK_INDEX_TYPE_UINT32,
    VK_INDEX_TYPE_RANGE_SIZE = (VK_INDEX_TYPE_UINT32 - VK_INDEX_TYPE_UINT16 + 1),
    VK_INDEX_TYPE_MAX_ENUM = 0x7FFFFFFF
} VkIndexType;

typedef enum VkSubpassContents {
    VK_SUBPASS_CONTENTS_INLINE = 0,
    VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS = 1,
    VK_SUBPASS_CONTENTS_BEGIN_RANGE = VK_SUBPASS_CONTENTS_INLINE,
    VK_SUBPASS_CONTENTS_END_RANGE = VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS,
    VK_SUBPASS_CONTENTS_RANGE_SIZE = (VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS - VK_SUBPASS_CONTENTS_INLINE + 1),
    VK_SUBPASS_CONTENTS_MAX_ENUM = 0x7FFFFFFF
} VkSubpassContents;

typedef enum VkObjectType {
    VK_OBJECT_TYPE_UNKNOWN = 0,
    VK_OBJECT_TYPE_INSTANCE = 1,
    VK_OBJECT_TYPE_PHYSICAL_DEVICE = 2,
    VK_OBJECT_TYPE_DEVICE = 3,
    VK_OBJECT_TYPE_QUEUE = 4,
    VK_OBJECT_TYPE_SEMAPHORE = 5,
    VK_OBJECT_TYPE_COMMAND_BUFFER = 6,
    VK_OBJECT_TYPE_FENCE = 7,
    VK_OBJECT_TYPE_DEVICE_MEMORY = 8,
    VK_OBJECT_TYPE_BUFFER = 9,
    VK_OBJECT_TYPE_IMAGE = 10,
    VK_OBJECT_TYPE_EVENT = 11,
    VK_OBJECT_TYPE_QUERY_POOL = 12,
    VK_OBJECT_TYPE_BUFFER_VIEW = 13,
    VK_OBJECT_TYPE_IMAGE_VIEW = 14,
    VK_OBJECT_TYPE_SHADER_MODULE = 15,
    VK_OBJECT_TYPE_PIPELINE_CACHE = 16,
    VK_OBJECT_TYPE_PIPELINE_LAYOUT = 17,
    VK_OBJECT_TYPE_RENDER_PASS = 18,
    VK_OBJECT_TYPE_PIPELINE = 19,
    VK_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT = 20,
    VK_OBJECT_TYPE_SAMPLER = 21,
    VK_OBJECT_TYPE_DESCRIPTOR_POOL = 22,
    VK_OBJECT_TYPE_DESCRIPTOR_SET = 23,
    VK_OBJECT_TYPE_FRAMEBUFFER = 24,
    VK_OBJECT_TYPE_COMMAND_POOL = 25,
    VK_OBJECT_TYPE_SURFACE_KHR = 1000000000,
    VK_OBJECT_TYPE_SWAPCHAIN_KHR = 1000001000,
    VK_OBJECT_TYPE_DISPLAY_KHR = 1000002000,
    VK_OBJECT_TYPE_DISPLAY_MODE_KHR = 1000002001,
    VK_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT = 1000011000,
    VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR = 1000085000,
    VK_OBJECT_TYPE_OBJECT_TABLE_NVX = 1000086000,
    VK_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NVX = 1000086001,
    VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_KHR = 1000156000,
    VK_OBJECT_TYPE_VALIDATION_CACHE_EXT = 1000160000,
    VK_OBJECT_TYPE_BEGIN_RANGE = VK_OBJECT_TYPE_UNKNOWN,
    VK_OBJECT_TYPE_END_RANGE = VK_OBJECT_TYPE_COMMAND_POOL,
    VK_OBJECT_TYPE_RANGE_SIZE = (VK_OBJECT_TYPE_COMMAND_POOL - VK_OBJECT_TYPE_UNKNOWN + 1),
    VK_OBJECT_TYPE_MAX_ENUM = 0x7FFFFFFF
} VkObjectType;

typedef VkFlags VkInstanceCreateFlags;

typedef enum VkFormatFeatureFlagBits {
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT = 0x00000001,
    VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT = 0x00000002,
    VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT = 0x00000004,
    VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT = 0x00000008,
    VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT = 0x00000010,
    VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT = 0x00000020,
    VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT = 0x00000040,
    VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT = 0x00000080,
    VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT = 0x00000100,
    VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT = 0x00000200,
    VK_FORMAT_FEATURE_BLIT_SRC_BIT = 0x00000400,
    VK_FORMAT_FEATURE_BLIT_DST_BIT = 0x00000800,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT = 0x00001000,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG = 0x00002000,
    VK_FORMAT_FEATURE_TRANSFER_SRC_BIT_KHR = 0x00004000,
    VK_FORMAT_FEATURE_TRANSFER_DST_BIT_KHR = 0x00008000,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT_EXT = 0x00010000,
    VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT_KHR = 0x00020000,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT_KHR = 0x00040000,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT_KHR = 0x00080000,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT_KHR = 0x00100000,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT_KHR = 0x00200000,
    VK_FORMAT_FEATURE_DISJOINT_BIT_KHR = 0x00400000,
    VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT_KHR = 0x00800000,
    VK_FORMAT_FEATURE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkFormatFeatureFlagBits;
typedef VkFlags VkFormatFeatureFlags;

typedef enum VkImageUsageFlagBits {
    VK_IMAGE_USAGE_TRANSFER_SRC_BIT = 0x00000001,
    VK_IMAGE_USAGE_TRANSFER_DST_BIT = 0x00000002,
    VK_IMAGE_USAGE_SAMPLED_BIT = 0x00000004,
    VK_IMAGE_USAGE_STORAGE_BIT = 0x00000008,
    VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT = 0x00000010,
    VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT = 0x00000020,
    VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT = 0x00000040,
    VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT = 0x00000080,
    VK_IMAGE_USAGE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkImageUsageFlagBits;
typedef VkFlags VkImageUsageFlags;

typedef enum VkImageCreateFlagBits {
    VK_IMAGE_CREATE_SPARSE_BINDING_BIT = 0x00000001,
    VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT = 0x00000002,
    VK_IMAGE_CREATE_SPARSE_ALIASED_BIT = 0x00000004,
    VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT = 0x00000008,
    VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT = 0x00000010,
    VK_IMAGE_CREATE_BIND_SFR_BIT_KHX = 0x00000040,
    VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT_KHR = 0x00000020,
    VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT_KHR = 0x00000080,
    VK_IMAGE_CREATE_EXTENDED_USAGE_BIT_KHR = 0x00000100,
    VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT = 0x00001000,
    VK_IMAGE_CREATE_DISJOINT_BIT_KHR = 0x00000200,
    VK_IMAGE_CREATE_ALIAS_BIT_KHR = 0x00000400,
    VK_IMAGE_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkImageCreateFlagBits;
typedef VkFlags VkImageCreateFlags;

typedef enum VkSampleCountFlagBits {
    VK_SAMPLE_COUNT_1_BIT = 0x00000001,
    VK_SAMPLE_COUNT_2_BIT = 0x00000002,
    VK_SAMPLE_COUNT_4_BIT = 0x00000004,
    VK_SAMPLE_COUNT_8_BIT = 0x00000008,
    VK_SAMPLE_COUNT_16_BIT = 0x00000010,
    VK_SAMPLE_COUNT_32_BIT = 0x00000020,
    VK_SAMPLE_COUNT_64_BIT = 0x00000040,
    VK_SAMPLE_COUNT_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkSampleCountFlagBits;
typedef VkFlags VkSampleCountFlags;

typedef enum VkQueueFlagBits {
    VK_QUEUE_GRAPHICS_BIT = 0x00000001,
    VK_QUEUE_COMPUTE_BIT = 0x00000002,
    VK_QUEUE_TRANSFER_BIT = 0x00000004,
    VK_QUEUE_SPARSE_BINDING_BIT = 0x00000008,
    VK_QUEUE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkQueueFlagBits;
typedef VkFlags VkQueueFlags;

typedef enum VkMemoryPropertyFlagBits {
    VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT = 0x00000001,
    VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT = 0x00000002,
    VK_MEMORY_PROPERTY_HOST_COHERENT_BIT = 0x00000004,
    VK_MEMORY_PROPERTY_HOST_CACHED_BIT = 0x00000008,
    VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT = 0x00000010,
    VK_MEMORY_PROPERTY_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkMemoryPropertyFlagBits;
typedef VkFlags VkMemoryPropertyFlags;

typedef enum VkMemoryHeapFlagBits {
    VK_MEMORY_HEAP_DEVICE_LOCAL_BIT = 0x00000001,
    VK_MEMORY_HEAP_MULTI_INSTANCE_BIT_KHX = 0x00000002,
    VK_MEMORY_HEAP_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkMemoryHeapFlagBits;
typedef VkFlags VkMemoryHeapFlags;
typedef VkFlags VkDeviceCreateFlags;
typedef VkFlags VkDeviceQueueCreateFlags;

typedef enum VkPipelineStageFlagBits {
    VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT = 0x00000001,
    VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT = 0x00000002,
    VK_PIPELINE_STAGE_VERTEX_INPUT_BIT = 0x00000004,
    VK_PIPELINE_STAGE_VERTEX_SHADER_BIT = 0x00000008,
    VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT = 0x00000010,
    VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT = 0x00000020,
    VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT = 0x00000040,
    VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT = 0x00000080,
    VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT = 0x00000100,
    VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT = 0x00000200,
    VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT = 0x00000400,
    VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT = 0x00000800,
    VK_PIPELINE_STAGE_TRANSFER_BIT = 0x00001000,
    VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT = 0x00002000,
    VK_PIPELINE_STAGE_HOST_BIT = 0x00004000,
    VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT = 0x00008000,
    VK_PIPELINE_STAGE_ALL_COMMANDS_BIT = 0x00010000,
    VK_PIPELINE_STAGE_COMMAND_PROCESS_BIT_NVX = 0x00020000,
    VK_PIPELINE_STAGE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkPipelineStageFlagBits;
typedef VkFlags VkPipelineStageFlags;
typedef VkFlags VkMemoryMapFlags;

typedef enum VkImageAspectFlagBits {
    VK_IMAGE_ASPECT_COLOR_BIT = 0x00000001,
    VK_IMAGE_ASPECT_DEPTH_BIT = 0x00000002,
    VK_IMAGE_ASPECT_STENCIL_BIT = 0x00000004,
    VK_IMAGE_ASPECT_METADATA_BIT = 0x00000008,
    VK_IMAGE_ASPECT_PLANE_0_BIT_KHR = 0x00000010,
    VK_IMAGE_ASPECT_PLANE_1_BIT_KHR = 0x00000020,
    VK_IMAGE_ASPECT_PLANE_2_BIT_KHR = 0x00000040,
    VK_IMAGE_ASPECT_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkImageAspectFlagBits;
typedef VkFlags VkImageAspectFlags;

typedef enum VkSparseImageFormatFlagBits {
    VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT = 0x00000001,
    VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT = 0x00000002,
    VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT = 0x00000004,
    VK_SPARSE_IMAGE_FORMAT_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkSparseImageFormatFlagBits;
typedef VkFlags VkSparseImageFormatFlags;

typedef enum VkSparseMemoryBindFlagBits {
    VK_SPARSE_MEMORY_BIND_METADATA_BIT = 0x00000001,
    VK_SPARSE_MEMORY_BIND_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkSparseMemoryBindFlagBits;
typedef VkFlags VkSparseMemoryBindFlags;

typedef enum VkFenceCreateFlagBits {
    VK_FENCE_CREATE_SIGNALED_BIT = 0x00000001,
    VK_FENCE_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkFenceCreateFlagBits;
typedef VkFlags VkFenceCreateFlags;
typedef VkFlags VkSemaphoreCreateFlags;
typedef VkFlags VkEventCreateFlags;
typedef VkFlags VkQueryPoolCreateFlags;

typedef enum VkQueryPipelineStatisticFlagBits {
    VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT = 0x00000001,
    VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT = 0x00000002,
    VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT = 0x00000004,
    VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT = 0x00000008,
    VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT = 0x00000010,
    VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT = 0x00000020,
    VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT = 0x00000040,
    VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT = 0x00000080,
    VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT = 0x00000100,
    VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT = 0x00000200,
    VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT = 0x00000400,
    VK_QUERY_PIPELINE_STATISTIC_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkQueryPipelineStatisticFlagBits;
typedef VkFlags VkQueryPipelineStatisticFlags;

typedef enum VkQueryResultFlagBits {
    VK_QUERY_RESULT_64_BIT = 0x00000001,
    VK_QUERY_RESULT_WAIT_BIT = 0x00000002,
    VK_QUERY_RESULT_WITH_AVAILABILITY_BIT = 0x00000004,
    VK_QUERY_RESULT_PARTIAL_BIT = 0x00000008,
    VK_QUERY_RESULT_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkQueryResultFlagBits;
typedef VkFlags VkQueryResultFlags;

typedef enum VkBufferCreateFlagBits {
    VK_BUFFER_CREATE_SPARSE_BINDING_BIT = 0x00000001,
    VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT = 0x00000002,
    VK_BUFFER_CREATE_SPARSE_ALIASED_BIT = 0x00000004,
    VK_BUFFER_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkBufferCreateFlagBits;
typedef VkFlags VkBufferCreateFlags;

typedef enum VkBufferUsageFlagBits {
    VK_BUFFER_USAGE_TRANSFER_SRC_BIT = 0x00000001,
    VK_BUFFER_USAGE_TRANSFER_DST_BIT = 0x00000002,
    VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT = 0x00000004,
    VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT = 0x00000008,
    VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT = 0x00000010,
    VK_BUFFER_USAGE_STORAGE_BUFFER_BIT = 0x00000020,
    VK_BUFFER_USAGE_INDEX_BUFFER_BIT = 0x00000040,
    VK_BUFFER_USAGE_VERTEX_BUFFER_BIT = 0x00000080,
    VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT = 0x00000100,
    VK_BUFFER_USAGE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkBufferUsageFlagBits;
typedef VkFlags VkBufferUsageFlags;
typedef VkFlags VkBufferViewCreateFlags;
typedef VkFlags VkImageViewCreateFlags;
typedef VkFlags VkShaderModuleCreateFlags;
typedef VkFlags VkPipelineCacheCreateFlags;

typedef enum VkPipelineCreateFlagBits {
    VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT = 0x00000001,
    VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT = 0x00000002,
    VK_PIPELINE_CREATE_DERIVATIVE_BIT = 0x00000004,
    VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT_KHX = 0x00000008,
    VK_PIPELINE_CREATE_DISPATCH_BASE_KHX = 0x00000010,
    VK_PIPELINE_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkPipelineCreateFlagBits;
typedef VkFlags VkPipelineCreateFlags;
typedef VkFlags VkPipelineShaderStageCreateFlags;

typedef enum VkShaderStageFlagBits {
    VK_SHADER_STAGE_VERTEX_BIT = 0x00000001,
    VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT = 0x00000002,
    VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT = 0x00000004,
    VK_SHADER_STAGE_GEOMETRY_BIT = 0x00000008,
    VK_SHADER_STAGE_FRAGMENT_BIT = 0x00000010,
    VK_SHADER_STAGE_COMPUTE_BIT = 0x00000020,
    VK_SHADER_STAGE_ALL_GRAPHICS = 0x0000001F,
    VK_SHADER_STAGE_ALL = 0x7FFFFFFF,
    VK_SHADER_STAGE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkShaderStageFlagBits;
typedef VkFlags VkPipelineVertexInputStateCreateFlags;
typedef VkFlags VkPipelineInputAssemblyStateCreateFlags;
typedef VkFlags VkPipelineTessellationStateCreateFlags;
typedef VkFlags VkPipelineViewportStateCreateFlags;
typedef VkFlags VkPipelineRasterizationStateCreateFlags;

typedef enum VkCullModeFlagBits {
    VK_CULL_MODE_NONE = 0,
    VK_CULL_MODE_FRONT_BIT = 0x00000001,
    VK_CULL_MODE_BACK_BIT = 0x00000002,
    VK_CULL_MODE_FRONT_AND_BACK = 0x00000003,
    VK_CULL_MODE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkCullModeFlagBits;
typedef VkFlags VkCullModeFlags;
typedef VkFlags VkPipelineMultisampleStateCreateFlags;
typedef VkFlags VkPipelineDepthStencilStateCreateFlags;
typedef VkFlags VkPipelineColorBlendStateCreateFlags;

typedef enum VkColorComponentFlagBits {
    VK_COLOR_COMPONENT_R_BIT = 0x00000001,
    VK_COLOR_COMPONENT_G_BIT = 0x00000002,
    VK_COLOR_COMPONENT_B_BIT = 0x00000004,
    VK_COLOR_COMPONENT_A_BIT = 0x00000008,
    VK_COLOR_COMPONENT_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkColorComponentFlagBits;
typedef VkFlags VkColorComponentFlags;
typedef VkFlags VkPipelineDynamicStateCreateFlags;
typedef VkFlags VkPipelineLayoutCreateFlags;
typedef VkFlags VkShaderStageFlags;
typedef VkFlags VkSamplerCreateFlags;

typedef enum VkDescriptorSetLayoutCreateFlagBits {
    VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR = 0x00000001,
    VK_DESCRIPTOR_SET_LAYOUT_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkDescriptorSetLayoutCreateFlagBits;
typedef VkFlags VkDescriptorSetLayoutCreateFlags;

typedef enum VkDescriptorPoolCreateFlagBits {
    VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT = 0x00000001,
    VK_DESCRIPTOR_POOL_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkDescriptorPoolCreateFlagBits;
typedef VkFlags VkDescriptorPoolCreateFlags;
typedef VkFlags VkDescriptorPoolResetFlags;
typedef VkFlags VkFramebufferCreateFlags;
typedef VkFlags VkRenderPassCreateFlags;

typedef enum VkAttachmentDescriptionFlagBits {
    VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT = 0x00000001,
    VK_ATTACHMENT_DESCRIPTION_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkAttachmentDescriptionFlagBits;
typedef VkFlags VkAttachmentDescriptionFlags;

typedef enum VkSubpassDescriptionFlagBits {
    VK_SUBPASS_DESCRIPTION_PER_VIEW_ATTRIBUTES_BIT_NVX = 0x00000001,
    VK_SUBPASS_DESCRIPTION_PER_VIEW_POSITION_X_ONLY_BIT_NVX = 0x00000002,
    VK_SUBPASS_DESCRIPTION_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkSubpassDescriptionFlagBits;
typedef VkFlags VkSubpassDescriptionFlags;

typedef enum VkAccessFlagBits {
    VK_ACCESS_INDIRECT_COMMAND_READ_BIT = 0x00000001,
    VK_ACCESS_INDEX_READ_BIT = 0x00000002,
    VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT = 0x00000004,
    VK_ACCESS_UNIFORM_READ_BIT = 0x00000008,
    VK_ACCESS_INPUT_ATTACHMENT_READ_BIT = 0x00000010,
    VK_ACCESS_SHADER_READ_BIT = 0x00000020,
    VK_ACCESS_SHADER_WRITE_BIT = 0x00000040,
    VK_ACCESS_COLOR_ATTACHMENT_READ_BIT = 0x00000080,
    VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT = 0x00000100,
    VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT = 0x00000200,
    VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT = 0x00000400,
    VK_ACCESS_TRANSFER_READ_BIT = 0x00000800,
    VK_ACCESS_TRANSFER_WRITE_BIT = 0x00001000,
    VK_ACCESS_HOST_READ_BIT = 0x00002000,
    VK_ACCESS_HOST_WRITE_BIT = 0x00004000,
    VK_ACCESS_MEMORY_READ_BIT = 0x00008000,
    VK_ACCESS_MEMORY_WRITE_BIT = 0x00010000,
    VK_ACCESS_COMMAND_PROCESS_READ_BIT_NVX = 0x00020000,
    VK_ACCESS_COMMAND_PROCESS_WRITE_BIT_NVX = 0x00040000,
    VK_ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT = 0x00080000,
    VK_ACCESS_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkAccessFlagBits;
typedef VkFlags VkAccessFlags;

typedef enum VkDependencyFlagBits {
    VK_DEPENDENCY_BY_REGION_BIT = 0x00000001,
    VK_DEPENDENCY_VIEW_LOCAL_BIT_KHX = 0x00000002,
    VK_DEPENDENCY_DEVICE_GROUP_BIT_KHX = 0x00000004,
    VK_DEPENDENCY_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkDependencyFlagBits;
typedef VkFlags VkDependencyFlags;

typedef enum VkCommandPoolCreateFlagBits {
    VK_COMMAND_POOL_CREATE_TRANSIENT_BIT = 0x00000001,
    VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT = 0x00000002,
    VK_COMMAND_POOL_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkCommandPoolCreateFlagBits;
typedef VkFlags VkCommandPoolCreateFlags;

typedef enum VkCommandPoolResetFlagBits {
    VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT = 0x00000001,
    VK_COMMAND_POOL_RESET_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkCommandPoolResetFlagBits;
typedef VkFlags VkCommandPoolResetFlags;

typedef enum VkCommandBufferUsageFlagBits {
    VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT = 0x00000001,
    VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT = 0x00000002,
    VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT = 0x00000004,
    VK_COMMAND_BUFFER_USAGE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkCommandBufferUsageFlagBits;
typedef VkFlags VkCommandBufferUsageFlags;

typedef enum VkQueryControlFlagBits {
    VK_QUERY_CONTROL_PRECISE_BIT = 0x00000001,
    VK_QUERY_CONTROL_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkQueryControlFlagBits;
typedef VkFlags VkQueryControlFlags;

typedef enum VkCommandBufferResetFlagBits {
    VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT = 0x00000001,
    VK_COMMAND_BUFFER_RESET_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkCommandBufferResetFlagBits;
typedef VkFlags VkCommandBufferResetFlags;

typedef enum VkStencilFaceFlagBits {
    VK_STENCIL_FACE_FRONT_BIT = 0x00000001,
    VK_STENCIL_FACE_BACK_BIT = 0x00000002,
    VK_STENCIL_FRONT_AND_BACK = 0x00000003,
    VK_STENCIL_FACE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkStencilFaceFlagBits;
typedef VkFlags VkStencilFaceFlags;

typedef struct VkApplicationInfo {
    VkStructureType    sType;
    const void*        pNext;
    const char*        pApplicationName;
    uint32_t           applicationVersion;
    const char*        pEngineName;
    uint32_t           engineVersion;
    uint32_t           apiVersion;
} VkApplicationInfo;

struct VkApplicationInfoRAII {
   VkApplicationInfo nonRaiiObj;
    std::string                                 strApplicationName;
    std::string                                 strEngineName;
};

typedef struct VkInstanceCreateInfo {
    VkStructureType             sType;
    const void*                 pNext;
    VkInstanceCreateFlags       flags;
    const VkApplicationInfo*    pApplicationInfo;
    uint32_t                    enabledLayerCount;
    const char* const*          ppEnabledLayerNames;
    uint32_t                    enabledExtensionCount;
    const char* const*          ppEnabledExtensionNames;
} VkInstanceCreateInfo;

struct VkInstanceCreateInfoRAII {
   VkInstanceCreateInfo nonRaiiObj;
    std::shared_ptr<VkApplicationInfoRAII>      pApplicationInfo;
    std::vector<std::string>                    vecEnabledLayerNames;
    std::vector<const char *>                   vecPtrEnabledLayerNames;
    std::vector<std::string>                    vecEnabledExtensionNames;
    std::vector<const char *>                   vecPtrEnabledExtensionNames;
};

typedef void* (VKAPI_PTR *PFN_vkAllocationFunction)(
    void*                                       pUserData,
    size_t                                      size,
    size_t                                      alignment,
    VkSystemAllocationScope                     allocationScope);

typedef void* (VKAPI_PTR *PFN_vkReallocationFunction)(
    void*                                       pUserData,
    void*                                       pOriginal,
    size_t                                      size,
    size_t                                      alignment,
    VkSystemAllocationScope                     allocationScope);

typedef void (VKAPI_PTR *PFN_vkFreeFunction)(
    void*                                       pUserData,
    void*                                       pMemory);

typedef void (VKAPI_PTR *PFN_vkInternalAllocationNotification)(
    void*                                       pUserData,
    size_t                                      size,
    VkInternalAllocationType                    allocationType,
    VkSystemAllocationScope                     allocationScope);

typedef void (VKAPI_PTR *PFN_vkInternalFreeNotification)(
    void*                                       pUserData,
    size_t                                      size,
    VkInternalAllocationType                    allocationType,
    VkSystemAllocationScope                     allocationScope);

typedef struct VkAllocationCallbacks {
    void*                                   pUserData;
    PFN_vkAllocationFunction                pfnAllocation;
    PFN_vkReallocationFunction              pfnReallocation;
    PFN_vkFreeFunction                      pfnFree;
    PFN_vkInternalAllocationNotification    pfnInternalAllocation;
    PFN_vkInternalFreeNotification          pfnInternalFree;
} VkAllocationCallbacks;

typedef struct VkPhysicalDeviceFeatures {
    VkBool32    robustBufferAccess;
    VkBool32    fullDrawIndexUint32;
    VkBool32    imageCubeArray;
    VkBool32    independentBlend;
    VkBool32    geometryShader;
    VkBool32    tessellationShader;
    VkBool32    sampleRateShading;
    VkBool32    dualSrcBlend;
    VkBool32    logicOp;
    VkBool32    multiDrawIndirect;
    VkBool32    drawIndirectFirstInstance;
    VkBool32    depthClamp;
    VkBool32    depthBiasClamp;
    VkBool32    fillModeNonSolid;
    VkBool32    depthBounds;
    VkBool32    wideLines;
    VkBool32    largePoints;
    VkBool32    alphaToOne;
    VkBool32    multiViewport;
    VkBool32    samplerAnisotropy;
    VkBool32    textureCompressionETC2;
    VkBool32    textureCompressionASTC_LDR;
    VkBool32    textureCompressionBC;
    VkBool32    occlusionQueryPrecise;
    VkBool32    pipelineStatisticsQuery;
    VkBool32    vertexPipelineStoresAndAtomics;
    VkBool32    fragmentStoresAndAtomics;
    VkBool32    shaderTessellationAndGeometryPointSize;
    VkBool32    shaderImageGatherExtended;
    VkBool32    shaderStorageImageExtendedFormats;
    VkBool32    shaderStorageImageMultisample;
    VkBool32    shaderStorageImageReadWithoutFormat;
    VkBool32    shaderStorageImageWriteWithoutFormat;
    VkBool32    shaderUniformBufferArrayDynamicIndexing;
    VkBool32    shaderSampledImageArrayDynamicIndexing;
    VkBool32    shaderStorageBufferArrayDynamicIndexing;
    VkBool32    shaderStorageImageArrayDynamicIndexing;
    VkBool32    shaderClipDistance;
    VkBool32    shaderCullDistance;
    VkBool32    shaderFloat64;
    VkBool32    shaderInt64;
    VkBool32    shaderInt16;
    VkBool32    shaderResourceResidency;
    VkBool32    shaderResourceMinLod;
    VkBool32    sparseBinding;
    VkBool32    sparseResidencyBuffer;
    VkBool32    sparseResidencyImage2D;
    VkBool32    sparseResidencyImage3D;
    VkBool32    sparseResidency2Samples;
    VkBool32    sparseResidency4Samples;
    VkBool32    sparseResidency8Samples;
    VkBool32    sparseResidency16Samples;
    VkBool32    sparseResidencyAliased;
    VkBool32    variableMultisampleRate;
    VkBool32    inheritedQueries;
} VkPhysicalDeviceFeatures;

typedef struct VkFormatProperties {
    VkFormatFeatureFlags    linearTilingFeatures;
    VkFormatFeatureFlags    optimalTilingFeatures;
    VkFormatFeatureFlags    bufferFeatures;
} VkFormatProperties;

typedef struct VkExtent3D {
    uint32_t    width;
    uint32_t    height;
    uint32_t    depth;
} VkExtent3D;

typedef struct VkImageFormatProperties {
    VkExtent3D            maxExtent;
    uint32_t              maxMipLevels;
    uint32_t              maxArrayLayers;
    VkSampleCountFlags    sampleCounts;
    VkDeviceSize          maxResourceSize;
} VkImageFormatProperties;

typedef struct VkPhysicalDeviceLimits {
    uint32_t              maxImageDimension1D;
    uint32_t              maxImageDimension2D;
    uint32_t              maxImageDimension3D;
    uint32_t              maxImageDimensionCube;
    uint32_t              maxImageArrayLayers;
    uint32_t              maxTexelBufferElements;
    uint32_t              maxUniformBufferRange;
    uint32_t              maxStorageBufferRange;
    uint32_t              maxPushConstantsSize;
    uint32_t              maxMemoryAllocationCount;
    uint32_t              maxSamplerAllocationCount;
    VkDeviceSize          bufferImageGranularity;
    VkDeviceSize          sparseAddressSpaceSize;
    uint32_t              maxBoundDescriptorSets;
    uint32_t              maxPerStageDescriptorSamplers;
    uint32_t              maxPerStageDescriptorUniformBuffers;
    uint32_t              maxPerStageDescriptorStorageBuffers;
    uint32_t              maxPerStageDescriptorSampledImages;
    uint32_t              maxPerStageDescriptorStorageImages;
    uint32_t              maxPerStageDescriptorInputAttachments;
    uint32_t              maxPerStageResources;
    uint32_t              maxDescriptorSetSamplers;
    uint32_t              maxDescriptorSetUniformBuffers;
    uint32_t              maxDescriptorSetUniformBuffersDynamic;
    uint32_t              maxDescriptorSetStorageBuffers;
    uint32_t              maxDescriptorSetStorageBuffersDynamic;
    uint32_t              maxDescriptorSetSampledImages;
    uint32_t              maxDescriptorSetStorageImages;
    uint32_t              maxDescriptorSetInputAttachments;
    uint32_t              maxVertexInputAttributes;
    uint32_t              maxVertexInputBindings;
    uint32_t              maxVertexInputAttributeOffset;
    uint32_t              maxVertexInputBindingStride;
    uint32_t              maxVertexOutputComponents;
    uint32_t              maxTessellationGenerationLevel;
    uint32_t              maxTessellationPatchSize;
    uint32_t              maxTessellationControlPerVertexInputComponents;
    uint32_t              maxTessellationControlPerVertexOutputComponents;
    uint32_t              maxTessellationControlPerPatchOutputComponents;
    uint32_t              maxTessellationControlTotalOutputComponents;
    uint32_t              maxTessellationEvaluationInputComponents;
    uint32_t              maxTessellationEvaluationOutputComponents;
    uint32_t              maxGeometryShaderInvocations;
    uint32_t              maxGeometryInputComponents;
    uint32_t              maxGeometryOutputComponents;
    uint32_t              maxGeometryOutputVertices;
    uint32_t              maxGeometryTotalOutputComponents;
    uint32_t              maxFragmentInputComponents;
    uint32_t              maxFragmentOutputAttachments;
    uint32_t              maxFragmentDualSrcAttachments;
    uint32_t              maxFragmentCombinedOutputResources;
    uint32_t              maxComputeSharedMemorySize;
    uint32_t              maxComputeWorkGroupCount[3];
    uint32_t              maxComputeWorkGroupInvocations;
    uint32_t              maxComputeWorkGroupSize[3];
    uint32_t              subPixelPrecisionBits;
    uint32_t              subTexelPrecisionBits;
    uint32_t              mipmapPrecisionBits;
    uint32_t              maxDrawIndexedIndexValue;
    uint32_t              maxDrawIndirectCount;
    float                 maxSamplerLodBias;
    float                 maxSamplerAnisotropy;
    uint32_t              maxViewports;
    uint32_t              maxViewportDimensions[2];
    float                 viewportBoundsRange[2];
    uint32_t              viewportSubPixelBits;
    size_t                minMemoryMapAlignment;
    VkDeviceSize          minTexelBufferOffsetAlignment;
    VkDeviceSize          minUniformBufferOffsetAlignment;
    VkDeviceSize          minStorageBufferOffsetAlignment;
    int32_t               minTexelOffset;
    uint32_t              maxTexelOffset;
    int32_t               minTexelGatherOffset;
    uint32_t              maxTexelGatherOffset;
    float                 minInterpolationOffset;
    float                 maxInterpolationOffset;
    uint32_t              subPixelInterpolationOffsetBits;
    uint32_t              maxFramebufferWidth;
    uint32_t              maxFramebufferHeight;
    uint32_t              maxFramebufferLayers;
    VkSampleCountFlags    framebufferColorSampleCounts;
    VkSampleCountFlags    framebufferDepthSampleCounts;
    VkSampleCountFlags    framebufferStencilSampleCounts;
    VkSampleCountFlags    framebufferNoAttachmentsSampleCounts;
    uint32_t              maxColorAttachments;
    VkSampleCountFlags    sampledImageColorSampleCounts;
    VkSampleCountFlags    sampledImageIntegerSampleCounts;
    VkSampleCountFlags    sampledImageDepthSampleCounts;
    VkSampleCountFlags    sampledImageStencilSampleCounts;
    VkSampleCountFlags    storageImageSampleCounts;
    uint32_t              maxSampleMaskWords;
    VkBool32              timestampComputeAndGraphics;
    float                 timestampPeriod;
    uint32_t              maxClipDistances;
    uint32_t              maxCullDistances;
    uint32_t              maxCombinedClipAndCullDistances;
    uint32_t              discreteQueuePriorities;
    float                 pointSizeRange[2];
    float                 lineWidthRange[2];
    float                 pointSizeGranularity;
    float                 lineWidthGranularity;
    VkBool32              strictLines;
    VkBool32              standardSampleLocations;
    VkDeviceSize          optimalBufferCopyOffsetAlignment;
    VkDeviceSize          optimalBufferCopyRowPitchAlignment;
    VkDeviceSize          nonCoherentAtomSize;
} VkPhysicalDeviceLimits;

typedef struct VkPhysicalDeviceSparseProperties {
    VkBool32    residencyStandard2DBlockShape;
    VkBool32    residencyStandard2DMultisampleBlockShape;
    VkBool32    residencyStandard3DBlockShape;
    VkBool32    residencyAlignedMipSize;
    VkBool32    residencyNonResidentStrict;
} VkPhysicalDeviceSparseProperties;

typedef struct VkPhysicalDeviceProperties {
    uint32_t                            apiVersion;
    uint32_t                            driverVersion;
    uint32_t                            vendorID;
    uint32_t                            deviceID;
    VkPhysicalDeviceType                deviceType;
    char                                deviceName[VK_MAX_PHYSICAL_DEVICE_NAME_SIZE];
    uint8_t                             pipelineCacheUUID[VK_UUID_SIZE];
    VkPhysicalDeviceLimits              limits;
    VkPhysicalDeviceSparseProperties    sparseProperties;
} VkPhysicalDeviceProperties;

typedef struct VkQueueFamilyProperties {
    VkQueueFlags    queueFlags;
    uint32_t        queueCount;
    uint32_t        timestampValidBits;
    VkExtent3D      minImageTransferGranularity;
} VkQueueFamilyProperties;

typedef struct VkMemoryType {
    VkMemoryPropertyFlags    propertyFlags;
    uint32_t                 heapIndex;
} VkMemoryType;

typedef struct VkMemoryHeap {
    VkDeviceSize         size;
    VkMemoryHeapFlags    flags;
} VkMemoryHeap;

typedef struct VkPhysicalDeviceMemoryProperties {
    uint32_t        memoryTypeCount;
    VkMemoryType    memoryTypes[VK_MAX_MEMORY_TYPES];
    uint32_t        memoryHeapCount;
    VkMemoryHeap    memoryHeaps[VK_MAX_MEMORY_HEAPS];
} VkPhysicalDeviceMemoryProperties;

typedef void (VKAPI_PTR *PFN_vkVoidFunction)(void);
typedef struct VkDeviceQueueCreateInfo {
    VkStructureType             sType;
    const void*                 pNext;
    VkDeviceQueueCreateFlags    flags;
    uint32_t                    queueFamilyIndex;
    uint32_t                    queueCount;
    const float*                pQueuePriorities;
} VkDeviceQueueCreateInfo;

struct VkDeviceQueueCreateInfoRAII {
   VkDeviceQueueCreateInfo nonRaiiObj;
    std::vector<float>                          vecQueuePriorities;
};

typedef struct VkDeviceCreateInfo {
    VkStructureType                    sType;
    const void*                        pNext;
    VkDeviceCreateFlags                flags;
    uint32_t                           queueCreateInfoCount;
    const VkDeviceQueueCreateInfo*     pQueueCreateInfos;
    uint32_t                           enabledLayerCount;
    const char* const*                 ppEnabledLayerNames;
    uint32_t                           enabledExtensionCount;
    const char* const*                 ppEnabledExtensionNames;
    const VkPhysicalDeviceFeatures*    pEnabledFeatures;
} VkDeviceCreateInfo;

struct VkDeviceCreateInfoRAII {
   VkDeviceCreateInfo nonRaiiObj;
    std::vector<VkDeviceQueueCreateInfo>        vecQueueCreateInfos;
    std::vector<std::string>                    vecEnabledLayerNames;
    std::vector<const char *>                   vecPtrEnabledLayerNames;
    std::vector<std::string>                    vecEnabledExtensionNames;
    std::vector<const char *>                   vecPtrEnabledExtensionNames;
    std::shared_ptr<VkPhysicalDeviceFeatures>   pEnabledFeatures;
};

typedef struct VkExtensionProperties {
    char        extensionName[VK_MAX_EXTENSION_NAME_SIZE];
    uint32_t    specVersion;
} VkExtensionProperties;

typedef struct VkLayerProperties {
    char        layerName[VK_MAX_EXTENSION_NAME_SIZE];
    uint32_t    specVersion;
    uint32_t    implementationVersion;
    char        description[VK_MAX_DESCRIPTION_SIZE];
} VkLayerProperties;

typedef struct VkSubmitInfo {
    VkStructureType                sType;
    const void*                    pNext;
    uint32_t                       waitSemaphoreCount;
    const VkSemaphore*             pWaitSemaphores;
    const VkPipelineStageFlags*    pWaitDstStageMask;
    uint32_t                       commandBufferCount;
    const VkCommandBuffer*         pCommandBuffers;
    uint32_t                       signalSemaphoreCount;
    const VkSemaphore*             pSignalSemaphores;
} VkSubmitInfo;

struct VkSubmitInfoRAII {
   VkSubmitInfo nonRaiiObj;
    std::vector<VkSemaphore>                    vecWaitSemaphores;
    std::vector<VkPipelineStageFlags>           vecWaitDstStageMask;
    std::vector<VkCommandBuffer>                vecCommandBuffers;
    std::vector<VkSemaphore>                    vecSignalSemaphores;
};

typedef struct VkMemoryAllocateInfo {
    VkStructureType    sType;
    const void*        pNext;
    VkDeviceSize       allocationSize;
    uint32_t           memoryTypeIndex;
} VkMemoryAllocateInfo;

typedef struct VkMappedMemoryRange {
    VkStructureType    sType;
    const void*        pNext;
    VkDeviceMemory     memory;
    VkDeviceSize       offset;
    VkDeviceSize       size;
} VkMappedMemoryRange;

typedef struct VkMemoryRequirements {
    VkDeviceSize    size;
    VkDeviceSize    alignment;
    uint32_t        memoryTypeBits;
} VkMemoryRequirements;

typedef struct VkSparseImageFormatProperties {
    VkImageAspectFlags          aspectMask;
    VkExtent3D                  imageGranularity;
    VkSparseImageFormatFlags    flags;
} VkSparseImageFormatProperties;

typedef struct VkSparseImageMemoryRequirements {
    VkSparseImageFormatProperties    formatProperties;
    uint32_t                         imageMipTailFirstLod;
    VkDeviceSize                     imageMipTailSize;
    VkDeviceSize                     imageMipTailOffset;
    VkDeviceSize                     imageMipTailStride;
} VkSparseImageMemoryRequirements;

typedef struct VkSparseMemoryBind {
    VkDeviceSize               resourceOffset;
    VkDeviceSize               size;
    VkDeviceMemory             memory;
    VkDeviceSize               memoryOffset;
    VkSparseMemoryBindFlags    flags;
} VkSparseMemoryBind;

typedef struct VkSparseBufferMemoryBindInfo {
    VkBuffer                     buffer;
    uint32_t                     bindCount;
    const VkSparseMemoryBind*    pBinds;
} VkSparseBufferMemoryBindInfo;

struct VkSparseBufferMemoryBindInfoRAII {
   VkSparseBufferMemoryBindInfo nonRaiiObj;
    std::vector<VkSparseMemoryBind>             vecBinds;
};

typedef struct VkSparseImageOpaqueMemoryBindInfo {
    VkImage                      image;
    uint32_t                     bindCount;
    const VkSparseMemoryBind*    pBinds;
} VkSparseImageOpaqueMemoryBindInfo;

struct VkSparseImageOpaqueMemoryBindInfoRAII {
   VkSparseImageOpaqueMemoryBindInfo nonRaiiObj;
    std::vector<VkSparseMemoryBind>             vecBinds;
};

typedef struct VkImageSubresource {
    VkImageAspectFlags    aspectMask;
    uint32_t              mipLevel;
    uint32_t              arrayLayer;
} VkImageSubresource;

typedef struct VkOffset3D {
    int32_t    x;
    int32_t    y;
    int32_t    z;
} VkOffset3D;

typedef struct VkSparseImageMemoryBind {
    VkImageSubresource         subresource;
    VkOffset3D                 offset;
    VkExtent3D                 extent;
    VkDeviceMemory             memory;
    VkDeviceSize               memoryOffset;
    VkSparseMemoryBindFlags    flags;
} VkSparseImageMemoryBind;

typedef struct VkSparseImageMemoryBindInfo {
    VkImage                           image;
    uint32_t                          bindCount;
    const VkSparseImageMemoryBind*    pBinds;
} VkSparseImageMemoryBindInfo;

struct VkSparseImageMemoryBindInfoRAII {
   VkSparseImageMemoryBindInfo nonRaiiObj;
    std::vector<VkSparseImageMemoryBind>        vecBinds;
};

typedef struct VkBindSparseInfo {
    VkStructureType                             sType;
    const void*                                 pNext;
    uint32_t                                    waitSemaphoreCount;
    const VkSemaphore*                          pWaitSemaphores;
    uint32_t                                    bufferBindCount;
    const VkSparseBufferMemoryBindInfo*         pBufferBinds;
    uint32_t                                    imageOpaqueBindCount;
    const VkSparseImageOpaqueMemoryBindInfo*    pImageOpaqueBinds;
    uint32_t                                    imageBindCount;
    const VkSparseImageMemoryBindInfo*          pImageBinds;
    uint32_t                                    signalSemaphoreCount;
    const VkSemaphore*                          pSignalSemaphores;
} VkBindSparseInfo;

struct VkBindSparseInfoRAII {
   VkBindSparseInfo nonRaiiObj;
    std::vector<VkSemaphore>                    vecWaitSemaphores;
    std::vector<VkSparseBufferMemoryBindInfo>   vecBufferBinds;
    std::vector<VkSparseImageOpaqueMemoryBindInfo>vecImageOpaqueBinds;
    std::vector<VkSparseImageMemoryBindInfo>    vecImageBinds;
    std::vector<VkSemaphore>                    vecSignalSemaphores;
};

typedef struct VkFenceCreateInfo {
    VkStructureType       sType;
    const void*           pNext;
    VkFenceCreateFlags    flags;
} VkFenceCreateInfo;

typedef struct VkSemaphoreCreateInfo {
    VkStructureType           sType;
    const void*               pNext;
    VkSemaphoreCreateFlags    flags;
} VkSemaphoreCreateInfo;

typedef struct VkEventCreateInfo {
    VkStructureType       sType;
    const void*           pNext;
    VkEventCreateFlags    flags;
} VkEventCreateInfo;

typedef struct VkQueryPoolCreateInfo {
    VkStructureType                  sType;
    const void*                      pNext;
    VkQueryPoolCreateFlags           flags;
    VkQueryType                      queryType;
    uint32_t                         queryCount;
    VkQueryPipelineStatisticFlags    pipelineStatistics;
} VkQueryPoolCreateInfo;

typedef struct VkBufferCreateInfo {
    VkStructureType        sType;
    const void*            pNext;
    VkBufferCreateFlags    flags;
    VkDeviceSize           size;
    VkBufferUsageFlags     usage;
    VkSharingMode          sharingMode;
    uint32_t               queueFamilyIndexCount;
    const uint32_t*        pQueueFamilyIndices;
} VkBufferCreateInfo;

struct VkBufferCreateInfoRAII {
   VkBufferCreateInfo nonRaiiObj;
    std::vector<uint32_t>                       vecQueueFamilyIndices;
};

typedef struct VkBufferViewCreateInfo {
    VkStructureType            sType;
    const void*                pNext;
    VkBufferViewCreateFlags    flags;
    VkBuffer                   buffer;
    VkFormat                   format;
    VkDeviceSize               offset;
    VkDeviceSize               range;
} VkBufferViewCreateInfo;

typedef struct VkImageCreateInfo {
    VkStructureType          sType;
    const void*              pNext;
    VkImageCreateFlags       flags;
    VkImageType              imageType;
    VkFormat                 format;
    VkExtent3D               extent;
    uint32_t                 mipLevels;
    uint32_t                 arrayLayers;
    VkSampleCountFlagBits    samples;
    VkImageTiling            tiling;
    VkImageUsageFlags        usage;
    VkSharingMode            sharingMode;
    uint32_t                 queueFamilyIndexCount;
    const uint32_t*          pQueueFamilyIndices;
    VkImageLayout            initialLayout;
} VkImageCreateInfo;

struct VkImageCreateInfoRAII {
   VkImageCreateInfo nonRaiiObj;
    std::vector<uint32_t>                       vecQueueFamilyIndices;
};

typedef struct VkSubresourceLayout {
    VkDeviceSize    offset;
    VkDeviceSize    size;
    VkDeviceSize    rowPitch;
    VkDeviceSize    arrayPitch;
    VkDeviceSize    depthPitch;
} VkSubresourceLayout;

typedef struct VkComponentMapping {
    VkComponentSwizzle    r;
    VkComponentSwizzle    g;
    VkComponentSwizzle    b;
    VkComponentSwizzle    a;
} VkComponentMapping;

typedef struct VkImageSubresourceRange {
    VkImageAspectFlags    aspectMask;
    uint32_t              baseMipLevel;
    uint32_t              levelCount;
    uint32_t              baseArrayLayer;
    uint32_t              layerCount;
} VkImageSubresourceRange;

typedef struct VkImageViewCreateInfo {
    VkStructureType            sType;
    const void*                pNext;
    VkImageViewCreateFlags     flags;
    VkImage                    image;
    VkImageViewType            viewType;
    VkFormat                   format;
    VkComponentMapping         components;
    VkImageSubresourceRange    subresourceRange;
} VkImageViewCreateInfo;

typedef struct VkShaderModuleCreateInfo {
    VkStructureType              sType;
    const void*                  pNext;
    VkShaderModuleCreateFlags    flags;
    size_t                       codeSize;
    const uint32_t*              pCode;
} VkShaderModuleCreateInfo;

struct VkShaderModuleCreateInfoRAII {
   VkShaderModuleCreateInfo nonRaiiObj;
    std::vector<uint32_t>                       vecCode;
};

typedef struct VkPipelineCacheCreateInfo {
    VkStructureType               sType;
    const void*                   pNext;
    VkPipelineCacheCreateFlags    flags;
    size_t                        initialDataSize;
    const void*                   pInitialData;
} VkPipelineCacheCreateInfo;

struct VkPipelineCacheCreateInfoRAII {
   VkPipelineCacheCreateInfo nonRaiiObj;
    std::vector<uint8_t>                        vecInitialData;
};

typedef struct VkSpecializationMapEntry {
    uint32_t    constantID;
    uint32_t    offset;
    size_t      size;
} VkSpecializationMapEntry;

typedef struct VkSpecializationInfo {
    uint32_t                           mapEntryCount;
    const VkSpecializationMapEntry*    pMapEntries;
    size_t                             dataSize;
    const void*                        pData;
} VkSpecializationInfo;

struct VkSpecializationInfoRAII {
   VkSpecializationInfo nonRaiiObj;
    std::vector<VkSpecializationMapEntry>       vecMapEntries;
    std::vector<uint8_t>                        vecData;
};

typedef struct VkPipelineShaderStageCreateInfo {
    VkStructureType                     sType;
    const void*                         pNext;
    VkPipelineShaderStageCreateFlags    flags;
    VkShaderStageFlagBits               stage;
    VkShaderModule                      module;
    const char*                         pName;
    const VkSpecializationInfo*         pSpecializationInfo;
} VkPipelineShaderStageCreateInfo;

struct VkPipelineShaderStageCreateInfoRAII {
   VkPipelineShaderStageCreateInfo nonRaiiObj;
    std::string                                 strName;
    std::shared_ptr<VkSpecializationInfoRAII>   pSpecializationInfo;
};

typedef struct VkVertexInputBindingDescription {
    uint32_t             binding;
    uint32_t             stride;
    VkVertexInputRate    inputRate;
} VkVertexInputBindingDescription;

typedef struct VkVertexInputAttributeDescription {
    uint32_t    location;
    uint32_t    binding;
    VkFormat    format;
    uint32_t    offset;
} VkVertexInputAttributeDescription;

typedef struct VkPipelineVertexInputStateCreateInfo {
    VkStructureType                             sType;
    const void*                                 pNext;
    VkPipelineVertexInputStateCreateFlags       flags;
    uint32_t                                    vertexBindingDescriptionCount;
    const VkVertexInputBindingDescription*      pVertexBindingDescriptions;
    uint32_t                                    vertexAttributeDescriptionCount;
    const VkVertexInputAttributeDescription*    pVertexAttributeDescriptions;
} VkPipelineVertexInputStateCreateInfo;

struct VkPipelineVertexInputStateCreateInfoRAII {
   VkPipelineVertexInputStateCreateInfo nonRaiiObj;
    std::vector<VkVertexInputBindingDescription>vecVertexBindingDescriptions;
    std::vector<VkVertexInputAttributeDescription>vecVertexAttributeDescriptions;
};

typedef struct VkPipelineInputAssemblyStateCreateInfo {
    VkStructureType                            sType;
    const void*                                pNext;
    VkPipelineInputAssemblyStateCreateFlags    flags;
    VkPrimitiveTopology                        topology;
    VkBool32                                   primitiveRestartEnable;
} VkPipelineInputAssemblyStateCreateInfo;

typedef struct VkPipelineTessellationStateCreateInfo {
    VkStructureType                           sType;
    const void*                               pNext;
    VkPipelineTessellationStateCreateFlags    flags;
    uint32_t                                  patchControlPoints;
} VkPipelineTessellationStateCreateInfo;

typedef struct VkViewport {
    float    x;
    float    y;
    float    width;
    float    height;
    float    minDepth;
    float    maxDepth;
} VkViewport;

typedef struct VkOffset2D {
    int32_t    x;
    int32_t    y;
} VkOffset2D;

typedef struct VkExtent2D {
    uint32_t    width;
    uint32_t    height;
} VkExtent2D;

typedef struct VkRect2D {
    VkOffset2D    offset;
    VkExtent2D    extent;
} VkRect2D;

typedef struct VkPipelineViewportStateCreateInfo {
    VkStructureType                       sType;
    const void*                           pNext;
    VkPipelineViewportStateCreateFlags    flags;
    uint32_t                              viewportCount;
    const VkViewport*                     pViewports;
    uint32_t                              scissorCount;
    const VkRect2D*                       pScissors;
} VkPipelineViewportStateCreateInfo;

struct VkPipelineViewportStateCreateInfoRAII {
   VkPipelineViewportStateCreateInfo nonRaiiObj;
    std::vector<VkViewport>                     vecViewports;
    std::vector<VkRect2D>                       vecScissors;
};

typedef struct VkPipelineRasterizationStateCreateInfo {
    VkStructureType                            sType;
    const void*                                pNext;
    VkPipelineRasterizationStateCreateFlags    flags;
    VkBool32                                   depthClampEnable;
    VkBool32                                   rasterizerDiscardEnable;
    VkPolygonMode                              polygonMode;
    VkCullModeFlags                            cullMode;
    VkFrontFace                                frontFace;
    VkBool32                                   depthBiasEnable;
    float                                      depthBiasConstantFactor;
    float                                      depthBiasClamp;
    float                                      depthBiasSlopeFactor;
    float                                      lineWidth;
} VkPipelineRasterizationStateCreateInfo;

typedef struct VkPipelineMultisampleStateCreateInfo {
    VkStructureType                          sType;
    const void*                              pNext;
    VkPipelineMultisampleStateCreateFlags    flags;
    VkSampleCountFlagBits                    rasterizationSamples;
    VkBool32                                 sampleShadingEnable;
    float                                    minSampleShading;
    const VkSampleMask*                      pSampleMask;
    VkBool32                                 alphaToCoverageEnable;
    VkBool32                                 alphaToOneEnable;
} VkPipelineMultisampleStateCreateInfo;

typedef struct VkStencilOpState {
    VkStencilOp    failOp;
    VkStencilOp    passOp;
    VkStencilOp    depthFailOp;
    VkCompareOp    compareOp;
    uint32_t       compareMask;
    uint32_t       writeMask;
    uint32_t       reference;
} VkStencilOpState;

typedef struct VkPipelineDepthStencilStateCreateInfo {
    VkStructureType                           sType;
    const void*                               pNext;
    VkPipelineDepthStencilStateCreateFlags    flags;
    VkBool32                                  depthTestEnable;
    VkBool32                                  depthWriteEnable;
    VkCompareOp                               depthCompareOp;
    VkBool32                                  depthBoundsTestEnable;
    VkBool32                                  stencilTestEnable;
    VkStencilOpState                          front;
    VkStencilOpState                          back;
    float                                     minDepthBounds;
    float                                     maxDepthBounds;
} VkPipelineDepthStencilStateCreateInfo;

typedef struct VkPipelineColorBlendAttachmentState {
    VkBool32                 blendEnable;
    VkBlendFactor            srcColorBlendFactor;
    VkBlendFactor            dstColorBlendFactor;
    VkBlendOp                colorBlendOp;
    VkBlendFactor            srcAlphaBlendFactor;
    VkBlendFactor            dstAlphaBlendFactor;
    VkBlendOp                alphaBlendOp;
    VkColorComponentFlags    colorWriteMask;
} VkPipelineColorBlendAttachmentState;

typedef struct VkPipelineColorBlendStateCreateInfo {
    VkStructureType                               sType;
    const void*                                   pNext;
    VkPipelineColorBlendStateCreateFlags          flags;
    VkBool32                                      logicOpEnable;
    VkLogicOp                                     logicOp;
    uint32_t                                      attachmentCount;
    const VkPipelineColorBlendAttachmentState*    pAttachments;
    float                                         blendConstants[4];
} VkPipelineColorBlendStateCreateInfo;

struct VkPipelineColorBlendStateCreateInfoRAII {
   VkPipelineColorBlendStateCreateInfo nonRaiiObj;
    std::vector<VkPipelineColorBlendAttachmentState>vecAttachments;
};

typedef struct VkPipelineDynamicStateCreateInfo {
    VkStructureType                      sType;
    const void*                          pNext;
    VkPipelineDynamicStateCreateFlags    flags;
    uint32_t                             dynamicStateCount;
    const VkDynamicState*                pDynamicStates;
} VkPipelineDynamicStateCreateInfo;

struct VkPipelineDynamicStateCreateInfoRAII {
   VkPipelineDynamicStateCreateInfo nonRaiiObj;
    std::vector<VkDynamicState>                 vecDynamicStates;
};

typedef struct VkGraphicsPipelineCreateInfo {
    VkStructureType                                  sType;
    const void*                                      pNext;
    VkPipelineCreateFlags                            flags;
    uint32_t                                         stageCount;
    const VkPipelineShaderStageCreateInfo*           pStages;
    const VkPipelineVertexInputStateCreateInfo*      pVertexInputState;
    const VkPipelineInputAssemblyStateCreateInfo*    pInputAssemblyState;
    const VkPipelineTessellationStateCreateInfo*     pTessellationState;
    const VkPipelineViewportStateCreateInfo*         pViewportState;
    const VkPipelineRasterizationStateCreateInfo*    pRasterizationState;
    const VkPipelineMultisampleStateCreateInfo*      pMultisampleState;
    const VkPipelineDepthStencilStateCreateInfo*     pDepthStencilState;
    const VkPipelineColorBlendStateCreateInfo*       pColorBlendState;
    const VkPipelineDynamicStateCreateInfo*          pDynamicState;
    VkPipelineLayout                                 layout;
    VkRenderPass                                     renderPass;
    uint32_t                                         subpass;
    VkPipeline                                       basePipelineHandle;
    int32_t                                          basePipelineIndex;
} VkGraphicsPipelineCreateInfo;

struct VkGraphicsPipelineCreateInfoRAII {
   VkGraphicsPipelineCreateInfo nonRaiiObj;
    std::vector<VkPipelineShaderStageCreateInfo>vecStages;
    std::shared_ptr<VkPipelineVertexInputStateCreateInfoRAII>pVertexInputState;
    std::shared_ptr<VkPipelineInputAssemblyStateCreateInfo>pInputAssemblyState;
    std::shared_ptr<VkPipelineTessellationStateCreateInfo>pTessellationState;
    std::shared_ptr<VkPipelineViewportStateCreateInfoRAII>pViewportState;
    std::shared_ptr<VkPipelineRasterizationStateCreateInfo>pRasterizationState;
    std::shared_ptr<VkPipelineMultisampleStateCreateInfo>pMultisampleState;
    std::shared_ptr<VkPipelineDepthStencilStateCreateInfo>pDepthStencilState;
    std::shared_ptr<VkPipelineColorBlendStateCreateInfoRAII>pColorBlendState;
    std::shared_ptr<VkPipelineDynamicStateCreateInfoRAII>pDynamicState;
};

typedef struct VkComputePipelineCreateInfo {
    VkStructureType                    sType;
    const void*                        pNext;
    VkPipelineCreateFlags              flags;
    VkPipelineShaderStageCreateInfo    stage;
    VkPipelineLayout                   layout;
    VkPipeline                         basePipelineHandle;
    int32_t                            basePipelineIndex;
} VkComputePipelineCreateInfo;

typedef struct VkPushConstantRange {
    VkShaderStageFlags    stageFlags;
    uint32_t              offset;
    uint32_t              size;
} VkPushConstantRange;

typedef struct VkPipelineLayoutCreateInfo {
    VkStructureType                 sType;
    const void*                     pNext;
    VkPipelineLayoutCreateFlags     flags;
    uint32_t                        setLayoutCount;
    const VkDescriptorSetLayout*    pSetLayouts;
    uint32_t                        pushConstantRangeCount;
    const VkPushConstantRange*      pPushConstantRanges;
} VkPipelineLayoutCreateInfo;

struct VkPipelineLayoutCreateInfoRAII {
   VkPipelineLayoutCreateInfo nonRaiiObj;
    std::vector<VkDescriptorSetLayout>          vecSetLayouts;
    std::vector<VkPushConstantRange>            vecPushConstantRanges;
};

typedef struct VkSamplerCreateInfo {
    VkStructureType         sType;
    const void*             pNext;
    VkSamplerCreateFlags    flags;
    VkFilter                magFilter;
    VkFilter                minFilter;
    VkSamplerMipmapMode     mipmapMode;
    VkSamplerAddressMode    addressModeU;
    VkSamplerAddressMode    addressModeV;
    VkSamplerAddressMode    addressModeW;
    float                   mipLodBias;
    VkBool32                anisotropyEnable;
    float                   maxAnisotropy;
    VkBool32                compareEnable;
    VkCompareOp             compareOp;
    float                   minLod;
    float                   maxLod;
    VkBorderColor           borderColor;
    VkBool32                unnormalizedCoordinates;
} VkSamplerCreateInfo;

typedef struct VkDescriptorSetLayoutBinding {
    uint32_t              binding;
    VkDescriptorType      descriptorType;
    uint32_t              descriptorCount;
    VkShaderStageFlags    stageFlags;
    const VkSampler*      pImmutableSamplers;
} VkDescriptorSetLayoutBinding;

struct VkDescriptorSetLayoutBindingRAII {
   VkDescriptorSetLayoutBinding nonRaiiObj;
    std::vector<VkSampler>                      vecImmutableSamplers;
};

typedef struct VkDescriptorSetLayoutCreateInfo {
    VkStructureType                        sType;
    const void*                            pNext;
    VkDescriptorSetLayoutCreateFlags       flags;
    uint32_t                               bindingCount;
    const VkDescriptorSetLayoutBinding*    pBindings;
} VkDescriptorSetLayoutCreateInfo;

struct VkDescriptorSetLayoutCreateInfoRAII {
   VkDescriptorSetLayoutCreateInfo nonRaiiObj;
    std::vector<VkDescriptorSetLayoutBinding>   vecBindings;
};

typedef struct VkDescriptorPoolSize {
    VkDescriptorType    type;
    uint32_t            descriptorCount;
} VkDescriptorPoolSize;

typedef struct VkDescriptorPoolCreateInfo {
    VkStructureType                sType;
    const void*                    pNext;
    VkDescriptorPoolCreateFlags    flags;
    uint32_t                       maxSets;
    uint32_t                       poolSizeCount;
    const VkDescriptorPoolSize*    pPoolSizes;
} VkDescriptorPoolCreateInfo;

struct VkDescriptorPoolCreateInfoRAII {
   VkDescriptorPoolCreateInfo nonRaiiObj;
    std::vector<VkDescriptorPoolSize>           vecPoolSizes;
};

typedef struct VkDescriptorSetAllocateInfo {
    VkStructureType                 sType;
    const void*                     pNext;
    VkDescriptorPool                descriptorPool;
    uint32_t                        descriptorSetCount;
    const VkDescriptorSetLayout*    pSetLayouts;
} VkDescriptorSetAllocateInfo;

struct VkDescriptorSetAllocateInfoRAII {
   VkDescriptorSetAllocateInfo nonRaiiObj;
    std::vector<VkDescriptorSetLayout>          vecSetLayouts;
};

typedef struct VkDescriptorImageInfo {
    VkSampler        sampler;
    VkImageView      imageView;
    VkImageLayout    imageLayout;
} VkDescriptorImageInfo;

typedef struct VkDescriptorBufferInfo {
    VkBuffer        buffer;
    VkDeviceSize    offset;
    VkDeviceSize    range;
} VkDescriptorBufferInfo;

typedef struct VkWriteDescriptorSet {
    VkStructureType                  sType;
    const void*                      pNext;
    VkDescriptorSet                  dstSet;
    uint32_t                         dstBinding;
    uint32_t                         dstArrayElement;
    uint32_t                         descriptorCount;
    VkDescriptorType                 descriptorType;
    const VkDescriptorImageInfo*     pImageInfo;
    const VkDescriptorBufferInfo*    pBufferInfo;
    const VkBufferView*              pTexelBufferView;
} VkWriteDescriptorSet;

struct VkWriteDescriptorSetRAII {
   VkWriteDescriptorSet nonRaiiObj;
    std::vector<VkDescriptorImageInfo>          vecImageInfo;
    std::vector<VkDescriptorBufferInfo>         vecBufferInfo;
    std::vector<VkBufferView>                   vecTexelBufferView;
};

typedef struct VkCopyDescriptorSet {
    VkStructureType    sType;
    const void*        pNext;
    VkDescriptorSet    srcSet;
    uint32_t           srcBinding;
    uint32_t           srcArrayElement;
    VkDescriptorSet    dstSet;
    uint32_t           dstBinding;
    uint32_t           dstArrayElement;
    uint32_t           descriptorCount;
} VkCopyDescriptorSet;

typedef struct VkFramebufferCreateInfo {
    VkStructureType             sType;
    const void*                 pNext;
    VkFramebufferCreateFlags    flags;
    VkRenderPass                renderPass;
    uint32_t                    attachmentCount;
    const VkImageView*          pAttachments;
    uint32_t                    width;
    uint32_t                    height;
    uint32_t                    layers;
} VkFramebufferCreateInfo;

struct VkFramebufferCreateInfoRAII {
   VkFramebufferCreateInfo nonRaiiObj;
    std::vector<VkImageView>                    vecAttachments;
};

typedef struct VkAttachmentDescription {
    VkAttachmentDescriptionFlags    flags;
    VkFormat                        format;
    VkSampleCountFlagBits           samples;
    VkAttachmentLoadOp              loadOp;
    VkAttachmentStoreOp             storeOp;
    VkAttachmentLoadOp              stencilLoadOp;
    VkAttachmentStoreOp             stencilStoreOp;
    VkImageLayout                   initialLayout;
    VkImageLayout                   finalLayout;
} VkAttachmentDescription;

typedef struct VkAttachmentReference {
    uint32_t         attachment;
    VkImageLayout    layout;
} VkAttachmentReference;

typedef struct VkSubpassDescription {
    VkSubpassDescriptionFlags       flags;
    VkPipelineBindPoint             pipelineBindPoint;
    uint32_t                        inputAttachmentCount;
    const VkAttachmentReference*    pInputAttachments;
    uint32_t                        colorAttachmentCount;
    const VkAttachmentReference*    pColorAttachments;
    const VkAttachmentReference*    pResolveAttachments;
    const VkAttachmentReference*    pDepthStencilAttachment;
    uint32_t                        preserveAttachmentCount;
    const uint32_t*                 pPreserveAttachments;
} VkSubpassDescription;

struct VkSubpassDescriptionRAII {
   VkSubpassDescription nonRaiiObj;
    std::vector<VkAttachmentReference>          vecInputAttachments;
    std::vector<VkAttachmentReference>          vecColorAttachments;
    std::vector<VkAttachmentReference>          vecResolveAttachments;
    std::shared_ptr<VkAttachmentReference>      pDepthStencilAttachment;
    std::vector<uint32_t>                       vecPreserveAttachments;
};

typedef struct VkSubpassDependency {
    uint32_t                srcSubpass;
    uint32_t                dstSubpass;
    VkPipelineStageFlags    srcStageMask;
    VkPipelineStageFlags    dstStageMask;
    VkAccessFlags           srcAccessMask;
    VkAccessFlags           dstAccessMask;
    VkDependencyFlags       dependencyFlags;
} VkSubpassDependency;

typedef struct VkRenderPassCreateInfo {
    VkStructureType                   sType;
    const void*                       pNext;
    VkRenderPassCreateFlags           flags;
    uint32_t                          attachmentCount;
    const VkAttachmentDescription*    pAttachments;
    uint32_t                          subpassCount;
    const VkSubpassDescription*       pSubpasses;
    uint32_t                          dependencyCount;
    const VkSubpassDependency*        pDependencies;
} VkRenderPassCreateInfo;

struct VkRenderPassCreateInfoRAII {
   VkRenderPassCreateInfo nonRaiiObj;
    std::vector<VkAttachmentDescription>        vecAttachments;
    std::vector<VkSubpassDescription>           vecSubpasses;
    std::vector<VkSubpassDependency>            vecDependencies;
};

typedef struct VkCommandPoolCreateInfo {
    VkStructureType             sType;
    const void*                 pNext;
    VkCommandPoolCreateFlags    flags;
    uint32_t                    queueFamilyIndex;
} VkCommandPoolCreateInfo;

typedef struct VkCommandBufferAllocateInfo {
    VkStructureType         sType;
    const void*             pNext;
    VkCommandPool           commandPool;
    VkCommandBufferLevel    level;
    uint32_t                commandBufferCount;
} VkCommandBufferAllocateInfo;

typedef struct VkCommandBufferInheritanceInfo {
    VkStructureType                  sType;
    const void*                      pNext;
    VkRenderPass                     renderPass;
    uint32_t                         subpass;
    VkFramebuffer                    framebuffer;
    VkBool32                         occlusionQueryEnable;
    VkQueryControlFlags              queryFlags;
    VkQueryPipelineStatisticFlags    pipelineStatistics;
} VkCommandBufferInheritanceInfo;

typedef struct VkCommandBufferBeginInfo {
    VkStructureType                          sType;
    const void*                              pNext;
    VkCommandBufferUsageFlags                flags;
    const VkCommandBufferInheritanceInfo*    pInheritanceInfo;
} VkCommandBufferBeginInfo;

struct VkCommandBufferBeginInfoRAII {
   VkCommandBufferBeginInfo nonRaiiObj;
    std::shared_ptr<VkCommandBufferInheritanceInfo>pInheritanceInfo;
};

typedef struct VkBufferCopy {
    VkDeviceSize    srcOffset;
    VkDeviceSize    dstOffset;
    VkDeviceSize    size;
} VkBufferCopy;

typedef struct VkImageSubresourceLayers {
    VkImageAspectFlags    aspectMask;
    uint32_t              mipLevel;
    uint32_t              baseArrayLayer;
    uint32_t              layerCount;
} VkImageSubresourceLayers;

typedef struct VkImageCopy {
    VkImageSubresourceLayers    srcSubresource;
    VkOffset3D                  srcOffset;
    VkImageSubresourceLayers    dstSubresource;
    VkOffset3D                  dstOffset;
    VkExtent3D                  extent;
} VkImageCopy;

typedef struct VkImageBlit {
    VkImageSubresourceLayers    srcSubresource;
    VkOffset3D                  srcOffsets[2];
    VkImageSubresourceLayers    dstSubresource;
    VkOffset3D                  dstOffsets[2];
} VkImageBlit;

typedef struct VkBufferImageCopy {
    VkDeviceSize                bufferOffset;
    uint32_t                    bufferRowLength;
    uint32_t                    bufferImageHeight;
    VkImageSubresourceLayers    imageSubresource;
    VkOffset3D                  imageOffset;
    VkExtent3D                  imageExtent;
} VkBufferImageCopy;

typedef union VkClearColorValue {
    float       float32[4];
    int32_t     int32[4];
    uint32_t    uint32[4];
} VkClearColorValue;

typedef struct VkClearDepthStencilValue {
    float       depth;
    uint32_t    stencil;
} VkClearDepthStencilValue;

typedef union VkClearValue {
    VkClearColorValue           color;
    VkClearDepthStencilValue    depthStencil;
} VkClearValue;

typedef struct VkClearAttachment {
    VkImageAspectFlags    aspectMask;
    uint32_t              colorAttachment;
    VkClearValue          clearValue;
} VkClearAttachment;

typedef struct VkClearRect {
    VkRect2D    rect;
    uint32_t    baseArrayLayer;
    uint32_t    layerCount;
} VkClearRect;

typedef struct VkImageResolve {
    VkImageSubresourceLayers    srcSubresource;
    VkOffset3D                  srcOffset;
    VkImageSubresourceLayers    dstSubresource;
    VkOffset3D                  dstOffset;
    VkExtent3D                  extent;
} VkImageResolve;

typedef struct VkMemoryBarrier {
    VkStructureType    sType;
    const void*        pNext;
    VkAccessFlags      srcAccessMask;
    VkAccessFlags      dstAccessMask;
} VkMemoryBarrier;

typedef struct VkBufferMemoryBarrier {
    VkStructureType    sType;
    const void*        pNext;
    VkAccessFlags      srcAccessMask;
    VkAccessFlags      dstAccessMask;
    uint32_t           srcQueueFamilyIndex;
    uint32_t           dstQueueFamilyIndex;
    VkBuffer           buffer;
    VkDeviceSize       offset;
    VkDeviceSize       size;
} VkBufferMemoryBarrier;

typedef struct VkImageMemoryBarrier {
    VkStructureType            sType;
    const void*                pNext;
    VkAccessFlags              srcAccessMask;
    VkAccessFlags              dstAccessMask;
    VkImageLayout              oldLayout;
    VkImageLayout              newLayout;
    uint32_t                   srcQueueFamilyIndex;
    uint32_t                   dstQueueFamilyIndex;
    VkImage                    image;
    VkImageSubresourceRange    subresourceRange;
} VkImageMemoryBarrier;

typedef struct VkRenderPassBeginInfo {
    VkStructureType        sType;
    const void*            pNext;
    VkRenderPass           renderPass;
    VkFramebuffer          framebuffer;
    VkRect2D               renderArea;
    uint32_t               clearValueCount;
    const VkClearValue*    pClearValues;
} VkRenderPassBeginInfo;

struct VkRenderPassBeginInfoRAII {
   VkRenderPassBeginInfo nonRaiiObj;
    std::vector<VkClearValue>                   vecClearValues;
};

typedef struct VkDispatchIndirectCommand {
    uint32_t    x;
    uint32_t    y;
    uint32_t    z;
} VkDispatchIndirectCommand;

typedef struct VkDrawIndexedIndirectCommand {
    uint32_t    indexCount;
    uint32_t    instanceCount;
    uint32_t    firstIndex;
    int32_t     vertexOffset;
    uint32_t    firstInstance;
} VkDrawIndexedIndirectCommand;

typedef struct VkDrawIndirectCommand {
    uint32_t    vertexCount;
    uint32_t    instanceCount;
    uint32_t    firstVertex;
    uint32_t    firstInstance;
} VkDrawIndirectCommand;


typedef VkResult (VKAPI_PTR *PFN_vkCreateInstance)(const VkInstanceCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkInstance* pInstance);
typedef void (VKAPI_PTR *PFN_vkDestroyInstance)(VkInstance instance, const VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkEnumeratePhysicalDevices)(VkInstance instance, uint32_t* pPhysicalDeviceCount, VkPhysicalDevice* pPhysicalDevices);
typedef void (VKAPI_PTR *PFN_vkGetPhysicalDeviceFeatures)(VkPhysicalDevice physicalDevice, VkPhysicalDeviceFeatures* pFeatures);
typedef void (VKAPI_PTR *PFN_vkGetPhysicalDeviceFormatProperties)(VkPhysicalDevice physicalDevice, VkFormat format, VkFormatProperties* pFormatProperties);
typedef VkResult (VKAPI_PTR *PFN_vkGetPhysicalDeviceImageFormatProperties)(VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type, VkImageTiling tiling, VkImageUsageFlags usage, VkImageCreateFlags flags, VkImageFormatProperties* pImageFormatProperties);
typedef void (VKAPI_PTR *PFN_vkGetPhysicalDeviceProperties)(VkPhysicalDevice physicalDevice, VkPhysicalDeviceProperties* pProperties);
typedef void (VKAPI_PTR *PFN_vkGetPhysicalDeviceQueueFamilyProperties)(VkPhysicalDevice physicalDevice, uint32_t* pQueueFamilyPropertyCount, VkQueueFamilyProperties* pQueueFamilyProperties);
typedef void (VKAPI_PTR *PFN_vkGetPhysicalDeviceMemoryProperties)(VkPhysicalDevice physicalDevice, VkPhysicalDeviceMemoryProperties* pMemoryProperties);
typedef VkResult (VKAPI_PTR *PFN_vkCreateDevice)(VkPhysicalDevice physicalDevice, const VkDeviceCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkDevice* pDevice);
typedef void (VKAPI_PTR *PFN_vkDestroyDevice)(VkDevice device, const VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkEnumerateInstanceExtensionProperties)(const char* pLayerName, uint32_t* pPropertyCount, VkExtensionProperties* pProperties);
typedef VkResult (VKAPI_PTR *PFN_vkEnumerateDeviceExtensionProperties)(VkPhysicalDevice physicalDevice, const char* pLayerName, uint32_t* pPropertyCount, VkExtensionProperties* pProperties);
typedef VkResult (VKAPI_PTR *PFN_vkEnumerateInstanceLayerProperties)(uint32_t* pPropertyCount, VkLayerProperties* pProperties);
typedef VkResult (VKAPI_PTR *PFN_vkEnumerateDeviceLayerProperties)(VkPhysicalDevice physicalDevice, uint32_t* pPropertyCount, VkLayerProperties* pProperties);
typedef void (VKAPI_PTR *PFN_vkGetDeviceQueue)(VkDevice device, uint32_t queueFamilyIndex, uint32_t queueIndex, VkQueue* pQueue);
typedef VkResult (VKAPI_PTR *PFN_vkQueueSubmit)(VkQueue queue, uint32_t submitCount, const VkSubmitInfo* pSubmits, VkFence fence);
typedef VkResult (VKAPI_PTR *PFN_vkQueueWaitIdle)(VkQueue queue);
typedef VkResult (VKAPI_PTR *PFN_vkDeviceWaitIdle)(VkDevice device);
typedef VkResult (VKAPI_PTR *PFN_vkAllocateMemory)(VkDevice device, const VkMemoryAllocateInfo* pAllocateInfo, const VkAllocationCallbacks* pAllocator, VkDeviceMemory* pMemory);
typedef void (VKAPI_PTR *PFN_vkFreeMemory)(VkDevice device, VkDeviceMemory memory, const VkAllocationCallbacks* pAllocator);
typedef void (VKAPI_PTR *PFN_vkUnmapMemory)(VkDevice device, VkDeviceMemory memory);
typedef VkResult (VKAPI_PTR *PFN_vkFlushMappedMemoryRanges)(VkDevice device, uint32_t memoryRangeCount, const VkMappedMemoryRange* pMemoryRanges);
typedef VkResult (VKAPI_PTR *PFN_vkInvalidateMappedMemoryRanges)(VkDevice device, uint32_t memoryRangeCount, const VkMappedMemoryRange* pMemoryRanges);
typedef void (VKAPI_PTR *PFN_vkGetDeviceMemoryCommitment)(VkDevice device, VkDeviceMemory memory, VkDeviceSize* pCommittedMemoryInBytes);
typedef VkResult (VKAPI_PTR *PFN_vkBindBufferMemory)(VkDevice device, VkBuffer buffer, VkDeviceMemory memory, VkDeviceSize memoryOffset);
typedef VkResult (VKAPI_PTR *PFN_vkBindImageMemory)(VkDevice device, VkImage image, VkDeviceMemory memory, VkDeviceSize memoryOffset);
typedef void (VKAPI_PTR *PFN_vkGetBufferMemoryRequirements)(VkDevice device, VkBuffer buffer, VkMemoryRequirements* pMemoryRequirements);
typedef void (VKAPI_PTR *PFN_vkGetImageMemoryRequirements)(VkDevice device, VkImage image, VkMemoryRequirements* pMemoryRequirements);
typedef void (VKAPI_PTR *PFN_vkGetImageSparseMemoryRequirements)(VkDevice device, VkImage image, uint32_t* pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements* pSparseMemoryRequirements);
typedef void (VKAPI_PTR *PFN_vkGetPhysicalDeviceSparseImageFormatProperties)(VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type, VkSampleCountFlagBits samples, VkImageUsageFlags usage, VkImageTiling tiling, uint32_t* pPropertyCount, VkSparseImageFormatProperties* pProperties);
typedef VkResult (VKAPI_PTR *PFN_vkQueueBindSparse)(VkQueue queue, uint32_t bindInfoCount, const VkBindSparseInfo* pBindInfo, VkFence fence);
typedef VkResult (VKAPI_PTR *PFN_vkCreateFence)(VkDevice device, const VkFenceCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkFence* pFence);
typedef void (VKAPI_PTR *PFN_vkDestroyFence)(VkDevice device, VkFence fence, const VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkResetFences)(VkDevice device, uint32_t fenceCount, const VkFence* pFences);
typedef VkResult (VKAPI_PTR *PFN_vkGetFenceStatus)(VkDevice device, VkFence fence);
typedef VkResult (VKAPI_PTR *PFN_vkWaitForFences)(VkDevice device, uint32_t fenceCount, const VkFence* pFences, VkBool32 waitAll, uint64_t timeout);
typedef VkResult (VKAPI_PTR *PFN_vkCreateSemaphore)(VkDevice device, const VkSemaphoreCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSemaphore* pSemaphore);
typedef void (VKAPI_PTR *PFN_vkDestroySemaphore)(VkDevice device, VkSemaphore semaphore, const VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkCreateEvent)(VkDevice device, const VkEventCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkEvent* pEvent);
typedef void (VKAPI_PTR *PFN_vkDestroyEvent)(VkDevice device, VkEvent event, const VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkGetEventStatus)(VkDevice device, VkEvent event);
typedef VkResult (VKAPI_PTR *PFN_vkSetEvent)(VkDevice device, VkEvent event);
typedef VkResult (VKAPI_PTR *PFN_vkResetEvent)(VkDevice device, VkEvent event);
typedef VkResult (VKAPI_PTR *PFN_vkCreateQueryPool)(VkDevice device, const VkQueryPoolCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkQueryPool* pQueryPool);
typedef void (VKAPI_PTR *PFN_vkDestroyQueryPool)(VkDevice device, VkQueryPool queryPool, const VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkGetQueryPoolResults)(VkDevice device, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount, size_t dataSize, void* pData, VkDeviceSize stride, VkQueryResultFlags flags);
typedef VkResult (VKAPI_PTR *PFN_vkCreateBuffer)(VkDevice device, const VkBufferCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkBuffer* pBuffer);
typedef void (VKAPI_PTR *PFN_vkDestroyBuffer)(VkDevice device, VkBuffer buffer, const VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkCreateBufferView)(VkDevice device, const VkBufferViewCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkBufferView* pView);
typedef void (VKAPI_PTR *PFN_vkDestroyBufferView)(VkDevice device, VkBufferView bufferView, const VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkCreateImage)(VkDevice device, const VkImageCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkImage* pImage);
typedef void (VKAPI_PTR *PFN_vkDestroyImage)(VkDevice device, VkImage image, const VkAllocationCallbacks* pAllocator);
typedef void (VKAPI_PTR *PFN_vkGetImageSubresourceLayout)(VkDevice device, VkImage image, const VkImageSubresource* pSubresource, VkSubresourceLayout* pLayout);
typedef VkResult (VKAPI_PTR *PFN_vkCreateImageView)(VkDevice device, const VkImageViewCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkImageView* pView);
typedef void (VKAPI_PTR *PFN_vkDestroyImageView)(VkDevice device, VkImageView imageView, const VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkCreateShaderModule)(VkDevice device, const VkShaderModuleCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkShaderModule* pShaderModule);
typedef void (VKAPI_PTR *PFN_vkDestroyShaderModule)(VkDevice device, VkShaderModule shaderModule, const VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkCreatePipelineCache)(VkDevice device, const VkPipelineCacheCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkPipelineCache* pPipelineCache);
typedef void (VKAPI_PTR *PFN_vkDestroyPipelineCache)(VkDevice device, VkPipelineCache pipelineCache, const VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkGetPipelineCacheData)(VkDevice device, VkPipelineCache pipelineCache, size_t* pDataSize, void* pData);
typedef VkResult (VKAPI_PTR *PFN_vkMergePipelineCaches)(VkDevice device, VkPipelineCache dstCache, uint32_t srcCacheCount, const VkPipelineCache* pSrcCaches);
typedef VkResult (VKAPI_PTR *PFN_vkCreateGraphicsPipelines)(VkDevice device, VkPipelineCache pipelineCache, uint32_t createInfoCount, const VkGraphicsPipelineCreateInfo* pCreateInfos, const VkAllocationCallbacks* pAllocator, VkPipeline* pPipelines);
typedef VkResult (VKAPI_PTR *PFN_vkCreateComputePipelines)(VkDevice device, VkPipelineCache pipelineCache, uint32_t createInfoCount, const VkComputePipelineCreateInfo* pCreateInfos, const VkAllocationCallbacks* pAllocator, VkPipeline* pPipelines);
typedef void (VKAPI_PTR *PFN_vkDestroyPipeline)(VkDevice device, VkPipeline pipeline, const VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkCreatePipelineLayout)(VkDevice device, const VkPipelineLayoutCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkPipelineLayout* pPipelineLayout);
typedef void (VKAPI_PTR *PFN_vkDestroyPipelineLayout)(VkDevice device, VkPipelineLayout pipelineLayout, const VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkCreateSampler)(VkDevice device, const VkSamplerCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSampler* pSampler);
typedef void (VKAPI_PTR *PFN_vkDestroySampler)(VkDevice device, VkSampler sampler, const VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkCreateDescriptorSetLayout)(VkDevice device, const VkDescriptorSetLayoutCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkDescriptorSetLayout* pSetLayout);
typedef void (VKAPI_PTR *PFN_vkDestroyDescriptorSetLayout)(VkDevice device, VkDescriptorSetLayout descriptorSetLayout, const VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkCreateDescriptorPool)(VkDevice device, const VkDescriptorPoolCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkDescriptorPool* pDescriptorPool);
typedef void (VKAPI_PTR *PFN_vkDestroyDescriptorPool)(VkDevice device, VkDescriptorPool descriptorPool, const VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkResetDescriptorPool)(VkDevice device, VkDescriptorPool descriptorPool, VkDescriptorPoolResetFlags flags);
typedef VkResult (VKAPI_PTR *PFN_vkFreeDescriptorSets)(VkDevice device, VkDescriptorPool descriptorPool, uint32_t descriptorSetCount, const VkDescriptorSet* pDescriptorSets);
typedef void (VKAPI_PTR *PFN_vkUpdateDescriptorSets)(VkDevice device, uint32_t descriptorWriteCount, const VkWriteDescriptorSet* pDescriptorWrites, uint32_t descriptorCopyCount, const VkCopyDescriptorSet* pDescriptorCopies);
typedef VkResult (VKAPI_PTR *PFN_vkCreateFramebuffer)(VkDevice device, const VkFramebufferCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkFramebuffer* pFramebuffer);
typedef void (VKAPI_PTR *PFN_vkDestroyFramebuffer)(VkDevice device, VkFramebuffer framebuffer, const VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkCreateRenderPass)(VkDevice device, const VkRenderPassCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkRenderPass* pRenderPass);
typedef void (VKAPI_PTR *PFN_vkDestroyRenderPass)(VkDevice device, VkRenderPass renderPass, const VkAllocationCallbacks* pAllocator);
typedef void (VKAPI_PTR *PFN_vkGetRenderAreaGranularity)(VkDevice device, VkRenderPass renderPass, VkExtent2D* pGranularity);
typedef VkResult (VKAPI_PTR *PFN_vkCreateCommandPool)(VkDevice device, const VkCommandPoolCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkCommandPool* pCommandPool);
typedef void (VKAPI_PTR *PFN_vkDestroyCommandPool)(VkDevice device, VkCommandPool commandPool, const VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkResetCommandPool)(VkDevice device, VkCommandPool commandPool, VkCommandPoolResetFlags flags);
typedef void (VKAPI_PTR *PFN_vkFreeCommandBuffers)(VkDevice device, VkCommandPool commandPool, uint32_t commandBufferCount, const VkCommandBuffer* pCommandBuffers);
typedef VkResult (VKAPI_PTR *PFN_vkBeginCommandBuffer)(VkCommandBuffer commandBuffer, const VkCommandBufferBeginInfo* pBeginInfo);
typedef VkResult (VKAPI_PTR *PFN_vkEndCommandBuffer)(VkCommandBuffer commandBuffer);
typedef VkResult (VKAPI_PTR *PFN_vkResetCommandBuffer)(VkCommandBuffer commandBuffer, VkCommandBufferResetFlags flags);
typedef void (VKAPI_PTR *PFN_vkCmdBindPipeline)(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipeline pipeline);
typedef void (VKAPI_PTR *PFN_vkCmdSetViewport)(VkCommandBuffer commandBuffer, uint32_t firstViewport, uint32_t viewportCount, const VkViewport* pViewports);
typedef void (VKAPI_PTR *PFN_vkCmdSetScissor)(VkCommandBuffer commandBuffer, uint32_t firstScissor, uint32_t scissorCount, const VkRect2D* pScissors);
typedef void (VKAPI_PTR *PFN_vkCmdSetLineWidth)(VkCommandBuffer commandBuffer, float lineWidth);
typedef void (VKAPI_PTR *PFN_vkCmdSetDepthBias)(VkCommandBuffer commandBuffer, float depthBiasConstantFactor, float depthBiasClamp, float depthBiasSlopeFactor);
typedef void (VKAPI_PTR *PFN_vkCmdSetBlendConstants)(VkCommandBuffer commandBuffer, const float blendConstants[4]);
typedef void (VKAPI_PTR *PFN_vkCmdSetDepthBounds)(VkCommandBuffer commandBuffer, float minDepthBounds, float maxDepthBounds);
typedef void (VKAPI_PTR *PFN_vkCmdSetStencilCompareMask)(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, uint32_t compareMask);
typedef void (VKAPI_PTR *PFN_vkCmdSetStencilWriteMask)(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, uint32_t writeMask);
typedef void (VKAPI_PTR *PFN_vkCmdSetStencilReference)(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, uint32_t reference);
typedef void (VKAPI_PTR *PFN_vkCmdBindDescriptorSets)(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout, uint32_t firstSet, uint32_t descriptorSetCount, const VkDescriptorSet* pDescriptorSets, uint32_t dynamicOffsetCount, const uint32_t* pDynamicOffsets);
typedef void (VKAPI_PTR *PFN_vkCmdBindIndexBuffer)(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkIndexType indexType);
typedef void (VKAPI_PTR *PFN_vkCmdBindVertexBuffers)(VkCommandBuffer commandBuffer, uint32_t firstBinding, uint32_t bindingCount, const VkBuffer* pBuffers, const VkDeviceSize* pOffsets);
typedef void (VKAPI_PTR *PFN_vkCmdDraw)(VkCommandBuffer commandBuffer, uint32_t vertexCount, uint32_t instanceCount, uint32_t firstVertex, uint32_t firstInstance);
typedef void (VKAPI_PTR *PFN_vkCmdDrawIndexed)(VkCommandBuffer commandBuffer, uint32_t indexCount, uint32_t instanceCount, uint32_t firstIndex, int32_t vertexOffset, uint32_t firstInstance);
typedef void (VKAPI_PTR *PFN_vkCmdDrawIndirect)(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, uint32_t drawCount, uint32_t stride);
typedef void (VKAPI_PTR *PFN_vkCmdDrawIndexedIndirect)(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, uint32_t drawCount, uint32_t stride);
typedef void (VKAPI_PTR *PFN_vkCmdDispatch)(VkCommandBuffer commandBuffer, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ);
typedef void (VKAPI_PTR *PFN_vkCmdDispatchIndirect)(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset);
typedef void (VKAPI_PTR *PFN_vkCmdCopyBuffer)(VkCommandBuffer commandBuffer, VkBuffer srcBuffer, VkBuffer dstBuffer, uint32_t regionCount, const VkBufferCopy* pRegions);
typedef void (VKAPI_PTR *PFN_vkCmdCopyImage)(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, const VkImageCopy* pRegions);
typedef void (VKAPI_PTR *PFN_vkCmdBlitImage)(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, const VkImageBlit* pRegions, VkFilter filter);
typedef void (VKAPI_PTR *PFN_vkCmdCopyBufferToImage)(VkCommandBuffer commandBuffer, VkBuffer srcBuffer, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, const VkBufferImageCopy* pRegions);
typedef void (VKAPI_PTR *PFN_vkCmdCopyImageToBuffer)(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkBuffer dstBuffer, uint32_t regionCount, const VkBufferImageCopy* pRegions);
typedef void (VKAPI_PTR *PFN_vkCmdFillBuffer)(VkCommandBuffer commandBuffer, VkBuffer dstBuffer, VkDeviceSize dstOffset, VkDeviceSize size, uint32_t data);
typedef void (VKAPI_PTR *PFN_vkCmdClearColorImage)(VkCommandBuffer commandBuffer, VkImage image, VkImageLayout imageLayout, const VkClearColorValue* pColor, uint32_t rangeCount, const VkImageSubresourceRange* pRanges);
typedef void (VKAPI_PTR *PFN_vkCmdClearDepthStencilImage)(VkCommandBuffer commandBuffer, VkImage image, VkImageLayout imageLayout, const VkClearDepthStencilValue* pDepthStencil, uint32_t rangeCount, const VkImageSubresourceRange* pRanges);
typedef void (VKAPI_PTR *PFN_vkCmdClearAttachments)(VkCommandBuffer commandBuffer, uint32_t attachmentCount, const VkClearAttachment* pAttachments, uint32_t rectCount, const VkClearRect* pRects);
typedef void (VKAPI_PTR *PFN_vkCmdResolveImage)(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, const VkImageResolve* pRegions);
typedef void (VKAPI_PTR *PFN_vkCmdSetEvent)(VkCommandBuffer commandBuffer, VkEvent event, VkPipelineStageFlags stageMask);
typedef void (VKAPI_PTR *PFN_vkCmdResetEvent)(VkCommandBuffer commandBuffer, VkEvent event, VkPipelineStageFlags stageMask);
typedef void (VKAPI_PTR *PFN_vkCmdWaitEvents)(VkCommandBuffer commandBuffer, uint32_t eventCount, const VkEvent* pEvents, VkPipelineStageFlags srcStageMask, VkPipelineStageFlags dstStageMask, uint32_t memoryBarrierCount, const VkMemoryBarrier* pMemoryBarriers, uint32_t bufferMemoryBarrierCount, const VkBufferMemoryBarrier* pBufferMemoryBarriers, uint32_t imageMemoryBarrierCount, const VkImageMemoryBarrier* pImageMemoryBarriers);
typedef void (VKAPI_PTR *PFN_vkCmdPipelineBarrier)(VkCommandBuffer commandBuffer, VkPipelineStageFlags srcStageMask, VkPipelineStageFlags dstStageMask, VkDependencyFlags dependencyFlags, uint32_t memoryBarrierCount, const VkMemoryBarrier* pMemoryBarriers, uint32_t bufferMemoryBarrierCount, const VkBufferMemoryBarrier* pBufferMemoryBarriers, uint32_t imageMemoryBarrierCount, const VkImageMemoryBarrier* pImageMemoryBarriers);
typedef void (VKAPI_PTR *PFN_vkCmdBeginQuery)(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query, VkQueryControlFlags flags);
typedef void (VKAPI_PTR *PFN_vkCmdEndQuery)(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query);
typedef void (VKAPI_PTR *PFN_vkCmdResetQueryPool)(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount);
typedef void (VKAPI_PTR *PFN_vkCmdWriteTimestamp)(VkCommandBuffer commandBuffer, VkPipelineStageFlagBits pipelineStage, VkQueryPool queryPool, uint32_t query);
typedef void (VKAPI_PTR *PFN_vkCmdCopyQueryPoolResults)(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount, VkBuffer dstBuffer, VkDeviceSize dstOffset, VkDeviceSize stride, VkQueryResultFlags flags);
typedef void (VKAPI_PTR *PFN_vkCmdBeginRenderPass)(VkCommandBuffer commandBuffer, const VkRenderPassBeginInfo* pRenderPassBegin, VkSubpassContents contents);
typedef void (VKAPI_PTR *PFN_vkCmdNextSubpass)(VkCommandBuffer commandBuffer, VkSubpassContents contents);
typedef void (VKAPI_PTR *PFN_vkCmdEndRenderPass)(VkCommandBuffer commandBuffer);
typedef void (VKAPI_PTR *PFN_vkCmdExecuteCommands)(VkCommandBuffer commandBuffer, uint32_t commandBufferCount, const VkCommandBuffer* pCommandBuffers);

std::shared_ptr<VkApplicationInfoRAII> ApplicationInfo(
    const std::string &                         strApplicationName,
    uint32_t                                    applicationVersion,
    const std::string &                         strEngineName,
    uint32_t                                    engineVersion,
    uint32_t                                    apiVersion);


std::shared_ptr<VkInstanceCreateInfoRAII> InstanceCreateInfo(
    VkInstanceCreateFlags                       flags,
    const std::shared_ptr<VkApplicationInfoRAII> &pApplicationInfo,
    const std::vector<std::string> &            vecEnabledLayerNames,
    const std::vector<std::string> &            vecEnabledExtensionNames);


VkAllocationCallbacks AllocationCallbacks(
    PFN_vkAllocationFunction                    pfnAllocation,
    PFN_vkReallocationFunction                  pfnReallocation,
    PFN_vkFreeFunction                          pfnFree,
    PFN_vkInternalAllocationNotification        pfnInternalAllocation,
    PFN_vkInternalFreeNotification              pfnInternalFree);


std::shared_ptr<VkInstance_T> createInstance(
        const VkInstanceCreateInfo & pCreateInfo);

std::vector< VkPhysicalDevice > enumeratePhysicalDevices(
        VkInstance instance);

VkPhysicalDeviceFeatures PhysicalDeviceFeatures(
    VkBool32                                    robustBufferAccess,
    VkBool32                                    fullDrawIndexUint32,
    VkBool32                                    imageCubeArray,
    VkBool32                                    independentBlend,
    VkBool32                                    geometryShader,
    VkBool32                                    tessellationShader,
    VkBool32                                    sampleRateShading,
    VkBool32                                    dualSrcBlend,
    VkBool32                                    logicOp,
    VkBool32                                    multiDrawIndirect,
    VkBool32                                    drawIndirectFirstInstance,
    VkBool32                                    depthClamp,
    VkBool32                                    depthBiasClamp,
    VkBool32                                    fillModeNonSolid,
    VkBool32                                    depthBounds,
    VkBool32                                    wideLines,
    VkBool32                                    largePoints,
    VkBool32                                    alphaToOne,
    VkBool32                                    multiViewport,
    VkBool32                                    samplerAnisotropy,
    VkBool32                                    textureCompressionETC2,
    VkBool32                                    textureCompressionASTC_LDR,
    VkBool32                                    textureCompressionBC,
    VkBool32                                    occlusionQueryPrecise,
    VkBool32                                    pipelineStatisticsQuery,
    VkBool32                                    vertexPipelineStoresAndAtomics,
    VkBool32                                    fragmentStoresAndAtomics,
    VkBool32                                    shaderTessellationAndGeometryPointSize,
    VkBool32                                    shaderImageGatherExtended,
    VkBool32                                    shaderStorageImageExtendedFormats,
    VkBool32                                    shaderStorageImageMultisample,
    VkBool32                                    shaderStorageImageReadWithoutFormat,
    VkBool32                                    shaderStorageImageWriteWithoutFormat,
    VkBool32                                    shaderUniformBufferArrayDynamicIndexing,
    VkBool32                                    shaderSampledImageArrayDynamicIndexing,
    VkBool32                                    shaderStorageBufferArrayDynamicIndexing,
    VkBool32                                    shaderStorageImageArrayDynamicIndexing,
    VkBool32                                    shaderClipDistance,
    VkBool32                                    shaderCullDistance,
    VkBool32                                    shaderFloat64,
    VkBool32                                    shaderInt64,
    VkBool32                                    shaderInt16,
    VkBool32                                    shaderResourceResidency,
    VkBool32                                    shaderResourceMinLod,
    VkBool32                                    sparseBinding,
    VkBool32                                    sparseResidencyBuffer,
    VkBool32                                    sparseResidencyImage2D,
    VkBool32                                    sparseResidencyImage3D,
    VkBool32                                    sparseResidency2Samples,
    VkBool32                                    sparseResidency4Samples,
    VkBool32                                    sparseResidency8Samples,
    VkBool32                                    sparseResidency16Samples,
    VkBool32                                    sparseResidencyAliased,
    VkBool32                                    variableMultisampleRate,
    VkBool32                                    inheritedQueries);


VkPhysicalDeviceFeatures getPhysicalDeviceFeatures(
        VkPhysicalDevice physicalDevice);

VkFormatProperties FormatProperties(
    VkFormatFeatureFlags                        linearTilingFeatures,
    VkFormatFeatureFlags                        optimalTilingFeatures,
    VkFormatFeatureFlags                        bufferFeatures);


VkFormatProperties getPhysicalDeviceFormatProperties(
        VkPhysicalDevice physicalDevice,
        VkFormat format);

VkExtent3D Extent3D(
    uint32_t                                    width,
    uint32_t                                    height,
    uint32_t                                    depth);


VkImageFormatProperties ImageFormatProperties(
    VkExtent3D                                  maxExtent,
    uint32_t                                    maxMipLevels,
    uint32_t                                    maxArrayLayers,
    VkSampleCountFlags                          sampleCounts,
    VkDeviceSize                                maxResourceSize);


VkImageFormatProperties getPhysicalDeviceImageFormatProperties(
        VkPhysicalDevice physicalDevice,
        VkFormat format,
        VkImageType type,
        VkImageTiling tiling,
        VkImageUsageFlags usage,
        VkImageCreateFlags flags);

VkPhysicalDeviceLimits PhysicalDeviceLimits(
    uint32_t                                    maxImageDimension1D,
    uint32_t                                    maxImageDimension2D,
    uint32_t                                    maxImageDimension3D,
    uint32_t                                    maxImageDimensionCube,
    uint32_t                                    maxImageArrayLayers,
    uint32_t                                    maxTexelBufferElements,
    uint32_t                                    maxUniformBufferRange,
    uint32_t                                    maxStorageBufferRange,
    uint32_t                                    maxPushConstantsSize,
    uint32_t                                    maxMemoryAllocationCount,
    uint32_t                                    maxSamplerAllocationCount,
    VkDeviceSize                                bufferImageGranularity,
    VkDeviceSize                                sparseAddressSpaceSize,
    uint32_t                                    maxBoundDescriptorSets,
    uint32_t                                    maxPerStageDescriptorSamplers,
    uint32_t                                    maxPerStageDescriptorUniformBuffers,
    uint32_t                                    maxPerStageDescriptorStorageBuffers,
    uint32_t                                    maxPerStageDescriptorSampledImages,
    uint32_t                                    maxPerStageDescriptorStorageImages,
    uint32_t                                    maxPerStageDescriptorInputAttachments,
    uint32_t                                    maxPerStageResources,
    uint32_t                                    maxDescriptorSetSamplers,
    uint32_t                                    maxDescriptorSetUniformBuffers,
    uint32_t                                    maxDescriptorSetUniformBuffersDynamic,
    uint32_t                                    maxDescriptorSetStorageBuffers,
    uint32_t                                    maxDescriptorSetStorageBuffersDynamic,
    uint32_t                                    maxDescriptorSetSampledImages,
    uint32_t                                    maxDescriptorSetStorageImages,
    uint32_t                                    maxDescriptorSetInputAttachments,
    uint32_t                                    maxVertexInputAttributes,
    uint32_t                                    maxVertexInputBindings,
    uint32_t                                    maxVertexInputAttributeOffset,
    uint32_t                                    maxVertexInputBindingStride,
    uint32_t                                    maxVertexOutputComponents,
    uint32_t                                    maxTessellationGenerationLevel,
    uint32_t                                    maxTessellationPatchSize,
    uint32_t                                    maxTessellationControlPerVertexInputComponents,
    uint32_t                                    maxTessellationControlPerVertexOutputComponents,
    uint32_t                                    maxTessellationControlPerPatchOutputComponents,
    uint32_t                                    maxTessellationControlTotalOutputComponents,
    uint32_t                                    maxTessellationEvaluationInputComponents,
    uint32_t                                    maxTessellationEvaluationOutputComponents,
    uint32_t                                    maxGeometryShaderInvocations,
    uint32_t                                    maxGeometryInputComponents,
    uint32_t                                    maxGeometryOutputComponents,
    uint32_t                                    maxGeometryOutputVertices,
    uint32_t                                    maxGeometryTotalOutputComponents,
    uint32_t                                    maxFragmentInputComponents,
    uint32_t                                    maxFragmentOutputAttachments,
    uint32_t                                    maxFragmentDualSrcAttachments,
    uint32_t                                    maxFragmentCombinedOutputResources,
    uint32_t                                    maxComputeSharedMemorySize,
    uint32_t                                    maxComputeWorkGroupCount[3],
    uint32_t                                    maxComputeWorkGroupInvocations,
    uint32_t                                    maxComputeWorkGroupSize[3],
    uint32_t                                    subPixelPrecisionBits,
    uint32_t                                    subTexelPrecisionBits,
    uint32_t                                    mipmapPrecisionBits,
    uint32_t                                    maxDrawIndexedIndexValue,
    uint32_t                                    maxDrawIndirectCount,
    float                                       maxSamplerLodBias,
    float                                       maxSamplerAnisotropy,
    uint32_t                                    maxViewports,
    uint32_t                                    maxViewportDimensions[2],
    float                                       viewportBoundsRange[2],
    uint32_t                                    viewportSubPixelBits,
    size_t                                      minMemoryMapAlignment,
    VkDeviceSize                                minTexelBufferOffsetAlignment,
    VkDeviceSize                                minUniformBufferOffsetAlignment,
    VkDeviceSize                                minStorageBufferOffsetAlignment,
    int32_t                                     minTexelOffset,
    uint32_t                                    maxTexelOffset,
    int32_t                                     minTexelGatherOffset,
    uint32_t                                    maxTexelGatherOffset,
    float                                       minInterpolationOffset,
    float                                       maxInterpolationOffset,
    uint32_t                                    subPixelInterpolationOffsetBits,
    uint32_t                                    maxFramebufferWidth,
    uint32_t                                    maxFramebufferHeight,
    uint32_t                                    maxFramebufferLayers,
    VkSampleCountFlags                          framebufferColorSampleCounts,
    VkSampleCountFlags                          framebufferDepthSampleCounts,
    VkSampleCountFlags                          framebufferStencilSampleCounts,
    VkSampleCountFlags                          framebufferNoAttachmentsSampleCounts,
    uint32_t                                    maxColorAttachments,
    VkSampleCountFlags                          sampledImageColorSampleCounts,
    VkSampleCountFlags                          sampledImageIntegerSampleCounts,
    VkSampleCountFlags                          sampledImageDepthSampleCounts,
    VkSampleCountFlags                          sampledImageStencilSampleCounts,
    VkSampleCountFlags                          storageImageSampleCounts,
    uint32_t                                    maxSampleMaskWords,
    VkBool32                                    timestampComputeAndGraphics,
    float                                       timestampPeriod,
    uint32_t                                    maxClipDistances,
    uint32_t                                    maxCullDistances,
    uint32_t                                    maxCombinedClipAndCullDistances,
    uint32_t                                    discreteQueuePriorities,
    float                                       pointSizeRange[2],
    float                                       lineWidthRange[2],
    float                                       pointSizeGranularity,
    float                                       lineWidthGranularity,
    VkBool32                                    strictLines,
    VkBool32                                    standardSampleLocations,
    VkDeviceSize                                optimalBufferCopyOffsetAlignment,
    VkDeviceSize                                optimalBufferCopyRowPitchAlignment,
    VkDeviceSize                                nonCoherentAtomSize);


VkPhysicalDeviceSparseProperties PhysicalDeviceSparseProperties(
    VkBool32                                    residencyStandard2DBlockShape,
    VkBool32                                    residencyStandard2DMultisampleBlockShape,
    VkBool32                                    residencyStandard3DBlockShape,
    VkBool32                                    residencyAlignedMipSize,
    VkBool32                                    residencyNonResidentStrict);


VkPhysicalDeviceProperties PhysicalDeviceProperties(
    uint32_t                                    apiVersion,
    uint32_t                                    driverVersion,
    uint32_t                                    vendorID,
    uint32_t                                    deviceID,
    VkPhysicalDeviceType                        deviceType,
    char                                        deviceName[VK_MAX_PHYSICAL_DEVICE_NAME_SIZE],
    uint8_t                                     pipelineCacheUUID[VK_UUID_SIZE],
    VkPhysicalDeviceLimits                      limits,
    VkPhysicalDeviceSparseProperties            sparseProperties);


VkPhysicalDeviceProperties getPhysicalDeviceProperties(
        VkPhysicalDevice physicalDevice);

VkQueueFamilyProperties QueueFamilyProperties(
    VkQueueFlags                                queueFlags,
    uint32_t                                    queueCount,
    uint32_t                                    timestampValidBits,
    VkExtent3D                                  minImageTransferGranularity);


std::vector< VkQueueFamilyProperties > getPhysicalDeviceQueueFamilyProperties(
        VkPhysicalDevice physicalDevice);

VkMemoryType MemoryType(
    VkMemoryPropertyFlags                       propertyFlags,
    uint32_t                                    heapIndex);


VkMemoryHeap MemoryHeap(
    VkDeviceSize                                size,
    VkMemoryHeapFlags                           flags);


VkPhysicalDeviceMemoryProperties PhysicalDeviceMemoryProperties(
    uint32_t                                    memoryTypeCount,
    VkMemoryType                                memoryTypes[VK_MAX_MEMORY_TYPES],
    uint32_t                                    memoryHeapCount,
    VkMemoryHeap                                memoryHeaps[VK_MAX_MEMORY_HEAPS]);


VkPhysicalDeviceMemoryProperties getPhysicalDeviceMemoryProperties(
        VkPhysicalDevice physicalDevice);

std::shared_ptr<VkDeviceQueueCreateInfoRAII> DeviceQueueCreateInfo(
    VkDeviceQueueCreateFlags                    flags,
    uint32_t                                    queueFamilyIndex,
    float* pQueuePriorities_in_array1, int pQueuePriorities_dim1);


std::shared_ptr<VkDeviceCreateInfoRAII> DeviceCreateInfo(
    VkDeviceCreateFlags                         flags,
    const std::vector<VkDeviceQueueCreateInfo> &vecQueueCreateInfos,
    const std::vector<std::string> &            vecEnabledLayerNames,
    const std::vector<std::string> &            vecEnabledExtensionNames,
    const VkPhysicalDeviceFeatures *            pEnabledFeatures);


std::shared_ptr<VkDevice_T> createDevice(
        VkPhysicalDevice physicalDevice,
        const VkDeviceCreateInfo & pCreateInfo);

VkExtensionProperties ExtensionProperties(
    char                                        extensionName[VK_MAX_EXTENSION_NAME_SIZE],
    uint32_t                                    specVersion);


std::vector< VkExtensionProperties > enumerateInstanceExtensionProperties(
        const char* pLayerName);

std::vector< VkExtensionProperties > enumerateDeviceExtensionProperties(
        VkPhysicalDevice physicalDevice,
        const char* pLayerName);

VkLayerProperties LayerProperties(
    char                                        layerName[VK_MAX_EXTENSION_NAME_SIZE],
    uint32_t                                    specVersion,
    uint32_t                                    implementationVersion,
    char                                        description[VK_MAX_DESCRIPTION_SIZE]);


std::vector< VkLayerProperties > enumerateInstanceLayerProperties(void);

std::vector< VkLayerProperties > enumerateDeviceLayerProperties(
        VkPhysicalDevice physicalDevice);

VkQueue getDeviceQueue(
        VkDevice device,
        uint32_t queueFamilyIndex,
        uint32_t queueIndex);

std::shared_ptr<VkSubmitInfoRAII> SubmitInfo(
    const std::vector<VkSemaphore> &            vecWaitSemaphores,
    const std::vector<VkPipelineStageFlags> &   vecWaitDstStageMask,
    const std::vector<VkCommandBuffer> &        vecCommandBuffers,
    const std::vector<VkSemaphore> &            vecSignalSemaphores);


void  queueSubmit(
        VkQueue queue,
        const std::vector<VkSubmitInfo> & pSubmits,
        VkFence fence);

void  queueWaitIdle(
        VkQueue queue);

void  deviceWaitIdle(
        VkDevice device);

VkMemoryAllocateInfo MemoryAllocateInfo(
    VkDeviceSize                                allocationSize,
    uint32_t                                    memoryTypeIndex);


std::shared_ptr<VkDeviceMemory_T> allocateMemory(
        VkDevice device,
        const VkMemoryAllocateInfo & pAllocateInfo);

void  unmapMemory(
        VkDevice device,
        VkDeviceMemory memory);

VkMappedMemoryRange MappedMemoryRange(
    VkDeviceMemory                              memory,
    VkDeviceSize                                offset,
    VkDeviceSize                                size);


void  flushMappedMemoryRanges(
        VkDevice device,
        const std::vector<VkMappedMemoryRange> & pMemoryRanges);

void  invalidateMappedMemoryRanges(
        VkDevice device,
        const std::vector<VkMappedMemoryRange> & pMemoryRanges);

VkDeviceSize getDeviceMemoryCommitment(
        VkDevice device,
        VkDeviceMemory memory);

void  bindBufferMemory(
        VkDevice device,
        VkBuffer buffer,
        VkDeviceMemory memory,
        VkDeviceSize memoryOffset);

void  bindImageMemory(
        VkDevice device,
        VkImage image,
        VkDeviceMemory memory,
        VkDeviceSize memoryOffset);

VkMemoryRequirements MemoryRequirements(
    VkDeviceSize                                size,
    VkDeviceSize                                alignment,
    uint32_t                                    memoryTypeBits);


VkMemoryRequirements getBufferMemoryRequirements(
        VkDevice device,
        VkBuffer buffer);

VkMemoryRequirements getImageMemoryRequirements(
        VkDevice device,
        VkImage image);

VkSparseImageFormatProperties SparseImageFormatProperties(
    VkImageAspectFlags                          aspectMask,
    VkExtent3D                                  imageGranularity,
    VkSparseImageFormatFlags                    flags);


VkSparseImageMemoryRequirements SparseImageMemoryRequirements(
    VkSparseImageFormatProperties               formatProperties,
    uint32_t                                    imageMipTailFirstLod,
    VkDeviceSize                                imageMipTailSize,
    VkDeviceSize                                imageMipTailOffset,
    VkDeviceSize                                imageMipTailStride);


std::vector< VkSparseImageMemoryRequirements > getImageSparseMemoryRequirements(
        VkDevice device,
        VkImage image);

std::vector< VkSparseImageFormatProperties > getPhysicalDeviceSparseImageFormatProperties(
        VkPhysicalDevice physicalDevice,
        VkFormat format,
        VkImageType type,
        VkSampleCountFlagBits samples,
        VkImageUsageFlags usage,
        VkImageTiling tiling);

VkSparseMemoryBind SparseMemoryBind(
    VkDeviceSize                                resourceOffset,
    VkDeviceSize                                size,
    VkDeviceMemory                              memory,
    VkDeviceSize                                memoryOffset,
    VkSparseMemoryBindFlags                     flags);


std::shared_ptr<VkSparseBufferMemoryBindInfoRAII> SparseBufferMemoryBindInfo(
    VkBuffer                                    buffer,
    const std::vector<VkSparseMemoryBind> &     vecBinds);


std::shared_ptr<VkSparseImageOpaqueMemoryBindInfoRAII> SparseImageOpaqueMemoryBindInfo(
    VkImage                                     image,
    const std::vector<VkSparseMemoryBind> &     vecBinds);


VkImageSubresource ImageSubresource(
    VkImageAspectFlags                          aspectMask,
    uint32_t                                    mipLevel,
    uint32_t                                    arrayLayer);


VkOffset3D Offset3D(
    int32_t                                     x,
    int32_t                                     y,
    int32_t                                     z);


VkSparseImageMemoryBind SparseImageMemoryBind(
    VkImageSubresource                          subresource,
    VkOffset3D                                  offset,
    VkExtent3D                                  extent,
    VkDeviceMemory                              memory,
    VkDeviceSize                                memoryOffset,
    VkSparseMemoryBindFlags                     flags);


std::shared_ptr<VkSparseImageMemoryBindInfoRAII> SparseImageMemoryBindInfo(
    VkImage                                     image,
    const std::vector<VkSparseImageMemoryBind> &vecBinds);


std::shared_ptr<VkBindSparseInfoRAII> BindSparseInfo(
    const std::vector<VkSemaphore> &            vecWaitSemaphores,
    const std::vector<VkSparseBufferMemoryBindInfo> &vecBufferBinds,
    const std::vector<VkSparseImageOpaqueMemoryBindInfo> &vecImageOpaqueBinds,
    const std::vector<VkSparseImageMemoryBindInfo> &vecImageBinds,
    const std::vector<VkSemaphore> &            vecSignalSemaphores);


void  queueBindSparse(
        VkQueue queue,
        const std::vector<VkBindSparseInfo> & pBindInfo,
        VkFence fence);

VkFenceCreateInfo FenceCreateInfo(
    VkFenceCreateFlags                          flags);


std::shared_ptr<VkFence_T> createFence(
        VkDevice device,
        const VkFenceCreateInfo & pCreateInfo);

void  resetFences(
        VkDevice device,
        const std::vector<VkFence> & pFences);

void  getFenceStatus(
        VkDevice device,
        VkFence fence);

void  waitForFences(
        VkDevice device,
        const std::vector<VkFence> & pFences,
        VkBool32 waitAll,
        uint64_t timeout);

VkSemaphoreCreateInfo SemaphoreCreateInfo(
    VkSemaphoreCreateFlags                      flags);


std::shared_ptr<VkSemaphore_T> createSemaphore(
        VkDevice device,
        const VkSemaphoreCreateInfo & pCreateInfo);

VkEventCreateInfo EventCreateInfo(
    VkEventCreateFlags                          flags);


std::shared_ptr<VkEvent_T> createEvent(
        VkDevice device,
        const VkEventCreateInfo & pCreateInfo);

void  getEventStatus(
        VkDevice device,
        VkEvent event);

void  setEvent(
        VkDevice device,
        VkEvent event);

void  resetEvent(
        VkDevice device,
        VkEvent event);

VkQueryPoolCreateInfo QueryPoolCreateInfo(
    VkQueryPoolCreateFlags                      flags,
    VkQueryType                                 queryType,
    uint32_t                                    queryCount,
    VkQueryPipelineStatisticFlags               pipelineStatistics);


std::shared_ptr<VkQueryPool_T> createQueryPool(
        VkDevice device,
        const VkQueryPoolCreateInfo & pCreateInfo);

void  getQueryPoolResults(
        VkDevice device,
        VkQueryPool queryPool,
        uint32_t firstQuery,
        uint32_t queryCount,
        size_t dataSize,
        VkDeviceSize stride,
        VkQueryResultFlags flags);

std::shared_ptr<VkBufferCreateInfoRAII> BufferCreateInfo(
    VkBufferCreateFlags                         flags,
    VkDeviceSize                                size,
    VkBufferUsageFlags                          usage,
    VkSharingMode                               sharingMode,
    unsigned int* pQueueFamilyIndices_in_array1, int pQueueFamilyIndices_dim1);


std::shared_ptr<VkBuffer_T> createBuffer(
        VkDevice device,
        const VkBufferCreateInfo & pCreateInfo);

VkBufferViewCreateInfo BufferViewCreateInfo(
    VkBufferViewCreateFlags                     flags,
    VkBuffer                                    buffer,
    VkFormat                                    format,
    VkDeviceSize                                offset,
    VkDeviceSize                                range);


std::shared_ptr<VkBufferView_T> createBufferView(
        VkDevice device,
        const VkBufferViewCreateInfo & pCreateInfo);

std::shared_ptr<VkImageCreateInfoRAII> ImageCreateInfo(
    VkImageCreateFlags                          flags,
    VkImageType                                 imageType,
    VkFormat                                    format,
    VkExtent3D                                  extent,
    uint32_t                                    mipLevels,
    uint32_t                                    arrayLayers,
    VkSampleCountFlagBits                       samples,
    VkImageTiling                               tiling,
    VkImageUsageFlags                           usage,
    VkSharingMode                               sharingMode,
    unsigned int* pQueueFamilyIndices_in_array1, int pQueueFamilyIndices_dim1,
    VkImageLayout                               initialLayout);


std::shared_ptr<VkImage_T> createImage(
        VkDevice device,
        const VkImageCreateInfo & pCreateInfo);

VkSubresourceLayout SubresourceLayout(
    VkDeviceSize                                offset,
    VkDeviceSize                                size,
    VkDeviceSize                                rowPitch,
    VkDeviceSize                                arrayPitch,
    VkDeviceSize                                depthPitch);


VkSubresourceLayout getImageSubresourceLayout(
        VkDevice device,
        VkImage image,
        const VkImageSubresource & pSubresource);

VkComponentMapping ComponentMapping(
    VkComponentSwizzle                          r,
    VkComponentSwizzle                          g,
    VkComponentSwizzle                          b,
    VkComponentSwizzle                          a);


VkImageSubresourceRange ImageSubresourceRange(
    VkImageAspectFlags                          aspectMask,
    uint32_t                                    baseMipLevel,
    uint32_t                                    levelCount,
    uint32_t                                    baseArrayLayer,
    uint32_t                                    layerCount);


VkImageViewCreateInfo ImageViewCreateInfo(
    VkImageViewCreateFlags                      flags,
    VkImage                                     image,
    VkImageViewType                             viewType,
    VkFormat                                    format,
    VkComponentMapping                          components,
    VkImageSubresourceRange                     subresourceRange);


std::shared_ptr<VkImageView_T> createImageView(
        VkDevice device,
        const VkImageViewCreateInfo & pCreateInfo);

std::shared_ptr<VkShaderModuleCreateInfoRAII> ShaderModuleCreateInfo(
    VkShaderModuleCreateFlags                   flags,
    unsigned int* pCode_in_array1, int pCode_dim1);


std::shared_ptr<VkShaderModule_T> createShaderModule(
        VkDevice device,
        const VkShaderModuleCreateInfo & pCreateInfo);

std::shared_ptr<VkPipelineCacheCreateInfoRAII> PipelineCacheCreateInfo(
    VkPipelineCacheCreateFlags                  flags,
    const std::vector<uint8_t> &                vecInitialData);


std::shared_ptr<VkPipelineCache_T> createPipelineCache(
        VkDevice device,
        const VkPipelineCacheCreateInfo & pCreateInfo);

size_t getPipelineCacheData(
        VkDevice device,
        VkPipelineCache pipelineCache);

void  mergePipelineCaches(
        VkDevice device,
        VkPipelineCache dstCache,
        const std::vector<VkPipelineCache> & pSrcCaches);

VkSpecializationMapEntry SpecializationMapEntry(
    uint32_t                                    constantID,
    uint32_t                                    offset,
    size_t                                      size);


std::shared_ptr<VkSpecializationInfoRAII> SpecializationInfo(
    const std::vector<VkSpecializationMapEntry> &vecMapEntries,
    const std::vector<uint8_t> &                vecData);


std::shared_ptr<VkPipelineShaderStageCreateInfoRAII> PipelineShaderStageCreateInfo(
    VkPipelineShaderStageCreateFlags            flags,
    VkShaderStageFlagBits                       stage,
    VkShaderModule                              module,
    const std::string &                         strName,
    const std::shared_ptr<VkSpecializationInfoRAII> &pSpecializationInfo);


VkVertexInputBindingDescription VertexInputBindingDescription(
    uint32_t                                    binding,
    uint32_t                                    stride,
    VkVertexInputRate                           inputRate);


VkVertexInputAttributeDescription VertexInputAttributeDescription(
    uint32_t                                    location,
    uint32_t                                    binding,
    VkFormat                                    format,
    uint32_t                                    offset);


std::shared_ptr<VkPipelineVertexInputStateCreateInfoRAII> PipelineVertexInputStateCreateInfo(
    VkPipelineVertexInputStateCreateFlags       flags,
    const std::vector<VkVertexInputBindingDescription> &vecVertexBindingDescriptions,
    const std::vector<VkVertexInputAttributeDescription> &vecVertexAttributeDescriptions);


VkPipelineInputAssemblyStateCreateInfo PipelineInputAssemblyStateCreateInfo(
    VkPipelineInputAssemblyStateCreateFlags     flags,
    VkPrimitiveTopology                         topology,
    VkBool32                                    primitiveRestartEnable);


VkPipelineTessellationStateCreateInfo PipelineTessellationStateCreateInfo(
    VkPipelineTessellationStateCreateFlags      flags,
    uint32_t                                    patchControlPoints);


VkViewport Viewport(
    float                                       x,
    float                                       y,
    float                                       width,
    float                                       height,
    float                                       minDepth,
    float                                       maxDepth);


VkOffset2D Offset2D(
    int32_t                                     x,
    int32_t                                     y);


VkExtent2D Extent2D(
    uint32_t                                    width,
    uint32_t                                    height);


VkRect2D Rect2D(
    VkOffset2D                                  offset,
    VkExtent2D                                  extent);


std::shared_ptr<VkPipelineViewportStateCreateInfoRAII> PipelineViewportStateCreateInfo(
    VkPipelineViewportStateCreateFlags          flags,
    const std::vector<VkViewport> &             vecViewports,
    const std::vector<VkRect2D> &               vecScissors);


VkPipelineRasterizationStateCreateInfo PipelineRasterizationStateCreateInfo(
    VkPipelineRasterizationStateCreateFlags     flags,
    VkBool32                                    depthClampEnable,
    VkBool32                                    rasterizerDiscardEnable,
    VkPolygonMode                               polygonMode,
    VkCullModeFlags                             cullMode,
    VkFrontFace                                 frontFace,
    VkBool32                                    depthBiasEnable,
    float                                       depthBiasConstantFactor,
    float                                       depthBiasClamp,
    float                                       depthBiasSlopeFactor,
    float                                       lineWidth);


VkPipelineMultisampleStateCreateInfo PipelineMultisampleStateCreateInfo(
    VkPipelineMultisampleStateCreateFlags       flags,
    VkSampleCountFlagBits                       rasterizationSamples,
    VkBool32                                    sampleShadingEnable,
    float                                       minSampleShading,
    const VkSampleMask*                         pSampleMask,
    VkBool32                                    alphaToCoverageEnable,
    VkBool32                                    alphaToOneEnable);


VkStencilOpState StencilOpState(
    VkStencilOp                                 failOp,
    VkStencilOp                                 passOp,
    VkStencilOp                                 depthFailOp,
    VkCompareOp                                 compareOp,
    uint32_t                                    compareMask,
    uint32_t                                    writeMask,
    uint32_t                                    reference);


VkPipelineDepthStencilStateCreateInfo PipelineDepthStencilStateCreateInfo(
    VkPipelineDepthStencilStateCreateFlags      flags,
    VkBool32                                    depthTestEnable,
    VkBool32                                    depthWriteEnable,
    VkCompareOp                                 depthCompareOp,
    VkBool32                                    depthBoundsTestEnable,
    VkBool32                                    stencilTestEnable,
    VkStencilOpState                            front,
    VkStencilOpState                            back,
    float                                       minDepthBounds,
    float                                       maxDepthBounds);


VkPipelineColorBlendAttachmentState PipelineColorBlendAttachmentState(
    VkBool32                                    blendEnable,
    VkBlendFactor                               srcColorBlendFactor,
    VkBlendFactor                               dstColorBlendFactor,
    VkBlendOp                                   colorBlendOp,
    VkBlendFactor                               srcAlphaBlendFactor,
    VkBlendFactor                               dstAlphaBlendFactor,
    VkBlendOp                                   alphaBlendOp,
    VkColorComponentFlags                       colorWriteMask);


std::shared_ptr<VkPipelineColorBlendStateCreateInfoRAII> PipelineColorBlendStateCreateInfo(
    VkPipelineColorBlendStateCreateFlags        flags,
    VkBool32                                    logicOpEnable,
    VkLogicOp                                   logicOp,
    const std::vector<VkPipelineColorBlendAttachmentState> &vecAttachments,
    float                                       blendConstants[4]);


std::shared_ptr<VkPipelineDynamicStateCreateInfoRAII> PipelineDynamicStateCreateInfo(
    VkPipelineDynamicStateCreateFlags           flags,
    const std::vector<VkDynamicState> &         vecDynamicStates);


std::shared_ptr<VkGraphicsPipelineCreateInfoRAII> GraphicsPipelineCreateInfo(
    VkPipelineCreateFlags                       flags,
    const std::vector<VkPipelineShaderStageCreateInfo> &vecStages,
    const std::shared_ptr<VkPipelineVertexInputStateCreateInfoRAII> &pVertexInputState,
    const VkPipelineInputAssemblyStateCreateInfo *pInputAssemblyState,
    const VkPipelineTessellationStateCreateInfo *pTessellationState,
    const std::shared_ptr<VkPipelineViewportStateCreateInfoRAII> &pViewportState,
    const VkPipelineRasterizationStateCreateInfo *pRasterizationState,
    const VkPipelineMultisampleStateCreateInfo *pMultisampleState,
    const VkPipelineDepthStencilStateCreateInfo *pDepthStencilState,
    const std::shared_ptr<VkPipelineColorBlendStateCreateInfoRAII> &pColorBlendState,
    const std::shared_ptr<VkPipelineDynamicStateCreateInfoRAII> &pDynamicState,
    VkPipelineLayout                            layout,
    VkRenderPass                                renderPass,
    uint32_t                                    subpass,
    VkPipeline                                  basePipelineHandle,
    int32_t                                     basePipelineIndex);


std::vector< std::shared_ptr<VkPipeline_T> > createGraphicsPipelines(
        VkDevice device,
        VkPipelineCache pipelineCache,
        const std::vector<VkGraphicsPipelineCreateInfo> & pCreateInfos);

VkComputePipelineCreateInfo ComputePipelineCreateInfo(
    VkPipelineCreateFlags                       flags,
    VkPipelineShaderStageCreateInfo             stage,
    VkPipelineLayout                            layout,
    VkPipeline                                  basePipelineHandle,
    int32_t                                     basePipelineIndex);


std::vector< std::shared_ptr<VkPipeline_T> > createComputePipelines(
        VkDevice device,
        VkPipelineCache pipelineCache,
        const std::vector<VkComputePipelineCreateInfo> & pCreateInfos);

VkPushConstantRange PushConstantRange(
    VkShaderStageFlags                          stageFlags,
    uint32_t                                    offset,
    uint32_t                                    size);


std::shared_ptr<VkPipelineLayoutCreateInfoRAII> PipelineLayoutCreateInfo(
    VkPipelineLayoutCreateFlags                 flags,
    const std::vector<VkDescriptorSetLayout> &  vecSetLayouts,
    const std::vector<VkPushConstantRange> &    vecPushConstantRanges);


std::shared_ptr<VkPipelineLayout_T> createPipelineLayout(
        VkDevice device,
        const VkPipelineLayoutCreateInfo & pCreateInfo);

VkSamplerCreateInfo SamplerCreateInfo(
    VkSamplerCreateFlags                        flags,
    VkFilter                                    magFilter,
    VkFilter                                    minFilter,
    VkSamplerMipmapMode                         mipmapMode,
    VkSamplerAddressMode                        addressModeU,
    VkSamplerAddressMode                        addressModeV,
    VkSamplerAddressMode                        addressModeW,
    float                                       mipLodBias,
    VkBool32                                    anisotropyEnable,
    float                                       maxAnisotropy,
    VkBool32                                    compareEnable,
    VkCompareOp                                 compareOp,
    float                                       minLod,
    float                                       maxLod,
    VkBorderColor                               borderColor,
    VkBool32                                    unnormalizedCoordinates);


std::shared_ptr<VkSampler_T> createSampler(
        VkDevice device,
        const VkSamplerCreateInfo & pCreateInfo);

std::shared_ptr<VkDescriptorSetLayoutBindingRAII> DescriptorSetLayoutBinding(
    uint32_t                                    binding,
    VkDescriptorType                            descriptorType,
    uint32_t                                    descriptorCount,
    VkShaderStageFlags                          stageFlags,
    const std::vector<VkSampler> &              vecImmutableSamplers);


std::shared_ptr<VkDescriptorSetLayoutCreateInfoRAII> DescriptorSetLayoutCreateInfo(
    VkDescriptorSetLayoutCreateFlags            flags,
    const std::vector<VkDescriptorSetLayoutBinding> &vecBindings);


std::shared_ptr<VkDescriptorSetLayout_T> createDescriptorSetLayout(
        VkDevice device,
        const VkDescriptorSetLayoutCreateInfo & pCreateInfo);

VkDescriptorPoolSize DescriptorPoolSize(
    VkDescriptorType                            type,
    uint32_t                                    descriptorCount);


std::shared_ptr<VkDescriptorPoolCreateInfoRAII> DescriptorPoolCreateInfo(
    VkDescriptorPoolCreateFlags                 flags,
    uint32_t                                    maxSets,
    const std::vector<VkDescriptorPoolSize> &   vecPoolSizes);


std::shared_ptr<VkDescriptorPool_T> createDescriptorPool(
        VkDevice device,
        const VkDescriptorPoolCreateInfo & pCreateInfo);

void  resetDescriptorPool(
        VkDevice device,
        VkDescriptorPool descriptorPool,
        VkDescriptorPoolResetFlags flags);

std::shared_ptr<VkDescriptorSetAllocateInfoRAII> DescriptorSetAllocateInfo(
    VkDescriptorPool                            descriptorPool,
    const std::vector<VkDescriptorSetLayout> &  vecSetLayouts);


VkDescriptorImageInfo DescriptorImageInfo(
    VkSampler                                   sampler,
    VkImageView                                 imageView,
    VkImageLayout                               imageLayout);


VkDescriptorBufferInfo DescriptorBufferInfo(
    VkBuffer                                    buffer,
    VkDeviceSize                                offset,
    VkDeviceSize                                range);


std::shared_ptr<VkWriteDescriptorSetRAII> WriteDescriptorSet(
    VkDescriptorSet                             dstSet,
    uint32_t                                    dstBinding,
    uint32_t                                    dstArrayElement,
    uint32_t                                    descriptorCount,
    VkDescriptorType                            descriptorType,
    const std::vector<VkDescriptorImageInfo> &  vecImageInfo,
    const std::vector<VkDescriptorBufferInfo> & vecBufferInfo,
    const std::vector<VkBufferView> &           vecTexelBufferView);


VkCopyDescriptorSet CopyDescriptorSet(
    VkDescriptorSet                             srcSet,
    uint32_t                                    srcBinding,
    uint32_t                                    srcArrayElement,
    VkDescriptorSet                             dstSet,
    uint32_t                                    dstBinding,
    uint32_t                                    dstArrayElement,
    uint32_t                                    descriptorCount);


void  updateDescriptorSets(
        VkDevice device,
        const std::vector<VkWriteDescriptorSet> & pDescriptorWrites,
        const std::vector<VkCopyDescriptorSet> & pDescriptorCopies);

std::shared_ptr<VkFramebufferCreateInfoRAII> FramebufferCreateInfo(
    VkFramebufferCreateFlags                    flags,
    VkRenderPass                                renderPass,
    const std::vector<VkImageView> &            vecAttachments,
    uint32_t                                    width,
    uint32_t                                    height,
    uint32_t                                    layers);


std::shared_ptr<VkFramebuffer_T> createFramebuffer(
        VkDevice device,
        const VkFramebufferCreateInfo & pCreateInfo);

VkAttachmentDescription AttachmentDescription(
    VkAttachmentDescriptionFlags                flags,
    VkFormat                                    format,
    VkSampleCountFlagBits                       samples,
    VkAttachmentLoadOp                          loadOp,
    VkAttachmentStoreOp                         storeOp,
    VkAttachmentLoadOp                          stencilLoadOp,
    VkAttachmentStoreOp                         stencilStoreOp,
    VkImageLayout                               initialLayout,
    VkImageLayout                               finalLayout);


VkAttachmentReference AttachmentReference(
    uint32_t                                    attachment,
    VkImageLayout                               layout);


std::shared_ptr<VkSubpassDescriptionRAII> SubpassDescription(
    VkSubpassDescriptionFlags                   flags,
    VkPipelineBindPoint                         pipelineBindPoint,
    const std::vector<VkAttachmentReference> &  vecInputAttachments,
    const std::vector<VkAttachmentReference> &  vecColorAttachments,
    const std::vector<VkAttachmentReference> &  vecResolveAttachments,
    const VkAttachmentReference *               pDepthStencilAttachment,
    unsigned int* pPreserveAttachments_in_array1, int pPreserveAttachments_dim1);


VkSubpassDependency SubpassDependency(
    uint32_t                                    srcSubpass,
    uint32_t                                    dstSubpass,
    VkPipelineStageFlags                        srcStageMask,
    VkPipelineStageFlags                        dstStageMask,
    VkAccessFlags                               srcAccessMask,
    VkAccessFlags                               dstAccessMask,
    VkDependencyFlags                           dependencyFlags);


std::shared_ptr<VkRenderPassCreateInfoRAII> RenderPassCreateInfo(
    VkRenderPassCreateFlags                     flags,
    const std::vector<VkAttachmentDescription> &vecAttachments,
    const std::vector<VkSubpassDescription> &   vecSubpasses,
    const std::vector<VkSubpassDependency> &    vecDependencies);


std::shared_ptr<VkRenderPass_T> createRenderPass(
        VkDevice device,
        const VkRenderPassCreateInfo & pCreateInfo);

VkExtent2D getRenderAreaGranularity(
        VkDevice device,
        VkRenderPass renderPass);

VkCommandPoolCreateInfo CommandPoolCreateInfo(
    VkCommandPoolCreateFlags                    flags,
    uint32_t                                    queueFamilyIndex);


std::shared_ptr<VkCommandPool_T> createCommandPool(
        VkDevice device,
        const VkCommandPoolCreateInfo & pCreateInfo);

void  resetCommandPool(
        VkDevice device,
        VkCommandPool commandPool,
        VkCommandPoolResetFlags flags);

VkCommandBufferAllocateInfo CommandBufferAllocateInfo(
    VkCommandPool                               commandPool,
    VkCommandBufferLevel                        level,
    uint32_t                                    commandBufferCount);


VkCommandBufferInheritanceInfo CommandBufferInheritanceInfo(
    VkRenderPass                                renderPass,
    uint32_t                                    subpass,
    VkFramebuffer                               framebuffer,
    VkBool32                                    occlusionQueryEnable,
    VkQueryControlFlags                         queryFlags,
    VkQueryPipelineStatisticFlags               pipelineStatistics);


std::shared_ptr<VkCommandBufferBeginInfoRAII> CommandBufferBeginInfo(
    VkCommandBufferUsageFlags                   flags,
    const VkCommandBufferInheritanceInfo *      pInheritanceInfo);


void  beginCommandBuffer(
        VkCommandBuffer commandBuffer,
        const VkCommandBufferBeginInfo & pBeginInfo);

void  endCommandBuffer(
        VkCommandBuffer commandBuffer);

void  resetCommandBuffer(
        VkCommandBuffer commandBuffer,
        VkCommandBufferResetFlags flags);

void  cmdBindPipeline(
        VkCommandBuffer commandBuffer,
        VkPipelineBindPoint pipelineBindPoint,
        VkPipeline pipeline);

void  cmdSetViewport(
        VkCommandBuffer commandBuffer,
        uint32_t firstViewport,
        const std::vector<VkViewport> & pViewports);

void  cmdSetScissor(
        VkCommandBuffer commandBuffer,
        uint32_t firstScissor,
        const std::vector<VkRect2D> & pScissors);

void  cmdSetLineWidth(
        VkCommandBuffer commandBuffer,
        float lineWidth);

void  cmdSetDepthBias(
        VkCommandBuffer commandBuffer,
        float depthBiasConstantFactor,
        float depthBiasClamp,
        float depthBiasSlopeFactor);

void  cmdSetBlendConstants(
        VkCommandBuffer commandBuffer,
        const float blendConstants[4]);

void  cmdSetDepthBounds(
        VkCommandBuffer commandBuffer,
        float minDepthBounds,
        float maxDepthBounds);

void  cmdSetStencilCompareMask(
        VkCommandBuffer commandBuffer,
        VkStencilFaceFlags faceMask,
        uint32_t compareMask);

void  cmdSetStencilWriteMask(
        VkCommandBuffer commandBuffer,
        VkStencilFaceFlags faceMask,
        uint32_t writeMask);

void  cmdSetStencilReference(
        VkCommandBuffer commandBuffer,
        VkStencilFaceFlags faceMask,
        uint32_t reference);

void  cmdBindDescriptorSets(
        VkCommandBuffer commandBuffer,
        VkPipelineBindPoint pipelineBindPoint,
        VkPipelineLayout layout,
        uint32_t firstSet,
        const std::vector<VkDescriptorSet> & pDescriptorSets,
        unsigned int* pDynamicOffsets_in_array1, int pDynamicOffsets_dim1);

void  cmdBindIndexBuffer(
        VkCommandBuffer commandBuffer,
        VkBuffer buffer,
        VkDeviceSize offset,
        VkIndexType indexType);

void  cmdBindVertexBuffers(
        VkCommandBuffer commandBuffer,
        uint32_t firstBinding,
        const std::vector<VkBuffer> & pBuffers,
        const std::vector<VkDeviceSize> & pOffsets);

void  cmdDraw(
        VkCommandBuffer commandBuffer,
        uint32_t vertexCount,
        uint32_t instanceCount,
        uint32_t firstVertex,
        uint32_t firstInstance);

void  cmdDrawIndexed(
        VkCommandBuffer commandBuffer,
        uint32_t indexCount,
        uint32_t instanceCount,
        uint32_t firstIndex,
        int32_t vertexOffset,
        uint32_t firstInstance);

void  cmdDrawIndirect(
        VkCommandBuffer commandBuffer,
        VkBuffer buffer,
        VkDeviceSize offset,
        uint32_t drawCount,
        uint32_t stride);

void  cmdDrawIndexedIndirect(
        VkCommandBuffer commandBuffer,
        VkBuffer buffer,
        VkDeviceSize offset,
        uint32_t drawCount,
        uint32_t stride);

void  cmdDispatch(
        VkCommandBuffer commandBuffer,
        uint32_t groupCountX,
        uint32_t groupCountY,
        uint32_t groupCountZ);

void  cmdDispatchIndirect(
        VkCommandBuffer commandBuffer,
        VkBuffer buffer,
        VkDeviceSize offset);

VkBufferCopy BufferCopy(
    VkDeviceSize                                srcOffset,
    VkDeviceSize                                dstOffset,
    VkDeviceSize                                size);


void  cmdCopyBuffer(
        VkCommandBuffer commandBuffer,
        VkBuffer srcBuffer,
        VkBuffer dstBuffer,
        const std::vector<VkBufferCopy> & pRegions);

VkImageSubresourceLayers ImageSubresourceLayers(
    VkImageAspectFlags                          aspectMask,
    uint32_t                                    mipLevel,
    uint32_t                                    baseArrayLayer,
    uint32_t                                    layerCount);


VkImageCopy ImageCopy(
    VkImageSubresourceLayers                    srcSubresource,
    VkOffset3D                                  srcOffset,
    VkImageSubresourceLayers                    dstSubresource,
    VkOffset3D                                  dstOffset,
    VkExtent3D                                  extent);


void  cmdCopyImage(
        VkCommandBuffer commandBuffer,
        VkImage srcImage,
        VkImageLayout srcImageLayout,
        VkImage dstImage,
        VkImageLayout dstImageLayout,
        const std::vector<VkImageCopy> & pRegions);

VkImageBlit ImageBlit(
    VkImageSubresourceLayers                    srcSubresource,
    VkOffset3D                                  srcOffsets[2],
    VkImageSubresourceLayers                    dstSubresource,
    VkOffset3D                                  dstOffsets[2]);


void  cmdBlitImage(
        VkCommandBuffer commandBuffer,
        VkImage srcImage,
        VkImageLayout srcImageLayout,
        VkImage dstImage,
        VkImageLayout dstImageLayout,
        const std::vector<VkImageBlit> & pRegions,
        VkFilter filter);

VkBufferImageCopy BufferImageCopy(
    VkDeviceSize                                bufferOffset,
    uint32_t                                    bufferRowLength,
    uint32_t                                    bufferImageHeight,
    VkImageSubresourceLayers                    imageSubresource,
    VkOffset3D                                  imageOffset,
    VkExtent3D                                  imageExtent);


void  cmdCopyBufferToImage(
        VkCommandBuffer commandBuffer,
        VkBuffer srcBuffer,
        VkImage dstImage,
        VkImageLayout dstImageLayout,
        const std::vector<VkBufferImageCopy> & pRegions);

void  cmdCopyImageToBuffer(
        VkCommandBuffer commandBuffer,
        VkImage srcImage,
        VkImageLayout srcImageLayout,
        VkBuffer dstBuffer,
        const std::vector<VkBufferImageCopy> & pRegions);

void  cmdFillBuffer(
        VkCommandBuffer commandBuffer,
        VkBuffer dstBuffer,
        VkDeviceSize dstOffset,
        VkDeviceSize size,
        uint32_t data);

void  cmdClearColorImage(
        VkCommandBuffer commandBuffer,
        VkImage image,
        VkImageLayout imageLayout,
        const VkClearColorValue & pColor,
        const std::vector<VkImageSubresourceRange> & pRanges);

VkClearDepthStencilValue ClearDepthStencilValue(
    float                                       depth,
    uint32_t                                    stencil);


void  cmdClearDepthStencilImage(
        VkCommandBuffer commandBuffer,
        VkImage image,
        VkImageLayout imageLayout,
        const VkClearDepthStencilValue & pDepthStencil,
        const std::vector<VkImageSubresourceRange> & pRanges);

VkClearAttachment ClearAttachment(
    VkImageAspectFlags                          aspectMask,
    uint32_t                                    colorAttachment,
    VkClearValue                                clearValue);


VkClearRect ClearRect(
    VkRect2D                                    rect,
    uint32_t                                    baseArrayLayer,
    uint32_t                                    layerCount);


void  cmdClearAttachments(
        VkCommandBuffer commandBuffer,
        const std::vector<VkClearAttachment> & pAttachments,
        const std::vector<VkClearRect> & pRects);

VkImageResolve ImageResolve(
    VkImageSubresourceLayers                    srcSubresource,
    VkOffset3D                                  srcOffset,
    VkImageSubresourceLayers                    dstSubresource,
    VkOffset3D                                  dstOffset,
    VkExtent3D                                  extent);


void  cmdResolveImage(
        VkCommandBuffer commandBuffer,
        VkImage srcImage,
        VkImageLayout srcImageLayout,
        VkImage dstImage,
        VkImageLayout dstImageLayout,
        const std::vector<VkImageResolve> & pRegions);

void  cmdSetEvent(
        VkCommandBuffer commandBuffer,
        VkEvent event,
        VkPipelineStageFlags stageMask);

void  cmdResetEvent(
        VkCommandBuffer commandBuffer,
        VkEvent event,
        VkPipelineStageFlags stageMask);

VkMemoryBarrier MemoryBarrier(
    VkAccessFlags                               srcAccessMask,
    VkAccessFlags                               dstAccessMask);


VkBufferMemoryBarrier BufferMemoryBarrier(
    VkAccessFlags                               srcAccessMask,
    VkAccessFlags                               dstAccessMask,
    uint32_t                                    srcQueueFamilyIndex,
    uint32_t                                    dstQueueFamilyIndex,
    VkBuffer                                    buffer,
    VkDeviceSize                                offset,
    VkDeviceSize                                size);


VkImageMemoryBarrier ImageMemoryBarrier(
    VkAccessFlags                               srcAccessMask,
    VkAccessFlags                               dstAccessMask,
    VkImageLayout                               oldLayout,
    VkImageLayout                               newLayout,
    uint32_t                                    srcQueueFamilyIndex,
    uint32_t                                    dstQueueFamilyIndex,
    VkImage                                     image,
    VkImageSubresourceRange                     subresourceRange);


void  cmdWaitEvents(
        VkCommandBuffer commandBuffer,
        const std::vector<VkEvent> & pEvents,
        VkPipelineStageFlags srcStageMask,
        VkPipelineStageFlags dstStageMask,
        const std::vector<VkMemoryBarrier> & pMemoryBarriers,
        const std::vector<VkBufferMemoryBarrier> & pBufferMemoryBarriers,
        const std::vector<VkImageMemoryBarrier> & pImageMemoryBarriers);

void  cmdPipelineBarrier(
        VkCommandBuffer commandBuffer,
        VkPipelineStageFlags srcStageMask,
        VkPipelineStageFlags dstStageMask,
        VkDependencyFlags dependencyFlags,
        const std::vector<VkMemoryBarrier> & pMemoryBarriers,
        const std::vector<VkBufferMemoryBarrier> & pBufferMemoryBarriers,
        const std::vector<VkImageMemoryBarrier> & pImageMemoryBarriers);

void  cmdBeginQuery(
        VkCommandBuffer commandBuffer,
        VkQueryPool queryPool,
        uint32_t query,
        VkQueryControlFlags flags);

void  cmdEndQuery(
        VkCommandBuffer commandBuffer,
        VkQueryPool queryPool,
        uint32_t query);

void  cmdResetQueryPool(
        VkCommandBuffer commandBuffer,
        VkQueryPool queryPool,
        uint32_t firstQuery,
        uint32_t queryCount);

void  cmdWriteTimestamp(
        VkCommandBuffer commandBuffer,
        VkPipelineStageFlagBits pipelineStage,
        VkQueryPool queryPool,
        uint32_t query);

void  cmdCopyQueryPoolResults(
        VkCommandBuffer commandBuffer,
        VkQueryPool queryPool,
        uint32_t firstQuery,
        uint32_t queryCount,
        VkBuffer dstBuffer,
        VkDeviceSize dstOffset,
        VkDeviceSize stride,
        VkQueryResultFlags flags);

std::shared_ptr<VkRenderPassBeginInfoRAII> RenderPassBeginInfo(
    VkRenderPass                                renderPass,
    VkFramebuffer                               framebuffer,
    VkRect2D                                    renderArea,
    const std::vector<VkClearValue> &           vecClearValues);


void  cmdBeginRenderPass(
        VkCommandBuffer commandBuffer,
        const VkRenderPassBeginInfo & pRenderPassBegin,
        VkSubpassContents contents);

void  cmdNextSubpass(
        VkCommandBuffer commandBuffer,
        VkSubpassContents contents);

void  cmdEndRenderPass(
        VkCommandBuffer commandBuffer);

void  cmdExecuteCommands(
        VkCommandBuffer commandBuffer,
        const std::vector<VkCommandBuffer> & pCommandBuffers);

VkDispatchIndirectCommand DispatchIndirectCommand(
    uint32_t                                    x,
    uint32_t                                    y,
    uint32_t                                    z);


VkDrawIndexedIndirectCommand DrawIndexedIndirectCommand(
    uint32_t                                    indexCount,
    uint32_t                                    instanceCount,
    uint32_t                                    firstIndex,
    int32_t                                     vertexOffset,
    uint32_t                                    firstInstance);


VkDrawIndirectCommand DrawIndirectCommand(
    uint32_t                                    vertexCount,
    uint32_t                                    instanceCount,
    uint32_t                                    firstVertex,
    uint32_t                                    firstInstance);



#define VK_KHR_surface 1
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkSurfaceKHR)

#define VK_KHR_SURFACE_SPEC_VERSION       25
#define VK_KHR_SURFACE_EXTENSION_NAME     "VK_KHR_surface"
#define VK_COLORSPACE_SRGB_NONLINEAR_KHR  VK_COLOR_SPACE_SRGB_NONLINEAR_KHR


typedef enum VkColorSpaceKHR {
    VK_COLOR_SPACE_SRGB_NONLINEAR_KHR = 0,
    VK_COLOR_SPACE_DISPLAY_P3_NONLINEAR_EXT = 1000104001,
    VK_COLOR_SPACE_EXTENDED_SRGB_LINEAR_EXT = 1000104002,
    VK_COLOR_SPACE_DCI_P3_LINEAR_EXT = 1000104003,
    VK_COLOR_SPACE_DCI_P3_NONLINEAR_EXT = 1000104004,
    VK_COLOR_SPACE_BT709_LINEAR_EXT = 1000104005,
    VK_COLOR_SPACE_BT709_NONLINEAR_EXT = 1000104006,
    VK_COLOR_SPACE_BT2020_LINEAR_EXT = 1000104007,
    VK_COLOR_SPACE_HDR10_ST2084_EXT = 1000104008,
    VK_COLOR_SPACE_DOLBYVISION_EXT = 1000104009,
    VK_COLOR_SPACE_HDR10_HLG_EXT = 1000104010,
    VK_COLOR_SPACE_ADOBERGB_LINEAR_EXT = 1000104011,
    VK_COLOR_SPACE_ADOBERGB_NONLINEAR_EXT = 1000104012,
    VK_COLOR_SPACE_PASS_THROUGH_EXT = 1000104013,
    VK_COLOR_SPACE_EXTENDED_SRGB_NONLINEAR_EXT = 1000104014,
    VK_COLOR_SPACE_BEGIN_RANGE_KHR = VK_COLOR_SPACE_SRGB_NONLINEAR_KHR,
    VK_COLOR_SPACE_END_RANGE_KHR = VK_COLOR_SPACE_SRGB_NONLINEAR_KHR,
    VK_COLOR_SPACE_RANGE_SIZE_KHR = (VK_COLOR_SPACE_SRGB_NONLINEAR_KHR - VK_COLOR_SPACE_SRGB_NONLINEAR_KHR + 1),
    VK_COLOR_SPACE_MAX_ENUM_KHR = 0x7FFFFFFF
} VkColorSpaceKHR;

typedef enum VkPresentModeKHR {
    VK_PRESENT_MODE_IMMEDIATE_KHR = 0,
    VK_PRESENT_MODE_MAILBOX_KHR = 1,
    VK_PRESENT_MODE_FIFO_KHR = 2,
    VK_PRESENT_MODE_FIFO_RELAXED_KHR = 3,
    VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR = 1000111000,
    VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR = 1000111001,
    VK_PRESENT_MODE_BEGIN_RANGE_KHR = VK_PRESENT_MODE_IMMEDIATE_KHR,
    VK_PRESENT_MODE_END_RANGE_KHR = VK_PRESENT_MODE_FIFO_RELAXED_KHR,
    VK_PRESENT_MODE_RANGE_SIZE_KHR = (VK_PRESENT_MODE_FIFO_RELAXED_KHR - VK_PRESENT_MODE_IMMEDIATE_KHR + 1),
    VK_PRESENT_MODE_MAX_ENUM_KHR = 0x7FFFFFFF
} VkPresentModeKHR;


typedef enum VkSurfaceTransformFlagBitsKHR {
    VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR = 0x00000001,
    VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR = 0x00000002,
    VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR = 0x00000004,
    VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR = 0x00000008,
    VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR = 0x00000010,
    VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR = 0x00000020,
    VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR = 0x00000040,
    VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR = 0x00000080,
    VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR = 0x00000100,
    VK_SURFACE_TRANSFORM_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF
} VkSurfaceTransformFlagBitsKHR;
typedef VkFlags VkSurfaceTransformFlagsKHR;

typedef enum VkCompositeAlphaFlagBitsKHR {
    VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR = 0x00000001,
    VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR = 0x00000002,
    VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR = 0x00000004,
    VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR = 0x00000008,
    VK_COMPOSITE_ALPHA_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF
} VkCompositeAlphaFlagBitsKHR;
typedef VkFlags VkCompositeAlphaFlagsKHR;

typedef struct VkSurfaceCapabilitiesKHR {
    uint32_t                         minImageCount;
    uint32_t                         maxImageCount;
    VkExtent2D                       currentExtent;
    VkExtent2D                       minImageExtent;
    VkExtent2D                       maxImageExtent;
    uint32_t                         maxImageArrayLayers;
    VkSurfaceTransformFlagsKHR       supportedTransforms;
    VkSurfaceTransformFlagBitsKHR    currentTransform;
    VkCompositeAlphaFlagsKHR         supportedCompositeAlpha;
    VkImageUsageFlags                supportedUsageFlags;
} VkSurfaceCapabilitiesKHR;

typedef struct VkSurfaceFormatKHR {
    VkFormat           format;
    VkColorSpaceKHR    colorSpace;
} VkSurfaceFormatKHR;


typedef void (VKAPI_PTR *PFN_vkDestroySurfaceKHR)(VkInstance instance, VkSurfaceKHR surface, const VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkGetPhysicalDeviceSurfaceSupportKHR)(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, VkSurfaceKHR surface, VkBool32* pSupported);
typedef VkResult (VKAPI_PTR *PFN_vkGetPhysicalDeviceSurfaceCapabilitiesKHR)(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, VkSurfaceCapabilitiesKHR* pSurfaceCapabilities);
typedef VkResult (VKAPI_PTR *PFN_vkGetPhysicalDeviceSurfaceFormatsKHR)(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, uint32_t* pSurfaceFormatCount, VkSurfaceFormatKHR* pSurfaceFormats);
typedef VkResult (VKAPI_PTR *PFN_vkGetPhysicalDeviceSurfacePresentModesKHR)(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, uint32_t* pPresentModeCount, VkPresentModeKHR* pPresentModes);

VkBool32 getPhysicalDeviceSurfaceSupportKHR(
        VkPhysicalDevice physicalDevice,
        uint32_t queueFamilyIndex,
        VkSurfaceKHR surface);

VkSurfaceCapabilitiesKHR SurfaceCapabilitiesKHR(
    uint32_t                                    minImageCount,
    uint32_t                                    maxImageCount,
    VkExtent2D                                  currentExtent,
    VkExtent2D                                  minImageExtent,
    VkExtent2D                                  maxImageExtent,
    uint32_t                                    maxImageArrayLayers,
    VkSurfaceTransformFlagsKHR                  supportedTransforms,
    VkSurfaceTransformFlagBitsKHR               currentTransform,
    VkCompositeAlphaFlagsKHR                    supportedCompositeAlpha,
    VkImageUsageFlags                           supportedUsageFlags);


VkSurfaceCapabilitiesKHR getPhysicalDeviceSurfaceCapabilitiesKHR(
        VkPhysicalDevice physicalDevice,
        VkSurfaceKHR surface);

VkSurfaceFormatKHR SurfaceFormatKHR(
    VkFormat                                    format,
    VkColorSpaceKHR                             colorSpace);


std::vector< VkSurfaceFormatKHR > getPhysicalDeviceSurfaceFormatsKHR(
        VkPhysicalDevice physicalDevice,
        VkSurfaceKHR surface);

std::vector< VkPresentModeKHR > getPhysicalDeviceSurfacePresentModesKHR(
        VkPhysicalDevice physicalDevice,
        VkSurfaceKHR surface);


#define VK_KHR_swapchain 1
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkSwapchainKHR)

#define VK_KHR_SWAPCHAIN_SPEC_VERSION     68
#define VK_KHR_SWAPCHAIN_EXTENSION_NAME   "VK_KHR_swapchain"


typedef enum VkSwapchainCreateFlagBitsKHR {
    VK_SWAPCHAIN_CREATE_BIND_SFR_BIT_KHX = 0x00000001,
    VK_SWAPCHAIN_CREATE_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF
} VkSwapchainCreateFlagBitsKHR;
typedef VkFlags VkSwapchainCreateFlagsKHR;

typedef struct VkSwapchainCreateInfoKHR {
    VkStructureType                  sType;
    const void*                      pNext;
    VkSwapchainCreateFlagsKHR        flags;
    VkSurfaceKHR                     surface;
    uint32_t                         minImageCount;
    VkFormat                         imageFormat;
    VkColorSpaceKHR                  imageColorSpace;
    VkExtent2D                       imageExtent;
    uint32_t                         imageArrayLayers;
    VkImageUsageFlags                imageUsage;
    VkSharingMode                    imageSharingMode;
    uint32_t                         queueFamilyIndexCount;
    const uint32_t*                  pQueueFamilyIndices;
    VkSurfaceTransformFlagBitsKHR    preTransform;
    VkCompositeAlphaFlagBitsKHR      compositeAlpha;
    VkPresentModeKHR                 presentMode;
    VkBool32                         clipped;
    VkSwapchainKHR                   oldSwapchain;
} VkSwapchainCreateInfoKHR;

struct VkSwapchainCreateInfoKHRRAII {
   VkSwapchainCreateInfoKHR nonRaiiObj;
    std::vector<uint32_t>                       vecQueueFamilyIndices;
};

typedef struct VkPresentInfoKHR {
    VkStructureType          sType;
    const void*              pNext;
    uint32_t                 waitSemaphoreCount;
    const VkSemaphore*       pWaitSemaphores;
    uint32_t                 swapchainCount;
    const VkSwapchainKHR*    pSwapchains;
    const uint32_t*          pImageIndices;
    VkResult*                pResults;
} VkPresentInfoKHR;

struct VkPresentInfoKHRRAII {
   VkPresentInfoKHR nonRaiiObj;
    std::vector<VkSemaphore>                    vecWaitSemaphores;
    std::vector<VkSwapchainKHR>                 vecSwapchains;
    std::vector<uint32_t>                       vecImageIndices;
    std::vector<VkResult>                       vecResults;
};


typedef VkResult (VKAPI_PTR *PFN_vkCreateSwapchainKHR)(VkDevice device, const VkSwapchainCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSwapchainKHR* pSwapchain);
typedef void (VKAPI_PTR *PFN_vkDestroySwapchainKHR)(VkDevice device, VkSwapchainKHR swapchain, const VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkGetSwapchainImagesKHR)(VkDevice device, VkSwapchainKHR swapchain, uint32_t* pSwapchainImageCount, VkImage* pSwapchainImages);
typedef VkResult (VKAPI_PTR *PFN_vkAcquireNextImageKHR)(VkDevice device, VkSwapchainKHR swapchain, uint64_t timeout, VkSemaphore semaphore, VkFence fence, uint32_t* pImageIndex);
typedef VkResult (VKAPI_PTR *PFN_vkQueuePresentKHR)(VkQueue queue, const VkPresentInfoKHR* pPresentInfo);

std::shared_ptr<VkSwapchainCreateInfoKHRRAII> SwapchainCreateInfoKHR(
    VkSwapchainCreateFlagsKHR                   flags,
    VkSurfaceKHR                                surface,
    uint32_t                                    minImageCount,
    VkFormat                                    imageFormat,
    VkColorSpaceKHR                             imageColorSpace,
    VkExtent2D                                  imageExtent,
    uint32_t                                    imageArrayLayers,
    VkImageUsageFlags                           imageUsage,
    VkSharingMode                               imageSharingMode,
    unsigned int* pQueueFamilyIndices_in_array1, int pQueueFamilyIndices_dim1,
    VkSurfaceTransformFlagBitsKHR               preTransform,
    VkCompositeAlphaFlagBitsKHR                 compositeAlpha,
    VkPresentModeKHR                            presentMode,
    VkBool32                                    clipped,
    VkSwapchainKHR                              oldSwapchain);


std::shared_ptr<VkSwapchainKHR_T> createSwapchainKHR(
        VkDevice device,
        const VkSwapchainCreateInfoKHR & pCreateInfo);

std::vector< VkImage > getSwapchainImagesKHR(
        VkDevice device,
        VkSwapchainKHR swapchain);

uint32_t acquireNextImageKHR(
        VkDevice device,
        VkSwapchainKHR swapchain,
        uint64_t timeout,
        VkSemaphore semaphore,
        VkFence fence);

std::shared_ptr<VkPresentInfoKHRRAII> PresentInfoKHR(
    const std::vector<VkSemaphore> &            vecWaitSemaphores,
    const std::vector<VkSwapchainKHR> &         vecSwapchains,
    unsigned int* pImageIndices_in_array1, int pImageIndices_dim1,
    const std::vector<VkResult> &               vecResults);


void  queuePresentKHR(
        VkQueue queue,
        const VkPresentInfoKHR & pPresentInfo);


#define VK_KHR_display 1
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkDisplayKHR)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkDisplayModeKHR)

#define VK_KHR_DISPLAY_SPEC_VERSION       21
#define VK_KHR_DISPLAY_EXTENSION_NAME     "VK_KHR_display"


typedef enum VkDisplayPlaneAlphaFlagBitsKHR {
    VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR = 0x00000001,
    VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR = 0x00000002,
    VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR = 0x00000004,
    VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR = 0x00000008,
    VK_DISPLAY_PLANE_ALPHA_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF
} VkDisplayPlaneAlphaFlagBitsKHR;
typedef VkFlags VkDisplayPlaneAlphaFlagsKHR;
typedef VkFlags VkDisplayModeCreateFlagsKHR;
typedef VkFlags VkDisplaySurfaceCreateFlagsKHR;

typedef struct VkDisplayPropertiesKHR {
    VkDisplayKHR                  display;
    const char*                   displayName;
    VkExtent2D                    physicalDimensions;
    VkExtent2D                    physicalResolution;
    VkSurfaceTransformFlagsKHR    supportedTransforms;
    VkBool32                      planeReorderPossible;
    VkBool32                      persistentContent;
} VkDisplayPropertiesKHR;

struct VkDisplayPropertiesKHRRAII {
   VkDisplayPropertiesKHR nonRaiiObj;
    std::string                                 strisplayName;
};

typedef struct VkDisplayModeParametersKHR {
    VkExtent2D    visibleRegion;
    uint32_t      refreshRate;
} VkDisplayModeParametersKHR;

typedef struct VkDisplayModePropertiesKHR {
    VkDisplayModeKHR              displayMode;
    VkDisplayModeParametersKHR    parameters;
} VkDisplayModePropertiesKHR;

typedef struct VkDisplayModeCreateInfoKHR {
    VkStructureType                sType;
    const void*                    pNext;
    VkDisplayModeCreateFlagsKHR    flags;
    VkDisplayModeParametersKHR     parameters;
} VkDisplayModeCreateInfoKHR;

typedef struct VkDisplayPlaneCapabilitiesKHR {
    VkDisplayPlaneAlphaFlagsKHR    supportedAlpha;
    VkOffset2D                     minSrcPosition;
    VkOffset2D                     maxSrcPosition;
    VkExtent2D                     minSrcExtent;
    VkExtent2D                     maxSrcExtent;
    VkOffset2D                     minDstPosition;
    VkOffset2D                     maxDstPosition;
    VkExtent2D                     minDstExtent;
    VkExtent2D                     maxDstExtent;
} VkDisplayPlaneCapabilitiesKHR;

typedef struct VkDisplayPlanePropertiesKHR {
    VkDisplayKHR    currentDisplay;
    uint32_t        currentStackIndex;
} VkDisplayPlanePropertiesKHR;

typedef struct VkDisplaySurfaceCreateInfoKHR {
    VkStructureType                   sType;
    const void*                       pNext;
    VkDisplaySurfaceCreateFlagsKHR    flags;
    VkDisplayModeKHR                  displayMode;
    uint32_t                          planeIndex;
    uint32_t                          planeStackIndex;
    VkSurfaceTransformFlagBitsKHR     transform;
    float                             globalAlpha;
    VkDisplayPlaneAlphaFlagBitsKHR    alphaMode;
    VkExtent2D                        imageExtent;
} VkDisplaySurfaceCreateInfoKHR;


typedef VkResult (VKAPI_PTR *PFN_vkGetPhysicalDeviceDisplayPropertiesKHR)(VkPhysicalDevice physicalDevice, uint32_t* pPropertyCount, VkDisplayPropertiesKHR* pProperties);
typedef VkResult (VKAPI_PTR *PFN_vkGetPhysicalDeviceDisplayPlanePropertiesKHR)(VkPhysicalDevice physicalDevice, uint32_t* pPropertyCount, VkDisplayPlanePropertiesKHR* pProperties);
typedef VkResult (VKAPI_PTR *PFN_vkGetDisplayPlaneSupportedDisplaysKHR)(VkPhysicalDevice physicalDevice, uint32_t planeIndex, uint32_t* pDisplayCount, VkDisplayKHR* pDisplays);
typedef VkResult (VKAPI_PTR *PFN_vkGetDisplayModePropertiesKHR)(VkPhysicalDevice physicalDevice, VkDisplayKHR display, uint32_t* pPropertyCount, VkDisplayModePropertiesKHR* pProperties);
typedef VkResult (VKAPI_PTR *PFN_vkCreateDisplayModeKHR)(VkPhysicalDevice physicalDevice, VkDisplayKHR display, const VkDisplayModeCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkDisplayModeKHR* pMode);
typedef VkResult (VKAPI_PTR *PFN_vkGetDisplayPlaneCapabilitiesKHR)(VkPhysicalDevice physicalDevice, VkDisplayModeKHR mode, uint32_t planeIndex, VkDisplayPlaneCapabilitiesKHR* pCapabilities);
typedef VkResult (VKAPI_PTR *PFN_vkCreateDisplayPlaneSurfaceKHR)(VkInstance instance, const VkDisplaySurfaceCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface);

std::shared_ptr<VkDisplayPropertiesKHRRAII> DisplayPropertiesKHR(
    VkDisplayKHR                                display,
    const std::string &                         strisplayName,
    VkExtent2D                                  physicalDimensions,
    VkExtent2D                                  physicalResolution,
    VkSurfaceTransformFlagsKHR                  supportedTransforms,
    VkBool32                                    planeReorderPossible,
    VkBool32                                    persistentContent);


VkDisplayModeParametersKHR DisplayModeParametersKHR(
    VkExtent2D                                  visibleRegion,
    uint32_t                                    refreshRate);


VkDisplayModePropertiesKHR DisplayModePropertiesKHR(
    VkDisplayModeKHR                            displayMode,
    VkDisplayModeParametersKHR                  parameters);


VkDisplayModeCreateInfoKHR DisplayModeCreateInfoKHR(
    VkDisplayModeCreateFlagsKHR                 flags,
    VkDisplayModeParametersKHR                  parameters);


VkDisplayPlaneCapabilitiesKHR DisplayPlaneCapabilitiesKHR(
    VkDisplayPlaneAlphaFlagsKHR                 supportedAlpha,
    VkOffset2D                                  minSrcPosition,
    VkOffset2D                                  maxSrcPosition,
    VkExtent2D                                  minSrcExtent,
    VkExtent2D                                  maxSrcExtent,
    VkOffset2D                                  minDstPosition,
    VkOffset2D                                  maxDstPosition,
    VkExtent2D                                  minDstExtent,
    VkExtent2D                                  maxDstExtent);


VkDisplayPlanePropertiesKHR DisplayPlanePropertiesKHR(
    VkDisplayKHR                                currentDisplay,
    uint32_t                                    currentStackIndex);


VkDisplaySurfaceCreateInfoKHR DisplaySurfaceCreateInfoKHR(
    VkDisplaySurfaceCreateFlagsKHR              flags,
    VkDisplayModeKHR                            displayMode,
    uint32_t                                    planeIndex,
    uint32_t                                    planeStackIndex,
    VkSurfaceTransformFlagBitsKHR               transform,
    float                                       globalAlpha,
    VkDisplayPlaneAlphaFlagBitsKHR              alphaMode,
    VkExtent2D                                  imageExtent);


std::vector< VkDisplayPropertiesKHR > getPhysicalDeviceDisplayPropertiesKHR(
        VkPhysicalDevice physicalDevice);

std::vector< VkDisplayPlanePropertiesKHR > getPhysicalDeviceDisplayPlanePropertiesKHR(
        VkPhysicalDevice physicalDevice);

std::vector< VkDisplayKHR > getDisplayPlaneSupportedDisplaysKHR(
        VkPhysicalDevice physicalDevice,
        uint32_t planeIndex);

std::vector< VkDisplayModePropertiesKHR > getDisplayModePropertiesKHR(
        VkPhysicalDevice physicalDevice,
        VkDisplayKHR display);

std::shared_ptr<VkDisplayModeKHR_T> createDisplayModeKHR(
        VkPhysicalDevice physicalDevice,
        VkDisplayKHR display,
        const VkDisplayModeCreateInfoKHR & pCreateInfo);

VkDisplayPlaneCapabilitiesKHR getDisplayPlaneCapabilitiesKHR(
        VkPhysicalDevice physicalDevice,
        VkDisplayModeKHR mode,
        uint32_t planeIndex);

std::shared_ptr<VkSurfaceKHR_T> createDisplayPlaneSurfaceKHR(
        VkInstance instance,
        const VkDisplaySurfaceCreateInfoKHR & pCreateInfo);


#define VK_KHR_display_swapchain 1
#define VK_KHR_DISPLAY_SWAPCHAIN_SPEC_VERSION 9
#define VK_KHR_DISPLAY_SWAPCHAIN_EXTENSION_NAME "VK_KHR_display_swapchain"

typedef struct VkDisplayPresentInfoKHR {
    VkStructureType    sType;
    const void*        pNext;
    VkRect2D           srcRect;
    VkRect2D           dstRect;
    VkBool32           persistent;
} VkDisplayPresentInfoKHR;


typedef VkResult (VKAPI_PTR *PFN_vkCreateSharedSwapchainsKHR)(VkDevice device, uint32_t swapchainCount, const VkSwapchainCreateInfoKHR* pCreateInfos, const VkAllocationCallbacks* pAllocator, VkSwapchainKHR* pSwapchains);

VkDisplayPresentInfoKHR DisplayPresentInfoKHR(
    VkRect2D                                    srcRect,
    VkRect2D                                    dstRect,
    VkBool32                                    persistent);


std::vector< std::shared_ptr<VkSwapchainKHR_T> > createSharedSwapchainsKHR(
        VkDevice device,
        const std::vector<VkSwapchainCreateInfoKHR> & pCreateInfos);


#ifdef VK_USE_PLATFORM_XLIB_KHR
#define VK_KHR_xlib_surface 1
#include <X11/Xlib.h>

#define VK_KHR_XLIB_SURFACE_SPEC_VERSION  6
#define VK_KHR_XLIB_SURFACE_EXTENSION_NAME "VK_KHR_xlib_surface"

typedef VkFlags VkXlibSurfaceCreateFlagsKHR;

typedef struct VkXlibSurfaceCreateInfoKHR {
    VkStructureType                sType;
    const void*                    pNext;
    VkXlibSurfaceCreateFlagsKHR    flags;
    Display*                       dpy;
    Window                         window;
} VkXlibSurfaceCreateInfoKHR;


typedef VkResult (VKAPI_PTR *PFN_vkCreateXlibSurfaceKHR)(VkInstance instance, const VkXlibSurfaceCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface);
typedef VkBool32 (VKAPI_PTR *PFN_vkGetPhysicalDeviceXlibPresentationSupportKHR)(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, Display* dpy, VisualID visualID);

VkXlibSurfaceCreateInfoKHR XlibSurfaceCreateInfoKHR(
    VkXlibSurfaceCreateFlagsKHR                 flags,
    Display*                                    dpy,
    Window                                      window);


std::shared_ptr<VkSurfaceKHR_T> createXlibSurfaceKHR(
        VkInstance instance,
        const VkXlibSurfaceCreateInfoKHR & pCreateInfo);

Display getPhysicalDeviceXlibPresentationSupportKHR(
        VkPhysicalDevice physicalDevice,
        uint32_t queueFamilyIndex,
        VisualID visualID);

#endif /* VK_USE_PLATFORM_XLIB_KHR */

#ifdef VK_USE_PLATFORM_XCB_KHR
#define VK_KHR_xcb_surface 1
#include <xcb/xcb.h>

#define VK_KHR_XCB_SURFACE_SPEC_VERSION   6
#define VK_KHR_XCB_SURFACE_EXTENSION_NAME "VK_KHR_xcb_surface"

typedef VkFlags VkXcbSurfaceCreateFlagsKHR;

typedef struct VkXcbSurfaceCreateInfoKHR {
    VkStructureType               sType;
    const void*                   pNext;
    VkXcbSurfaceCreateFlagsKHR    flags;
    xcb_connection_t*             connection;
    xcb_window_t                  window;
} VkXcbSurfaceCreateInfoKHR;


typedef VkResult (VKAPI_PTR *PFN_vkCreateXcbSurfaceKHR)(VkInstance instance, const VkXcbSurfaceCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface);
typedef VkBool32 (VKAPI_PTR *PFN_vkGetPhysicalDeviceXcbPresentationSupportKHR)(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, xcb_connection_t* connection, xcb_visualid_t visual_id);

VkXcbSurfaceCreateInfoKHR XcbSurfaceCreateInfoKHR(
    VkXcbSurfaceCreateFlagsKHR                  flags,
    xcb_connection_t*                           connection,
    xcb_window_t                                window);


std::shared_ptr<VkSurfaceKHR_T> createXcbSurfaceKHR(
        VkInstance instance,
        const VkXcbSurfaceCreateInfoKHR & pCreateInfo);

xcb_connection_t getPhysicalDeviceXcbPresentationSupportKHR(
        VkPhysicalDevice physicalDevice,
        uint32_t queueFamilyIndex,
        xcb_visualid_t visual_id);

#endif /* VK_USE_PLATFORM_XCB_KHR */

#ifdef VK_USE_PLATFORM_WAYLAND_KHR
#define VK_KHR_wayland_surface 1
#include <wayland-client.h>

#define VK_KHR_WAYLAND_SURFACE_SPEC_VERSION 6
#define VK_KHR_WAYLAND_SURFACE_EXTENSION_NAME "VK_KHR_wayland_surface"

typedef VkFlags VkWaylandSurfaceCreateFlagsKHR;

typedef struct VkWaylandSurfaceCreateInfoKHR {
    VkStructureType                   sType;
    const void*                       pNext;
    VkWaylandSurfaceCreateFlagsKHR    flags;
    struct wl_display*                display;
    struct wl_surface*                surface;
} VkWaylandSurfaceCreateInfoKHR;


typedef VkResult (VKAPI_PTR *PFN_vkCreateWaylandSurfaceKHR)(VkInstance instance, const VkWaylandSurfaceCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface);
typedef VkBool32 (VKAPI_PTR *PFN_vkGetPhysicalDeviceWaylandPresentationSupportKHR)(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, struct wl_display* display);

VkWaylandSurfaceCreateInfoKHR WaylandSurfaceCreateInfoKHR(
    VkWaylandSurfaceCreateFlagsKHR              flags,
    struct wl_display*                          display,
    struct wl_surface*                          surface);


std::shared_ptr<VkSurfaceKHR_T> createWaylandSurfaceKHR(
        VkInstance instance,
        const VkWaylandSurfaceCreateInfoKHR & pCreateInfo);

wl_display getPhysicalDeviceWaylandPresentationSupportKHR(
        VkPhysicalDevice physicalDevice,
        uint32_t queueFamilyIndex);

#endif /* VK_USE_PLATFORM_WAYLAND_KHR */

#ifdef VK_USE_PLATFORM_MIR_KHR
#define VK_KHR_mir_surface 1
#include <mir_toolkit/client_types.h>

#define VK_KHR_MIR_SURFACE_SPEC_VERSION   4
#define VK_KHR_MIR_SURFACE_EXTENSION_NAME "VK_KHR_mir_surface"

typedef VkFlags VkMirSurfaceCreateFlagsKHR;

typedef struct VkMirSurfaceCreateInfoKHR {
    VkStructureType               sType;
    const void*                   pNext;
    VkMirSurfaceCreateFlagsKHR    flags;
    MirConnection*                connection;
    MirSurface*                   mirSurface;
} VkMirSurfaceCreateInfoKHR;


typedef VkResult (VKAPI_PTR *PFN_vkCreateMirSurfaceKHR)(VkInstance instance, const VkMirSurfaceCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface);
typedef VkBool32 (VKAPI_PTR *PFN_vkGetPhysicalDeviceMirPresentationSupportKHR)(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, MirConnection* connection);

VkMirSurfaceCreateInfoKHR MirSurfaceCreateInfoKHR(
    VkMirSurfaceCreateFlagsKHR                  flags,
    MirConnection*                              connection,
    MirSurface*                                 mirSurface);


std::shared_ptr<VkSurfaceKHR_T> createMirSurfaceKHR(
        VkInstance instance,
        const VkMirSurfaceCreateInfoKHR & pCreateInfo);

MirConnection getPhysicalDeviceMirPresentationSupportKHR(
        VkPhysicalDevice physicalDevice,
        uint32_t queueFamilyIndex);

#endif /* VK_USE_PLATFORM_MIR_KHR */

#ifdef VK_USE_PLATFORM_ANDROID_KHR
#define VK_KHR_android_surface 1
#include <android/native_window.h>

#define VK_KHR_ANDROID_SURFACE_SPEC_VERSION 6
#define VK_KHR_ANDROID_SURFACE_EXTENSION_NAME "VK_KHR_android_surface"

typedef VkFlags VkAndroidSurfaceCreateFlagsKHR;

typedef struct VkAndroidSurfaceCreateInfoKHR {
    VkStructureType                   sType;
    const void*                       pNext;
    VkAndroidSurfaceCreateFlagsKHR    flags;
    ANativeWindow*                    window;
} VkAndroidSurfaceCreateInfoKHR;


typedef VkResult (VKAPI_PTR *PFN_vkCreateAndroidSurfaceKHR)(VkInstance instance, const VkAndroidSurfaceCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface);

VkAndroidSurfaceCreateInfoKHR AndroidSurfaceCreateInfoKHR(
    VkAndroidSurfaceCreateFlagsKHR              flags,
    ANativeWindow*                              window);


std::shared_ptr<VkSurfaceKHR_T> createAndroidSurfaceKHR(
        VkInstance instance,
        const VkAndroidSurfaceCreateInfoKHR & pCreateInfo);

#endif /* VK_USE_PLATFORM_ANDROID_KHR */

#ifdef VK_USE_PLATFORM_WIN32_KHR
#define VK_KHR_win32_surface 1
#include <windows.h>

#define VK_KHR_WIN32_SURFACE_SPEC_VERSION 6
#define VK_KHR_WIN32_SURFACE_EXTENSION_NAME "VK_KHR_win32_surface"

typedef VkFlags VkWin32SurfaceCreateFlagsKHR;

typedef struct VkWin32SurfaceCreateInfoKHR {
    VkStructureType                 sType;
    const void*                     pNext;
    VkWin32SurfaceCreateFlagsKHR    flags;
    HINSTANCE                       hinstance;
    HWND                            hwnd;
} VkWin32SurfaceCreateInfoKHR;


typedef VkResult (VKAPI_PTR *PFN_vkCreateWin32SurfaceKHR)(VkInstance instance, const VkWin32SurfaceCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface);
typedef VkBool32 (VKAPI_PTR *PFN_vkGetPhysicalDeviceWin32PresentationSupportKHR)(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex);

VkWin32SurfaceCreateInfoKHR Win32SurfaceCreateInfoKHR(
    VkWin32SurfaceCreateFlagsKHR                flags,
    HINSTANCE                                   hinstance,
    HWND                                        hwnd);


std::shared_ptr<VkSurfaceKHR_T> createWin32SurfaceKHR(
        VkInstance instance,
        const VkWin32SurfaceCreateInfoKHR & pCreateInfo);

void  getPhysicalDeviceWin32PresentationSupportKHR(
        VkPhysicalDevice physicalDevice,
        uint32_t queueFamilyIndex);

#endif /* VK_USE_PLATFORM_WIN32_KHR */

#define VK_KHR_sampler_mirror_clamp_to_edge 1
#define VK_KHR_SAMPLER_MIRROR_CLAMP_TO_EDGE_SPEC_VERSION 1
#define VK_KHR_SAMPLER_MIRROR_CLAMP_TO_EDGE_EXTENSION_NAME "VK_KHR_sampler_mirror_clamp_to_edge"


#define VK_KHR_get_physical_device_properties2 1
#define VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_SPEC_VERSION 1
#define VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_EXTENSION_NAME "VK_KHR_get_physical_device_properties2"

typedef struct VkPhysicalDeviceFeatures2KHR {
    VkStructureType             sType;
    void*                       pNext;
    VkPhysicalDeviceFeatures    features;
} VkPhysicalDeviceFeatures2KHR;

typedef struct VkPhysicalDeviceProperties2KHR {
    VkStructureType               sType;
    void*                         pNext;
    VkPhysicalDeviceProperties    properties;
} VkPhysicalDeviceProperties2KHR;

typedef struct VkFormatProperties2KHR {
    VkStructureType       sType;
    void*                 pNext;
    VkFormatProperties    formatProperties;
} VkFormatProperties2KHR;

typedef struct VkImageFormatProperties2KHR {
    VkStructureType            sType;
    void*                      pNext;
    VkImageFormatProperties    imageFormatProperties;
} VkImageFormatProperties2KHR;

typedef struct VkPhysicalDeviceImageFormatInfo2KHR {
    VkStructureType       sType;
    const void*           pNext;
    VkFormat              format;
    VkImageType           type;
    VkImageTiling         tiling;
    VkImageUsageFlags     usage;
    VkImageCreateFlags    flags;
} VkPhysicalDeviceImageFormatInfo2KHR;

typedef struct VkQueueFamilyProperties2KHR {
    VkStructureType            sType;
    void*                      pNext;
    VkQueueFamilyProperties    queueFamilyProperties;
} VkQueueFamilyProperties2KHR;

typedef struct VkPhysicalDeviceMemoryProperties2KHR {
    VkStructureType                     sType;
    void*                               pNext;
    VkPhysicalDeviceMemoryProperties    memoryProperties;
} VkPhysicalDeviceMemoryProperties2KHR;

typedef struct VkSparseImageFormatProperties2KHR {
    VkStructureType                  sType;
    void*                            pNext;
    VkSparseImageFormatProperties    properties;
} VkSparseImageFormatProperties2KHR;

typedef struct VkPhysicalDeviceSparseImageFormatInfo2KHR {
    VkStructureType          sType;
    const void*              pNext;
    VkFormat                 format;
    VkImageType              type;
    VkSampleCountFlagBits    samples;
    VkImageUsageFlags        usage;
    VkImageTiling            tiling;
} VkPhysicalDeviceSparseImageFormatInfo2KHR;


typedef void (VKAPI_PTR *PFN_vkGetPhysicalDeviceFeatures2KHR)(VkPhysicalDevice physicalDevice, VkPhysicalDeviceFeatures2KHR* pFeatures);
typedef void (VKAPI_PTR *PFN_vkGetPhysicalDeviceProperties2KHR)(VkPhysicalDevice physicalDevice, VkPhysicalDeviceProperties2KHR* pProperties);
typedef void (VKAPI_PTR *PFN_vkGetPhysicalDeviceFormatProperties2KHR)(VkPhysicalDevice physicalDevice, VkFormat format, VkFormatProperties2KHR* pFormatProperties);
typedef VkResult (VKAPI_PTR *PFN_vkGetPhysicalDeviceImageFormatProperties2KHR)(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceImageFormatInfo2KHR* pImageFormatInfo, VkImageFormatProperties2KHR* pImageFormatProperties);
typedef void (VKAPI_PTR *PFN_vkGetPhysicalDeviceQueueFamilyProperties2KHR)(VkPhysicalDevice physicalDevice, uint32_t* pQueueFamilyPropertyCount, VkQueueFamilyProperties2KHR* pQueueFamilyProperties);
typedef void (VKAPI_PTR *PFN_vkGetPhysicalDeviceMemoryProperties2KHR)(VkPhysicalDevice physicalDevice, VkPhysicalDeviceMemoryProperties2KHR* pMemoryProperties);
typedef void (VKAPI_PTR *PFN_vkGetPhysicalDeviceSparseImageFormatProperties2KHR)(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSparseImageFormatInfo2KHR* pFormatInfo, uint32_t* pPropertyCount, VkSparseImageFormatProperties2KHR* pProperties);

VkPhysicalDeviceFeatures2KHR PhysicalDeviceFeatures2KHR(
    VkPhysicalDeviceFeatures                    features);


VkPhysicalDeviceProperties2KHR PhysicalDeviceProperties2KHR(
    VkPhysicalDeviceProperties                  properties);


VkFormatProperties2KHR FormatProperties2KHR(
    VkFormatProperties                          formatProperties);


VkImageFormatProperties2KHR ImageFormatProperties2KHR(
    VkImageFormatProperties                     imageFormatProperties);


VkPhysicalDeviceImageFormatInfo2KHR PhysicalDeviceImageFormatInfo2KHR(
    VkFormat                                    format,
    VkImageType                                 type,
    VkImageTiling                               tiling,
    VkImageUsageFlags                           usage,
    VkImageCreateFlags                          flags);


VkQueueFamilyProperties2KHR QueueFamilyProperties2KHR(
    VkQueueFamilyProperties                     queueFamilyProperties);


VkPhysicalDeviceMemoryProperties2KHR PhysicalDeviceMemoryProperties2KHR(
    VkPhysicalDeviceMemoryProperties            memoryProperties);


VkSparseImageFormatProperties2KHR SparseImageFormatProperties2KHR(
    VkSparseImageFormatProperties               properties);


VkPhysicalDeviceSparseImageFormatInfo2KHR PhysicalDeviceSparseImageFormatInfo2KHR(
    VkFormat                                    format,
    VkImageType                                 type,
    VkSampleCountFlagBits                       samples,
    VkImageUsageFlags                           usage,
    VkImageTiling                               tiling);


VkPhysicalDeviceFeatures2KHR getPhysicalDeviceFeatures2KHR(
        VkPhysicalDevice physicalDevice);

VkPhysicalDeviceProperties2KHR getPhysicalDeviceProperties2KHR(
        VkPhysicalDevice physicalDevice);

VkFormatProperties2KHR getPhysicalDeviceFormatProperties2KHR(
        VkPhysicalDevice physicalDevice,
        VkFormat format);

VkImageFormatProperties2KHR getPhysicalDeviceImageFormatProperties2KHR(
        VkPhysicalDevice physicalDevice,
        const VkPhysicalDeviceImageFormatInfo2KHR & pImageFormatInfo);

std::vector< VkQueueFamilyProperties2KHR > getPhysicalDeviceQueueFamilyProperties2KHR(
        VkPhysicalDevice physicalDevice);

VkPhysicalDeviceMemoryProperties2KHR getPhysicalDeviceMemoryProperties2KHR(
        VkPhysicalDevice physicalDevice);

std::vector< VkSparseImageFormatProperties2KHR > getPhysicalDeviceSparseImageFormatProperties2KHR(
        VkPhysicalDevice physicalDevice,
        const VkPhysicalDeviceSparseImageFormatInfo2KHR & pFormatInfo);


#define VK_KHR_shader_draw_parameters 1
#define VK_KHR_SHADER_DRAW_PARAMETERS_SPEC_VERSION 1
#define VK_KHR_SHADER_DRAW_PARAMETERS_EXTENSION_NAME "VK_KHR_shader_draw_parameters"


#define VK_KHR_maintenance1 1
#define VK_KHR_MAINTENANCE1_SPEC_VERSION  1
#define VK_KHR_MAINTENANCE1_EXTENSION_NAME "VK_KHR_maintenance1"

typedef VkFlags VkCommandPoolTrimFlagsKHR;

typedef void (VKAPI_PTR *PFN_vkTrimCommandPoolKHR)(VkDevice device, VkCommandPool commandPool, VkCommandPoolTrimFlagsKHR flags);

void  trimCommandPoolKHR(
        VkDevice device,
        VkCommandPool commandPool,
        VkCommandPoolTrimFlagsKHR flags);


#define VK_KHR_external_memory_capabilities 1
#define VK_LUID_SIZE_KHR                  8
#define VK_KHR_EXTERNAL_MEMORY_CAPABILITIES_SPEC_VERSION 1
#define VK_KHR_EXTERNAL_MEMORY_CAPABILITIES_EXTENSION_NAME "VK_KHR_external_memory_capabilities"


typedef enum VkExternalMemoryHandleTypeFlagBitsKHR {
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT_KHR = 0x00000001,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR = 0x00000002,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR = 0x00000004,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT_KHR = 0x00000008,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT_KHR = 0x00000010,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT_KHR = 0x00000020,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT_KHR = 0x00000040,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF
} VkExternalMemoryHandleTypeFlagBitsKHR;
typedef VkFlags VkExternalMemoryHandleTypeFlagsKHR;

typedef enum VkExternalMemoryFeatureFlagBitsKHR {
    VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_KHR = 0x00000001,
    VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_KHR = 0x00000002,
    VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_KHR = 0x00000004,
    VK_EXTERNAL_MEMORY_FEATURE_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF
} VkExternalMemoryFeatureFlagBitsKHR;
typedef VkFlags VkExternalMemoryFeatureFlagsKHR;

typedef struct VkExternalMemoryPropertiesKHR {
    VkExternalMemoryFeatureFlagsKHR       externalMemoryFeatures;
    VkExternalMemoryHandleTypeFlagsKHR    exportFromImportedHandleTypes;
    VkExternalMemoryHandleTypeFlagsKHR    compatibleHandleTypes;
} VkExternalMemoryPropertiesKHR;

typedef struct VkPhysicalDeviceExternalImageFormatInfoKHR {
    VkStructureType                          sType;
    const void*                              pNext;
    VkExternalMemoryHandleTypeFlagBitsKHR    handleType;
} VkPhysicalDeviceExternalImageFormatInfoKHR;

typedef struct VkExternalImageFormatPropertiesKHR {
    VkStructureType                  sType;
    void*                            pNext;
    VkExternalMemoryPropertiesKHR    externalMemoryProperties;
} VkExternalImageFormatPropertiesKHR;

typedef struct VkPhysicalDeviceExternalBufferInfoKHR {
    VkStructureType                          sType;
    const void*                              pNext;
    VkBufferCreateFlags                      flags;
    VkBufferUsageFlags                       usage;
    VkExternalMemoryHandleTypeFlagBitsKHR    handleType;
} VkPhysicalDeviceExternalBufferInfoKHR;

typedef struct VkExternalBufferPropertiesKHR {
    VkStructureType                  sType;
    void*                            pNext;
    VkExternalMemoryPropertiesKHR    externalMemoryProperties;
} VkExternalBufferPropertiesKHR;

typedef struct VkPhysicalDeviceIDPropertiesKHR {
    VkStructureType    sType;
    void*              pNext;
    uint8_t            deviceUUID[VK_UUID_SIZE];
    uint8_t            driverUUID[VK_UUID_SIZE];
    uint8_t            deviceLUID[VK_LUID_SIZE_KHR];
    uint32_t           deviceNodeMask;
    VkBool32           deviceLUIDValid;
} VkPhysicalDeviceIDPropertiesKHR;


typedef void (VKAPI_PTR *PFN_vkGetPhysicalDeviceExternalBufferPropertiesKHR)(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalBufferInfoKHR* pExternalBufferInfo, VkExternalBufferPropertiesKHR* pExternalBufferProperties);

VkExternalMemoryPropertiesKHR ExternalMemoryPropertiesKHR(
    VkExternalMemoryFeatureFlagsKHR             externalMemoryFeatures,
    VkExternalMemoryHandleTypeFlagsKHR          exportFromImportedHandleTypes,
    VkExternalMemoryHandleTypeFlagsKHR          compatibleHandleTypes);


VkPhysicalDeviceExternalImageFormatInfoKHR PhysicalDeviceExternalImageFormatInfoKHR(
    VkExternalMemoryHandleTypeFlagBitsKHR       handleType);


VkExternalImageFormatPropertiesKHR ExternalImageFormatPropertiesKHR(
    VkExternalMemoryPropertiesKHR               externalMemoryProperties);


VkPhysicalDeviceExternalBufferInfoKHR PhysicalDeviceExternalBufferInfoKHR(
    VkBufferCreateFlags                         flags,
    VkBufferUsageFlags                          usage,
    VkExternalMemoryHandleTypeFlagBitsKHR       handleType);


VkExternalBufferPropertiesKHR ExternalBufferPropertiesKHR(
    VkExternalMemoryPropertiesKHR               externalMemoryProperties);


VkPhysicalDeviceIDPropertiesKHR PhysicalDeviceIDPropertiesKHR(
    uint8_t                                     deviceUUID[VK_UUID_SIZE],
    uint8_t                                     driverUUID[VK_UUID_SIZE],
    uint8_t                                     deviceLUID[VK_LUID_SIZE_KHR],
    uint32_t                                    deviceNodeMask,
    VkBool32                                    deviceLUIDValid);


VkExternalBufferPropertiesKHR getPhysicalDeviceExternalBufferPropertiesKHR(
        VkPhysicalDevice physicalDevice,
        const VkPhysicalDeviceExternalBufferInfoKHR & pExternalBufferInfo);


#define VK_KHR_external_memory 1
#define VK_KHR_EXTERNAL_MEMORY_SPEC_VERSION 1
#define VK_KHR_EXTERNAL_MEMORY_EXTENSION_NAME "VK_KHR_external_memory"
#define VK_QUEUE_FAMILY_EXTERNAL_KHR      (~0U-1)

typedef struct VkExternalMemoryImageCreateInfoKHR {
    VkStructureType                       sType;
    const void*                           pNext;
    VkExternalMemoryHandleTypeFlagsKHR    handleTypes;
} VkExternalMemoryImageCreateInfoKHR;

typedef struct VkExternalMemoryBufferCreateInfoKHR {
    VkStructureType                       sType;
    const void*                           pNext;
    VkExternalMemoryHandleTypeFlagsKHR    handleTypes;
} VkExternalMemoryBufferCreateInfoKHR;

typedef struct VkExportMemoryAllocateInfoKHR {
    VkStructureType                       sType;
    const void*                           pNext;
    VkExternalMemoryHandleTypeFlagsKHR    handleTypes;
} VkExportMemoryAllocateInfoKHR;


VkExternalMemoryImageCreateInfoKHR ExternalMemoryImageCreateInfoKHR(
    VkExternalMemoryHandleTypeFlagsKHR          handleTypes);


VkExternalMemoryBufferCreateInfoKHR ExternalMemoryBufferCreateInfoKHR(
    VkExternalMemoryHandleTypeFlagsKHR          handleTypes);


VkExportMemoryAllocateInfoKHR ExportMemoryAllocateInfoKHR(
    VkExternalMemoryHandleTypeFlagsKHR          handleTypes);



#ifdef VK_USE_PLATFORM_WIN32_KHR
#define VK_KHR_external_memory_win32 1
#define VK_KHR_EXTERNAL_MEMORY_WIN32_SPEC_VERSION 1
#define VK_KHR_EXTERNAL_MEMORY_WIN32_EXTENSION_NAME "VK_KHR_external_memory_win32"

typedef struct VkImportMemoryWin32HandleInfoKHR {
    VkStructureType                          sType;
    const void*                              pNext;
    VkExternalMemoryHandleTypeFlagBitsKHR    handleType;
    HANDLE                                   handle;
    LPCWSTR                                  name;
} VkImportMemoryWin32HandleInfoKHR;

typedef struct VkExportMemoryWin32HandleInfoKHR {
    VkStructureType               sType;
    const void*                   pNext;
    const SECURITY_ATTRIBUTES*    pAttributes;
    DWORD                         dwAccess;
    LPCWSTR                       name;
} VkExportMemoryWin32HandleInfoKHR;

struct VkExportMemoryWin32HandleInfoKHRRAII {
   VkExportMemoryWin32HandleInfoKHR nonRaiiObj;
    std::shared_ptr<SECURITY_ATTRIBUTES>        pAttributes;
};

typedef struct VkMemoryWin32HandlePropertiesKHR {
    VkStructureType    sType;
    void*              pNext;
    uint32_t           memoryTypeBits;
} VkMemoryWin32HandlePropertiesKHR;

typedef struct VkMemoryGetWin32HandleInfoKHR {
    VkStructureType                          sType;
    const void*                              pNext;
    VkDeviceMemory                           memory;
    VkExternalMemoryHandleTypeFlagBitsKHR    handleType;
} VkMemoryGetWin32HandleInfoKHR;


typedef VkResult (VKAPI_PTR *PFN_vkGetMemoryWin32HandleKHR)(VkDevice device, const VkMemoryGetWin32HandleInfoKHR* pGetWin32HandleInfo, HANDLE* pHandle);
typedef VkResult (VKAPI_PTR *PFN_vkGetMemoryWin32HandlePropertiesKHR)(VkDevice device, VkExternalMemoryHandleTypeFlagBitsKHR handleType, HANDLE handle, VkMemoryWin32HandlePropertiesKHR* pMemoryWin32HandleProperties);

VkImportMemoryWin32HandleInfoKHR ImportMemoryWin32HandleInfoKHR(
    VkExternalMemoryHandleTypeFlagBitsKHR       handleType,
    HANDLE                                      handle,
    LPCWSTR                                     name);


std::shared_ptr<VkExportMemoryWin32HandleInfoKHRRAII> ExportMemoryWin32HandleInfoKHR(
    const SECURITY_ATTRIBUTES *                 pAttributes,
    DWORD                                       dwAccess,
    LPCWSTR                                     name);


VkMemoryWin32HandlePropertiesKHR MemoryWin32HandlePropertiesKHR(
    uint32_t                                    memoryTypeBits);


VkMemoryGetWin32HandleInfoKHR MemoryGetWin32HandleInfoKHR(
    VkDeviceMemory                              memory,
    VkExternalMemoryHandleTypeFlagBitsKHR       handleType);


HANDLE getMemoryWin32HandleKHR(
        VkDevice device,
        const VkMemoryGetWin32HandleInfoKHR & pGetWin32HandleInfo);

VkMemoryWin32HandlePropertiesKHR getMemoryWin32HandlePropertiesKHR(
        VkDevice device,
        VkExternalMemoryHandleTypeFlagBitsKHR handleType,
        HANDLE handle);

#endif /* VK_USE_PLATFORM_WIN32_KHR */

#define VK_KHR_external_memory_fd 1
#define VK_KHR_EXTERNAL_MEMORY_FD_SPEC_VERSION 1
#define VK_KHR_EXTERNAL_MEMORY_FD_EXTENSION_NAME "VK_KHR_external_memory_fd"

typedef struct VkImportMemoryFdInfoKHR {
    VkStructureType                          sType;
    const void*                              pNext;
    VkExternalMemoryHandleTypeFlagBitsKHR    handleType;
    int                                      fd;
} VkImportMemoryFdInfoKHR;

typedef struct VkMemoryFdPropertiesKHR {
    VkStructureType    sType;
    void*              pNext;
    uint32_t           memoryTypeBits;
} VkMemoryFdPropertiesKHR;

typedef struct VkMemoryGetFdInfoKHR {
    VkStructureType                          sType;
    const void*                              pNext;
    VkDeviceMemory                           memory;
    VkExternalMemoryHandleTypeFlagBitsKHR    handleType;
} VkMemoryGetFdInfoKHR;


typedef VkResult (VKAPI_PTR *PFN_vkGetMemoryFdKHR)(VkDevice device, const VkMemoryGetFdInfoKHR* pGetFdInfo, int* pFd);
typedef VkResult (VKAPI_PTR *PFN_vkGetMemoryFdPropertiesKHR)(VkDevice device, VkExternalMemoryHandleTypeFlagBitsKHR handleType, int fd, VkMemoryFdPropertiesKHR* pMemoryFdProperties);

VkImportMemoryFdInfoKHR ImportMemoryFdInfoKHR(
    VkExternalMemoryHandleTypeFlagBitsKHR       handleType,
    int                                         fd);


VkMemoryFdPropertiesKHR MemoryFdPropertiesKHR(
    uint32_t                                    memoryTypeBits);


VkMemoryGetFdInfoKHR MemoryGetFdInfoKHR(
    VkDeviceMemory                              memory,
    VkExternalMemoryHandleTypeFlagBitsKHR       handleType);


int getMemoryFdKHR(
        VkDevice device,
        const VkMemoryGetFdInfoKHR & pGetFdInfo);

VkMemoryFdPropertiesKHR getMemoryFdPropertiesKHR(
        VkDevice device,
        VkExternalMemoryHandleTypeFlagBitsKHR handleType,
        int fd);


#ifdef VK_USE_PLATFORM_WIN32_KHR
#define VK_KHR_win32_keyed_mutex 1
#define VK_KHR_WIN32_KEYED_MUTEX_SPEC_VERSION 1
#define VK_KHR_WIN32_KEYED_MUTEX_EXTENSION_NAME "VK_KHR_win32_keyed_mutex"

typedef struct VkWin32KeyedMutexAcquireReleaseInfoKHR {
    VkStructureType          sType;
    const void*              pNext;
    uint32_t                 acquireCount;
    const VkDeviceMemory*    pAcquireSyncs;
    const uint64_t*          pAcquireKeys;
    const uint32_t*          pAcquireTimeouts;
    uint32_t                 releaseCount;
    const VkDeviceMemory*    pReleaseSyncs;
    const uint64_t*          pReleaseKeys;
} VkWin32KeyedMutexAcquireReleaseInfoKHR;

struct VkWin32KeyedMutexAcquireReleaseInfoKHRRAII {
   VkWin32KeyedMutexAcquireReleaseInfoKHR nonRaiiObj;
    std::vector<VkDeviceMemory>                 vecAcquireSyncs;
    std::vector<uint64_t>                       vecAcquireKeys;
    std::vector<uint32_t>                       vecAcquireTimeouts;
    std::vector<VkDeviceMemory>                 vecReleaseSyncs;
    std::vector<uint64_t>                       vecReleaseKeys;
};


std::shared_ptr<VkWin32KeyedMutexAcquireReleaseInfoKHRRAII> Win32KeyedMutexAcquireReleaseInfoKHR(
    const std::vector<VkDeviceMemory> &         vecAcquireSyncs,
    const std::vector<uint64_t> &               vecAcquireKeys,
    unsigned int* pAcquireTimeouts_in_array1, int pAcquireTimeouts_dim1,
    const std::vector<VkDeviceMemory> &         vecReleaseSyncs,
    const std::vector<uint64_t> &               vecReleaseKeys);


#endif /* VK_USE_PLATFORM_WIN32_KHR */

#define VK_KHR_external_semaphore_capabilities 1
#define VK_KHR_EXTERNAL_SEMAPHORE_CAPABILITIES_SPEC_VERSION 1
#define VK_KHR_EXTERNAL_SEMAPHORE_CAPABILITIES_EXTENSION_NAME "VK_KHR_external_semaphore_capabilities"


typedef enum VkExternalSemaphoreHandleTypeFlagBitsKHR {
    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR = 0x00000001,
    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR = 0x00000002,
    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR = 0x00000004,
    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT_KHR = 0x00000008,
    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT_KHR = 0x00000010,
    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF
} VkExternalSemaphoreHandleTypeFlagBitsKHR;
typedef VkFlags VkExternalSemaphoreHandleTypeFlagsKHR;

typedef enum VkExternalSemaphoreFeatureFlagBitsKHR {
    VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT_KHR = 0x00000001,
    VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT_KHR = 0x00000002,
    VK_EXTERNAL_SEMAPHORE_FEATURE_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF
} VkExternalSemaphoreFeatureFlagBitsKHR;
typedef VkFlags VkExternalSemaphoreFeatureFlagsKHR;

typedef struct VkPhysicalDeviceExternalSemaphoreInfoKHR {
    VkStructureType                             sType;
    const void*                                 pNext;
    VkExternalSemaphoreHandleTypeFlagBitsKHR    handleType;
} VkPhysicalDeviceExternalSemaphoreInfoKHR;

typedef struct VkExternalSemaphorePropertiesKHR {
    VkStructureType                          sType;
    void*                                    pNext;
    VkExternalSemaphoreHandleTypeFlagsKHR    exportFromImportedHandleTypes;
    VkExternalSemaphoreHandleTypeFlagsKHR    compatibleHandleTypes;
    VkExternalSemaphoreFeatureFlagsKHR       externalSemaphoreFeatures;
} VkExternalSemaphorePropertiesKHR;


typedef void (VKAPI_PTR *PFN_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR)(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalSemaphoreInfoKHR* pExternalSemaphoreInfo, VkExternalSemaphorePropertiesKHR* pExternalSemaphoreProperties);

VkPhysicalDeviceExternalSemaphoreInfoKHR PhysicalDeviceExternalSemaphoreInfoKHR(
    VkExternalSemaphoreHandleTypeFlagBitsKHR    handleType);


VkExternalSemaphorePropertiesKHR ExternalSemaphorePropertiesKHR(
    VkExternalSemaphoreHandleTypeFlagsKHR       exportFromImportedHandleTypes,
    VkExternalSemaphoreHandleTypeFlagsKHR       compatibleHandleTypes,
    VkExternalSemaphoreFeatureFlagsKHR          externalSemaphoreFeatures);


VkExternalSemaphorePropertiesKHR getPhysicalDeviceExternalSemaphorePropertiesKHR(
        VkPhysicalDevice physicalDevice,
        const VkPhysicalDeviceExternalSemaphoreInfoKHR & pExternalSemaphoreInfo);


#define VK_KHR_external_semaphore 1
#define VK_KHR_EXTERNAL_SEMAPHORE_SPEC_VERSION 1
#define VK_KHR_EXTERNAL_SEMAPHORE_EXTENSION_NAME "VK_KHR_external_semaphore"


typedef enum VkSemaphoreImportFlagBitsKHR {
    VK_SEMAPHORE_IMPORT_TEMPORARY_BIT_KHR = 0x00000001,
    VK_SEMAPHORE_IMPORT_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF
} VkSemaphoreImportFlagBitsKHR;
typedef VkFlags VkSemaphoreImportFlagsKHR;

typedef struct VkExportSemaphoreCreateInfoKHR {
    VkStructureType                          sType;
    const void*                              pNext;
    VkExternalSemaphoreHandleTypeFlagsKHR    handleTypes;
} VkExportSemaphoreCreateInfoKHR;


VkExportSemaphoreCreateInfoKHR ExportSemaphoreCreateInfoKHR(
    VkExternalSemaphoreHandleTypeFlagsKHR       handleTypes);



#ifdef VK_USE_PLATFORM_WIN32_KHR
#define VK_KHR_external_semaphore_win32 1
#define VK_KHR_EXTERNAL_SEMAPHORE_WIN32_SPEC_VERSION 1
#define VK_KHR_EXTERNAL_SEMAPHORE_WIN32_EXTENSION_NAME "VK_KHR_external_semaphore_win32"

typedef struct VkImportSemaphoreWin32HandleInfoKHR {
    VkStructureType                             sType;
    const void*                                 pNext;
    VkSemaphore                                 semaphore;
    VkSemaphoreImportFlagsKHR                   flags;
    VkExternalSemaphoreHandleTypeFlagBitsKHR    handleType;
    HANDLE                                      handle;
    LPCWSTR                                     name;
} VkImportSemaphoreWin32HandleInfoKHR;

typedef struct VkExportSemaphoreWin32HandleInfoKHR {
    VkStructureType               sType;
    const void*                   pNext;
    const SECURITY_ATTRIBUTES*    pAttributes;
    DWORD                         dwAccess;
    LPCWSTR                       name;
} VkExportSemaphoreWin32HandleInfoKHR;

struct VkExportSemaphoreWin32HandleInfoKHRRAII {
   VkExportSemaphoreWin32HandleInfoKHR nonRaiiObj;
    std::shared_ptr<SECURITY_ATTRIBUTES>        pAttributes;
};

typedef struct VkD3D12FenceSubmitInfoKHR {
    VkStructureType    sType;
    const void*        pNext;
    uint32_t           waitSemaphoreValuesCount;
    const uint64_t*    pWaitSemaphoreValues;
    uint32_t           signalSemaphoreValuesCount;
    const uint64_t*    pSignalSemaphoreValues;
} VkD3D12FenceSubmitInfoKHR;

struct VkD3D12FenceSubmitInfoKHRRAII {
   VkD3D12FenceSubmitInfoKHR nonRaiiObj;
    std::vector<uint64_t>                       vecWaitSemaphoreValues;
    std::vector<uint64_t>                       vecSignalSemaphoreValues;
};

typedef struct VkSemaphoreGetWin32HandleInfoKHR {
    VkStructureType                             sType;
    const void*                                 pNext;
    VkSemaphore                                 semaphore;
    VkExternalSemaphoreHandleTypeFlagBitsKHR    handleType;
} VkSemaphoreGetWin32HandleInfoKHR;


typedef VkResult (VKAPI_PTR *PFN_vkImportSemaphoreWin32HandleKHR)(VkDevice device, const VkImportSemaphoreWin32HandleInfoKHR* pImportSemaphoreWin32HandleInfo);
typedef VkResult (VKAPI_PTR *PFN_vkGetSemaphoreWin32HandleKHR)(VkDevice device, const VkSemaphoreGetWin32HandleInfoKHR* pGetWin32HandleInfo, HANDLE* pHandle);

VkImportSemaphoreWin32HandleInfoKHR ImportSemaphoreWin32HandleInfoKHR(
    VkSemaphore                                 semaphore,
    VkSemaphoreImportFlagsKHR                   flags,
    VkExternalSemaphoreHandleTypeFlagBitsKHR    handleType,
    HANDLE                                      handle,
    LPCWSTR                                     name);


std::shared_ptr<VkExportSemaphoreWin32HandleInfoKHRRAII> ExportSemaphoreWin32HandleInfoKHR(
    const SECURITY_ATTRIBUTES *                 pAttributes,
    DWORD                                       dwAccess,
    LPCWSTR                                     name);


std::shared_ptr<VkD3D12FenceSubmitInfoKHRRAII> D3D12FenceSubmitInfoKHR(
    const std::vector<uint64_t> &               vecWaitSemaphoreValues,
    const std::vector<uint64_t> &               vecSignalSemaphoreValues);


VkSemaphoreGetWin32HandleInfoKHR SemaphoreGetWin32HandleInfoKHR(
    VkSemaphore                                 semaphore,
    VkExternalSemaphoreHandleTypeFlagBitsKHR    handleType);


void  importSemaphoreWin32HandleKHR(
        VkDevice device,
        const VkImportSemaphoreWin32HandleInfoKHR & pImportSemaphoreWin32HandleInfo);

HANDLE getSemaphoreWin32HandleKHR(
        VkDevice device,
        const VkSemaphoreGetWin32HandleInfoKHR & pGetWin32HandleInfo);

#endif /* VK_USE_PLATFORM_WIN32_KHR */

#define VK_KHR_external_semaphore_fd 1
#define VK_KHR_EXTERNAL_SEMAPHORE_FD_SPEC_VERSION 1
#define VK_KHR_EXTERNAL_SEMAPHORE_FD_EXTENSION_NAME "VK_KHR_external_semaphore_fd"

typedef struct VkImportSemaphoreFdInfoKHR {
    VkStructureType                             sType;
    const void*                                 pNext;
    VkSemaphore                                 semaphore;
    VkSemaphoreImportFlagsKHR                   flags;
    VkExternalSemaphoreHandleTypeFlagBitsKHR    handleType;
    int                                         fd;
} VkImportSemaphoreFdInfoKHR;

typedef struct VkSemaphoreGetFdInfoKHR {
    VkStructureType                             sType;
    const void*                                 pNext;
    VkSemaphore                                 semaphore;
    VkExternalSemaphoreHandleTypeFlagBitsKHR    handleType;
} VkSemaphoreGetFdInfoKHR;


typedef VkResult (VKAPI_PTR *PFN_vkImportSemaphoreFdKHR)(VkDevice device, const VkImportSemaphoreFdInfoKHR* pImportSemaphoreFdInfo);
typedef VkResult (VKAPI_PTR *PFN_vkGetSemaphoreFdKHR)(VkDevice device, const VkSemaphoreGetFdInfoKHR* pGetFdInfo, int* pFd);

VkImportSemaphoreFdInfoKHR ImportSemaphoreFdInfoKHR(
    VkSemaphore                                 semaphore,
    VkSemaphoreImportFlagsKHR                   flags,
    VkExternalSemaphoreHandleTypeFlagBitsKHR    handleType,
    int                                         fd);


VkSemaphoreGetFdInfoKHR SemaphoreGetFdInfoKHR(
    VkSemaphore                                 semaphore,
    VkExternalSemaphoreHandleTypeFlagBitsKHR    handleType);


void  importSemaphoreFdKHR(
        VkDevice device,
        const VkImportSemaphoreFdInfoKHR & pImportSemaphoreFdInfo);

int getSemaphoreFdKHR(
        VkDevice device,
        const VkSemaphoreGetFdInfoKHR & pGetFdInfo);


#define VK_KHR_push_descriptor 1
#define VK_KHR_PUSH_DESCRIPTOR_SPEC_VERSION 1
#define VK_KHR_PUSH_DESCRIPTOR_EXTENSION_NAME "VK_KHR_push_descriptor"

typedef struct VkPhysicalDevicePushDescriptorPropertiesKHR {
    VkStructureType    sType;
    void*              pNext;
    uint32_t           maxPushDescriptors;
} VkPhysicalDevicePushDescriptorPropertiesKHR;


typedef void (VKAPI_PTR *PFN_vkCmdPushDescriptorSetKHR)(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout, uint32_t set, uint32_t descriptorWriteCount, const VkWriteDescriptorSet* pDescriptorWrites);

VkPhysicalDevicePushDescriptorPropertiesKHR PhysicalDevicePushDescriptorPropertiesKHR(
    uint32_t                                    maxPushDescriptors);


void  cmdPushDescriptorSetKHR(
        VkCommandBuffer commandBuffer,
        VkPipelineBindPoint pipelineBindPoint,
        VkPipelineLayout layout,
        uint32_t set,
        const std::vector<VkWriteDescriptorSet> & pDescriptorWrites);


#define VK_KHR_16bit_storage 1
#define VK_KHR_16BIT_STORAGE_SPEC_VERSION 1
#define VK_KHR_16BIT_STORAGE_EXTENSION_NAME "VK_KHR_16bit_storage"

typedef struct VkPhysicalDevice16BitStorageFeaturesKHR {
    VkStructureType    sType;
    void*              pNext;
    VkBool32           storageBuffer16BitAccess;
    VkBool32           uniformAndStorageBuffer16BitAccess;
    VkBool32           storagePushConstant16;
    VkBool32           storageInputOutput16;
} VkPhysicalDevice16BitStorageFeaturesKHR;


VkPhysicalDevice16BitStorageFeaturesKHR PhysicalDevice16BitStorageFeaturesKHR(
    VkBool32                                    storageBuffer16BitAccess,
    VkBool32                                    uniformAndStorageBuffer16BitAccess,
    VkBool32                                    storagePushConstant16,
    VkBool32                                    storageInputOutput16);



#define VK_KHR_incremental_present 1
#define VK_KHR_INCREMENTAL_PRESENT_SPEC_VERSION 1
#define VK_KHR_INCREMENTAL_PRESENT_EXTENSION_NAME "VK_KHR_incremental_present"

typedef struct VkRectLayerKHR {
    VkOffset2D    offset;
    VkExtent2D    extent;
    uint32_t      layer;
} VkRectLayerKHR;

typedef struct VkPresentRegionKHR {
    uint32_t                 rectangleCount;
    const VkRectLayerKHR*    pRectangles;
} VkPresentRegionKHR;

struct VkPresentRegionKHRRAII {
   VkPresentRegionKHR nonRaiiObj;
    std::vector<VkRectLayerKHR>                 vecRectangles;
};

typedef struct VkPresentRegionsKHR {
    VkStructureType              sType;
    const void*                  pNext;
    uint32_t                     swapchainCount;
    const VkPresentRegionKHR*    pRegions;
} VkPresentRegionsKHR;

struct VkPresentRegionsKHRRAII {
   VkPresentRegionsKHR nonRaiiObj;
    std::vector<VkPresentRegionKHR>             vecRegions;
};


VkRectLayerKHR RectLayerKHR(
    VkOffset2D                                  offset,
    VkExtent2D                                  extent,
    uint32_t                                    layer);


std::shared_ptr<VkPresentRegionKHRRAII> PresentRegionKHR(
    const std::vector<VkRectLayerKHR> &         vecRectangles);


std::shared_ptr<VkPresentRegionsKHRRAII> PresentRegionsKHR(
    const std::vector<VkPresentRegionKHR> &     vecRegions);



#define VK_KHR_descriptor_update_template 1
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkDescriptorUpdateTemplateKHR)

#define VK_KHR_DESCRIPTOR_UPDATE_TEMPLATE_SPEC_VERSION 1
#define VK_KHR_DESCRIPTOR_UPDATE_TEMPLATE_EXTENSION_NAME "VK_KHR_descriptor_update_template"


typedef enum VkDescriptorUpdateTemplateTypeKHR {
    VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET_KHR = 0,
    VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR = 1,
    VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_BEGIN_RANGE_KHR = VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET_KHR,
    VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_END_RANGE_KHR = VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR,
    VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_RANGE_SIZE_KHR = (VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR - VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET_KHR + 1),
    VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_MAX_ENUM_KHR = 0x7FFFFFFF
} VkDescriptorUpdateTemplateTypeKHR;

typedef VkFlags VkDescriptorUpdateTemplateCreateFlagsKHR;

typedef struct VkDescriptorUpdateTemplateEntryKHR {
    uint32_t            dstBinding;
    uint32_t            dstArrayElement;
    uint32_t            descriptorCount;
    VkDescriptorType    descriptorType;
    size_t              offset;
    size_t              stride;
} VkDescriptorUpdateTemplateEntryKHR;

typedef struct VkDescriptorUpdateTemplateCreateInfoKHR {
    VkStructureType                              sType;
    void*                                        pNext;
    VkDescriptorUpdateTemplateCreateFlagsKHR     flags;
    uint32_t                                     descriptorUpdateEntryCount;
    const VkDescriptorUpdateTemplateEntryKHR*    pDescriptorUpdateEntries;
    VkDescriptorUpdateTemplateTypeKHR            templateType;
    VkDescriptorSetLayout                        descriptorSetLayout;
    VkPipelineBindPoint                          pipelineBindPoint;
    VkPipelineLayout                             pipelineLayout;
    uint32_t                                     set;
} VkDescriptorUpdateTemplateCreateInfoKHR;

struct VkDescriptorUpdateTemplateCreateInfoKHRRAII {
   VkDescriptorUpdateTemplateCreateInfoKHR nonRaiiObj;
    std::vector<VkDescriptorUpdateTemplateEntryKHR>vecDescriptorUpdateEntries;
};


typedef VkResult (VKAPI_PTR *PFN_vkCreateDescriptorUpdateTemplateKHR)(VkDevice device, const VkDescriptorUpdateTemplateCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkDescriptorUpdateTemplateKHR* pDescriptorUpdateTemplate);
typedef void (VKAPI_PTR *PFN_vkDestroyDescriptorUpdateTemplateKHR)(VkDevice device, VkDescriptorUpdateTemplateKHR descriptorUpdateTemplate, const VkAllocationCallbacks* pAllocator);

VkDescriptorUpdateTemplateEntryKHR DescriptorUpdateTemplateEntryKHR(
    uint32_t                                    dstBinding,
    uint32_t                                    dstArrayElement,
    uint32_t                                    descriptorCount,
    VkDescriptorType                            descriptorType,
    size_t                                      offset,
    size_t                                      stride);


std::shared_ptr<VkDescriptorUpdateTemplateCreateInfoKHRRAII> DescriptorUpdateTemplateCreateInfoKHR(
    VkDescriptorUpdateTemplateCreateFlagsKHR    flags,
    const std::vector<VkDescriptorUpdateTemplateEntryKHR> &vecDescriptorUpdateEntries,
    VkDescriptorUpdateTemplateTypeKHR           templateType,
    VkDescriptorSetLayout                       descriptorSetLayout,
    VkPipelineBindPoint                         pipelineBindPoint,
    VkPipelineLayout                            pipelineLayout,
    uint32_t                                    set);


std::shared_ptr<VkDescriptorUpdateTemplateKHR_T> createDescriptorUpdateTemplateKHR(
        VkDevice device,
        const VkDescriptorUpdateTemplateCreateInfoKHR & pCreateInfo);


#define VK_KHR_shared_presentable_image 1
#define VK_KHR_SHARED_PRESENTABLE_IMAGE_SPEC_VERSION 1
#define VK_KHR_SHARED_PRESENTABLE_IMAGE_EXTENSION_NAME "VK_KHR_shared_presentable_image"

typedef struct VkSharedPresentSurfaceCapabilitiesKHR {
    VkStructureType      sType;
    void*                pNext;
    VkImageUsageFlags    sharedPresentSupportedUsageFlags;
} VkSharedPresentSurfaceCapabilitiesKHR;


typedef VkResult (VKAPI_PTR *PFN_vkGetSwapchainStatusKHR)(VkDevice device, VkSwapchainKHR swapchain);

VkSharedPresentSurfaceCapabilitiesKHR SharedPresentSurfaceCapabilitiesKHR(
    VkImageUsageFlags                           sharedPresentSupportedUsageFlags);


void  getSwapchainStatusKHR(
        VkDevice device,
        VkSwapchainKHR swapchain);


#define VK_KHR_external_fence_capabilities 1
#define VK_KHR_EXTERNAL_FENCE_CAPABILITIES_SPEC_VERSION 1
#define VK_KHR_EXTERNAL_FENCE_CAPABILITIES_EXTENSION_NAME "VK_KHR_external_fence_capabilities"


typedef enum VkExternalFenceHandleTypeFlagBitsKHR {
    VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR = 0x00000001,
    VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR = 0x00000002,
    VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR = 0x00000004,
    VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT_KHR = 0x00000008,
    VK_EXTERNAL_FENCE_HANDLE_TYPE_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF
} VkExternalFenceHandleTypeFlagBitsKHR;
typedef VkFlags VkExternalFenceHandleTypeFlagsKHR;

typedef enum VkExternalFenceFeatureFlagBitsKHR {
    VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT_KHR = 0x00000001,
    VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT_KHR = 0x00000002,
    VK_EXTERNAL_FENCE_FEATURE_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF
} VkExternalFenceFeatureFlagBitsKHR;
typedef VkFlags VkExternalFenceFeatureFlagsKHR;

typedef struct VkPhysicalDeviceExternalFenceInfoKHR {
    VkStructureType                         sType;
    const void*                             pNext;
    VkExternalFenceHandleTypeFlagBitsKHR    handleType;
} VkPhysicalDeviceExternalFenceInfoKHR;

typedef struct VkExternalFencePropertiesKHR {
    VkStructureType                      sType;
    void*                                pNext;
    VkExternalFenceHandleTypeFlagsKHR    exportFromImportedHandleTypes;
    VkExternalFenceHandleTypeFlagsKHR    compatibleHandleTypes;
    VkExternalFenceFeatureFlagsKHR       externalFenceFeatures;
} VkExternalFencePropertiesKHR;


typedef void (VKAPI_PTR *PFN_vkGetPhysicalDeviceExternalFencePropertiesKHR)(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalFenceInfoKHR* pExternalFenceInfo, VkExternalFencePropertiesKHR* pExternalFenceProperties);

VkPhysicalDeviceExternalFenceInfoKHR PhysicalDeviceExternalFenceInfoKHR(
    VkExternalFenceHandleTypeFlagBitsKHR        handleType);


VkExternalFencePropertiesKHR ExternalFencePropertiesKHR(
    VkExternalFenceHandleTypeFlagsKHR           exportFromImportedHandleTypes,
    VkExternalFenceHandleTypeFlagsKHR           compatibleHandleTypes,
    VkExternalFenceFeatureFlagsKHR              externalFenceFeatures);


VkExternalFencePropertiesKHR getPhysicalDeviceExternalFencePropertiesKHR(
        VkPhysicalDevice physicalDevice,
        const VkPhysicalDeviceExternalFenceInfoKHR & pExternalFenceInfo);


#define VK_KHR_external_fence 1
#define VK_KHR_EXTERNAL_FENCE_SPEC_VERSION 1
#define VK_KHR_EXTERNAL_FENCE_EXTENSION_NAME "VK_KHR_external_fence"


typedef enum VkFenceImportFlagBitsKHR {
    VK_FENCE_IMPORT_TEMPORARY_BIT_KHR = 0x00000001,
    VK_FENCE_IMPORT_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF
} VkFenceImportFlagBitsKHR;
typedef VkFlags VkFenceImportFlagsKHR;

typedef struct VkExportFenceCreateInfoKHR {
    VkStructureType                      sType;
    const void*                          pNext;
    VkExternalFenceHandleTypeFlagsKHR    handleTypes;
} VkExportFenceCreateInfoKHR;


VkExportFenceCreateInfoKHR ExportFenceCreateInfoKHR(
    VkExternalFenceHandleTypeFlagsKHR           handleTypes);



#ifdef VK_USE_PLATFORM_WIN32_KHR
#define VK_KHR_external_fence_win32 1
#define VK_KHR_EXTERNAL_FENCE_WIN32_SPEC_VERSION 1
#define VK_KHR_EXTERNAL_FENCE_WIN32_EXTENSION_NAME "VK_KHR_external_fence_win32"

typedef struct VkImportFenceWin32HandleInfoKHR {
    VkStructureType                         sType;
    const void*                             pNext;
    VkFence                                 fence;
    VkFenceImportFlagsKHR                   flags;
    VkExternalFenceHandleTypeFlagBitsKHR    handleType;
    HANDLE                                  handle;
    LPCWSTR                                 name;
} VkImportFenceWin32HandleInfoKHR;

typedef struct VkExportFenceWin32HandleInfoKHR {
    VkStructureType               sType;
    const void*                   pNext;
    const SECURITY_ATTRIBUTES*    pAttributes;
    DWORD                         dwAccess;
    LPCWSTR                       name;
} VkExportFenceWin32HandleInfoKHR;

struct VkExportFenceWin32HandleInfoKHRRAII {
   VkExportFenceWin32HandleInfoKHR nonRaiiObj;
    std::shared_ptr<SECURITY_ATTRIBUTES>        pAttributes;
};

typedef struct VkFenceGetWin32HandleInfoKHR {
    VkStructureType                         sType;
    const void*                             pNext;
    VkFence                                 fence;
    VkExternalFenceHandleTypeFlagBitsKHR    handleType;
} VkFenceGetWin32HandleInfoKHR;


typedef VkResult (VKAPI_PTR *PFN_vkImportFenceWin32HandleKHR)(VkDevice device, const VkImportFenceWin32HandleInfoKHR* pImportFenceWin32HandleInfo);
typedef VkResult (VKAPI_PTR *PFN_vkGetFenceWin32HandleKHR)(VkDevice device, const VkFenceGetWin32HandleInfoKHR* pGetWin32HandleInfo, HANDLE* pHandle);

VkImportFenceWin32HandleInfoKHR ImportFenceWin32HandleInfoKHR(
    VkFence                                     fence,
    VkFenceImportFlagsKHR                       flags,
    VkExternalFenceHandleTypeFlagBitsKHR        handleType,
    HANDLE                                      handle,
    LPCWSTR                                     name);


std::shared_ptr<VkExportFenceWin32HandleInfoKHRRAII> ExportFenceWin32HandleInfoKHR(
    const SECURITY_ATTRIBUTES *                 pAttributes,
    DWORD                                       dwAccess,
    LPCWSTR                                     name);


VkFenceGetWin32HandleInfoKHR FenceGetWin32HandleInfoKHR(
    VkFence                                     fence,
    VkExternalFenceHandleTypeFlagBitsKHR        handleType);


void  importFenceWin32HandleKHR(
        VkDevice device,
        const VkImportFenceWin32HandleInfoKHR & pImportFenceWin32HandleInfo);

HANDLE getFenceWin32HandleKHR(
        VkDevice device,
        const VkFenceGetWin32HandleInfoKHR & pGetWin32HandleInfo);

#endif /* VK_USE_PLATFORM_WIN32_KHR */

#define VK_KHR_external_fence_fd 1
#define VK_KHR_EXTERNAL_FENCE_FD_SPEC_VERSION 1
#define VK_KHR_EXTERNAL_FENCE_FD_EXTENSION_NAME "VK_KHR_external_fence_fd"

typedef struct VkImportFenceFdInfoKHR {
    VkStructureType                         sType;
    const void*                             pNext;
    VkFence                                 fence;
    VkFenceImportFlagsKHR                   flags;
    VkExternalFenceHandleTypeFlagBitsKHR    handleType;
    int                                     fd;
} VkImportFenceFdInfoKHR;

typedef struct VkFenceGetFdInfoKHR {
    VkStructureType                         sType;
    const void*                             pNext;
    VkFence                                 fence;
    VkExternalFenceHandleTypeFlagBitsKHR    handleType;
} VkFenceGetFdInfoKHR;


typedef VkResult (VKAPI_PTR *PFN_vkImportFenceFdKHR)(VkDevice device, const VkImportFenceFdInfoKHR* pImportFenceFdInfo);
typedef VkResult (VKAPI_PTR *PFN_vkGetFenceFdKHR)(VkDevice device, const VkFenceGetFdInfoKHR* pGetFdInfo, int* pFd);

VkImportFenceFdInfoKHR ImportFenceFdInfoKHR(
    VkFence                                     fence,
    VkFenceImportFlagsKHR                       flags,
    VkExternalFenceHandleTypeFlagBitsKHR        handleType,
    int                                         fd);


VkFenceGetFdInfoKHR FenceGetFdInfoKHR(
    VkFence                                     fence,
    VkExternalFenceHandleTypeFlagBitsKHR        handleType);


void  importFenceFdKHR(
        VkDevice device,
        const VkImportFenceFdInfoKHR & pImportFenceFdInfo);

int getFenceFdKHR(
        VkDevice device,
        const VkFenceGetFdInfoKHR & pGetFdInfo);


#define VK_KHR_maintenance2 1
#define VK_KHR_MAINTENANCE2_SPEC_VERSION  1
#define VK_KHR_MAINTENANCE2_EXTENSION_NAME "VK_KHR_maintenance2"


typedef enum VkPointClippingBehaviorKHR {
    VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES_KHR = 0,
    VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY_KHR = 1,
    VK_POINT_CLIPPING_BEHAVIOR_BEGIN_RANGE_KHR = VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES_KHR,
    VK_POINT_CLIPPING_BEHAVIOR_END_RANGE_KHR = VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY_KHR,
    VK_POINT_CLIPPING_BEHAVIOR_RANGE_SIZE_KHR = (VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY_KHR - VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES_KHR + 1),
    VK_POINT_CLIPPING_BEHAVIOR_MAX_ENUM_KHR = 0x7FFFFFFF
} VkPointClippingBehaviorKHR;

typedef enum VkTessellationDomainOriginKHR {
    VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT_KHR = 0,
    VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT_KHR = 1,
    VK_TESSELLATION_DOMAIN_ORIGIN_BEGIN_RANGE_KHR = VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT_KHR,
    VK_TESSELLATION_DOMAIN_ORIGIN_END_RANGE_KHR = VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT_KHR,
    VK_TESSELLATION_DOMAIN_ORIGIN_RANGE_SIZE_KHR = (VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT_KHR - VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT_KHR + 1),
    VK_TESSELLATION_DOMAIN_ORIGIN_MAX_ENUM_KHR = 0x7FFFFFFF
} VkTessellationDomainOriginKHR;

typedef struct VkPhysicalDevicePointClippingPropertiesKHR {
    VkStructureType               sType;
    void*                         pNext;
    VkPointClippingBehaviorKHR    pointClippingBehavior;
} VkPhysicalDevicePointClippingPropertiesKHR;

typedef struct VkInputAttachmentAspectReferenceKHR {
    uint32_t              subpass;
    uint32_t              inputAttachmentIndex;
    VkImageAspectFlags    aspectMask;
} VkInputAttachmentAspectReferenceKHR;

typedef struct VkRenderPassInputAttachmentAspectCreateInfoKHR {
    VkStructureType                               sType;
    const void*                                   pNext;
    uint32_t                                      aspectReferenceCount;
    const VkInputAttachmentAspectReferenceKHR*    pAspectReferences;
} VkRenderPassInputAttachmentAspectCreateInfoKHR;

struct VkRenderPassInputAttachmentAspectCreateInfoKHRRAII {
   VkRenderPassInputAttachmentAspectCreateInfoKHR nonRaiiObj;
    std::vector<VkInputAttachmentAspectReferenceKHR>vecAspectReferences;
};

typedef struct VkImageViewUsageCreateInfoKHR {
    VkStructureType      sType;
    const void*          pNext;
    VkImageUsageFlags    usage;
} VkImageViewUsageCreateInfoKHR;

typedef struct VkPipelineTessellationDomainOriginStateCreateInfoKHR {
    VkStructureType                  sType;
    const void*                      pNext;
    VkTessellationDomainOriginKHR    domainOrigin;
} VkPipelineTessellationDomainOriginStateCreateInfoKHR;


VkPhysicalDevicePointClippingPropertiesKHR PhysicalDevicePointClippingPropertiesKHR(
    VkPointClippingBehaviorKHR                  pointClippingBehavior);


VkInputAttachmentAspectReferenceKHR InputAttachmentAspectReferenceKHR(
    uint32_t                                    subpass,
    uint32_t                                    inputAttachmentIndex,
    VkImageAspectFlags                          aspectMask);


std::shared_ptr<VkRenderPassInputAttachmentAspectCreateInfoKHRRAII> RenderPassInputAttachmentAspectCreateInfoKHR(
    const std::vector<VkInputAttachmentAspectReferenceKHR> &vecAspectReferences);


VkImageViewUsageCreateInfoKHR ImageViewUsageCreateInfoKHR(
    VkImageUsageFlags                           usage);


VkPipelineTessellationDomainOriginStateCreateInfoKHR PipelineTessellationDomainOriginStateCreateInfoKHR(
    VkTessellationDomainOriginKHR               domainOrigin);



#define VK_KHR_get_surface_capabilities2 1
#define VK_KHR_GET_SURFACE_CAPABILITIES_2_SPEC_VERSION 1
#define VK_KHR_GET_SURFACE_CAPABILITIES_2_EXTENSION_NAME "VK_KHR_get_surface_capabilities2"

typedef struct VkPhysicalDeviceSurfaceInfo2KHR {
    VkStructureType    sType;
    const void*        pNext;
    VkSurfaceKHR       surface;
} VkPhysicalDeviceSurfaceInfo2KHR;

typedef struct VkSurfaceCapabilities2KHR {
    VkStructureType             sType;
    void*                       pNext;
    VkSurfaceCapabilitiesKHR    surfaceCapabilities;
} VkSurfaceCapabilities2KHR;

typedef struct VkSurfaceFormat2KHR {
    VkStructureType       sType;
    void*                 pNext;
    VkSurfaceFormatKHR    surfaceFormat;
} VkSurfaceFormat2KHR;


typedef VkResult (VKAPI_PTR *PFN_vkGetPhysicalDeviceSurfaceCapabilities2KHR)(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo, VkSurfaceCapabilities2KHR* pSurfaceCapabilities);
typedef VkResult (VKAPI_PTR *PFN_vkGetPhysicalDeviceSurfaceFormats2KHR)(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo, uint32_t* pSurfaceFormatCount, VkSurfaceFormat2KHR* pSurfaceFormats);

VkPhysicalDeviceSurfaceInfo2KHR PhysicalDeviceSurfaceInfo2KHR(
    VkSurfaceKHR                                surface);


VkSurfaceCapabilities2KHR SurfaceCapabilities2KHR(
    VkSurfaceCapabilitiesKHR                    surfaceCapabilities);


VkSurfaceFormat2KHR SurfaceFormat2KHR(
    VkSurfaceFormatKHR                          surfaceFormat);


VkSurfaceCapabilities2KHR getPhysicalDeviceSurfaceCapabilities2KHR(
        VkPhysicalDevice physicalDevice,
        const VkPhysicalDeviceSurfaceInfo2KHR & pSurfaceInfo);

std::vector< VkSurfaceFormat2KHR > getPhysicalDeviceSurfaceFormats2KHR(
        VkPhysicalDevice physicalDevice,
        const VkPhysicalDeviceSurfaceInfo2KHR & pSurfaceInfo);


#define VK_KHR_variable_pointers 1
#define VK_KHR_VARIABLE_POINTERS_SPEC_VERSION 1
#define VK_KHR_VARIABLE_POINTERS_EXTENSION_NAME "VK_KHR_variable_pointers"

typedef struct VkPhysicalDeviceVariablePointerFeaturesKHR {
    VkStructureType    sType;
    void*              pNext;
    VkBool32           variablePointersStorageBuffer;
    VkBool32           variablePointers;
} VkPhysicalDeviceVariablePointerFeaturesKHR;


VkPhysicalDeviceVariablePointerFeaturesKHR PhysicalDeviceVariablePointerFeaturesKHR(
    VkBool32                                    variablePointersStorageBuffer,
    VkBool32                                    variablePointers);



#define VK_KHR_dedicated_allocation 1
#define VK_KHR_DEDICATED_ALLOCATION_SPEC_VERSION 3
#define VK_KHR_DEDICATED_ALLOCATION_EXTENSION_NAME "VK_KHR_dedicated_allocation"

typedef struct VkMemoryDedicatedRequirementsKHR {
    VkStructureType    sType;
    void*              pNext;
    VkBool32           prefersDedicatedAllocation;
    VkBool32           requiresDedicatedAllocation;
} VkMemoryDedicatedRequirementsKHR;

typedef struct VkMemoryDedicatedAllocateInfoKHR {
    VkStructureType    sType;
    const void*        pNext;
    VkImage            image;
    VkBuffer           buffer;
} VkMemoryDedicatedAllocateInfoKHR;


VkMemoryDedicatedRequirementsKHR MemoryDedicatedRequirementsKHR(
    VkBool32                                    prefersDedicatedAllocation,
    VkBool32                                    requiresDedicatedAllocation);


VkMemoryDedicatedAllocateInfoKHR MemoryDedicatedAllocateInfoKHR(
    VkImage                                     image,
    VkBuffer                                    buffer);



#define VK_KHR_storage_buffer_storage_class 1
#define VK_KHR_STORAGE_BUFFER_STORAGE_CLASS_SPEC_VERSION 1
#define VK_KHR_STORAGE_BUFFER_STORAGE_CLASS_EXTENSION_NAME "VK_KHR_storage_buffer_storage_class"


#define VK_KHR_relaxed_block_layout 1
#define VK_KHR_RELAXED_BLOCK_LAYOUT_SPEC_VERSION 1
#define VK_KHR_RELAXED_BLOCK_LAYOUT_EXTENSION_NAME "VK_KHR_relaxed_block_layout"


#define VK_KHR_get_memory_requirements2 1
#define VK_KHR_GET_MEMORY_REQUIREMENTS_2_SPEC_VERSION 1
#define VK_KHR_GET_MEMORY_REQUIREMENTS_2_EXTENSION_NAME "VK_KHR_get_memory_requirements2"

typedef struct VkBufferMemoryRequirementsInfo2KHR {
    VkStructureType    sType;
    const void*        pNext;
    VkBuffer           buffer;
} VkBufferMemoryRequirementsInfo2KHR;

typedef struct VkImageMemoryRequirementsInfo2KHR {
    VkStructureType    sType;
    const void*        pNext;
    VkImage            image;
} VkImageMemoryRequirementsInfo2KHR;

typedef struct VkImageSparseMemoryRequirementsInfo2KHR {
    VkStructureType    sType;
    const void*        pNext;
    VkImage            image;
} VkImageSparseMemoryRequirementsInfo2KHR;

typedef struct VkMemoryRequirements2KHR {
    VkStructureType         sType;
    void*                   pNext;
    VkMemoryRequirements    memoryRequirements;
} VkMemoryRequirements2KHR;

typedef struct VkSparseImageMemoryRequirements2KHR {
    VkStructureType                    sType;
    void*                              pNext;
    VkSparseImageMemoryRequirements    memoryRequirements;
} VkSparseImageMemoryRequirements2KHR;


typedef void (VKAPI_PTR *PFN_vkGetImageMemoryRequirements2KHR)(VkDevice device, const VkImageMemoryRequirementsInfo2KHR* pInfo, VkMemoryRequirements2KHR* pMemoryRequirements);
typedef void (VKAPI_PTR *PFN_vkGetBufferMemoryRequirements2KHR)(VkDevice device, const VkBufferMemoryRequirementsInfo2KHR* pInfo, VkMemoryRequirements2KHR* pMemoryRequirements);
typedef void (VKAPI_PTR *PFN_vkGetImageSparseMemoryRequirements2KHR)(VkDevice device, const VkImageSparseMemoryRequirementsInfo2KHR* pInfo, uint32_t* pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements2KHR* pSparseMemoryRequirements);

VkBufferMemoryRequirementsInfo2KHR BufferMemoryRequirementsInfo2KHR(
    VkBuffer                                    buffer);


VkImageMemoryRequirementsInfo2KHR ImageMemoryRequirementsInfo2KHR(
    VkImage                                     image);


VkImageSparseMemoryRequirementsInfo2KHR ImageSparseMemoryRequirementsInfo2KHR(
    VkImage                                     image);


VkMemoryRequirements2KHR MemoryRequirements2KHR(
    VkMemoryRequirements                        memoryRequirements);


VkSparseImageMemoryRequirements2KHR SparseImageMemoryRequirements2KHR(
    VkSparseImageMemoryRequirements             memoryRequirements);


VkMemoryRequirements2KHR getImageMemoryRequirements2KHR(
        VkDevice device,
        const VkImageMemoryRequirementsInfo2KHR & pInfo);

VkMemoryRequirements2KHR getBufferMemoryRequirements2KHR(
        VkDevice device,
        const VkBufferMemoryRequirementsInfo2KHR & pInfo);

std::vector< VkSparseImageMemoryRequirements2KHR > getImageSparseMemoryRequirements2KHR(
        VkDevice device,
        const VkImageSparseMemoryRequirementsInfo2KHR & pInfo);


#define VK_KHR_image_format_list 1
#define VK_KHR_IMAGE_FORMAT_LIST_SPEC_VERSION 1
#define VK_KHR_IMAGE_FORMAT_LIST_EXTENSION_NAME "VK_KHR_image_format_list"

typedef struct VkImageFormatListCreateInfoKHR {
    VkStructureType    sType;
    const void*        pNext;
    uint32_t           viewFormatCount;
    const VkFormat*    pViewFormats;
} VkImageFormatListCreateInfoKHR;

struct VkImageFormatListCreateInfoKHRRAII {
   VkImageFormatListCreateInfoKHR nonRaiiObj;
    std::vector<VkFormat>                       vecViewFormats;
};


std::shared_ptr<VkImageFormatListCreateInfoKHRRAII> ImageFormatListCreateInfoKHR(
    const std::vector<VkFormat> &               vecViewFormats);



#define VK_KHR_sampler_ycbcr_conversion 1
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkSamplerYcbcrConversionKHR)

#define VK_KHR_SAMPLER_YCBCR_CONVERSION_SPEC_VERSION 1
#define VK_KHR_SAMPLER_YCBCR_CONVERSION_EXTENSION_NAME "VK_KHR_sampler_ycbcr_conversion"


typedef enum VkSamplerYcbcrModelConversionKHR {
    VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY_KHR = 0,
    VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY_KHR = 1,
    VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709_KHR = 2,
    VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601_KHR = 3,
    VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020_KHR = 4,
    VK_SAMPLER_YCBCR_MODEL_CONVERSION_BEGIN_RANGE_KHR = VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY_KHR,
    VK_SAMPLER_YCBCR_MODEL_CONVERSION_END_RANGE_KHR = VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020_KHR,
    VK_SAMPLER_YCBCR_MODEL_CONVERSION_RANGE_SIZE_KHR = (VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020_KHR - VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY_KHR + 1),
    VK_SAMPLER_YCBCR_MODEL_CONVERSION_MAX_ENUM_KHR = 0x7FFFFFFF
} VkSamplerYcbcrModelConversionKHR;

typedef enum VkSamplerYcbcrRangeKHR {
    VK_SAMPLER_YCBCR_RANGE_ITU_FULL_KHR = 0,
    VK_SAMPLER_YCBCR_RANGE_ITU_NARROW_KHR = 1,
    VK_SAMPLER_YCBCR_RANGE_BEGIN_RANGE_KHR = VK_SAMPLER_YCBCR_RANGE_ITU_FULL_KHR,
    VK_SAMPLER_YCBCR_RANGE_END_RANGE_KHR = VK_SAMPLER_YCBCR_RANGE_ITU_NARROW_KHR,
    VK_SAMPLER_YCBCR_RANGE_RANGE_SIZE_KHR = (VK_SAMPLER_YCBCR_RANGE_ITU_NARROW_KHR - VK_SAMPLER_YCBCR_RANGE_ITU_FULL_KHR + 1),
    VK_SAMPLER_YCBCR_RANGE_MAX_ENUM_KHR = 0x7FFFFFFF
} VkSamplerYcbcrRangeKHR;

typedef enum VkChromaLocationKHR {
    VK_CHROMA_LOCATION_COSITED_EVEN_KHR = 0,
    VK_CHROMA_LOCATION_MIDPOINT_KHR = 1,
    VK_CHROMA_LOCATION_BEGIN_RANGE_KHR = VK_CHROMA_LOCATION_COSITED_EVEN_KHR,
    VK_CHROMA_LOCATION_END_RANGE_KHR = VK_CHROMA_LOCATION_MIDPOINT_KHR,
    VK_CHROMA_LOCATION_RANGE_SIZE_KHR = (VK_CHROMA_LOCATION_MIDPOINT_KHR - VK_CHROMA_LOCATION_COSITED_EVEN_KHR + 1),
    VK_CHROMA_LOCATION_MAX_ENUM_KHR = 0x7FFFFFFF
} VkChromaLocationKHR;

typedef struct VkSamplerYcbcrConversionCreateInfoKHR {
    VkStructureType                     sType;
    const void*                         pNext;
    VkFormat                            format;
    VkSamplerYcbcrModelConversionKHR    ycbcrModel;
    VkSamplerYcbcrRangeKHR              ycbcrRange;
    VkComponentMapping                  components;
    VkChromaLocationKHR                 xChromaOffset;
    VkChromaLocationKHR                 yChromaOffset;
    VkFilter                            chromaFilter;
    VkBool32                            forceExplicitReconstruction;
} VkSamplerYcbcrConversionCreateInfoKHR;

typedef struct VkSamplerYcbcrConversionInfoKHR {
    VkStructureType                sType;
    const void*                    pNext;
    VkSamplerYcbcrConversionKHR    conversion;
} VkSamplerYcbcrConversionInfoKHR;

typedef struct VkBindImagePlaneMemoryInfoKHR {
    VkStructureType          sType;
    const void*              pNext;
    VkImageAspectFlagBits    planeAspect;
} VkBindImagePlaneMemoryInfoKHR;

typedef struct VkImagePlaneMemoryRequirementsInfoKHR {
    VkStructureType          sType;
    const void*              pNext;
    VkImageAspectFlagBits    planeAspect;
} VkImagePlaneMemoryRequirementsInfoKHR;

typedef struct VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR {
    VkStructureType    sType;
    void*              pNext;
    VkBool32           samplerYcbcrConversion;
} VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR;

typedef struct VkSamplerYcbcrConversionImageFormatPropertiesKHR {
    VkStructureType    sType;
    void*              pNext;
    uint32_t           combinedImageSamplerDescriptorCount;
} VkSamplerYcbcrConversionImageFormatPropertiesKHR;


typedef VkResult (VKAPI_PTR *PFN_vkCreateSamplerYcbcrConversionKHR)(VkDevice device, const VkSamplerYcbcrConversionCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSamplerYcbcrConversionKHR* pYcbcrConversion);
typedef void (VKAPI_PTR *PFN_vkDestroySamplerYcbcrConversionKHR)(VkDevice device, VkSamplerYcbcrConversionKHR ycbcrConversion, const VkAllocationCallbacks* pAllocator);

VkSamplerYcbcrConversionCreateInfoKHR SamplerYcbcrConversionCreateInfoKHR(
    VkFormat                                    format,
    VkSamplerYcbcrModelConversionKHR            ycbcrModel,
    VkSamplerYcbcrRangeKHR                      ycbcrRange,
    VkComponentMapping                          components,
    VkChromaLocationKHR                         xChromaOffset,
    VkChromaLocationKHR                         yChromaOffset,
    VkFilter                                    chromaFilter,
    VkBool32                                    forceExplicitReconstruction);


VkSamplerYcbcrConversionInfoKHR SamplerYcbcrConversionInfoKHR(
    VkSamplerYcbcrConversionKHR                 conversion);


VkBindImagePlaneMemoryInfoKHR BindImagePlaneMemoryInfoKHR(
    VkImageAspectFlagBits                       planeAspect);


VkImagePlaneMemoryRequirementsInfoKHR ImagePlaneMemoryRequirementsInfoKHR(
    VkImageAspectFlagBits                       planeAspect);


VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR PhysicalDeviceSamplerYcbcrConversionFeaturesKHR(
    VkBool32                                    samplerYcbcrConversion);


VkSamplerYcbcrConversionImageFormatPropertiesKHR SamplerYcbcrConversionImageFormatPropertiesKHR(
    uint32_t                                    combinedImageSamplerDescriptorCount);


std::shared_ptr<VkSamplerYcbcrConversionKHR_T> createSamplerYcbcrConversionKHR(
        VkDevice device,
        const VkSamplerYcbcrConversionCreateInfoKHR & pCreateInfo);


#define VK_KHR_bind_memory2 1
#define VK_KHR_BIND_MEMORY_2_SPEC_VERSION 1
#define VK_KHR_BIND_MEMORY_2_EXTENSION_NAME "VK_KHR_bind_memory2"

typedef struct VkBindBufferMemoryInfoKHR {
    VkStructureType    sType;
    const void*        pNext;
    VkBuffer           buffer;
    VkDeviceMemory     memory;
    VkDeviceSize       memoryOffset;
} VkBindBufferMemoryInfoKHR;

typedef struct VkBindImageMemoryInfoKHR {
    VkStructureType    sType;
    const void*        pNext;
    VkImage            image;
    VkDeviceMemory     memory;
    VkDeviceSize       memoryOffset;
} VkBindImageMemoryInfoKHR;


typedef VkResult (VKAPI_PTR *PFN_vkBindBufferMemory2KHR)(VkDevice device, uint32_t bindInfoCount, const VkBindBufferMemoryInfoKHR* pBindInfos);
typedef VkResult (VKAPI_PTR *PFN_vkBindImageMemory2KHR)(VkDevice device, uint32_t bindInfoCount, const VkBindImageMemoryInfoKHR* pBindInfos);

VkBindBufferMemoryInfoKHR BindBufferMemoryInfoKHR(
    VkBuffer                                    buffer,
    VkDeviceMemory                              memory,
    VkDeviceSize                                memoryOffset);


VkBindImageMemoryInfoKHR BindImageMemoryInfoKHR(
    VkImage                                     image,
    VkDeviceMemory                              memory,
    VkDeviceSize                                memoryOffset);


void  bindBufferMemory2KHR(
        VkDevice device,
        const std::vector<VkBindBufferMemoryInfoKHR> & pBindInfos);

void  bindImageMemory2KHR(
        VkDevice device,
        const std::vector<VkBindImageMemoryInfoKHR> & pBindInfos);


#define VK_EXT_debug_report 1
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkDebugReportCallbackEXT)

#define VK_EXT_DEBUG_REPORT_SPEC_VERSION  9
#define VK_EXT_DEBUG_REPORT_EXTENSION_NAME "VK_EXT_debug_report"
#define VK_STRUCTURE_TYPE_DEBUG_REPORT_CREATE_INFO_EXT VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT
#define VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_EXT VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT_EXT


typedef enum VkDebugReportObjectTypeEXT {
    VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT = 0,
    VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT = 1,
    VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT = 2,
    VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT = 3,
    VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT = 4,
    VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT = 5,
    VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT = 6,
    VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT = 7,
    VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT = 8,
    VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT = 9,
    VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT = 10,
    VK_DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT = 11,
    VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT = 12,
    VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT = 13,
    VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT = 14,
    VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT = 15,
    VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT = 16,
    VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT = 17,
    VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT = 18,
    VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT = 19,
    VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT = 20,
    VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT = 21,
    VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT = 22,
    VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT = 23,
    VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT = 24,
    VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT = 25,
    VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT = 26,
    VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT = 27,
    VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT_EXT = 28,
    VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_KHR_EXT = 29,
    VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_MODE_KHR_EXT = 30,
    VK_DEBUG_REPORT_OBJECT_TYPE_OBJECT_TABLE_NVX_EXT = 31,
    VK_DEBUG_REPORT_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NVX_EXT = 32,
    VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT = 33,
    VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR_EXT = 1000085000,
    VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_KHR_EXT = 1000156000,
    VK_DEBUG_REPORT_OBJECT_TYPE_BEGIN_RANGE_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT,
    VK_DEBUG_REPORT_OBJECT_TYPE_END_RANGE_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT,
    VK_DEBUG_REPORT_OBJECT_TYPE_RANGE_SIZE_EXT = (VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT - VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT + 1),
    VK_DEBUG_REPORT_OBJECT_TYPE_MAX_ENUM_EXT = 0x7FFFFFFF
} VkDebugReportObjectTypeEXT;


typedef enum VkDebugReportFlagBitsEXT {
    VK_DEBUG_REPORT_INFORMATION_BIT_EXT = 0x00000001,
    VK_DEBUG_REPORT_WARNING_BIT_EXT = 0x00000002,
    VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT = 0x00000004,
    VK_DEBUG_REPORT_ERROR_BIT_EXT = 0x00000008,
    VK_DEBUG_REPORT_DEBUG_BIT_EXT = 0x00000010,
    VK_DEBUG_REPORT_FLAG_BITS_MAX_ENUM_EXT = 0x7FFFFFFF
} VkDebugReportFlagBitsEXT;
typedef VkFlags VkDebugReportFlagsEXT;

typedef VkBool32 (VKAPI_PTR *PFN_vkDebugReportCallbackEXT)(
    VkDebugReportFlagsEXT                       flags,
    VkDebugReportObjectTypeEXT                  objectType,
    uint64_t                                    object,
    size_t                                      location,
    int32_t                                     messageCode,
    const char*                                 pLayerPrefix,
    const char*                                 pMessage,
    void*                                       pUserData);

typedef struct VkDebugReportCallbackCreateInfoEXT {
    VkStructureType                 sType;
    const void*                     pNext;
    VkDebugReportFlagsEXT           flags;
    PFN_vkDebugReportCallbackEXT    pfnCallback;
    void*                           pUserData;
} VkDebugReportCallbackCreateInfoEXT;


typedef VkResult (VKAPI_PTR *PFN_vkCreateDebugReportCallbackEXT)(VkInstance instance, const VkDebugReportCallbackCreateInfoEXT* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkDebugReportCallbackEXT* pCallback);
typedef void (VKAPI_PTR *PFN_vkDestroyDebugReportCallbackEXT)(VkInstance instance, VkDebugReportCallbackEXT callback, const VkAllocationCallbacks* pAllocator);
typedef void (VKAPI_PTR *PFN_vkDebugReportMessageEXT)(VkInstance instance, VkDebugReportFlagsEXT flags, VkDebugReportObjectTypeEXT objectType, uint64_t object, size_t location, int32_t messageCode, const char* pLayerPrefix, const char* pMessage);

VkDebugReportCallbackCreateInfoEXT DebugReportCallbackCreateInfoEXT(
    VkDebugReportFlagsEXT                       flags,
    PFN_vkDebugReportCallbackEXT                pfnCallback);


std::shared_ptr<VkDebugReportCallbackEXT_T> createDebugReportCallbackEXT(
        VkInstance instance,
        const VkDebugReportCallbackCreateInfoEXT & pCreateInfo);

void  debugReportMessageEXT(
        VkInstance instance,
        VkDebugReportFlagsEXT flags,
        VkDebugReportObjectTypeEXT objectType,
        uint64_t object,
        size_t location,
        int32_t messageCode,
        const char* pLayerPrefix,
        const char* pMessage);


#define VK_NV_glsl_shader 1
#define VK_NV_GLSL_SHADER_SPEC_VERSION    1
#define VK_NV_GLSL_SHADER_EXTENSION_NAME  "VK_NV_glsl_shader"


#define VK_EXT_depth_range_unrestricted 1
#define VK_EXT_DEPTH_RANGE_UNRESTRICTED_SPEC_VERSION 1
#define VK_EXT_DEPTH_RANGE_UNRESTRICTED_EXTENSION_NAME "VK_EXT_depth_range_unrestricted"


#define VK_IMG_filter_cubic 1
#define VK_IMG_FILTER_CUBIC_SPEC_VERSION  1
#define VK_IMG_FILTER_CUBIC_EXTENSION_NAME "VK_IMG_filter_cubic"


#define VK_AMD_rasterization_order 1
#define VK_AMD_RASTERIZATION_ORDER_SPEC_VERSION 1
#define VK_AMD_RASTERIZATION_ORDER_EXTENSION_NAME "VK_AMD_rasterization_order"


typedef enum VkRasterizationOrderAMD {
    VK_RASTERIZATION_ORDER_STRICT_AMD = 0,
    VK_RASTERIZATION_ORDER_RELAXED_AMD = 1,
    VK_RASTERIZATION_ORDER_BEGIN_RANGE_AMD = VK_RASTERIZATION_ORDER_STRICT_AMD,
    VK_RASTERIZATION_ORDER_END_RANGE_AMD = VK_RASTERIZATION_ORDER_RELAXED_AMD,
    VK_RASTERIZATION_ORDER_RANGE_SIZE_AMD = (VK_RASTERIZATION_ORDER_RELAXED_AMD - VK_RASTERIZATION_ORDER_STRICT_AMD + 1),
    VK_RASTERIZATION_ORDER_MAX_ENUM_AMD = 0x7FFFFFFF
} VkRasterizationOrderAMD;

typedef struct VkPipelineRasterizationStateRasterizationOrderAMD {
    VkStructureType            sType;
    const void*                pNext;
    VkRasterizationOrderAMD    rasterizationOrder;
} VkPipelineRasterizationStateRasterizationOrderAMD;


VkPipelineRasterizationStateRasterizationOrderAMD PipelineRasterizationStateRasterizationOrderAMD(
    VkRasterizationOrderAMD                     rasterizationOrder);



#define VK_AMD_shader_trinary_minmax 1
#define VK_AMD_SHADER_TRINARY_MINMAX_SPEC_VERSION 1
#define VK_AMD_SHADER_TRINARY_MINMAX_EXTENSION_NAME "VK_AMD_shader_trinary_minmax"


#define VK_AMD_shader_explicit_vertex_parameter 1
#define VK_AMD_SHADER_EXPLICIT_VERTEX_PARAMETER_SPEC_VERSION 1
#define VK_AMD_SHADER_EXPLICIT_VERTEX_PARAMETER_EXTENSION_NAME "VK_AMD_shader_explicit_vertex_parameter"


#define VK_EXT_debug_marker 1
#define VK_EXT_DEBUG_MARKER_SPEC_VERSION  4
#define VK_EXT_DEBUG_MARKER_EXTENSION_NAME "VK_EXT_debug_marker"

typedef struct VkDebugMarkerObjectNameInfoEXT {
    VkStructureType               sType;
    const void*                   pNext;
    VkDebugReportObjectTypeEXT    objectType;
    uint64_t                      object;
    const char*                   pObjectName;
} VkDebugMarkerObjectNameInfoEXT;

struct VkDebugMarkerObjectNameInfoEXTRAII {
   VkDebugMarkerObjectNameInfoEXT nonRaiiObj;
    std::string                                 strObjectName;
};

typedef struct VkDebugMarkerObjectTagInfoEXT {
    VkStructureType               sType;
    const void*                   pNext;
    VkDebugReportObjectTypeEXT    objectType;
    uint64_t                      object;
    uint64_t                      tagName;
    size_t                        tagSize;
    const void*                   pTag;
} VkDebugMarkerObjectTagInfoEXT;

struct VkDebugMarkerObjectTagInfoEXTRAII {
   VkDebugMarkerObjectTagInfoEXT nonRaiiObj;
    std::vector<uint8_t>                        vecTag;
};

typedef struct VkDebugMarkerMarkerInfoEXT {
    VkStructureType    sType;
    const void*        pNext;
    const char*        pMarkerName;
    float              color[4];
} VkDebugMarkerMarkerInfoEXT;

struct VkDebugMarkerMarkerInfoEXTRAII {
   VkDebugMarkerMarkerInfoEXT nonRaiiObj;
    std::string                                 strMarkerName;
};


typedef VkResult (VKAPI_PTR *PFN_vkDebugMarkerSetObjectTagEXT)(VkDevice device, const VkDebugMarkerObjectTagInfoEXT* pTagInfo);
typedef VkResult (VKAPI_PTR *PFN_vkDebugMarkerSetObjectNameEXT)(VkDevice device, const VkDebugMarkerObjectNameInfoEXT* pNameInfo);
typedef void (VKAPI_PTR *PFN_vkCmdDebugMarkerBeginEXT)(VkCommandBuffer commandBuffer, const VkDebugMarkerMarkerInfoEXT* pMarkerInfo);
typedef void (VKAPI_PTR *PFN_vkCmdDebugMarkerEndEXT)(VkCommandBuffer commandBuffer);
typedef void (VKAPI_PTR *PFN_vkCmdDebugMarkerInsertEXT)(VkCommandBuffer commandBuffer, const VkDebugMarkerMarkerInfoEXT* pMarkerInfo);

std::shared_ptr<VkDebugMarkerObjectNameInfoEXTRAII> DebugMarkerObjectNameInfoEXT(
    VkDebugReportObjectTypeEXT                  objectType,
    uint64_t                                    object,
    const std::string &                         strObjectName);


std::shared_ptr<VkDebugMarkerObjectTagInfoEXTRAII> DebugMarkerObjectTagInfoEXT(
    VkDebugReportObjectTypeEXT                  objectType,
    uint64_t                                    object,
    uint64_t                                    tagName,
    const std::vector<uint8_t> &                vecTag);


std::shared_ptr<VkDebugMarkerMarkerInfoEXTRAII> DebugMarkerMarkerInfoEXT(
    const std::string &                         strMarkerName,
    float                                       color[4]);


void  debugMarkerSetObjectTagEXT(
        VkDevice device,
        const VkDebugMarkerObjectTagInfoEXT & pTagInfo);

void  debugMarkerSetObjectNameEXT(
        VkDevice device,
        const VkDebugMarkerObjectNameInfoEXT & pNameInfo);

void  cmdDebugMarkerBeginEXT(
        VkCommandBuffer commandBuffer,
        const VkDebugMarkerMarkerInfoEXT & pMarkerInfo);

void  cmdDebugMarkerEndEXT(
        VkCommandBuffer commandBuffer);

void  cmdDebugMarkerInsertEXT(
        VkCommandBuffer commandBuffer,
        const VkDebugMarkerMarkerInfoEXT & pMarkerInfo);


#define VK_AMD_gcn_shader 1
#define VK_AMD_GCN_SHADER_SPEC_VERSION    1
#define VK_AMD_GCN_SHADER_EXTENSION_NAME  "VK_AMD_gcn_shader"


#define VK_NV_dedicated_allocation 1
#define VK_NV_DEDICATED_ALLOCATION_SPEC_VERSION 1
#define VK_NV_DEDICATED_ALLOCATION_EXTENSION_NAME "VK_NV_dedicated_allocation"

typedef struct VkDedicatedAllocationImageCreateInfoNV {
    VkStructureType    sType;
    const void*        pNext;
    VkBool32           dedicatedAllocation;
} VkDedicatedAllocationImageCreateInfoNV;

typedef struct VkDedicatedAllocationBufferCreateInfoNV {
    VkStructureType    sType;
    const void*        pNext;
    VkBool32           dedicatedAllocation;
} VkDedicatedAllocationBufferCreateInfoNV;

typedef struct VkDedicatedAllocationMemoryAllocateInfoNV {
    VkStructureType    sType;
    const void*        pNext;
    VkImage            image;
    VkBuffer           buffer;
} VkDedicatedAllocationMemoryAllocateInfoNV;


VkDedicatedAllocationImageCreateInfoNV DedicatedAllocationImageCreateInfoNV(
    VkBool32                                    dedicatedAllocation);


VkDedicatedAllocationBufferCreateInfoNV DedicatedAllocationBufferCreateInfoNV(
    VkBool32                                    dedicatedAllocation);


VkDedicatedAllocationMemoryAllocateInfoNV DedicatedAllocationMemoryAllocateInfoNV(
    VkImage                                     image,
    VkBuffer                                    buffer);



#define VK_AMD_draw_indirect_count 1
#define VK_AMD_DRAW_INDIRECT_COUNT_SPEC_VERSION 1
#define VK_AMD_DRAW_INDIRECT_COUNT_EXTENSION_NAME "VK_AMD_draw_indirect_count"

typedef void (VKAPI_PTR *PFN_vkCmdDrawIndirectCountAMD)(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride);
typedef void (VKAPI_PTR *PFN_vkCmdDrawIndexedIndirectCountAMD)(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride);

void  cmdDrawIndirectCountAMD(
        VkCommandBuffer commandBuffer,
        VkBuffer buffer,
        VkDeviceSize offset,
        VkBuffer countBuffer,
        VkDeviceSize countBufferOffset,
        uint32_t maxDrawCount,
        uint32_t stride);

void  cmdDrawIndexedIndirectCountAMD(
        VkCommandBuffer commandBuffer,
        VkBuffer buffer,
        VkDeviceSize offset,
        VkBuffer countBuffer,
        VkDeviceSize countBufferOffset,
        uint32_t maxDrawCount,
        uint32_t stride);


#define VK_AMD_negative_viewport_height 1
#define VK_AMD_NEGATIVE_VIEWPORT_HEIGHT_SPEC_VERSION 1
#define VK_AMD_NEGATIVE_VIEWPORT_HEIGHT_EXTENSION_NAME "VK_AMD_negative_viewport_height"


#define VK_AMD_gpu_shader_half_float 1
#define VK_AMD_GPU_SHADER_HALF_FLOAT_SPEC_VERSION 1
#define VK_AMD_GPU_SHADER_HALF_FLOAT_EXTENSION_NAME "VK_AMD_gpu_shader_half_float"


#define VK_AMD_shader_ballot 1
#define VK_AMD_SHADER_BALLOT_SPEC_VERSION 1
#define VK_AMD_SHADER_BALLOT_EXTENSION_NAME "VK_AMD_shader_ballot"


#define VK_AMD_texture_gather_bias_lod 1
#define VK_AMD_TEXTURE_GATHER_BIAS_LOD_SPEC_VERSION 1
#define VK_AMD_TEXTURE_GATHER_BIAS_LOD_EXTENSION_NAME "VK_AMD_texture_gather_bias_lod"

typedef struct VkTextureLODGatherFormatPropertiesAMD {
    VkStructureType    sType;
    void*              pNext;
    VkBool32           supportsTextureGatherLODBiasAMD;
} VkTextureLODGatherFormatPropertiesAMD;


VkTextureLODGatherFormatPropertiesAMD TextureLODGatherFormatPropertiesAMD(
    VkBool32                                    supportsTextureGatherLODBiasAMD);



#define VK_AMD_shader_info 1
#define VK_AMD_SHADER_INFO_SPEC_VERSION   1
#define VK_AMD_SHADER_INFO_EXTENSION_NAME "VK_AMD_shader_info"


typedef enum VkShaderInfoTypeAMD {
    VK_SHADER_INFO_TYPE_STATISTICS_AMD = 0,
    VK_SHADER_INFO_TYPE_BINARY_AMD = 1,
    VK_SHADER_INFO_TYPE_DISASSEMBLY_AMD = 2,
    VK_SHADER_INFO_TYPE_BEGIN_RANGE_AMD = VK_SHADER_INFO_TYPE_STATISTICS_AMD,
    VK_SHADER_INFO_TYPE_END_RANGE_AMD = VK_SHADER_INFO_TYPE_DISASSEMBLY_AMD,
    VK_SHADER_INFO_TYPE_RANGE_SIZE_AMD = (VK_SHADER_INFO_TYPE_DISASSEMBLY_AMD - VK_SHADER_INFO_TYPE_STATISTICS_AMD + 1),
    VK_SHADER_INFO_TYPE_MAX_ENUM_AMD = 0x7FFFFFFF
} VkShaderInfoTypeAMD;

typedef struct VkShaderResourceUsageAMD {
    uint32_t    numUsedVgprs;
    uint32_t    numUsedSgprs;
    uint32_t    ldsSizePerLocalWorkGroup;
    size_t      ldsUsageSizeInBytes;
    size_t      scratchMemUsageInBytes;
} VkShaderResourceUsageAMD;

typedef struct VkShaderStatisticsInfoAMD {
    VkShaderStageFlags          shaderStageMask;
    VkShaderResourceUsageAMD    resourceUsage;
    uint32_t                    numPhysicalVgprs;
    uint32_t                    numPhysicalSgprs;
    uint32_t                    numAvailableVgprs;
    uint32_t                    numAvailableSgprs;
    uint32_t                    computeWorkGroupSize[3];
} VkShaderStatisticsInfoAMD;


typedef VkResult (VKAPI_PTR *PFN_vkGetShaderInfoAMD)(VkDevice device, VkPipeline pipeline, VkShaderStageFlagBits shaderStage, VkShaderInfoTypeAMD infoType, size_t* pInfoSize, void* pInfo);

VkShaderResourceUsageAMD ShaderResourceUsageAMD(
    uint32_t                                    numUsedVgprs,
    uint32_t                                    numUsedSgprs,
    uint32_t                                    ldsSizePerLocalWorkGroup,
    size_t                                      ldsUsageSizeInBytes,
    size_t                                      scratchMemUsageInBytes);


VkShaderStatisticsInfoAMD ShaderStatisticsInfoAMD(
    VkShaderStageFlags                          shaderStageMask,
    VkShaderResourceUsageAMD                    resourceUsage,
    uint32_t                                    numPhysicalVgprs,
    uint32_t                                    numPhysicalSgprs,
    uint32_t                                    numAvailableVgprs,
    uint32_t                                    numAvailableSgprs,
    uint32_t                                    computeWorkGroupSize[3]);


size_t getShaderInfoAMD(
        VkDevice device,
        VkPipeline pipeline,
        VkShaderStageFlagBits shaderStage,
        VkShaderInfoTypeAMD infoType);


#define VK_AMD_shader_image_load_store_lod 1
#define VK_AMD_SHADER_IMAGE_LOAD_STORE_LOD_SPEC_VERSION 1
#define VK_AMD_SHADER_IMAGE_LOAD_STORE_LOD_EXTENSION_NAME "VK_AMD_shader_image_load_store_lod"


#define VK_KHX_multiview 1
#define VK_KHX_MULTIVIEW_SPEC_VERSION     1
#define VK_KHX_MULTIVIEW_EXTENSION_NAME   "VK_KHX_multiview"

typedef struct VkRenderPassMultiviewCreateInfoKHX {
    VkStructureType    sType;
    const void*        pNext;
    uint32_t           subpassCount;
    const uint32_t*    pViewMasks;
    uint32_t           dependencyCount;
    const int32_t*     pViewOffsets;
    uint32_t           correlationMaskCount;
    const uint32_t*    pCorrelationMasks;
} VkRenderPassMultiviewCreateInfoKHX;

struct VkRenderPassMultiviewCreateInfoKHXRAII {
   VkRenderPassMultiviewCreateInfoKHX nonRaiiObj;
    std::vector<uint32_t>                       vecViewMasks;
    std::vector<int32_t>                        vecViewOffsets;
    std::vector<uint32_t>                       vecCorrelationMasks;
};

typedef struct VkPhysicalDeviceMultiviewFeaturesKHX {
    VkStructureType    sType;
    void*              pNext;
    VkBool32           multiview;
    VkBool32           multiviewGeometryShader;
    VkBool32           multiviewTessellationShader;
} VkPhysicalDeviceMultiviewFeaturesKHX;

typedef struct VkPhysicalDeviceMultiviewPropertiesKHX {
    VkStructureType    sType;
    void*              pNext;
    uint32_t           maxMultiviewViewCount;
    uint32_t           maxMultiviewInstanceIndex;
} VkPhysicalDeviceMultiviewPropertiesKHX;


std::shared_ptr<VkRenderPassMultiviewCreateInfoKHXRAII> RenderPassMultiviewCreateInfoKHX(
    unsigned int* pViewMasks_in_array1, int pViewMasks_dim1,
    int* pViewOffsets_in_array1, int pViewOffsets_dim1,
    unsigned int* pCorrelationMasks_in_array1, int pCorrelationMasks_dim1);


VkPhysicalDeviceMultiviewFeaturesKHX PhysicalDeviceMultiviewFeaturesKHX(
    VkBool32                                    multiview,
    VkBool32                                    multiviewGeometryShader,
    VkBool32                                    multiviewTessellationShader);


VkPhysicalDeviceMultiviewPropertiesKHX PhysicalDeviceMultiviewPropertiesKHX(
    uint32_t                                    maxMultiviewViewCount,
    uint32_t                                    maxMultiviewInstanceIndex);



#define VK_IMG_format_pvrtc 1
#define VK_IMG_FORMAT_PVRTC_SPEC_VERSION  1
#define VK_IMG_FORMAT_PVRTC_EXTENSION_NAME "VK_IMG_format_pvrtc"


#define VK_NV_external_memory_capabilities 1
#define VK_NV_EXTERNAL_MEMORY_CAPABILITIES_SPEC_VERSION 1
#define VK_NV_EXTERNAL_MEMORY_CAPABILITIES_EXTENSION_NAME "VK_NV_external_memory_capabilities"


typedef enum VkExternalMemoryHandleTypeFlagBitsNV {
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_NV = 0x00000001,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_NV = 0x00000002,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_BIT_NV = 0x00000004,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_KMT_BIT_NV = 0x00000008,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_FLAG_BITS_MAX_ENUM_NV = 0x7FFFFFFF
} VkExternalMemoryHandleTypeFlagBitsNV;
typedef VkFlags VkExternalMemoryHandleTypeFlagsNV;

typedef enum VkExternalMemoryFeatureFlagBitsNV {
    VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_NV = 0x00000001,
    VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_NV = 0x00000002,
    VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_NV = 0x00000004,
    VK_EXTERNAL_MEMORY_FEATURE_FLAG_BITS_MAX_ENUM_NV = 0x7FFFFFFF
} VkExternalMemoryFeatureFlagBitsNV;
typedef VkFlags VkExternalMemoryFeatureFlagsNV;

typedef struct VkExternalImageFormatPropertiesNV {
    VkImageFormatProperties              imageFormatProperties;
    VkExternalMemoryFeatureFlagsNV       externalMemoryFeatures;
    VkExternalMemoryHandleTypeFlagsNV    exportFromImportedHandleTypes;
    VkExternalMemoryHandleTypeFlagsNV    compatibleHandleTypes;
} VkExternalImageFormatPropertiesNV;


typedef VkResult (VKAPI_PTR *PFN_vkGetPhysicalDeviceExternalImageFormatPropertiesNV)(VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type, VkImageTiling tiling, VkImageUsageFlags usage, VkImageCreateFlags flags, VkExternalMemoryHandleTypeFlagsNV externalHandleType, VkExternalImageFormatPropertiesNV* pExternalImageFormatProperties);

VkExternalImageFormatPropertiesNV ExternalImageFormatPropertiesNV(
    VkImageFormatProperties                     imageFormatProperties,
    VkExternalMemoryFeatureFlagsNV              externalMemoryFeatures,
    VkExternalMemoryHandleTypeFlagsNV           exportFromImportedHandleTypes,
    VkExternalMemoryHandleTypeFlagsNV           compatibleHandleTypes);


VkExternalImageFormatPropertiesNV getPhysicalDeviceExternalImageFormatPropertiesNV(
        VkPhysicalDevice physicalDevice,
        VkFormat format,
        VkImageType type,
        VkImageTiling tiling,
        VkImageUsageFlags usage,
        VkImageCreateFlags flags,
        VkExternalMemoryHandleTypeFlagsNV externalHandleType);


#define VK_NV_external_memory 1
#define VK_NV_EXTERNAL_MEMORY_SPEC_VERSION 1
#define VK_NV_EXTERNAL_MEMORY_EXTENSION_NAME "VK_NV_external_memory"

typedef struct VkExternalMemoryImageCreateInfoNV {
    VkStructureType                      sType;
    const void*                          pNext;
    VkExternalMemoryHandleTypeFlagsNV    handleTypes;
} VkExternalMemoryImageCreateInfoNV;

typedef struct VkExportMemoryAllocateInfoNV {
    VkStructureType                      sType;
    const void*                          pNext;
    VkExternalMemoryHandleTypeFlagsNV    handleTypes;
} VkExportMemoryAllocateInfoNV;


VkExternalMemoryImageCreateInfoNV ExternalMemoryImageCreateInfoNV(
    VkExternalMemoryHandleTypeFlagsNV           handleTypes);


VkExportMemoryAllocateInfoNV ExportMemoryAllocateInfoNV(
    VkExternalMemoryHandleTypeFlagsNV           handleTypes);



#ifdef VK_USE_PLATFORM_WIN32_KHR
#define VK_NV_external_memory_win32 1
#define VK_NV_EXTERNAL_MEMORY_WIN32_SPEC_VERSION 1
#define VK_NV_EXTERNAL_MEMORY_WIN32_EXTENSION_NAME "VK_NV_external_memory_win32"

typedef struct VkImportMemoryWin32HandleInfoNV {
    VkStructureType                      sType;
    const void*                          pNext;
    VkExternalMemoryHandleTypeFlagsNV    handleType;
    HANDLE                               handle;
} VkImportMemoryWin32HandleInfoNV;

typedef struct VkExportMemoryWin32HandleInfoNV {
    VkStructureType               sType;
    const void*                   pNext;
    const SECURITY_ATTRIBUTES*    pAttributes;
    DWORD                         dwAccess;
} VkExportMemoryWin32HandleInfoNV;

struct VkExportMemoryWin32HandleInfoNVRAII {
   VkExportMemoryWin32HandleInfoNV nonRaiiObj;
    std::shared_ptr<SECURITY_ATTRIBUTES>        pAttributes;
};


typedef VkResult (VKAPI_PTR *PFN_vkGetMemoryWin32HandleNV)(VkDevice device, VkDeviceMemory memory, VkExternalMemoryHandleTypeFlagsNV handleType, HANDLE* pHandle);

VkImportMemoryWin32HandleInfoNV ImportMemoryWin32HandleInfoNV(
    VkExternalMemoryHandleTypeFlagsNV           handleType,
    HANDLE                                      handle);


std::shared_ptr<VkExportMemoryWin32HandleInfoNVRAII> ExportMemoryWin32HandleInfoNV(
    const SECURITY_ATTRIBUTES *                 pAttributes,
    DWORD                                       dwAccess);


HANDLE getMemoryWin32HandleNV(
        VkDevice device,
        VkDeviceMemory memory,
        VkExternalMemoryHandleTypeFlagsNV handleType);

#endif /* VK_USE_PLATFORM_WIN32_KHR */

#ifdef VK_USE_PLATFORM_WIN32_KHR
#define VK_NV_win32_keyed_mutex 1
#define VK_NV_WIN32_KEYED_MUTEX_SPEC_VERSION 1
#define VK_NV_WIN32_KEYED_MUTEX_EXTENSION_NAME "VK_NV_win32_keyed_mutex"

typedef struct VkWin32KeyedMutexAcquireReleaseInfoNV {
    VkStructureType          sType;
    const void*              pNext;
    uint32_t                 acquireCount;
    const VkDeviceMemory*    pAcquireSyncs;
    const uint64_t*          pAcquireKeys;
    const uint32_t*          pAcquireTimeoutMilliseconds;
    uint32_t                 releaseCount;
    const VkDeviceMemory*    pReleaseSyncs;
    const uint64_t*          pReleaseKeys;
} VkWin32KeyedMutexAcquireReleaseInfoNV;

struct VkWin32KeyedMutexAcquireReleaseInfoNVRAII {
   VkWin32KeyedMutexAcquireReleaseInfoNV nonRaiiObj;
    std::vector<VkDeviceMemory>                 vecAcquireSyncs;
    std::vector<uint64_t>                       vecAcquireKeys;
    std::vector<uint32_t>                       vecAcquireTimeoutMilliseconds;
    std::vector<VkDeviceMemory>                 vecReleaseSyncs;
    std::vector<uint64_t>                       vecReleaseKeys;
};


std::shared_ptr<VkWin32KeyedMutexAcquireReleaseInfoNVRAII> Win32KeyedMutexAcquireReleaseInfoNV(
    const std::vector<VkDeviceMemory> &         vecAcquireSyncs,
    const std::vector<uint64_t> &               vecAcquireKeys,
    unsigned int* pAcquireTimeoutMilliseconds_in_array1, int pAcquireTimeoutMilliseconds_dim1,
    const std::vector<VkDeviceMemory> &         vecReleaseSyncs,
    const std::vector<uint64_t> &               vecReleaseKeys);


#endif /* VK_USE_PLATFORM_WIN32_KHR */

#define VK_KHX_device_group 1
#define VK_KHX_DEVICE_GROUP_SPEC_VERSION  2
#define VK_KHX_DEVICE_GROUP_EXTENSION_NAME "VK_KHX_device_group"
#define VK_MAX_DEVICE_GROUP_SIZE_KHX      32


typedef enum VkPeerMemoryFeatureFlagBitsKHX {
    VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT_KHX = 0x00000001,
    VK_PEER_MEMORY_FEATURE_COPY_DST_BIT_KHX = 0x00000002,
    VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT_KHX = 0x00000004,
    VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT_KHX = 0x00000008,
    VK_PEER_MEMORY_FEATURE_FLAG_BITS_MAX_ENUM_KHX = 0x7FFFFFFF
} VkPeerMemoryFeatureFlagBitsKHX;
typedef VkFlags VkPeerMemoryFeatureFlagsKHX;

typedef enum VkMemoryAllocateFlagBitsKHX {
    VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT_KHX = 0x00000001,
    VK_MEMORY_ALLOCATE_FLAG_BITS_MAX_ENUM_KHX = 0x7FFFFFFF
} VkMemoryAllocateFlagBitsKHX;
typedef VkFlags VkMemoryAllocateFlagsKHX;

typedef enum VkDeviceGroupPresentModeFlagBitsKHX {
    VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHX = 0x00000001,
    VK_DEVICE_GROUP_PRESENT_MODE_REMOTE_BIT_KHX = 0x00000002,
    VK_DEVICE_GROUP_PRESENT_MODE_SUM_BIT_KHX = 0x00000004,
    VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_MULTI_DEVICE_BIT_KHX = 0x00000008,
    VK_DEVICE_GROUP_PRESENT_MODE_FLAG_BITS_MAX_ENUM_KHX = 0x7FFFFFFF
} VkDeviceGroupPresentModeFlagBitsKHX;
typedef VkFlags VkDeviceGroupPresentModeFlagsKHX;

typedef struct VkMemoryAllocateFlagsInfoKHX {
    VkStructureType             sType;
    const void*                 pNext;
    VkMemoryAllocateFlagsKHX    flags;
    uint32_t                    deviceMask;
} VkMemoryAllocateFlagsInfoKHX;

typedef struct VkDeviceGroupRenderPassBeginInfoKHX {
    VkStructureType    sType;
    const void*        pNext;
    uint32_t           deviceMask;
    uint32_t           deviceRenderAreaCount;
    const VkRect2D*    pDeviceRenderAreas;
} VkDeviceGroupRenderPassBeginInfoKHX;

struct VkDeviceGroupRenderPassBeginInfoKHXRAII {
   VkDeviceGroupRenderPassBeginInfoKHX nonRaiiObj;
    std::vector<VkRect2D>                       vecDeviceRenderAreas;
};

typedef struct VkDeviceGroupCommandBufferBeginInfoKHX {
    VkStructureType    sType;
    const void*        pNext;
    uint32_t           deviceMask;
} VkDeviceGroupCommandBufferBeginInfoKHX;

typedef struct VkDeviceGroupSubmitInfoKHX {
    VkStructureType    sType;
    const void*        pNext;
    uint32_t           waitSemaphoreCount;
    const uint32_t*    pWaitSemaphoreDeviceIndices;
    uint32_t           commandBufferCount;
    const uint32_t*    pCommandBufferDeviceMasks;
    uint32_t           signalSemaphoreCount;
    const uint32_t*    pSignalSemaphoreDeviceIndices;
} VkDeviceGroupSubmitInfoKHX;

struct VkDeviceGroupSubmitInfoKHXRAII {
   VkDeviceGroupSubmitInfoKHX nonRaiiObj;
    std::vector<uint32_t>                       vecWaitSemaphoreDeviceIndices;
    std::vector<uint32_t>                       vecCommandBufferDeviceMasks;
    std::vector<uint32_t>                       vecSignalSemaphoreDeviceIndices;
};

typedef struct VkDeviceGroupBindSparseInfoKHX {
    VkStructureType    sType;
    const void*        pNext;
    uint32_t           resourceDeviceIndex;
    uint32_t           memoryDeviceIndex;
} VkDeviceGroupBindSparseInfoKHX;

typedef struct VkBindBufferMemoryDeviceGroupInfoKHX {
    VkStructureType    sType;
    const void*        pNext;
    uint32_t           deviceIndexCount;
    const uint32_t*    pDeviceIndices;
} VkBindBufferMemoryDeviceGroupInfoKHX;

struct VkBindBufferMemoryDeviceGroupInfoKHXRAII {
   VkBindBufferMemoryDeviceGroupInfoKHX nonRaiiObj;
    std::vector<uint32_t>                       vecDeviceIndices;
};

typedef struct VkBindImageMemoryDeviceGroupInfoKHX {
    VkStructureType    sType;
    const void*        pNext;
    uint32_t           deviceIndexCount;
    const uint32_t*    pDeviceIndices;
    uint32_t           SFRRectCount;
    const VkRect2D*    pSFRRects;
} VkBindImageMemoryDeviceGroupInfoKHX;

struct VkBindImageMemoryDeviceGroupInfoKHXRAII {
   VkBindImageMemoryDeviceGroupInfoKHX nonRaiiObj;
    std::vector<uint32_t>                       vecDeviceIndices;
    std::vector<VkRect2D>                       vecSFRRects;
};

typedef struct VkDeviceGroupPresentCapabilitiesKHX {
    VkStructureType                     sType;
    const void*                         pNext;
    uint32_t                            presentMask[VK_MAX_DEVICE_GROUP_SIZE_KHX];
    VkDeviceGroupPresentModeFlagsKHX    modes;
} VkDeviceGroupPresentCapabilitiesKHX;

typedef struct VkImageSwapchainCreateInfoKHX {
    VkStructureType    sType;
    const void*        pNext;
    VkSwapchainKHR     swapchain;
} VkImageSwapchainCreateInfoKHX;

typedef struct VkBindImageMemorySwapchainInfoKHX {
    VkStructureType    sType;
    const void*        pNext;
    VkSwapchainKHR     swapchain;
    uint32_t           imageIndex;
} VkBindImageMemorySwapchainInfoKHX;

typedef struct VkAcquireNextImageInfoKHX {
    VkStructureType    sType;
    const void*        pNext;
    VkSwapchainKHR     swapchain;
    uint64_t           timeout;
    VkSemaphore        semaphore;
    VkFence            fence;
    uint32_t           deviceMask;
} VkAcquireNextImageInfoKHX;

typedef struct VkDeviceGroupPresentInfoKHX {
    VkStructureType                        sType;
    const void*                            pNext;
    uint32_t                               swapchainCount;
    const uint32_t*                        pDeviceMasks;
    VkDeviceGroupPresentModeFlagBitsKHX    mode;
} VkDeviceGroupPresentInfoKHX;

struct VkDeviceGroupPresentInfoKHXRAII {
   VkDeviceGroupPresentInfoKHX nonRaiiObj;
    std::vector<uint32_t>                       vecDeviceMasks;
};

typedef struct VkDeviceGroupSwapchainCreateInfoKHX {
    VkStructureType                     sType;
    const void*                         pNext;
    VkDeviceGroupPresentModeFlagsKHX    modes;
} VkDeviceGroupSwapchainCreateInfoKHX;


typedef void (VKAPI_PTR *PFN_vkGetDeviceGroupPeerMemoryFeaturesKHX)(VkDevice device, uint32_t heapIndex, uint32_t localDeviceIndex, uint32_t remoteDeviceIndex, VkPeerMemoryFeatureFlagsKHX* pPeerMemoryFeatures);
typedef void (VKAPI_PTR *PFN_vkCmdSetDeviceMaskKHX)(VkCommandBuffer commandBuffer, uint32_t deviceMask);
typedef void (VKAPI_PTR *PFN_vkCmdDispatchBaseKHX)(VkCommandBuffer commandBuffer, uint32_t baseGroupX, uint32_t baseGroupY, uint32_t baseGroupZ, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ);
typedef VkResult (VKAPI_PTR *PFN_vkGetDeviceGroupPresentCapabilitiesKHX)(VkDevice device, VkDeviceGroupPresentCapabilitiesKHX* pDeviceGroupPresentCapabilities);
typedef VkResult (VKAPI_PTR *PFN_vkGetDeviceGroupSurfacePresentModesKHX)(VkDevice device, VkSurfaceKHR surface, VkDeviceGroupPresentModeFlagsKHX* pModes);
typedef VkResult (VKAPI_PTR *PFN_vkGetPhysicalDevicePresentRectanglesKHX)(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, uint32_t* pRectCount, VkRect2D* pRects);
typedef VkResult (VKAPI_PTR *PFN_vkAcquireNextImage2KHX)(VkDevice device, const VkAcquireNextImageInfoKHX* pAcquireInfo, uint32_t* pImageIndex);

VkMemoryAllocateFlagsInfoKHX MemoryAllocateFlagsInfoKHX(
    VkMemoryAllocateFlagsKHX                    flags,
    uint32_t                                    deviceMask);


std::shared_ptr<VkDeviceGroupRenderPassBeginInfoKHXRAII> DeviceGroupRenderPassBeginInfoKHX(
    uint32_t                                    deviceMask,
    const std::vector<VkRect2D> &               vecDeviceRenderAreas);


VkDeviceGroupCommandBufferBeginInfoKHX DeviceGroupCommandBufferBeginInfoKHX(
    uint32_t                                    deviceMask);


std::shared_ptr<VkDeviceGroupSubmitInfoKHXRAII> DeviceGroupSubmitInfoKHX(
    unsigned int* pWaitSemaphoreDeviceIndices_in_array1, int pWaitSemaphoreDeviceIndices_dim1,
    unsigned int* pCommandBufferDeviceMasks_in_array1, int pCommandBufferDeviceMasks_dim1,
    unsigned int* pSignalSemaphoreDeviceIndices_in_array1, int pSignalSemaphoreDeviceIndices_dim1);


VkDeviceGroupBindSparseInfoKHX DeviceGroupBindSparseInfoKHX(
    uint32_t                                    resourceDeviceIndex,
    uint32_t                                    memoryDeviceIndex);


std::shared_ptr< VkPeerMemoryFeatureFlagsKHX > getDeviceGroupPeerMemoryFeaturesKHX(
        VkDevice device,
        uint32_t heapIndex,
        uint32_t localDeviceIndex,
        uint32_t remoteDeviceIndex);

void  cmdSetDeviceMaskKHX(
        VkCommandBuffer commandBuffer,
        uint32_t deviceMask);

void  cmdDispatchBaseKHX(
        VkCommandBuffer commandBuffer,
        uint32_t baseGroupX,
        uint32_t baseGroupY,
        uint32_t baseGroupZ,
        uint32_t groupCountX,
        uint32_t groupCountY,
        uint32_t groupCountZ);

std::shared_ptr<VkBindBufferMemoryDeviceGroupInfoKHXRAII> BindBufferMemoryDeviceGroupInfoKHX(
    unsigned int* pDeviceIndices_in_array1, int pDeviceIndices_dim1);


std::shared_ptr<VkBindImageMemoryDeviceGroupInfoKHXRAII> BindImageMemoryDeviceGroupInfoKHX(
    unsigned int* pDeviceIndices_in_array1, int pDeviceIndices_dim1,
    const std::vector<VkRect2D> &               vecSFRRects);


VkDeviceGroupPresentCapabilitiesKHX DeviceGroupPresentCapabilitiesKHX(
    uint32_t                                    presentMask[VK_MAX_DEVICE_GROUP_SIZE_KHX],
    VkDeviceGroupPresentModeFlagsKHX            modes);


VkDeviceGroupPresentCapabilitiesKHX getDeviceGroupPresentCapabilitiesKHX(
        VkDevice device);

std::shared_ptr< VkDeviceGroupPresentModeFlagsKHX > getDeviceGroupSurfacePresentModesKHX(
        VkDevice device,
        VkSurfaceKHR surface);

std::vector< VkRect2D > getPhysicalDevicePresentRectanglesKHX(
        VkPhysicalDevice physicalDevice,
        VkSurfaceKHR surface);

VkImageSwapchainCreateInfoKHX ImageSwapchainCreateInfoKHX(
    VkSwapchainKHR                              swapchain);


VkBindImageMemorySwapchainInfoKHX BindImageMemorySwapchainInfoKHX(
    VkSwapchainKHR                              swapchain,
    uint32_t                                    imageIndex);


VkAcquireNextImageInfoKHX AcquireNextImageInfoKHX(
    VkSwapchainKHR                              swapchain,
    uint64_t                                    timeout,
    VkSemaphore                                 semaphore,
    VkFence                                     fence,
    uint32_t                                    deviceMask);


std::shared_ptr<VkDeviceGroupPresentInfoKHXRAII> DeviceGroupPresentInfoKHX(
    unsigned int* pDeviceMasks_in_array1, int pDeviceMasks_dim1,
    VkDeviceGroupPresentModeFlagBitsKHX         mode);


VkDeviceGroupSwapchainCreateInfoKHX DeviceGroupSwapchainCreateInfoKHX(
    VkDeviceGroupPresentModeFlagsKHX            modes);


uint32_t acquireNextImage2KHX(
        VkDevice device,
        const VkAcquireNextImageInfoKHX & pAcquireInfo);


#define VK_EXT_validation_flags 1
#define VK_EXT_VALIDATION_FLAGS_SPEC_VERSION 1
#define VK_EXT_VALIDATION_FLAGS_EXTENSION_NAME "VK_EXT_validation_flags"


typedef enum VkValidationCheckEXT {
    VK_VALIDATION_CHECK_ALL_EXT = 0,
    VK_VALIDATION_CHECK_SHADERS_EXT = 1,
    VK_VALIDATION_CHECK_BEGIN_RANGE_EXT = VK_VALIDATION_CHECK_ALL_EXT,
    VK_VALIDATION_CHECK_END_RANGE_EXT = VK_VALIDATION_CHECK_SHADERS_EXT,
    VK_VALIDATION_CHECK_RANGE_SIZE_EXT = (VK_VALIDATION_CHECK_SHADERS_EXT - VK_VALIDATION_CHECK_ALL_EXT + 1),
    VK_VALIDATION_CHECK_MAX_ENUM_EXT = 0x7FFFFFFF
} VkValidationCheckEXT;

typedef struct VkValidationFlagsEXT {
    VkStructureType          sType;
    const void*              pNext;
    uint32_t                 disabledValidationCheckCount;
    VkValidationCheckEXT*    pDisabledValidationChecks;
} VkValidationFlagsEXT;

struct VkValidationFlagsEXTRAII {
   VkValidationFlagsEXT nonRaiiObj;
    std::vector<VkValidationCheckEXT>           vecDisabledValidationChecks;
};


std::shared_ptr<VkValidationFlagsEXTRAII> ValidationFlagsEXT(
    const std::vector<VkValidationCheckEXT> &   vecDisabledValidationChecks);



#ifdef VK_USE_PLATFORM_VI_NN
#define VK_NN_vi_surface 1
#define VK_NN_VI_SURFACE_SPEC_VERSION     1
#define VK_NN_VI_SURFACE_EXTENSION_NAME   "VK_NN_vi_surface"

typedef VkFlags VkViSurfaceCreateFlagsNN;

typedef struct VkViSurfaceCreateInfoNN {
    VkStructureType             sType;
    const void*                 pNext;
    VkViSurfaceCreateFlagsNN    flags;
    void*                       window;
} VkViSurfaceCreateInfoNN;


typedef VkResult (VKAPI_PTR *PFN_vkCreateViSurfaceNN)(VkInstance instance, const VkViSurfaceCreateInfoNN* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface);

VkViSurfaceCreateInfoNN ViSurfaceCreateInfoNN(
    VkViSurfaceCreateFlagsNN                    flags);


std::shared_ptr<VkSurfaceKHR_T> createViSurfaceNN(
        VkInstance instance,
        const VkViSurfaceCreateInfoNN & pCreateInfo);

#endif /* VK_USE_PLATFORM_VI_NN */

#define VK_EXT_shader_subgroup_ballot 1
#define VK_EXT_SHADER_SUBGROUP_BALLOT_SPEC_VERSION 1
#define VK_EXT_SHADER_SUBGROUP_BALLOT_EXTENSION_NAME "VK_EXT_shader_subgroup_ballot"


#define VK_EXT_shader_subgroup_vote 1
#define VK_EXT_SHADER_SUBGROUP_VOTE_SPEC_VERSION 1
#define VK_EXT_SHADER_SUBGROUP_VOTE_EXTENSION_NAME "VK_EXT_shader_subgroup_vote"


#define VK_KHX_device_group_creation 1
#define VK_KHX_DEVICE_GROUP_CREATION_SPEC_VERSION 1
#define VK_KHX_DEVICE_GROUP_CREATION_EXTENSION_NAME "VK_KHX_device_group_creation"

typedef struct VkPhysicalDeviceGroupPropertiesKHX {
    VkStructureType     sType;
    void*               pNext;
    uint32_t            physicalDeviceCount;
    VkPhysicalDevice    physicalDevices[VK_MAX_DEVICE_GROUP_SIZE_KHX];
    VkBool32            subsetAllocation;
} VkPhysicalDeviceGroupPropertiesKHX;

typedef struct VkDeviceGroupDeviceCreateInfoKHX {
    VkStructureType            sType;
    const void*                pNext;
    uint32_t                   physicalDeviceCount;
    const VkPhysicalDevice*    pPhysicalDevices;
} VkDeviceGroupDeviceCreateInfoKHX;

struct VkDeviceGroupDeviceCreateInfoKHXRAII {
   VkDeviceGroupDeviceCreateInfoKHX nonRaiiObj;
    std::vector<VkPhysicalDevice>               vecPhysicalDevices;
};


typedef VkResult (VKAPI_PTR *PFN_vkEnumeratePhysicalDeviceGroupsKHX)(VkInstance instance, uint32_t* pPhysicalDeviceGroupCount, VkPhysicalDeviceGroupPropertiesKHX* pPhysicalDeviceGroupProperties);

VkPhysicalDeviceGroupPropertiesKHX PhysicalDeviceGroupPropertiesKHX(
    uint32_t                                    physicalDeviceCount,
    VkPhysicalDevice                            physicalDevices[VK_MAX_DEVICE_GROUP_SIZE_KHX],
    VkBool32                                    subsetAllocation);


std::shared_ptr<VkDeviceGroupDeviceCreateInfoKHXRAII> DeviceGroupDeviceCreateInfoKHX(
    const std::vector<VkPhysicalDevice> &       vecPhysicalDevices);


std::vector< VkPhysicalDeviceGroupPropertiesKHX > enumeratePhysicalDeviceGroupsKHX(
        VkInstance instance);


#define VK_NVX_device_generated_commands 1
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkObjectTableNVX)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkIndirectCommandsLayoutNVX)

#define VK_NVX_DEVICE_GENERATED_COMMANDS_SPEC_VERSION 3
#define VK_NVX_DEVICE_GENERATED_COMMANDS_EXTENSION_NAME "VK_NVX_device_generated_commands"


typedef enum VkIndirectCommandsTokenTypeNVX {
    VK_INDIRECT_COMMANDS_TOKEN_TYPE_PIPELINE_NVX = 0,
    VK_INDIRECT_COMMANDS_TOKEN_TYPE_DESCRIPTOR_SET_NVX = 1,
    VK_INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_NVX = 2,
    VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_NVX = 3,
    VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_NVX = 4,
    VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_NVX = 5,
    VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_NVX = 6,
    VK_INDIRECT_COMMANDS_TOKEN_TYPE_DISPATCH_NVX = 7,
    VK_INDIRECT_COMMANDS_TOKEN_TYPE_BEGIN_RANGE_NVX = VK_INDIRECT_COMMANDS_TOKEN_TYPE_PIPELINE_NVX,
    VK_INDIRECT_COMMANDS_TOKEN_TYPE_END_RANGE_NVX = VK_INDIRECT_COMMANDS_TOKEN_TYPE_DISPATCH_NVX,
    VK_INDIRECT_COMMANDS_TOKEN_TYPE_RANGE_SIZE_NVX = (VK_INDIRECT_COMMANDS_TOKEN_TYPE_DISPATCH_NVX - VK_INDIRECT_COMMANDS_TOKEN_TYPE_PIPELINE_NVX + 1),
    VK_INDIRECT_COMMANDS_TOKEN_TYPE_MAX_ENUM_NVX = 0x7FFFFFFF
} VkIndirectCommandsTokenTypeNVX;

typedef enum VkObjectEntryTypeNVX {
    VK_OBJECT_ENTRY_TYPE_DESCRIPTOR_SET_NVX = 0,
    VK_OBJECT_ENTRY_TYPE_PIPELINE_NVX = 1,
    VK_OBJECT_ENTRY_TYPE_INDEX_BUFFER_NVX = 2,
    VK_OBJECT_ENTRY_TYPE_VERTEX_BUFFER_NVX = 3,
    VK_OBJECT_ENTRY_TYPE_PUSH_CONSTANT_NVX = 4,
    VK_OBJECT_ENTRY_TYPE_BEGIN_RANGE_NVX = VK_OBJECT_ENTRY_TYPE_DESCRIPTOR_SET_NVX,
    VK_OBJECT_ENTRY_TYPE_END_RANGE_NVX = VK_OBJECT_ENTRY_TYPE_PUSH_CONSTANT_NVX,
    VK_OBJECT_ENTRY_TYPE_RANGE_SIZE_NVX = (VK_OBJECT_ENTRY_TYPE_PUSH_CONSTANT_NVX - VK_OBJECT_ENTRY_TYPE_DESCRIPTOR_SET_NVX + 1),
    VK_OBJECT_ENTRY_TYPE_MAX_ENUM_NVX = 0x7FFFFFFF
} VkObjectEntryTypeNVX;


typedef enum VkIndirectCommandsLayoutUsageFlagBitsNVX {
    VK_INDIRECT_COMMANDS_LAYOUT_USAGE_UNORDERED_SEQUENCES_BIT_NVX = 0x00000001,
    VK_INDIRECT_COMMANDS_LAYOUT_USAGE_SPARSE_SEQUENCES_BIT_NVX = 0x00000002,
    VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EMPTY_EXECUTIONS_BIT_NVX = 0x00000004,
    VK_INDIRECT_COMMANDS_LAYOUT_USAGE_INDEXED_SEQUENCES_BIT_NVX = 0x00000008,
    VK_INDIRECT_COMMANDS_LAYOUT_USAGE_FLAG_BITS_MAX_ENUM_NVX = 0x7FFFFFFF
} VkIndirectCommandsLayoutUsageFlagBitsNVX;
typedef VkFlags VkIndirectCommandsLayoutUsageFlagsNVX;

typedef enum VkObjectEntryUsageFlagBitsNVX {
    VK_OBJECT_ENTRY_USAGE_GRAPHICS_BIT_NVX = 0x00000001,
    VK_OBJECT_ENTRY_USAGE_COMPUTE_BIT_NVX = 0x00000002,
    VK_OBJECT_ENTRY_USAGE_FLAG_BITS_MAX_ENUM_NVX = 0x7FFFFFFF
} VkObjectEntryUsageFlagBitsNVX;
typedef VkFlags VkObjectEntryUsageFlagsNVX;

typedef struct VkDeviceGeneratedCommandsFeaturesNVX {
    VkStructureType    sType;
    const void*        pNext;
    VkBool32           computeBindingPointSupport;
} VkDeviceGeneratedCommandsFeaturesNVX;

typedef struct VkDeviceGeneratedCommandsLimitsNVX {
    VkStructureType    sType;
    const void*        pNext;
    uint32_t           maxIndirectCommandsLayoutTokenCount;
    uint32_t           maxObjectEntryCounts;
    uint32_t           minSequenceCountBufferOffsetAlignment;
    uint32_t           minSequenceIndexBufferOffsetAlignment;
    uint32_t           minCommandsTokenBufferOffsetAlignment;
} VkDeviceGeneratedCommandsLimitsNVX;

typedef struct VkIndirectCommandsTokenNVX {
    VkIndirectCommandsTokenTypeNVX    tokenType;
    VkBuffer                          buffer;
    VkDeviceSize                      offset;
} VkIndirectCommandsTokenNVX;

typedef struct VkIndirectCommandsLayoutTokenNVX {
    VkIndirectCommandsTokenTypeNVX    tokenType;
    uint32_t                          bindingUnit;
    uint32_t                          dynamicCount;
    uint32_t                          divisor;
} VkIndirectCommandsLayoutTokenNVX;

typedef struct VkIndirectCommandsLayoutCreateInfoNVX {
    VkStructureType                            sType;
    const void*                                pNext;
    VkPipelineBindPoint                        pipelineBindPoint;
    VkIndirectCommandsLayoutUsageFlagsNVX      flags;
    uint32_t                                   tokenCount;
    const VkIndirectCommandsLayoutTokenNVX*    pTokens;
} VkIndirectCommandsLayoutCreateInfoNVX;

struct VkIndirectCommandsLayoutCreateInfoNVXRAII {
   VkIndirectCommandsLayoutCreateInfoNVX nonRaiiObj;
    std::vector<VkIndirectCommandsLayoutTokenNVX>vecTokens;
};

typedef struct VkCmdProcessCommandsInfoNVX {
    VkStructureType                      sType;
    const void*                          pNext;
    VkObjectTableNVX                     objectTable;
    VkIndirectCommandsLayoutNVX          indirectCommandsLayout;
    uint32_t                             indirectCommandsTokenCount;
    const VkIndirectCommandsTokenNVX*    pIndirectCommandsTokens;
    uint32_t                             maxSequencesCount;
    VkCommandBuffer                      targetCommandBuffer;
    VkBuffer                             sequencesCountBuffer;
    VkDeviceSize                         sequencesCountOffset;
    VkBuffer                             sequencesIndexBuffer;
    VkDeviceSize                         sequencesIndexOffset;
} VkCmdProcessCommandsInfoNVX;

struct VkCmdProcessCommandsInfoNVXRAII {
   VkCmdProcessCommandsInfoNVX nonRaiiObj;
    std::vector<VkIndirectCommandsTokenNVX>     vecIndirectCommandsTokens;
};

typedef struct VkCmdReserveSpaceForCommandsInfoNVX {
    VkStructureType                sType;
    const void*                    pNext;
    VkObjectTableNVX               objectTable;
    VkIndirectCommandsLayoutNVX    indirectCommandsLayout;
    uint32_t                       maxSequencesCount;
} VkCmdReserveSpaceForCommandsInfoNVX;

typedef struct VkObjectTableCreateInfoNVX {
    VkStructureType                      sType;
    const void*                          pNext;
    uint32_t                             objectCount;
    const VkObjectEntryTypeNVX*          pObjectEntryTypes;
    const uint32_t*                      pObjectEntryCounts;
    const VkObjectEntryUsageFlagsNVX*    pObjectEntryUsageFlags;
    uint32_t                             maxUniformBuffersPerDescriptor;
    uint32_t                             maxStorageBuffersPerDescriptor;
    uint32_t                             maxStorageImagesPerDescriptor;
    uint32_t                             maxSampledImagesPerDescriptor;
    uint32_t                             maxPipelineLayouts;
} VkObjectTableCreateInfoNVX;

struct VkObjectTableCreateInfoNVXRAII {
   VkObjectTableCreateInfoNVX nonRaiiObj;
    std::vector<VkObjectEntryTypeNVX>           vecObjectEntryTypes;
    std::vector<uint32_t>                       vecObjectEntryCounts;
    std::vector<VkObjectEntryUsageFlagsNVX>     vecObjectEntryUsageFlags;
};

typedef struct VkObjectTableEntryNVX {
    VkObjectEntryTypeNVX          type;
    VkObjectEntryUsageFlagsNVX    flags;
} VkObjectTableEntryNVX;

typedef struct VkObjectTablePipelineEntryNVX {
    VkObjectEntryTypeNVX          type;
    VkObjectEntryUsageFlagsNVX    flags;
    VkPipeline                    pipeline;
} VkObjectTablePipelineEntryNVX;

typedef struct VkObjectTableDescriptorSetEntryNVX {
    VkObjectEntryTypeNVX          type;
    VkObjectEntryUsageFlagsNVX    flags;
    VkPipelineLayout              pipelineLayout;
    VkDescriptorSet               descriptorSet;
} VkObjectTableDescriptorSetEntryNVX;

typedef struct VkObjectTableVertexBufferEntryNVX {
    VkObjectEntryTypeNVX          type;
    VkObjectEntryUsageFlagsNVX    flags;
    VkBuffer                      buffer;
} VkObjectTableVertexBufferEntryNVX;

typedef struct VkObjectTableIndexBufferEntryNVX {
    VkObjectEntryTypeNVX          type;
    VkObjectEntryUsageFlagsNVX    flags;
    VkBuffer                      buffer;
    VkIndexType                   indexType;
} VkObjectTableIndexBufferEntryNVX;

typedef struct VkObjectTablePushConstantEntryNVX {
    VkObjectEntryTypeNVX          type;
    VkObjectEntryUsageFlagsNVX    flags;
    VkPipelineLayout              pipelineLayout;
    VkShaderStageFlags            stageFlags;
} VkObjectTablePushConstantEntryNVX;


typedef void (VKAPI_PTR *PFN_vkCmdProcessCommandsNVX)(VkCommandBuffer commandBuffer, const VkCmdProcessCommandsInfoNVX* pProcessCommandsInfo);
typedef void (VKAPI_PTR *PFN_vkCmdReserveSpaceForCommandsNVX)(VkCommandBuffer commandBuffer, const VkCmdReserveSpaceForCommandsInfoNVX* pReserveSpaceInfo);
typedef VkResult (VKAPI_PTR *PFN_vkCreateIndirectCommandsLayoutNVX)(VkDevice device, const VkIndirectCommandsLayoutCreateInfoNVX* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkIndirectCommandsLayoutNVX* pIndirectCommandsLayout);
typedef void (VKAPI_PTR *PFN_vkDestroyIndirectCommandsLayoutNVX)(VkDevice device, VkIndirectCommandsLayoutNVX indirectCommandsLayout, const VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkCreateObjectTableNVX)(VkDevice device, const VkObjectTableCreateInfoNVX* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkObjectTableNVX* pObjectTable);
typedef void (VKAPI_PTR *PFN_vkDestroyObjectTableNVX)(VkDevice device, VkObjectTableNVX objectTable, const VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkUnregisterObjectsNVX)(VkDevice device, VkObjectTableNVX objectTable, uint32_t objectCount, const VkObjectEntryTypeNVX* pObjectEntryTypes, const uint32_t* pObjectIndices);
typedef void (VKAPI_PTR *PFN_vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX)(VkPhysicalDevice physicalDevice, VkDeviceGeneratedCommandsFeaturesNVX* pFeatures, VkDeviceGeneratedCommandsLimitsNVX* pLimits);

VkDeviceGeneratedCommandsFeaturesNVX DeviceGeneratedCommandsFeaturesNVX(
    VkBool32                                    computeBindingPointSupport);


VkDeviceGeneratedCommandsLimitsNVX DeviceGeneratedCommandsLimitsNVX(
    uint32_t                                    maxIndirectCommandsLayoutTokenCount,
    uint32_t                                    maxObjectEntryCounts,
    uint32_t                                    minSequenceCountBufferOffsetAlignment,
    uint32_t                                    minSequenceIndexBufferOffsetAlignment,
    uint32_t                                    minCommandsTokenBufferOffsetAlignment);


VkIndirectCommandsTokenNVX IndirectCommandsTokenNVX(
    VkIndirectCommandsTokenTypeNVX              tokenType,
    VkBuffer                                    buffer,
    VkDeviceSize                                offset);


VkIndirectCommandsLayoutTokenNVX IndirectCommandsLayoutTokenNVX(
    VkIndirectCommandsTokenTypeNVX              tokenType,
    uint32_t                                    bindingUnit,
    uint32_t                                    dynamicCount,
    uint32_t                                    divisor);


std::shared_ptr<VkIndirectCommandsLayoutCreateInfoNVXRAII> IndirectCommandsLayoutCreateInfoNVX(
    VkPipelineBindPoint                         pipelineBindPoint,
    VkIndirectCommandsLayoutUsageFlagsNVX       flags,
    const std::vector<VkIndirectCommandsLayoutTokenNVX> &vecTokens);


std::shared_ptr<VkCmdProcessCommandsInfoNVXRAII> CmdProcessCommandsInfoNVX(
    VkObjectTableNVX                            objectTable,
    VkIndirectCommandsLayoutNVX                 indirectCommandsLayout,
    const std::vector<VkIndirectCommandsTokenNVX> &vecIndirectCommandsTokens,
    uint32_t                                    maxSequencesCount,
    VkCommandBuffer                             targetCommandBuffer,
    VkBuffer                                    sequencesCountBuffer,
    VkDeviceSize                                sequencesCountOffset,
    VkBuffer                                    sequencesIndexBuffer,
    VkDeviceSize                                sequencesIndexOffset);


VkCmdReserveSpaceForCommandsInfoNVX CmdReserveSpaceForCommandsInfoNVX(
    VkObjectTableNVX                            objectTable,
    VkIndirectCommandsLayoutNVX                 indirectCommandsLayout,
    uint32_t                                    maxSequencesCount);


std::shared_ptr<VkObjectTableCreateInfoNVXRAII> ObjectTableCreateInfoNVX(
    const std::vector<VkObjectEntryTypeNVX> &   vecObjectEntryTypes,
    unsigned int* pObjectEntryCounts_in_array1, int pObjectEntryCounts_dim1,
    const std::vector<VkObjectEntryUsageFlagsNVX> &vecObjectEntryUsageFlags,
    uint32_t                                    maxUniformBuffersPerDescriptor,
    uint32_t                                    maxStorageBuffersPerDescriptor,
    uint32_t                                    maxStorageImagesPerDescriptor,
    uint32_t                                    maxSampledImagesPerDescriptor,
    uint32_t                                    maxPipelineLayouts);


VkObjectTableEntryNVX ObjectTableEntryNVX(
    VkObjectEntryTypeNVX                        type,
    VkObjectEntryUsageFlagsNVX                  flags);


VkObjectTablePipelineEntryNVX ObjectTablePipelineEntryNVX(
    VkObjectEntryTypeNVX                        type,
    VkObjectEntryUsageFlagsNVX                  flags,
    VkPipeline                                  pipeline);


VkObjectTableDescriptorSetEntryNVX ObjectTableDescriptorSetEntryNVX(
    VkObjectEntryTypeNVX                        type,
    VkObjectEntryUsageFlagsNVX                  flags,
    VkPipelineLayout                            pipelineLayout,
    VkDescriptorSet                             descriptorSet);


VkObjectTableVertexBufferEntryNVX ObjectTableVertexBufferEntryNVX(
    VkObjectEntryTypeNVX                        type,
    VkObjectEntryUsageFlagsNVX                  flags,
    VkBuffer                                    buffer);


VkObjectTableIndexBufferEntryNVX ObjectTableIndexBufferEntryNVX(
    VkObjectEntryTypeNVX                        type,
    VkObjectEntryUsageFlagsNVX                  flags,
    VkBuffer                                    buffer,
    VkIndexType                                 indexType);


VkObjectTablePushConstantEntryNVX ObjectTablePushConstantEntryNVX(
    VkObjectEntryTypeNVX                        type,
    VkObjectEntryUsageFlagsNVX                  flags,
    VkPipelineLayout                            pipelineLayout,
    VkShaderStageFlags                          stageFlags);


void  cmdProcessCommandsNVX(
        VkCommandBuffer commandBuffer,
        const VkCmdProcessCommandsInfoNVX & pProcessCommandsInfo);

void  cmdReserveSpaceForCommandsNVX(
        VkCommandBuffer commandBuffer,
        const VkCmdReserveSpaceForCommandsInfoNVX & pReserveSpaceInfo);

std::shared_ptr<VkIndirectCommandsLayoutNVX_T> createIndirectCommandsLayoutNVX(
        VkDevice device,
        const VkIndirectCommandsLayoutCreateInfoNVX & pCreateInfo);

std::shared_ptr<VkObjectTableNVX_T> createObjectTableNVX(
        VkDevice device,
        const VkObjectTableCreateInfoNVX & pCreateInfo);

void  unregisterObjectsNVX(
        VkDevice device,
        VkObjectTableNVX objectTable,
        const std::vector<VkObjectEntryTypeNVX> & pObjectEntryTypes,
        unsigned int* pObjectIndices_in_array1, int pObjectIndices_dim1);

VkDeviceGeneratedCommandsFeaturesNVX getPhysicalDeviceGeneratedCommandsPropertiesNVX(
        VkPhysicalDevice physicalDevice);


#define VK_NV_clip_space_w_scaling 1
#define VK_NV_CLIP_SPACE_W_SCALING_SPEC_VERSION 1
#define VK_NV_CLIP_SPACE_W_SCALING_EXTENSION_NAME "VK_NV_clip_space_w_scaling"

typedef struct VkViewportWScalingNV {
    float    xcoeff;
    float    ycoeff;
} VkViewportWScalingNV;

typedef struct VkPipelineViewportWScalingStateCreateInfoNV {
    VkStructureType                sType;
    const void*                    pNext;
    VkBool32                       viewportWScalingEnable;
    uint32_t                       viewportCount;
    const VkViewportWScalingNV*    pViewportWScalings;
} VkPipelineViewportWScalingStateCreateInfoNV;

struct VkPipelineViewportWScalingStateCreateInfoNVRAII {
   VkPipelineViewportWScalingStateCreateInfoNV nonRaiiObj;
    std::vector<VkViewportWScalingNV>           vecViewportWScalings;
};


typedef void (VKAPI_PTR *PFN_vkCmdSetViewportWScalingNV)(VkCommandBuffer commandBuffer, uint32_t firstViewport, uint32_t viewportCount, const VkViewportWScalingNV* pViewportWScalings);

VkViewportWScalingNV ViewportWScalingNV(
    float                                       xcoeff,
    float                                       ycoeff);


std::shared_ptr<VkPipelineViewportWScalingStateCreateInfoNVRAII> PipelineViewportWScalingStateCreateInfoNV(
    VkBool32                                    viewportWScalingEnable,
    const std::vector<VkViewportWScalingNV> &   vecViewportWScalings);


void  cmdSetViewportWScalingNV(
        VkCommandBuffer commandBuffer,
        uint32_t firstViewport,
        const std::vector<VkViewportWScalingNV> & pViewportWScalings);


#define VK_EXT_direct_mode_display 1
#define VK_EXT_DIRECT_MODE_DISPLAY_SPEC_VERSION 1
#define VK_EXT_DIRECT_MODE_DISPLAY_EXTENSION_NAME "VK_EXT_direct_mode_display"

typedef VkResult (VKAPI_PTR *PFN_vkReleaseDisplayEXT)(VkPhysicalDevice physicalDevice, VkDisplayKHR display);

void  releaseDisplayEXT(
        VkPhysicalDevice physicalDevice,
        VkDisplayKHR display);


#ifdef VK_USE_PLATFORM_XLIB_XRANDR_EXT
#define VK_EXT_acquire_xlib_display 1
#include <X11/extensions/Xrandr.h>

#define VK_EXT_ACQUIRE_XLIB_DISPLAY_SPEC_VERSION 1
#define VK_EXT_ACQUIRE_XLIB_DISPLAY_EXTENSION_NAME "VK_EXT_acquire_xlib_display"

typedef VkResult (VKAPI_PTR *PFN_vkAcquireXlibDisplayEXT)(VkPhysicalDevice physicalDevice, Display* dpy, VkDisplayKHR display);
typedef VkResult (VKAPI_PTR *PFN_vkGetRandROutputDisplayEXT)(VkPhysicalDevice physicalDevice, Display* dpy, RROutput rrOutput, VkDisplayKHR* pDisplay);

Display acquireXlibDisplayEXT(
        VkPhysicalDevice physicalDevice,
        VkDisplayKHR display);

VkDisplayKHR getRandROutputDisplayEXT(
        VkPhysicalDevice physicalDevice,
        RROutput rrOutput);

#endif /* VK_USE_PLATFORM_XLIB_XRANDR_EXT */

#define VK_EXT_display_surface_counter 1
#define VK_EXT_DISPLAY_SURFACE_COUNTER_SPEC_VERSION 1
#define VK_EXT_DISPLAY_SURFACE_COUNTER_EXTENSION_NAME "VK_EXT_display_surface_counter"
#define VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES2_EXT VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT


typedef enum VkSurfaceCounterFlagBitsEXT {
    VK_SURFACE_COUNTER_VBLANK_EXT = 0x00000001,
    VK_SURFACE_COUNTER_FLAG_BITS_MAX_ENUM_EXT = 0x7FFFFFFF
} VkSurfaceCounterFlagBitsEXT;
typedef VkFlags VkSurfaceCounterFlagsEXT;

typedef struct VkSurfaceCapabilities2EXT {
    VkStructureType                  sType;
    void*                            pNext;
    uint32_t                         minImageCount;
    uint32_t                         maxImageCount;
    VkExtent2D                       currentExtent;
    VkExtent2D                       minImageExtent;
    VkExtent2D                       maxImageExtent;
    uint32_t                         maxImageArrayLayers;
    VkSurfaceTransformFlagsKHR       supportedTransforms;
    VkSurfaceTransformFlagBitsKHR    currentTransform;
    VkCompositeAlphaFlagsKHR         supportedCompositeAlpha;
    VkImageUsageFlags                supportedUsageFlags;
    VkSurfaceCounterFlagsEXT         supportedSurfaceCounters;
} VkSurfaceCapabilities2EXT;


typedef VkResult (VKAPI_PTR *PFN_vkGetPhysicalDeviceSurfaceCapabilities2EXT)(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, VkSurfaceCapabilities2EXT* pSurfaceCapabilities);

VkSurfaceCapabilities2EXT SurfaceCapabilities2EXT(
    uint32_t                                    minImageCount,
    uint32_t                                    maxImageCount,
    VkExtent2D                                  currentExtent,
    VkExtent2D                                  minImageExtent,
    VkExtent2D                                  maxImageExtent,
    uint32_t                                    maxImageArrayLayers,
    VkSurfaceTransformFlagsKHR                  supportedTransforms,
    VkSurfaceTransformFlagBitsKHR               currentTransform,
    VkCompositeAlphaFlagsKHR                    supportedCompositeAlpha,
    VkImageUsageFlags                           supportedUsageFlags,
    VkSurfaceCounterFlagsEXT                    supportedSurfaceCounters);


VkSurfaceCapabilities2EXT getPhysicalDeviceSurfaceCapabilities2EXT(
        VkPhysicalDevice physicalDevice,
        VkSurfaceKHR surface);


#define VK_EXT_display_control 1
#define VK_EXT_DISPLAY_CONTROL_SPEC_VERSION 1
#define VK_EXT_DISPLAY_CONTROL_EXTENSION_NAME "VK_EXT_display_control"


typedef enum VkDisplayPowerStateEXT {
    VK_DISPLAY_POWER_STATE_OFF_EXT = 0,
    VK_DISPLAY_POWER_STATE_SUSPEND_EXT = 1,
    VK_DISPLAY_POWER_STATE_ON_EXT = 2,
    VK_DISPLAY_POWER_STATE_BEGIN_RANGE_EXT = VK_DISPLAY_POWER_STATE_OFF_EXT,
    VK_DISPLAY_POWER_STATE_END_RANGE_EXT = VK_DISPLAY_POWER_STATE_ON_EXT,
    VK_DISPLAY_POWER_STATE_RANGE_SIZE_EXT = (VK_DISPLAY_POWER_STATE_ON_EXT - VK_DISPLAY_POWER_STATE_OFF_EXT + 1),
    VK_DISPLAY_POWER_STATE_MAX_ENUM_EXT = 0x7FFFFFFF
} VkDisplayPowerStateEXT;

typedef enum VkDeviceEventTypeEXT {
    VK_DEVICE_EVENT_TYPE_DISPLAY_HOTPLUG_EXT = 0,
    VK_DEVICE_EVENT_TYPE_BEGIN_RANGE_EXT = VK_DEVICE_EVENT_TYPE_DISPLAY_HOTPLUG_EXT,
    VK_DEVICE_EVENT_TYPE_END_RANGE_EXT = VK_DEVICE_EVENT_TYPE_DISPLAY_HOTPLUG_EXT,
    VK_DEVICE_EVENT_TYPE_RANGE_SIZE_EXT = (VK_DEVICE_EVENT_TYPE_DISPLAY_HOTPLUG_EXT - VK_DEVICE_EVENT_TYPE_DISPLAY_HOTPLUG_EXT + 1),
    VK_DEVICE_EVENT_TYPE_MAX_ENUM_EXT = 0x7FFFFFFF
} VkDeviceEventTypeEXT;

typedef enum VkDisplayEventTypeEXT {
    VK_DISPLAY_EVENT_TYPE_FIRST_PIXEL_OUT_EXT = 0,
    VK_DISPLAY_EVENT_TYPE_BEGIN_RANGE_EXT = VK_DISPLAY_EVENT_TYPE_FIRST_PIXEL_OUT_EXT,
    VK_DISPLAY_EVENT_TYPE_END_RANGE_EXT = VK_DISPLAY_EVENT_TYPE_FIRST_PIXEL_OUT_EXT,
    VK_DISPLAY_EVENT_TYPE_RANGE_SIZE_EXT = (VK_DISPLAY_EVENT_TYPE_FIRST_PIXEL_OUT_EXT - VK_DISPLAY_EVENT_TYPE_FIRST_PIXEL_OUT_EXT + 1),
    VK_DISPLAY_EVENT_TYPE_MAX_ENUM_EXT = 0x7FFFFFFF
} VkDisplayEventTypeEXT;

typedef struct VkDisplayPowerInfoEXT {
    VkStructureType           sType;
    const void*               pNext;
    VkDisplayPowerStateEXT    powerState;
} VkDisplayPowerInfoEXT;

typedef struct VkDeviceEventInfoEXT {
    VkStructureType         sType;
    const void*             pNext;
    VkDeviceEventTypeEXT    deviceEvent;
} VkDeviceEventInfoEXT;

typedef struct VkDisplayEventInfoEXT {
    VkStructureType          sType;
    const void*              pNext;
    VkDisplayEventTypeEXT    displayEvent;
} VkDisplayEventInfoEXT;

typedef struct VkSwapchainCounterCreateInfoEXT {
    VkStructureType             sType;
    const void*                 pNext;
    VkSurfaceCounterFlagsEXT    surfaceCounters;
} VkSwapchainCounterCreateInfoEXT;


typedef VkResult (VKAPI_PTR *PFN_vkDisplayPowerControlEXT)(VkDevice device, VkDisplayKHR display, const VkDisplayPowerInfoEXT* pDisplayPowerInfo);
typedef VkResult (VKAPI_PTR *PFN_vkRegisterDeviceEventEXT)(VkDevice device, const VkDeviceEventInfoEXT* pDeviceEventInfo, const VkAllocationCallbacks* pAllocator, VkFence* pFence);
typedef VkResult (VKAPI_PTR *PFN_vkRegisterDisplayEventEXT)(VkDevice device, VkDisplayKHR display, const VkDisplayEventInfoEXT* pDisplayEventInfo, const VkAllocationCallbacks* pAllocator, VkFence* pFence);
typedef VkResult (VKAPI_PTR *PFN_vkGetSwapchainCounterEXT)(VkDevice device, VkSwapchainKHR swapchain, VkSurfaceCounterFlagBitsEXT counter, uint64_t* pCounterValue);

VkDisplayPowerInfoEXT DisplayPowerInfoEXT(
    VkDisplayPowerStateEXT                      powerState);


VkDeviceEventInfoEXT DeviceEventInfoEXT(
    VkDeviceEventTypeEXT                        deviceEvent);


VkDisplayEventInfoEXT DisplayEventInfoEXT(
    VkDisplayEventTypeEXT                       displayEvent);


VkSwapchainCounterCreateInfoEXT SwapchainCounterCreateInfoEXT(
    VkSurfaceCounterFlagsEXT                    surfaceCounters);


void  displayPowerControlEXT(
        VkDevice device,
        VkDisplayKHR display,
        const VkDisplayPowerInfoEXT & pDisplayPowerInfo);

std::shared_ptr<VkFence_T> registerDeviceEventEXT(
        VkDevice device,
        const VkDeviceEventInfoEXT & pDeviceEventInfo);

std::shared_ptr<VkFence_T> registerDisplayEventEXT(
        VkDevice device,
        VkDisplayKHR display,
        const VkDisplayEventInfoEXT & pDisplayEventInfo);

uint64_t getSwapchainCounterEXT(
        VkDevice device,
        VkSwapchainKHR swapchain,
        VkSurfaceCounterFlagBitsEXT counter);


#define VK_GOOGLE_display_timing 1
#define VK_GOOGLE_DISPLAY_TIMING_SPEC_VERSION 1
#define VK_GOOGLE_DISPLAY_TIMING_EXTENSION_NAME "VK_GOOGLE_display_timing"

typedef struct VkRefreshCycleDurationGOOGLE {
    uint64_t    refreshDuration;
} VkRefreshCycleDurationGOOGLE;

typedef struct VkPastPresentationTimingGOOGLE {
    uint32_t    presentID;
    uint64_t    desiredPresentTime;
    uint64_t    actualPresentTime;
    uint64_t    earliestPresentTime;
    uint64_t    presentMargin;
} VkPastPresentationTimingGOOGLE;

typedef struct VkPresentTimeGOOGLE {
    uint32_t    presentID;
    uint64_t    desiredPresentTime;
} VkPresentTimeGOOGLE;

typedef struct VkPresentTimesInfoGOOGLE {
    VkStructureType               sType;
    const void*                   pNext;
    uint32_t                      swapchainCount;
    const VkPresentTimeGOOGLE*    pTimes;
} VkPresentTimesInfoGOOGLE;

struct VkPresentTimesInfoGOOGLERAII {
   VkPresentTimesInfoGOOGLE nonRaiiObj;
    std::vector<VkPresentTimeGOOGLE>            vecTimes;
};


typedef VkResult (VKAPI_PTR *PFN_vkGetRefreshCycleDurationGOOGLE)(VkDevice device, VkSwapchainKHR swapchain, VkRefreshCycleDurationGOOGLE* pDisplayTimingProperties);
typedef VkResult (VKAPI_PTR *PFN_vkGetPastPresentationTimingGOOGLE)(VkDevice device, VkSwapchainKHR swapchain, uint32_t* pPresentationTimingCount, VkPastPresentationTimingGOOGLE* pPresentationTimings);

VkRefreshCycleDurationGOOGLE RefreshCycleDurationGOOGLE(
    uint64_t                                    refreshDuration);


VkPastPresentationTimingGOOGLE PastPresentationTimingGOOGLE(
    uint32_t                                    presentID,
    uint64_t                                    desiredPresentTime,
    uint64_t                                    actualPresentTime,
    uint64_t                                    earliestPresentTime,
    uint64_t                                    presentMargin);


VkPresentTimeGOOGLE PresentTimeGOOGLE(
    uint32_t                                    presentID,
    uint64_t                                    desiredPresentTime);


std::shared_ptr<VkPresentTimesInfoGOOGLERAII> PresentTimesInfoGOOGLE(
    const std::vector<VkPresentTimeGOOGLE> &    vecTimes);


VkRefreshCycleDurationGOOGLE getRefreshCycleDurationGOOGLE(
        VkDevice device,
        VkSwapchainKHR swapchain);

std::vector< VkPastPresentationTimingGOOGLE > getPastPresentationTimingGOOGLE(
        VkDevice device,
        VkSwapchainKHR swapchain);


#define VK_NV_sample_mask_override_coverage 1
#define VK_NV_SAMPLE_MASK_OVERRIDE_COVERAGE_SPEC_VERSION 1
#define VK_NV_SAMPLE_MASK_OVERRIDE_COVERAGE_EXTENSION_NAME "VK_NV_sample_mask_override_coverage"


#define VK_NV_geometry_shader_passthrough 1
#define VK_NV_GEOMETRY_SHADER_PASSTHROUGH_SPEC_VERSION 1
#define VK_NV_GEOMETRY_SHADER_PASSTHROUGH_EXTENSION_NAME "VK_NV_geometry_shader_passthrough"


#define VK_NV_viewport_array2 1
#define VK_NV_VIEWPORT_ARRAY2_SPEC_VERSION 1
#define VK_NV_VIEWPORT_ARRAY2_EXTENSION_NAME "VK_NV_viewport_array2"


#define VK_NVX_multiview_per_view_attributes 1
#define VK_NVX_MULTIVIEW_PER_VIEW_ATTRIBUTES_SPEC_VERSION 1
#define VK_NVX_MULTIVIEW_PER_VIEW_ATTRIBUTES_EXTENSION_NAME "VK_NVX_multiview_per_view_attributes"

typedef struct VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX {
    VkStructureType    sType;
    void*              pNext;
    VkBool32           perViewPositionAllComponents;
} VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX;


VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX(
    VkBool32                                    perViewPositionAllComponents);



#define VK_NV_viewport_swizzle 1
#define VK_NV_VIEWPORT_SWIZZLE_SPEC_VERSION 1
#define VK_NV_VIEWPORT_SWIZZLE_EXTENSION_NAME "VK_NV_viewport_swizzle"


typedef enum VkViewportCoordinateSwizzleNV {
    VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_X_NV = 0,
    VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_X_NV = 1,
    VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Y_NV = 2,
    VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Y_NV = 3,
    VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Z_NV = 4,
    VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Z_NV = 5,
    VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_W_NV = 6,
    VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_W_NV = 7,
    VK_VIEWPORT_COORDINATE_SWIZZLE_BEGIN_RANGE_NV = VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_X_NV,
    VK_VIEWPORT_COORDINATE_SWIZZLE_END_RANGE_NV = VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_W_NV,
    VK_VIEWPORT_COORDINATE_SWIZZLE_RANGE_SIZE_NV = (VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_W_NV - VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_X_NV + 1),
    VK_VIEWPORT_COORDINATE_SWIZZLE_MAX_ENUM_NV = 0x7FFFFFFF
} VkViewportCoordinateSwizzleNV;

typedef VkFlags VkPipelineViewportSwizzleStateCreateFlagsNV;

typedef struct VkViewportSwizzleNV {
    VkViewportCoordinateSwizzleNV    x;
    VkViewportCoordinateSwizzleNV    y;
    VkViewportCoordinateSwizzleNV    z;
    VkViewportCoordinateSwizzleNV    w;
} VkViewportSwizzleNV;

typedef struct VkPipelineViewportSwizzleStateCreateInfoNV {
    VkStructureType                                sType;
    const void*                                    pNext;
    VkPipelineViewportSwizzleStateCreateFlagsNV    flags;
    uint32_t                                       viewportCount;
    const VkViewportSwizzleNV*                     pViewportSwizzles;
} VkPipelineViewportSwizzleStateCreateInfoNV;

struct VkPipelineViewportSwizzleStateCreateInfoNVRAII {
   VkPipelineViewportSwizzleStateCreateInfoNV nonRaiiObj;
    std::vector<VkViewportSwizzleNV>            vecViewportSwizzles;
};


VkViewportSwizzleNV ViewportSwizzleNV(
    VkViewportCoordinateSwizzleNV               x,
    VkViewportCoordinateSwizzleNV               y,
    VkViewportCoordinateSwizzleNV               z,
    VkViewportCoordinateSwizzleNV               w);


std::shared_ptr<VkPipelineViewportSwizzleStateCreateInfoNVRAII> PipelineViewportSwizzleStateCreateInfoNV(
    VkPipelineViewportSwizzleStateCreateFlagsNV flags,
    const std::vector<VkViewportSwizzleNV> &    vecViewportSwizzles);



#define VK_EXT_discard_rectangles 1
#define VK_EXT_DISCARD_RECTANGLES_SPEC_VERSION 1
#define VK_EXT_DISCARD_RECTANGLES_EXTENSION_NAME "VK_EXT_discard_rectangles"


typedef enum VkDiscardRectangleModeEXT {
    VK_DISCARD_RECTANGLE_MODE_INCLUSIVE_EXT = 0,
    VK_DISCARD_RECTANGLE_MODE_EXCLUSIVE_EXT = 1,
    VK_DISCARD_RECTANGLE_MODE_BEGIN_RANGE_EXT = VK_DISCARD_RECTANGLE_MODE_INCLUSIVE_EXT,
    VK_DISCARD_RECTANGLE_MODE_END_RANGE_EXT = VK_DISCARD_RECTANGLE_MODE_EXCLUSIVE_EXT,
    VK_DISCARD_RECTANGLE_MODE_RANGE_SIZE_EXT = (VK_DISCARD_RECTANGLE_MODE_EXCLUSIVE_EXT - VK_DISCARD_RECTANGLE_MODE_INCLUSIVE_EXT + 1),
    VK_DISCARD_RECTANGLE_MODE_MAX_ENUM_EXT = 0x7FFFFFFF
} VkDiscardRectangleModeEXT;

typedef VkFlags VkPipelineDiscardRectangleStateCreateFlagsEXT;

typedef struct VkPhysicalDeviceDiscardRectanglePropertiesEXT {
    VkStructureType    sType;
    void*              pNext;
    uint32_t           maxDiscardRectangles;
} VkPhysicalDeviceDiscardRectanglePropertiesEXT;

typedef struct VkPipelineDiscardRectangleStateCreateInfoEXT {
    VkStructureType                                  sType;
    const void*                                      pNext;
    VkPipelineDiscardRectangleStateCreateFlagsEXT    flags;
    VkDiscardRectangleModeEXT                        discardRectangleMode;
    uint32_t                                         discardRectangleCount;
    const VkRect2D*                                  pDiscardRectangles;
} VkPipelineDiscardRectangleStateCreateInfoEXT;

struct VkPipelineDiscardRectangleStateCreateInfoEXTRAII {
   VkPipelineDiscardRectangleStateCreateInfoEXT nonRaiiObj;
    std::vector<VkRect2D>                       vecDiscardRectangles;
};


typedef void (VKAPI_PTR *PFN_vkCmdSetDiscardRectangleEXT)(VkCommandBuffer commandBuffer, uint32_t firstDiscardRectangle, uint32_t discardRectangleCount, const VkRect2D* pDiscardRectangles);

VkPhysicalDeviceDiscardRectanglePropertiesEXT PhysicalDeviceDiscardRectanglePropertiesEXT(
    uint32_t                                    maxDiscardRectangles);


std::shared_ptr<VkPipelineDiscardRectangleStateCreateInfoEXTRAII> PipelineDiscardRectangleStateCreateInfoEXT(
    VkPipelineDiscardRectangleStateCreateFlagsEXT flags,
    VkDiscardRectangleModeEXT                   discardRectangleMode,
    const std::vector<VkRect2D> &               vecDiscardRectangles);


void  cmdSetDiscardRectangleEXT(
        VkCommandBuffer commandBuffer,
        uint32_t firstDiscardRectangle,
        const std::vector<VkRect2D> & pDiscardRectangles);


#define VK_EXT_swapchain_colorspace 1
#define VK_EXT_SWAPCHAIN_COLOR_SPACE_SPEC_VERSION 3
#define VK_EXT_SWAPCHAIN_COLOR_SPACE_EXTENSION_NAME "VK_EXT_swapchain_colorspace"


#define VK_EXT_hdr_metadata 1
#define VK_EXT_HDR_METADATA_SPEC_VERSION  1
#define VK_EXT_HDR_METADATA_EXTENSION_NAME "VK_EXT_hdr_metadata"

typedef struct VkXYColorEXT {
    float    x;
    float    y;
} VkXYColorEXT;

typedef struct VkHdrMetadataEXT {
    VkStructureType    sType;
    const void*        pNext;
    VkXYColorEXT       displayPrimaryRed;
    VkXYColorEXT       displayPrimaryGreen;
    VkXYColorEXT       displayPrimaryBlue;
    VkXYColorEXT       whitePoint;
    float              maxLuminance;
    float              minLuminance;
    float              maxContentLightLevel;
    float              maxFrameAverageLightLevel;
} VkHdrMetadataEXT;


typedef void (VKAPI_PTR *PFN_vkSetHdrMetadataEXT)(VkDevice device, uint32_t swapchainCount, const VkSwapchainKHR* pSwapchains, const VkHdrMetadataEXT* pMetadata);

VkXYColorEXT XYColorEXT(
    float                                       x,
    float                                       y);


VkHdrMetadataEXT HdrMetadataEXT(
    VkXYColorEXT                                displayPrimaryRed,
    VkXYColorEXT                                displayPrimaryGreen,
    VkXYColorEXT                                displayPrimaryBlue,
    VkXYColorEXT                                whitePoint,
    float                                       maxLuminance,
    float                                       minLuminance,
    float                                       maxContentLightLevel,
    float                                       maxFrameAverageLightLevel);


void  setHdrMetadataEXT(
        VkDevice device,
        const std::vector<VkSwapchainKHR> & pSwapchains,
        const std::vector<VkHdrMetadataEXT> & pMetadata);


#ifdef VK_USE_PLATFORM_IOS_MVK
#define VK_MVK_ios_surface 1
#define VK_MVK_IOS_SURFACE_SPEC_VERSION   2
#define VK_MVK_IOS_SURFACE_EXTENSION_NAME "VK_MVK_ios_surface"

typedef VkFlags VkIOSSurfaceCreateFlagsMVK;

typedef struct VkIOSSurfaceCreateInfoMVK {
    VkStructureType               sType;
    const void*                   pNext;
    VkIOSSurfaceCreateFlagsMVK    flags;
    const void*                   pView;
} VkIOSSurfaceCreateInfoMVK;


typedef VkResult (VKAPI_PTR *PFN_vkCreateIOSSurfaceMVK)(VkInstance instance, const VkIOSSurfaceCreateInfoMVK* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface);

VkIOSSurfaceCreateInfoMVK IOSSurfaceCreateInfoMVK(
    VkIOSSurfaceCreateFlagsMVK                  flags);


std::shared_ptr<VkSurfaceKHR_T> createIOSSurfaceMVK(
        VkInstance instance,
        const VkIOSSurfaceCreateInfoMVK & pCreateInfo);

#endif /* VK_USE_PLATFORM_IOS_MVK */

#ifdef VK_USE_PLATFORM_MACOS_MVK
#define VK_MVK_macos_surface 1
#define VK_MVK_MACOS_SURFACE_SPEC_VERSION 2
#define VK_MVK_MACOS_SURFACE_EXTENSION_NAME "VK_MVK_macos_surface"

typedef VkFlags VkMacOSSurfaceCreateFlagsMVK;

typedef struct VkMacOSSurfaceCreateInfoMVK {
    VkStructureType                 sType;
    const void*                     pNext;
    VkMacOSSurfaceCreateFlagsMVK    flags;
    const void*                     pView;
} VkMacOSSurfaceCreateInfoMVK;


typedef VkResult (VKAPI_PTR *PFN_vkCreateMacOSSurfaceMVK)(VkInstance instance, const VkMacOSSurfaceCreateInfoMVK* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface);

VkMacOSSurfaceCreateInfoMVK MacOSSurfaceCreateInfoMVK(
    VkMacOSSurfaceCreateFlagsMVK                flags);


std::shared_ptr<VkSurfaceKHR_T> createMacOSSurfaceMVK(
        VkInstance instance,
        const VkMacOSSurfaceCreateInfoMVK & pCreateInfo);

#endif /* VK_USE_PLATFORM_MACOS_MVK */

#define VK_EXT_sampler_filter_minmax 1
#define VK_EXT_SAMPLER_FILTER_MINMAX_SPEC_VERSION 1
#define VK_EXT_SAMPLER_FILTER_MINMAX_EXTENSION_NAME "VK_EXT_sampler_filter_minmax"


typedef enum VkSamplerReductionModeEXT {
    VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_EXT = 0,
    VK_SAMPLER_REDUCTION_MODE_MIN_EXT = 1,
    VK_SAMPLER_REDUCTION_MODE_MAX_EXT = 2,
    VK_SAMPLER_REDUCTION_MODE_BEGIN_RANGE_EXT = VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_EXT,
    VK_SAMPLER_REDUCTION_MODE_END_RANGE_EXT = VK_SAMPLER_REDUCTION_MODE_MAX_EXT,
    VK_SAMPLER_REDUCTION_MODE_RANGE_SIZE_EXT = (VK_SAMPLER_REDUCTION_MODE_MAX_EXT - VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_EXT + 1),
    VK_SAMPLER_REDUCTION_MODE_MAX_ENUM_EXT = 0x7FFFFFFF
} VkSamplerReductionModeEXT;

typedef struct VkSamplerReductionModeCreateInfoEXT {
    VkStructureType              sType;
    const void*                  pNext;
    VkSamplerReductionModeEXT    reductionMode;
} VkSamplerReductionModeCreateInfoEXT;

typedef struct VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT {
    VkStructureType    sType;
    void*              pNext;
    VkBool32           filterMinmaxSingleComponentFormats;
    VkBool32           filterMinmaxImageComponentMapping;
} VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT;


VkSamplerReductionModeCreateInfoEXT SamplerReductionModeCreateInfoEXT(
    VkSamplerReductionModeEXT                   reductionMode);


VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT PhysicalDeviceSamplerFilterMinmaxPropertiesEXT(
    VkBool32                                    filterMinmaxSingleComponentFormats,
    VkBool32                                    filterMinmaxImageComponentMapping);



#define VK_AMD_gpu_shader_int16 1
#define VK_AMD_GPU_SHADER_INT16_SPEC_VERSION 1
#define VK_AMD_GPU_SHADER_INT16_EXTENSION_NAME "VK_AMD_gpu_shader_int16"


#define VK_AMD_mixed_attachment_samples 1
#define VK_AMD_MIXED_ATTACHMENT_SAMPLES_SPEC_VERSION 1
#define VK_AMD_MIXED_ATTACHMENT_SAMPLES_EXTENSION_NAME "VK_AMD_mixed_attachment_samples"


#define VK_AMD_shader_fragment_mask 1
#define VK_AMD_SHADER_FRAGMENT_MASK_SPEC_VERSION 1
#define VK_AMD_SHADER_FRAGMENT_MASK_EXTENSION_NAME "VK_AMD_shader_fragment_mask"


#define VK_EXT_shader_stencil_export 1
#define VK_EXT_SHADER_STENCIL_EXPORT_SPEC_VERSION 1
#define VK_EXT_SHADER_STENCIL_EXPORT_EXTENSION_NAME "VK_EXT_shader_stencil_export"


#define VK_EXT_sample_locations 1
#define VK_EXT_SAMPLE_LOCATIONS_SPEC_VERSION 1
#define VK_EXT_SAMPLE_LOCATIONS_EXTENSION_NAME "VK_EXT_sample_locations"

typedef struct VkSampleLocationEXT {
    float    x;
    float    y;
} VkSampleLocationEXT;

typedef struct VkSampleLocationsInfoEXT {
    VkStructureType               sType;
    const void*                   pNext;
    VkSampleCountFlagBits         sampleLocationsPerPixel;
    VkExtent2D                    sampleLocationGridSize;
    uint32_t                      sampleLocationsCount;
    const VkSampleLocationEXT*    pSampleLocations;
} VkSampleLocationsInfoEXT;

struct VkSampleLocationsInfoEXTRAII {
   VkSampleLocationsInfoEXT nonRaiiObj;
    std::vector<VkSampleLocationEXT>            vecSampleLocations;
};

typedef struct VkAttachmentSampleLocationsEXT {
    uint32_t                    attachmentIndex;
    VkSampleLocationsInfoEXT    sampleLocationsInfo;
} VkAttachmentSampleLocationsEXT;

typedef struct VkSubpassSampleLocationsEXT {
    uint32_t                    subpassIndex;
    VkSampleLocationsInfoEXT    sampleLocationsInfo;
} VkSubpassSampleLocationsEXT;

typedef struct VkRenderPassSampleLocationsBeginInfoEXT {
    VkStructureType                          sType;
    const void*                              pNext;
    uint32_t                                 attachmentInitialSampleLocationsCount;
    const VkAttachmentSampleLocationsEXT*    pAttachmentInitialSampleLocations;
    uint32_t                                 postSubpassSampleLocationsCount;
    const VkSubpassSampleLocationsEXT*       pPostSubpassSampleLocations;
} VkRenderPassSampleLocationsBeginInfoEXT;

struct VkRenderPassSampleLocationsBeginInfoEXTRAII {
   VkRenderPassSampleLocationsBeginInfoEXT nonRaiiObj;
    std::vector<VkAttachmentSampleLocationsEXT> vecAttachmentInitialSampleLocations;
    std::vector<VkSubpassSampleLocationsEXT>    vecPostSubpassSampleLocations;
};

typedef struct VkPipelineSampleLocationsStateCreateInfoEXT {
    VkStructureType             sType;
    const void*                 pNext;
    VkBool32                    sampleLocationsEnable;
    VkSampleLocationsInfoEXT    sampleLocationsInfo;
} VkPipelineSampleLocationsStateCreateInfoEXT;

typedef struct VkPhysicalDeviceSampleLocationsPropertiesEXT {
    VkStructureType       sType;
    void*                 pNext;
    VkSampleCountFlags    sampleLocationSampleCounts;
    VkExtent2D            maxSampleLocationGridSize;
    float                 sampleLocationCoordinateRange[2];
    uint32_t              sampleLocationSubPixelBits;
    VkBool32              variableSampleLocations;
} VkPhysicalDeviceSampleLocationsPropertiesEXT;

typedef struct VkMultisamplePropertiesEXT {
    VkStructureType    sType;
    void*              pNext;
    VkExtent2D         maxSampleLocationGridSize;
} VkMultisamplePropertiesEXT;


typedef void (VKAPI_PTR *PFN_vkCmdSetSampleLocationsEXT)(VkCommandBuffer commandBuffer, const VkSampleLocationsInfoEXT* pSampleLocationsInfo);
typedef void (VKAPI_PTR *PFN_vkGetPhysicalDeviceMultisamplePropertiesEXT)(VkPhysicalDevice physicalDevice, VkSampleCountFlagBits samples, VkMultisamplePropertiesEXT* pMultisampleProperties);

VkSampleLocationEXT SampleLocationEXT(
    float                                       x,
    float                                       y);


std::shared_ptr<VkSampleLocationsInfoEXTRAII> SampleLocationsInfoEXT(
    VkSampleCountFlagBits                       sampleLocationsPerPixel,
    VkExtent2D                                  sampleLocationGridSize,
    const std::vector<VkSampleLocationEXT> &    vecSampleLocations);


VkAttachmentSampleLocationsEXT AttachmentSampleLocationsEXT(
    uint32_t                                    attachmentIndex,
    VkSampleLocationsInfoEXT                    sampleLocationsInfo);


VkSubpassSampleLocationsEXT SubpassSampleLocationsEXT(
    uint32_t                                    subpassIndex,
    VkSampleLocationsInfoEXT                    sampleLocationsInfo);


std::shared_ptr<VkRenderPassSampleLocationsBeginInfoEXTRAII> RenderPassSampleLocationsBeginInfoEXT(
    const std::vector<VkAttachmentSampleLocationsEXT> &vecAttachmentInitialSampleLocations,
    const std::vector<VkSubpassSampleLocationsEXT> &vecPostSubpassSampleLocations);


VkPipelineSampleLocationsStateCreateInfoEXT PipelineSampleLocationsStateCreateInfoEXT(
    VkBool32                                    sampleLocationsEnable,
    VkSampleLocationsInfoEXT                    sampleLocationsInfo);


VkPhysicalDeviceSampleLocationsPropertiesEXT PhysicalDeviceSampleLocationsPropertiesEXT(
    VkSampleCountFlags                          sampleLocationSampleCounts,
    VkExtent2D                                  maxSampleLocationGridSize,
    float                                       sampleLocationCoordinateRange[2],
    uint32_t                                    sampleLocationSubPixelBits,
    VkBool32                                    variableSampleLocations);


VkMultisamplePropertiesEXT MultisamplePropertiesEXT(
    VkExtent2D                                  maxSampleLocationGridSize);


void  cmdSetSampleLocationsEXT(
        VkCommandBuffer commandBuffer,
        const VkSampleLocationsInfoEXT & pSampleLocationsInfo);

VkMultisamplePropertiesEXT getPhysicalDeviceMultisamplePropertiesEXT(
        VkPhysicalDevice physicalDevice,
        VkSampleCountFlagBits samples);


#define VK_EXT_blend_operation_advanced 1
#define VK_EXT_BLEND_OPERATION_ADVANCED_SPEC_VERSION 2
#define VK_EXT_BLEND_OPERATION_ADVANCED_EXTENSION_NAME "VK_EXT_blend_operation_advanced"


typedef enum VkBlendOverlapEXT {
    VK_BLEND_OVERLAP_UNCORRELATED_EXT = 0,
    VK_BLEND_OVERLAP_DISJOINT_EXT = 1,
    VK_BLEND_OVERLAP_CONJOINT_EXT = 2,
    VK_BLEND_OVERLAP_BEGIN_RANGE_EXT = VK_BLEND_OVERLAP_UNCORRELATED_EXT,
    VK_BLEND_OVERLAP_END_RANGE_EXT = VK_BLEND_OVERLAP_CONJOINT_EXT,
    VK_BLEND_OVERLAP_RANGE_SIZE_EXT = (VK_BLEND_OVERLAP_CONJOINT_EXT - VK_BLEND_OVERLAP_UNCORRELATED_EXT + 1),
    VK_BLEND_OVERLAP_MAX_ENUM_EXT = 0x7FFFFFFF
} VkBlendOverlapEXT;

typedef struct VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT {
    VkStructureType    sType;
    void*              pNext;
    VkBool32           advancedBlendCoherentOperations;
} VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT;

typedef struct VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT {
    VkStructureType    sType;
    void*              pNext;
    uint32_t           advancedBlendMaxColorAttachments;
    VkBool32           advancedBlendIndependentBlend;
    VkBool32           advancedBlendNonPremultipliedSrcColor;
    VkBool32           advancedBlendNonPremultipliedDstColor;
    VkBool32           advancedBlendCorrelatedOverlap;
    VkBool32           advancedBlendAllOperations;
} VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT;

typedef struct VkPipelineColorBlendAdvancedStateCreateInfoEXT {
    VkStructureType      sType;
    const void*          pNext;
    VkBool32             srcPremultiplied;
    VkBool32             dstPremultiplied;
    VkBlendOverlapEXT    blendOverlap;
} VkPipelineColorBlendAdvancedStateCreateInfoEXT;


VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT PhysicalDeviceBlendOperationAdvancedFeaturesEXT(
    VkBool32                                    advancedBlendCoherentOperations);


VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT PhysicalDeviceBlendOperationAdvancedPropertiesEXT(
    uint32_t                                    advancedBlendMaxColorAttachments,
    VkBool32                                    advancedBlendIndependentBlend,
    VkBool32                                    advancedBlendNonPremultipliedSrcColor,
    VkBool32                                    advancedBlendNonPremultipliedDstColor,
    VkBool32                                    advancedBlendCorrelatedOverlap,
    VkBool32                                    advancedBlendAllOperations);


VkPipelineColorBlendAdvancedStateCreateInfoEXT PipelineColorBlendAdvancedStateCreateInfoEXT(
    VkBool32                                    srcPremultiplied,
    VkBool32                                    dstPremultiplied,
    VkBlendOverlapEXT                           blendOverlap);



#define VK_NV_fragment_coverage_to_color 1
#define VK_NV_FRAGMENT_COVERAGE_TO_COLOR_SPEC_VERSION 1
#define VK_NV_FRAGMENT_COVERAGE_TO_COLOR_EXTENSION_NAME "VK_NV_fragment_coverage_to_color"

typedef VkFlags VkPipelineCoverageToColorStateCreateFlagsNV;

typedef struct VkPipelineCoverageToColorStateCreateInfoNV {
    VkStructureType                                sType;
    const void*                                    pNext;
    VkPipelineCoverageToColorStateCreateFlagsNV    flags;
    VkBool32                                       coverageToColorEnable;
    uint32_t                                       coverageToColorLocation;
} VkPipelineCoverageToColorStateCreateInfoNV;


VkPipelineCoverageToColorStateCreateInfoNV PipelineCoverageToColorStateCreateInfoNV(
    VkPipelineCoverageToColorStateCreateFlagsNV flags,
    VkBool32                                    coverageToColorEnable,
    uint32_t                                    coverageToColorLocation);



#define VK_NV_framebuffer_mixed_samples 1
#define VK_NV_FRAMEBUFFER_MIXED_SAMPLES_SPEC_VERSION 1
#define VK_NV_FRAMEBUFFER_MIXED_SAMPLES_EXTENSION_NAME "VK_NV_framebuffer_mixed_samples"


typedef enum VkCoverageModulationModeNV {
    VK_COVERAGE_MODULATION_MODE_NONE_NV = 0,
    VK_COVERAGE_MODULATION_MODE_RGB_NV = 1,
    VK_COVERAGE_MODULATION_MODE_ALPHA_NV = 2,
    VK_COVERAGE_MODULATION_MODE_RGBA_NV = 3,
    VK_COVERAGE_MODULATION_MODE_BEGIN_RANGE_NV = VK_COVERAGE_MODULATION_MODE_NONE_NV,
    VK_COVERAGE_MODULATION_MODE_END_RANGE_NV = VK_COVERAGE_MODULATION_MODE_RGBA_NV,
    VK_COVERAGE_MODULATION_MODE_RANGE_SIZE_NV = (VK_COVERAGE_MODULATION_MODE_RGBA_NV - VK_COVERAGE_MODULATION_MODE_NONE_NV + 1),
    VK_COVERAGE_MODULATION_MODE_MAX_ENUM_NV = 0x7FFFFFFF
} VkCoverageModulationModeNV;

typedef VkFlags VkPipelineCoverageModulationStateCreateFlagsNV;

typedef struct VkPipelineCoverageModulationStateCreateInfoNV {
    VkStructureType                                   sType;
    const void*                                       pNext;
    VkPipelineCoverageModulationStateCreateFlagsNV    flags;
    VkCoverageModulationModeNV                        coverageModulationMode;
    VkBool32                                          coverageModulationTableEnable;
    uint32_t                                          coverageModulationTableCount;
    const float*                                      pCoverageModulationTable;
} VkPipelineCoverageModulationStateCreateInfoNV;

struct VkPipelineCoverageModulationStateCreateInfoNVRAII {
   VkPipelineCoverageModulationStateCreateInfoNV nonRaiiObj;
    std::vector<float>                          vecCoverageModulationTable;
};


std::shared_ptr<VkPipelineCoverageModulationStateCreateInfoNVRAII> PipelineCoverageModulationStateCreateInfoNV(
    VkPipelineCoverageModulationStateCreateFlagsNV flags,
    VkCoverageModulationModeNV                  coverageModulationMode,
    VkBool32                                    coverageModulationTableEnable,
    float* pCoverageModulationTable_in_array1, int pCoverageModulationTable_dim1);



#define VK_NV_fill_rectangle 1
#define VK_NV_FILL_RECTANGLE_SPEC_VERSION 1
#define VK_NV_FILL_RECTANGLE_EXTENSION_NAME "VK_NV_fill_rectangle"


#define VK_EXT_post_depth_coverage 1
#define VK_EXT_POST_DEPTH_COVERAGE_SPEC_VERSION 1
#define VK_EXT_POST_DEPTH_COVERAGE_EXTENSION_NAME "VK_EXT_post_depth_coverage"


#define VK_EXT_validation_cache 1
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkValidationCacheEXT)

#define VK_EXT_VALIDATION_CACHE_SPEC_VERSION 1
#define VK_EXT_VALIDATION_CACHE_EXTENSION_NAME "VK_EXT_validation_cache"


typedef enum VkValidationCacheHeaderVersionEXT {
    VK_VALIDATION_CACHE_HEADER_VERSION_ONE_EXT = 1,
    VK_VALIDATION_CACHE_HEADER_VERSION_BEGIN_RANGE_EXT = VK_VALIDATION_CACHE_HEADER_VERSION_ONE_EXT,
    VK_VALIDATION_CACHE_HEADER_VERSION_END_RANGE_EXT = VK_VALIDATION_CACHE_HEADER_VERSION_ONE_EXT,
    VK_VALIDATION_CACHE_HEADER_VERSION_RANGE_SIZE_EXT = (VK_VALIDATION_CACHE_HEADER_VERSION_ONE_EXT - VK_VALIDATION_CACHE_HEADER_VERSION_ONE_EXT + 1),
    VK_VALIDATION_CACHE_HEADER_VERSION_MAX_ENUM_EXT = 0x7FFFFFFF
} VkValidationCacheHeaderVersionEXT;

typedef VkFlags VkValidationCacheCreateFlagsEXT;

typedef struct VkValidationCacheCreateInfoEXT {
    VkStructureType                    sType;
    const void*                        pNext;
    VkValidationCacheCreateFlagsEXT    flags;
    size_t                             initialDataSize;
    const void*                        pInitialData;
} VkValidationCacheCreateInfoEXT;

struct VkValidationCacheCreateInfoEXTRAII {
   VkValidationCacheCreateInfoEXT nonRaiiObj;
    std::vector<uint8_t>                        vecInitialData;
};

typedef struct VkShaderModuleValidationCacheCreateInfoEXT {
    VkStructureType         sType;
    const void*             pNext;
    VkValidationCacheEXT    validationCache;
} VkShaderModuleValidationCacheCreateInfoEXT;


typedef VkResult (VKAPI_PTR *PFN_vkCreateValidationCacheEXT)(VkDevice device, const VkValidationCacheCreateInfoEXT* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkValidationCacheEXT* pValidationCache);
typedef void (VKAPI_PTR *PFN_vkDestroyValidationCacheEXT)(VkDevice device, VkValidationCacheEXT validationCache, const VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkMergeValidationCachesEXT)(VkDevice device, VkValidationCacheEXT dstCache, uint32_t srcCacheCount, const VkValidationCacheEXT* pSrcCaches);
typedef VkResult (VKAPI_PTR *PFN_vkGetValidationCacheDataEXT)(VkDevice device, VkValidationCacheEXT validationCache, size_t* pDataSize, void* pData);

std::shared_ptr<VkValidationCacheCreateInfoEXTRAII> ValidationCacheCreateInfoEXT(
    VkValidationCacheCreateFlagsEXT             flags,
    const std::vector<uint8_t> &                vecInitialData);


VkShaderModuleValidationCacheCreateInfoEXT ShaderModuleValidationCacheCreateInfoEXT(
    VkValidationCacheEXT                        validationCache);


std::shared_ptr<VkValidationCacheEXT_T> createValidationCacheEXT(
        VkDevice device,
        const VkValidationCacheCreateInfoEXT & pCreateInfo);

void  mergeValidationCachesEXT(
        VkDevice device,
        VkValidationCacheEXT dstCache,
        const std::vector<VkValidationCacheEXT> & pSrcCaches);

size_t getValidationCacheDataEXT(
        VkDevice device,
        VkValidationCacheEXT validationCache);


#define VK_EXT_shader_viewport_index_layer 1
#define VK_EXT_SHADER_VIEWPORT_INDEX_LAYER_SPEC_VERSION 1
#define VK_EXT_SHADER_VIEWPORT_INDEX_LAYER_EXTENSION_NAME "VK_EXT_shader_viewport_index_layer"


#define VK_EXT_global_priority 1
#define VK_EXT_GLOBAL_PRIORITY_SPEC_VERSION 1
#define VK_EXT_GLOBAL_PRIORITY_EXTENSION_NAME "VK_EXT_global_priority"


typedef enum VkQueueGlobalPriorityEXT {
    VK_QUEUE_GLOBAL_PRIORITY_LOW = 128,
    VK_QUEUE_GLOBAL_PRIORITY_MEDIUM = 256,
    VK_QUEUE_GLOBAL_PRIORITY_HIGH = 512,
    VK_QUEUE_GLOBAL_PRIORITY_REALTIME = 1024,
    VK_QUEUE_GLOBAL_PRIORITY_BEGIN_RANGE_EXT = VK_QUEUE_GLOBAL_PRIORITY_LOW,
    VK_QUEUE_GLOBAL_PRIORITY_END_RANGE_EXT = VK_QUEUE_GLOBAL_PRIORITY_REALTIME,
    VK_QUEUE_GLOBAL_PRIORITY_RANGE_SIZE_EXT = (VK_QUEUE_GLOBAL_PRIORITY_REALTIME - VK_QUEUE_GLOBAL_PRIORITY_LOW + 1),
    VK_QUEUE_GLOBAL_PRIORITY_MAX_ENUM_EXT = 0x7FFFFFFF
} VkQueueGlobalPriorityEXT;

typedef struct VkDeviceQueueGlobalPriorityCreateInfoEXT {
    VkStructureType             sType;
    const void*                 pNext;
    VkQueueGlobalPriorityEXT    globalPriority;
} VkDeviceQueueGlobalPriorityCreateInfoEXT;


VkDeviceQueueGlobalPriorityCreateInfoEXT DeviceQueueGlobalPriorityCreateInfoEXT(
    VkQueueGlobalPriorityEXT                    globalPriority);


void load_vulkan_fct_ptrs(VkInstance instance);

%{

     const char* vkGetErrorString(VkResult retval)
     {
         static const char vk_err_messages[28][123] = {
             "Vulkan error (VK_SUCCESS) : Command completed successfully",
             "Vulkan error (VK_NOT_READY) : A fence or query has not yet completed",
             "Vulkan error (VK_TIMEOUT) : A wait operation has not completed in the specified time",
             "Vulkan error (VK_EVENT_SET) : An event is signaled",
             "Vulkan error (VK_EVENT_RESET) : An event is unsignaled",
             "Vulkan error (VK_INCOMPLETE) : A return array was too small for the result",
             "Vulkan error (VK_ERROR_OUT_OF_HOST_MEMORY) : A host memory allocation has failed",
             "Vulkan error (VK_ERROR_OUT_OF_DEVICE_MEMORY) : A device memory allocation has failed",
             "Vulkan error (VK_ERROR_INITIALIZATION_FAILED) : Initialization of a object has failed",
             "Vulkan error (VK_ERROR_DEVICE_LOST) : The logical device has been lost. See <<devsandqueues-lost-device>>",
             "Vulkan error (VK_ERROR_MEMORY_MAP_FAILED) : Mapping of a memory object has failed",
             "Vulkan error (VK_ERROR_LAYER_NOT_PRESENT) : Layer specified does not exist",
             "Vulkan error (VK_ERROR_EXTENSION_NOT_PRESENT) : Extension specified does not exist",
             "Vulkan error (VK_ERROR_FEATURE_NOT_PRESENT) : Requested feature is not available on this device",
             "Vulkan error (VK_ERROR_INCOMPATIBLE_DRIVER) : Unable to find a Vulkan driver",
             "Vulkan error (VK_ERROR_TOO_MANY_OBJECTS) : Too many objects of the type have already been created",
             "Vulkan error (VK_ERROR_FORMAT_NOT_SUPPORTED) : Requested format is not supported on this device",
             "Vulkan error (VK_ERROR_FRAGMENTED_POOL) : A requested pool allocation has failed due to fragmentation of the pool's memory",
             "Vulkan error: VK_ERROR_SURFACE_LOST_KHR",
             "Vulkan error: VK_ERROR_NATIVE_WINDOW_IN_USE_KHR",
             "Vulkan error: VK_SUBOPTIMAL_KHR",
             "Vulkan error: VK_ERROR_OUT_OF_DATE_KHR",
             "Vulkan error: VK_ERROR_INCOMPATIBLE_DISPLAY_KHR",
             "Vulkan error: VK_ERROR_VALIDATION_FAILED_EXT",
             "Vulkan error: VK_ERROR_INVALID_SHADER_NV",
             "Vulkan error: VK_ERROR_OUT_OF_POOL_MEMORY_KHR",
             "Vulkan error: VK_ERROR_INVALID_EXTERNAL_HANDLE_KHR",
             "Vulkan error: VK_ERROR_NOT_PERMITTED_EXT",
         };
         switch (retval) {
             case VK_SUCCESS : return vk_err_messages[0];
             case VK_NOT_READY : return vk_err_messages[1];
             case VK_TIMEOUT : return vk_err_messages[2];
             case VK_EVENT_SET : return vk_err_messages[3];
             case VK_EVENT_RESET : return vk_err_messages[4];
             case VK_INCOMPLETE : return vk_err_messages[5];
             case VK_ERROR_OUT_OF_HOST_MEMORY : return vk_err_messages[6];
             case VK_ERROR_OUT_OF_DEVICE_MEMORY : return vk_err_messages[7];
             case VK_ERROR_INITIALIZATION_FAILED : return vk_err_messages[8];
             case VK_ERROR_DEVICE_LOST : return vk_err_messages[9];
             case VK_ERROR_MEMORY_MAP_FAILED : return vk_err_messages[10];
             case VK_ERROR_LAYER_NOT_PRESENT : return vk_err_messages[11];
             case VK_ERROR_EXTENSION_NOT_PRESENT : return vk_err_messages[12];
             case VK_ERROR_FEATURE_NOT_PRESENT : return vk_err_messages[13];
             case VK_ERROR_INCOMPATIBLE_DRIVER : return vk_err_messages[14];
             case VK_ERROR_TOO_MANY_OBJECTS : return vk_err_messages[15];
             case VK_ERROR_FORMAT_NOT_SUPPORTED : return vk_err_messages[16];
             case VK_ERROR_FRAGMENTED_POOL : return vk_err_messages[17];
             case VK_ERROR_SURFACE_LOST_KHR : return vk_err_messages[18];
             case VK_ERROR_NATIVE_WINDOW_IN_USE_KHR : return vk_err_messages[19];
             case VK_SUBOPTIMAL_KHR : return vk_err_messages[20];
             case VK_ERROR_OUT_OF_DATE_KHR : return vk_err_messages[21];
             case VK_ERROR_INCOMPATIBLE_DISPLAY_KHR : return vk_err_messages[22];
             case VK_ERROR_VALIDATION_FAILED_EXT : return vk_err_messages[23];
             case VK_ERROR_INVALID_SHADER_NV : return vk_err_messages[24];
             case VK_ERROR_OUT_OF_POOL_MEMORY_KHR : return vk_err_messages[25];
             case VK_ERROR_INVALID_EXTERNAL_HANDLE_KHR : return vk_err_messages[26];
             case VK_ERROR_NOT_PERMITTED_EXT : return vk_err_messages[27];
         }
         return nullptr;
     }

#ifdef VK_KHR_display
    PFN_vkGetPhysicalDeviceDisplayPropertiesKHR pfvkGetPhysicalDeviceDisplayPropertiesKHR;
    #endif //VK_KHR_display
    #ifdef VK_KHR_display
    PFN_vkGetPhysicalDeviceDisplayPlanePropertiesKHR pfvkGetPhysicalDeviceDisplayPlanePropertiesKHR;
    #endif //VK_KHR_display
    #ifdef VK_KHR_display
    PFN_vkGetDisplayPlaneSupportedDisplaysKHR pfvkGetDisplayPlaneSupportedDisplaysKHR;
    #endif //VK_KHR_display
    #ifdef VK_KHR_display
    PFN_vkGetDisplayModePropertiesKHR pfvkGetDisplayModePropertiesKHR;
    #endif //VK_KHR_display
    #ifdef VK_KHR_display
    PFN_vkCreateDisplayModeKHR pfvkCreateDisplayModeKHR;
    #endif //VK_KHR_display
    #ifdef VK_KHR_display
    PFN_vkGetDisplayPlaneCapabilitiesKHR pfvkGetDisplayPlaneCapabilitiesKHR;
    #endif //VK_KHR_display
    #ifdef VK_KHR_display
    PFN_vkCreateDisplayPlaneSurfaceKHR pfvkCreateDisplayPlaneSurfaceKHR;
    #endif //VK_KHR_display
    #ifdef VK_KHR_display
    PFN_vkDestroySurfaceKHR pfvkDestroySurfaceKHR;
    #endif //VK_KHR_display
    #ifdef VK_KHR_display_swapchain
    PFN_vkCreateSharedSwapchainsKHR pfvkCreateSharedSwapchainsKHR;
    #endif //VK_KHR_display_swapchain
    #ifdef VK_KHR_get_physical_device_properties2
    PFN_vkGetPhysicalDeviceFeatures2KHR pfvkGetPhysicalDeviceFeatures2KHR;
    #endif //VK_KHR_get_physical_device_properties2
    #ifdef VK_KHR_get_physical_device_properties2
    PFN_vkGetPhysicalDeviceProperties2KHR pfvkGetPhysicalDeviceProperties2KHR;
    #endif //VK_KHR_get_physical_device_properties2
    #ifdef VK_KHR_get_physical_device_properties2
    PFN_vkGetPhysicalDeviceFormatProperties2KHR pfvkGetPhysicalDeviceFormatProperties2KHR;
    #endif //VK_KHR_get_physical_device_properties2
    #ifdef VK_KHR_get_physical_device_properties2
    PFN_vkGetPhysicalDeviceImageFormatProperties2KHR pfvkGetPhysicalDeviceImageFormatProperties2KHR;
    #endif //VK_KHR_get_physical_device_properties2
    #ifdef VK_KHR_get_physical_device_properties2
    PFN_vkGetPhysicalDeviceQueueFamilyProperties2KHR pfvkGetPhysicalDeviceQueueFamilyProperties2KHR;
    #endif //VK_KHR_get_physical_device_properties2
    #ifdef VK_KHR_get_physical_device_properties2
    PFN_vkGetPhysicalDeviceMemoryProperties2KHR pfvkGetPhysicalDeviceMemoryProperties2KHR;
    #endif //VK_KHR_get_physical_device_properties2
    #ifdef VK_KHR_get_physical_device_properties2
    PFN_vkGetPhysicalDeviceSparseImageFormatProperties2KHR pfvkGetPhysicalDeviceSparseImageFormatProperties2KHR;
    #endif //VK_KHR_get_physical_device_properties2
    #ifdef VK_KHR_maintenance1
    PFN_vkTrimCommandPoolKHR pfvkTrimCommandPoolKHR;
    #endif //VK_KHR_maintenance1
    #ifdef VK_KHR_external_memory_capabilities
    PFN_vkGetPhysicalDeviceExternalBufferPropertiesKHR pfvkGetPhysicalDeviceExternalBufferPropertiesKHR;
    #endif //VK_KHR_external_memory_capabilities
    #ifdef VK_KHR_external_memory_win32
    PFN_vkGetMemoryWin32HandleKHR pfvkGetMemoryWin32HandleKHR;
    #endif //VK_KHR_external_memory_win32
    #ifdef VK_KHR_external_memory_win32
    PFN_vkGetMemoryWin32HandlePropertiesKHR pfvkGetMemoryWin32HandlePropertiesKHR;
    #endif //VK_KHR_external_memory_win32
    #ifdef VK_KHR_external_memory_fd
    PFN_vkGetMemoryFdKHR pfvkGetMemoryFdKHR;
    #endif //VK_KHR_external_memory_fd
    #ifdef VK_KHR_external_memory_fd
    PFN_vkGetMemoryFdPropertiesKHR pfvkGetMemoryFdPropertiesKHR;
    #endif //VK_KHR_external_memory_fd
    #ifdef VK_KHR_external_semaphore_capabilities
    PFN_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR pfvkGetPhysicalDeviceExternalSemaphorePropertiesKHR;
    #endif //VK_KHR_external_semaphore_capabilities
    #ifdef VK_KHR_external_semaphore_win32
    PFN_vkImportSemaphoreWin32HandleKHR pfvkImportSemaphoreWin32HandleKHR;
    #endif //VK_KHR_external_semaphore_win32
    #ifdef VK_KHR_external_semaphore_win32
    PFN_vkGetSemaphoreWin32HandleKHR pfvkGetSemaphoreWin32HandleKHR;
    #endif //VK_KHR_external_semaphore_win32
    #ifdef VK_KHR_external_semaphore_fd
    PFN_vkImportSemaphoreFdKHR pfvkImportSemaphoreFdKHR;
    #endif //VK_KHR_external_semaphore_fd
    #ifdef VK_KHR_external_semaphore_fd
    PFN_vkGetSemaphoreFdKHR pfvkGetSemaphoreFdKHR;
    #endif //VK_KHR_external_semaphore_fd
    #ifdef VK_KHR_push_descriptor
    PFN_vkCmdPushDescriptorSetKHR pfvkCmdPushDescriptorSetKHR;
    #endif //VK_KHR_push_descriptor
    #ifdef VK_KHR_descriptor_update_template
    PFN_vkCreateDescriptorUpdateTemplateKHR pfvkCreateDescriptorUpdateTemplateKHR;
    #endif //VK_KHR_descriptor_update_template
    #ifdef VK_KHR_descriptor_update_template
    PFN_vkDestroyDescriptorUpdateTemplateKHR pfvkDestroyDescriptorUpdateTemplateKHR;
    #endif //VK_KHR_descriptor_update_template
    #ifdef VK_KHR_descriptor_update_template
    PFN_vkUpdateDescriptorSetWithTemplateKHR pfvkUpdateDescriptorSetWithTemplateKHR;
    #endif //VK_KHR_descriptor_update_template
    #ifdef VK_KHR_descriptor_update_template
    PFN_vkCmdPushDescriptorSetWithTemplateKHR pfvkCmdPushDescriptorSetWithTemplateKHR;
    #endif //VK_KHR_descriptor_update_template
    #ifdef VK_KHR_shared_presentable_image
    PFN_vkGetSwapchainStatusKHR pfvkGetSwapchainStatusKHR;
    #endif //VK_KHR_shared_presentable_image
    #ifdef VK_KHR_external_fence_capabilities
    PFN_vkGetPhysicalDeviceExternalFencePropertiesKHR pfvkGetPhysicalDeviceExternalFencePropertiesKHR;
    #endif //VK_KHR_external_fence_capabilities
    #ifdef VK_KHR_external_fence_win32
    PFN_vkImportFenceWin32HandleKHR pfvkImportFenceWin32HandleKHR;
    #endif //VK_KHR_external_fence_win32
    #ifdef VK_KHR_external_fence_win32
    PFN_vkGetFenceWin32HandleKHR pfvkGetFenceWin32HandleKHR;
    #endif //VK_KHR_external_fence_win32
    #ifdef VK_KHR_external_fence_fd
    PFN_vkImportFenceFdKHR pfvkImportFenceFdKHR;
    #endif //VK_KHR_external_fence_fd
    #ifdef VK_KHR_external_fence_fd
    PFN_vkGetFenceFdKHR pfvkGetFenceFdKHR;
    #endif //VK_KHR_external_fence_fd
    #ifdef VK_KHR_get_surface_capabilities2
    PFN_vkGetPhysicalDeviceSurfaceCapabilities2KHR pfvkGetPhysicalDeviceSurfaceCapabilities2KHR;
    #endif //VK_KHR_get_surface_capabilities2
    #ifdef VK_KHR_get_surface_capabilities2
    PFN_vkGetPhysicalDeviceSurfaceFormats2KHR pfvkGetPhysicalDeviceSurfaceFormats2KHR;
    #endif //VK_KHR_get_surface_capabilities2
    #ifdef VK_KHR_get_memory_requirements2
    PFN_vkGetImageMemoryRequirements2KHR pfvkGetImageMemoryRequirements2KHR;
    #endif //VK_KHR_get_memory_requirements2
    #ifdef VK_KHR_get_memory_requirements2
    PFN_vkGetBufferMemoryRequirements2KHR pfvkGetBufferMemoryRequirements2KHR;
    #endif //VK_KHR_get_memory_requirements2
    #ifdef VK_KHR_get_memory_requirements2
    PFN_vkGetImageSparseMemoryRequirements2KHR pfvkGetImageSparseMemoryRequirements2KHR;
    #endif //VK_KHR_get_memory_requirements2
    #ifdef VK_KHR_sampler_ycbcr_conversion
    PFN_vkCreateSamplerYcbcrConversionKHR pfvkCreateSamplerYcbcrConversionKHR;
    #endif //VK_KHR_sampler_ycbcr_conversion
    #ifdef VK_KHR_sampler_ycbcr_conversion
    PFN_vkDestroySamplerYcbcrConversionKHR pfvkDestroySamplerYcbcrConversionKHR;
    #endif //VK_KHR_sampler_ycbcr_conversion
    #ifdef VK_KHR_bind_memory2
    PFN_vkBindBufferMemory2KHR pfvkBindBufferMemory2KHR;
    #endif //VK_KHR_bind_memory2
    #ifdef VK_KHR_bind_memory2
    PFN_vkBindImageMemory2KHR pfvkBindImageMemory2KHR;
    #endif //VK_KHR_bind_memory2
    #ifdef VK_EXT_debug_report
    PFN_vkCreateDebugReportCallbackEXT pfvkCreateDebugReportCallbackEXT;
    #endif //VK_EXT_debug_report
    #ifdef VK_EXT_debug_report
    PFN_vkDestroyDebugReportCallbackEXT pfvkDestroyDebugReportCallbackEXT;
    #endif //VK_EXT_debug_report
    #ifdef VK_EXT_debug_report
    PFN_vkDebugReportMessageEXT pfvkDebugReportMessageEXT;
    #endif //VK_EXT_debug_report
    #ifdef VK_EXT_debug_marker
    PFN_vkDebugMarkerSetObjectTagEXT pfvkDebugMarkerSetObjectTagEXT;
    #endif //VK_EXT_debug_marker
    #ifdef VK_EXT_debug_marker
    PFN_vkDebugMarkerSetObjectNameEXT pfvkDebugMarkerSetObjectNameEXT;
    #endif //VK_EXT_debug_marker
    #ifdef VK_EXT_debug_marker
    PFN_vkCmdDebugMarkerBeginEXT pfvkCmdDebugMarkerBeginEXT;
    #endif //VK_EXT_debug_marker
    #ifdef VK_EXT_debug_marker
    PFN_vkCmdDebugMarkerEndEXT pfvkCmdDebugMarkerEndEXT;
    #endif //VK_EXT_debug_marker
    #ifdef VK_EXT_debug_marker
    PFN_vkCmdDebugMarkerInsertEXT pfvkCmdDebugMarkerInsertEXT;
    #endif //VK_EXT_debug_marker
    #ifdef VK_AMD_draw_indirect_count
    PFN_vkCmdDrawIndirectCountAMD pfvkCmdDrawIndirectCountAMD;
    #endif //VK_AMD_draw_indirect_count
    #ifdef VK_AMD_draw_indirect_count
    PFN_vkCmdDrawIndexedIndirectCountAMD pfvkCmdDrawIndexedIndirectCountAMD;
    #endif //VK_AMD_draw_indirect_count
    #ifdef VK_AMD_shader_info
    PFN_vkGetShaderInfoAMD pfvkGetShaderInfoAMD;
    #endif //VK_AMD_shader_info
    #ifdef VK_NV_external_memory_capabilities
    PFN_vkGetPhysicalDeviceExternalImageFormatPropertiesNV pfvkGetPhysicalDeviceExternalImageFormatPropertiesNV;
    #endif //VK_NV_external_memory_capabilities
    #ifdef VK_NV_external_memory_win32
    PFN_vkGetMemoryWin32HandleNV pfvkGetMemoryWin32HandleNV;
    #endif //VK_NV_external_memory_win32
    #ifdef VK_KHX_device_group
    PFN_vkGetDeviceGroupPeerMemoryFeaturesKHX pfvkGetDeviceGroupPeerMemoryFeaturesKHX;
    #endif //VK_KHX_device_group
    #ifdef VK_KHX_device_group
    PFN_vkCmdSetDeviceMaskKHX pfvkCmdSetDeviceMaskKHX;
    #endif //VK_KHX_device_group
    #ifdef VK_KHX_device_group
    PFN_vkCmdDispatchBaseKHX pfvkCmdDispatchBaseKHX;
    #endif //VK_KHX_device_group
    #ifdef VK_KHX_device_group
    PFN_vkGetDeviceGroupPresentCapabilitiesKHX pfvkGetDeviceGroupPresentCapabilitiesKHX;
    #endif //VK_KHX_device_group
    #ifdef VK_KHX_device_group
    PFN_vkGetDeviceGroupSurfacePresentModesKHX pfvkGetDeviceGroupSurfacePresentModesKHX;
    #endif //VK_KHX_device_group
    #ifdef VK_KHX_device_group
    PFN_vkGetPhysicalDevicePresentRectanglesKHX pfvkGetPhysicalDevicePresentRectanglesKHX;
    #endif //VK_KHX_device_group
    #ifdef VK_KHX_device_group
    PFN_vkAcquireNextImage2KHX pfvkAcquireNextImage2KHX;
    #endif //VK_KHX_device_group
    #ifdef VK_NN_vi_surface
    PFN_vkCreateViSurfaceNN pfvkCreateViSurfaceNN;
    #endif //VK_NN_vi_surface
    #ifdef VK_KHX_device_group_creation
    PFN_vkEnumeratePhysicalDeviceGroupsKHX pfvkEnumeratePhysicalDeviceGroupsKHX;
    #endif //VK_KHX_device_group_creation
    #ifdef VK_NVX_device_generated_commands
    PFN_vkCmdProcessCommandsNVX pfvkCmdProcessCommandsNVX;
    #endif //VK_NVX_device_generated_commands
    #ifdef VK_NVX_device_generated_commands
    PFN_vkCmdReserveSpaceForCommandsNVX pfvkCmdReserveSpaceForCommandsNVX;
    #endif //VK_NVX_device_generated_commands
    #ifdef VK_NVX_device_generated_commands
    PFN_vkCreateIndirectCommandsLayoutNVX pfvkCreateIndirectCommandsLayoutNVX;
    #endif //VK_NVX_device_generated_commands
    #ifdef VK_NVX_device_generated_commands
    PFN_vkDestroyIndirectCommandsLayoutNVX pfvkDestroyIndirectCommandsLayoutNVX;
    #endif //VK_NVX_device_generated_commands
    #ifdef VK_NVX_device_generated_commands
    PFN_vkCreateObjectTableNVX pfvkCreateObjectTableNVX;
    #endif //VK_NVX_device_generated_commands
    #ifdef VK_NVX_device_generated_commands
    PFN_vkDestroyObjectTableNVX pfvkDestroyObjectTableNVX;
    #endif //VK_NVX_device_generated_commands
    #ifdef VK_NVX_device_generated_commands
    PFN_vkRegisterObjectsNVX pfvkRegisterObjectsNVX;
    #endif //VK_NVX_device_generated_commands
    #ifdef VK_NVX_device_generated_commands
    PFN_vkUnregisterObjectsNVX pfvkUnregisterObjectsNVX;
    #endif //VK_NVX_device_generated_commands
    #ifdef VK_NVX_device_generated_commands
    PFN_vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX pfvkGetPhysicalDeviceGeneratedCommandsPropertiesNVX;
    #endif //VK_NVX_device_generated_commands
    #ifdef VK_NV_clip_space_w_scaling
    PFN_vkCmdSetViewportWScalingNV pfvkCmdSetViewportWScalingNV;
    #endif //VK_NV_clip_space_w_scaling
    #ifdef VK_EXT_direct_mode_display
    PFN_vkReleaseDisplayEXT pfvkReleaseDisplayEXT;
    #endif //VK_EXT_direct_mode_display
    #ifdef VK_EXT_acquire_xlib_display
    PFN_vkAcquireXlibDisplayEXT pfvkAcquireXlibDisplayEXT;
    #endif //VK_EXT_acquire_xlib_display
    #ifdef VK_EXT_acquire_xlib_display
    PFN_vkGetRandROutputDisplayEXT pfvkGetRandROutputDisplayEXT;
    #endif //VK_EXT_acquire_xlib_display
    #ifdef VK_EXT_display_surface_counter
    PFN_vkGetPhysicalDeviceSurfaceCapabilities2EXT pfvkGetPhysicalDeviceSurfaceCapabilities2EXT;
    #endif //VK_EXT_display_surface_counter
    #ifdef VK_EXT_display_control
    PFN_vkDisplayPowerControlEXT pfvkDisplayPowerControlEXT;
    #endif //VK_EXT_display_control
    #ifdef VK_EXT_display_control
    PFN_vkRegisterDeviceEventEXT pfvkRegisterDeviceEventEXT;
    #endif //VK_EXT_display_control
    #ifdef VK_EXT_display_control
    PFN_vkDestroyFence pfvkDestroyFence;
    #endif //VK_EXT_display_control
    #ifdef VK_EXT_display_control
    PFN_vkRegisterDisplayEventEXT pfvkRegisterDisplayEventEXT;
    #endif //VK_EXT_display_control
    #ifdef VK_EXT_display_control
    PFN_vkGetSwapchainCounterEXT pfvkGetSwapchainCounterEXT;
    #endif //VK_EXT_display_control
    #ifdef VK_GOOGLE_display_timing
    PFN_vkGetRefreshCycleDurationGOOGLE pfvkGetRefreshCycleDurationGOOGLE;
    #endif //VK_GOOGLE_display_timing
    #ifdef VK_GOOGLE_display_timing
    PFN_vkGetPastPresentationTimingGOOGLE pfvkGetPastPresentationTimingGOOGLE;
    #endif //VK_GOOGLE_display_timing
    #ifdef VK_EXT_discard_rectangles
    PFN_vkCmdSetDiscardRectangleEXT pfvkCmdSetDiscardRectangleEXT;
    #endif //VK_EXT_discard_rectangles
    #ifdef VK_EXT_hdr_metadata
    PFN_vkSetHdrMetadataEXT pfvkSetHdrMetadataEXT;
    #endif //VK_EXT_hdr_metadata
    #ifdef VK_MVK_ios_surface
    PFN_vkCreateIOSSurfaceMVK pfvkCreateIOSSurfaceMVK;
    #endif //VK_MVK_ios_surface
    #ifdef VK_MVK_macos_surface
    PFN_vkCreateMacOSSurfaceMVK pfvkCreateMacOSSurfaceMVK;
    #endif //VK_MVK_macos_surface
    #ifdef VK_EXT_sample_locations
    PFN_vkCmdSetSampleLocationsEXT pfvkCmdSetSampleLocationsEXT;
    #endif //VK_EXT_sample_locations
    #ifdef VK_EXT_sample_locations
    PFN_vkGetPhysicalDeviceMultisamplePropertiesEXT pfvkGetPhysicalDeviceMultisamplePropertiesEXT;
    #endif //VK_EXT_sample_locations
    #ifdef VK_EXT_validation_cache
    PFN_vkCreateValidationCacheEXT pfvkCreateValidationCacheEXT;
    #endif //VK_EXT_validation_cache
    #ifdef VK_EXT_validation_cache
    PFN_vkDestroyValidationCacheEXT pfvkDestroyValidationCacheEXT;
    #endif //VK_EXT_validation_cache
    #ifdef VK_EXT_validation_cache
    PFN_vkMergeValidationCachesEXT pfvkMergeValidationCachesEXT;
    #endif //VK_EXT_validation_cache
    #ifdef VK_EXT_validation_cache
    PFN_vkGetValidationCacheDataEXT pfvkGetValidationCacheDataEXT;
    #endif //VK_EXT_validation_cache

    void load_vulkan_fct_ptrs(VkInstance instance)
    {
#ifdef VK_KHR_display
	    pfvkGetPhysicalDeviceDisplayPropertiesKHR = reinterpret_cast<PFN_vkGetPhysicalDeviceDisplayPropertiesKHR>(vkGetInstanceProcAddr(instance, "vkGetPhysicalDeviceDisplayPropertiesKHR"));
#endif
#ifdef VK_KHR_display
	    pfvkGetPhysicalDeviceDisplayPlanePropertiesKHR = reinterpret_cast<PFN_vkGetPhysicalDeviceDisplayPlanePropertiesKHR>(vkGetInstanceProcAddr(instance, "vkGetPhysicalDeviceDisplayPlanePropertiesKHR"));
#endif
#ifdef VK_KHR_display
	    pfvkGetDisplayPlaneSupportedDisplaysKHR = reinterpret_cast<PFN_vkGetDisplayPlaneSupportedDisplaysKHR>(vkGetInstanceProcAddr(instance, "vkGetDisplayPlaneSupportedDisplaysKHR"));
#endif
#ifdef VK_KHR_display
	    pfvkGetDisplayModePropertiesKHR = reinterpret_cast<PFN_vkGetDisplayModePropertiesKHR>(vkGetInstanceProcAddr(instance, "vkGetDisplayModePropertiesKHR"));
#endif
#ifdef VK_KHR_display
	    pfvkCreateDisplayModeKHR = reinterpret_cast<PFN_vkCreateDisplayModeKHR>(vkGetInstanceProcAddr(instance, "vkCreateDisplayModeKHR"));
#endif
#ifdef VK_KHR_display
	    pfvkGetDisplayPlaneCapabilitiesKHR = reinterpret_cast<PFN_vkGetDisplayPlaneCapabilitiesKHR>(vkGetInstanceProcAddr(instance, "vkGetDisplayPlaneCapabilitiesKHR"));
#endif
#ifdef VK_KHR_display
	    pfvkCreateDisplayPlaneSurfaceKHR = reinterpret_cast<PFN_vkCreateDisplayPlaneSurfaceKHR>(vkGetInstanceProcAddr(instance, "vkCreateDisplayPlaneSurfaceKHR"));
#endif
#ifdef VK_KHR_display
	    pfvkDestroySurfaceKHR = reinterpret_cast<PFN_vkDestroySurfaceKHR>(vkGetInstanceProcAddr(instance, "vkDestroySurfaceKHR"));
#endif
#ifdef VK_KHR_display_swapchain
	    pfvkCreateSharedSwapchainsKHR = reinterpret_cast<PFN_vkCreateSharedSwapchainsKHR>(vkGetInstanceProcAddr(instance, "vkCreateSharedSwapchainsKHR"));
#endif
#ifdef VK_KHR_get_physical_device_properties2
	    pfvkGetPhysicalDeviceFeatures2KHR = reinterpret_cast<PFN_vkGetPhysicalDeviceFeatures2KHR>(vkGetInstanceProcAddr(instance, "vkGetPhysicalDeviceFeatures2KHR"));
#endif
#ifdef VK_KHR_get_physical_device_properties2
	    pfvkGetPhysicalDeviceProperties2KHR = reinterpret_cast<PFN_vkGetPhysicalDeviceProperties2KHR>(vkGetInstanceProcAddr(instance, "vkGetPhysicalDeviceProperties2KHR"));
#endif
#ifdef VK_KHR_get_physical_device_properties2
	    pfvkGetPhysicalDeviceFormatProperties2KHR = reinterpret_cast<PFN_vkGetPhysicalDeviceFormatProperties2KHR>(vkGetInstanceProcAddr(instance, "vkGetPhysicalDeviceFormatProperties2KHR"));
#endif
#ifdef VK_KHR_get_physical_device_properties2
	    pfvkGetPhysicalDeviceImageFormatProperties2KHR = reinterpret_cast<PFN_vkGetPhysicalDeviceImageFormatProperties2KHR>(vkGetInstanceProcAddr(instance, "vkGetPhysicalDeviceImageFormatProperties2KHR"));
#endif
#ifdef VK_KHR_get_physical_device_properties2
	    pfvkGetPhysicalDeviceQueueFamilyProperties2KHR = reinterpret_cast<PFN_vkGetPhysicalDeviceQueueFamilyProperties2KHR>(vkGetInstanceProcAddr(instance, "vkGetPhysicalDeviceQueueFamilyProperties2KHR"));
#endif
#ifdef VK_KHR_get_physical_device_properties2
	    pfvkGetPhysicalDeviceMemoryProperties2KHR = reinterpret_cast<PFN_vkGetPhysicalDeviceMemoryProperties2KHR>(vkGetInstanceProcAddr(instance, "vkGetPhysicalDeviceMemoryProperties2KHR"));
#endif
#ifdef VK_KHR_get_physical_device_properties2
	    pfvkGetPhysicalDeviceSparseImageFormatProperties2KHR = reinterpret_cast<PFN_vkGetPhysicalDeviceSparseImageFormatProperties2KHR>(vkGetInstanceProcAddr(instance, "vkGetPhysicalDeviceSparseImageFormatProperties2KHR"));
#endif
#ifdef VK_KHR_maintenance1
	    pfvkTrimCommandPoolKHR = reinterpret_cast<PFN_vkTrimCommandPoolKHR>(vkGetInstanceProcAddr(instance, "vkTrimCommandPoolKHR"));
#endif
#ifdef VK_KHR_external_memory_capabilities
	    pfvkGetPhysicalDeviceExternalBufferPropertiesKHR = reinterpret_cast<PFN_vkGetPhysicalDeviceExternalBufferPropertiesKHR>(vkGetInstanceProcAddr(instance, "vkGetPhysicalDeviceExternalBufferPropertiesKHR"));
#endif
#ifdef VK_KHR_external_memory_win32
	    pfvkGetMemoryWin32HandleKHR = reinterpret_cast<PFN_vkGetMemoryWin32HandleKHR>(vkGetInstanceProcAddr(instance, "vkGetMemoryWin32HandleKHR"));
#endif
#ifdef VK_KHR_external_memory_win32
	    pfvkGetMemoryWin32HandlePropertiesKHR = reinterpret_cast<PFN_vkGetMemoryWin32HandlePropertiesKHR>(vkGetInstanceProcAddr(instance, "vkGetMemoryWin32HandlePropertiesKHR"));
#endif
#ifdef VK_KHR_external_memory_fd
	    pfvkGetMemoryFdKHR = reinterpret_cast<PFN_vkGetMemoryFdKHR>(vkGetInstanceProcAddr(instance, "vkGetMemoryFdKHR"));
#endif
#ifdef VK_KHR_external_memory_fd
	    pfvkGetMemoryFdPropertiesKHR = reinterpret_cast<PFN_vkGetMemoryFdPropertiesKHR>(vkGetInstanceProcAddr(instance, "vkGetMemoryFdPropertiesKHR"));
#endif
#ifdef VK_KHR_external_semaphore_capabilities
	    pfvkGetPhysicalDeviceExternalSemaphorePropertiesKHR = reinterpret_cast<PFN_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR>(vkGetInstanceProcAddr(instance, "vkGetPhysicalDeviceExternalSemaphorePropertiesKHR"));
#endif
#ifdef VK_KHR_external_semaphore_win32
	    pfvkImportSemaphoreWin32HandleKHR = reinterpret_cast<PFN_vkImportSemaphoreWin32HandleKHR>(vkGetInstanceProcAddr(instance, "vkImportSemaphoreWin32HandleKHR"));
#endif
#ifdef VK_KHR_external_semaphore_win32
	    pfvkGetSemaphoreWin32HandleKHR = reinterpret_cast<PFN_vkGetSemaphoreWin32HandleKHR>(vkGetInstanceProcAddr(instance, "vkGetSemaphoreWin32HandleKHR"));
#endif
#ifdef VK_KHR_external_semaphore_fd
	    pfvkImportSemaphoreFdKHR = reinterpret_cast<PFN_vkImportSemaphoreFdKHR>(vkGetInstanceProcAddr(instance, "vkImportSemaphoreFdKHR"));
#endif
#ifdef VK_KHR_external_semaphore_fd
	    pfvkGetSemaphoreFdKHR = reinterpret_cast<PFN_vkGetSemaphoreFdKHR>(vkGetInstanceProcAddr(instance, "vkGetSemaphoreFdKHR"));
#endif
#ifdef VK_KHR_push_descriptor
	    pfvkCmdPushDescriptorSetKHR = reinterpret_cast<PFN_vkCmdPushDescriptorSetKHR>(vkGetInstanceProcAddr(instance, "vkCmdPushDescriptorSetKHR"));
#endif
#ifdef VK_KHR_descriptor_update_template
	    pfvkCreateDescriptorUpdateTemplateKHR = reinterpret_cast<PFN_vkCreateDescriptorUpdateTemplateKHR>(vkGetInstanceProcAddr(instance, "vkCreateDescriptorUpdateTemplateKHR"));
#endif
#ifdef VK_KHR_descriptor_update_template
	    pfvkDestroyDescriptorUpdateTemplateKHR = reinterpret_cast<PFN_vkDestroyDescriptorUpdateTemplateKHR>(vkGetInstanceProcAddr(instance, "vkDestroyDescriptorUpdateTemplateKHR"));
#endif
#ifdef VK_KHR_descriptor_update_template
	    pfvkUpdateDescriptorSetWithTemplateKHR = reinterpret_cast<PFN_vkUpdateDescriptorSetWithTemplateKHR>(vkGetInstanceProcAddr(instance, "vkUpdateDescriptorSetWithTemplateKHR"));
#endif
#ifdef VK_KHR_descriptor_update_template
	    pfvkCmdPushDescriptorSetWithTemplateKHR = reinterpret_cast<PFN_vkCmdPushDescriptorSetWithTemplateKHR>(vkGetInstanceProcAddr(instance, "vkCmdPushDescriptorSetWithTemplateKHR"));
#endif
#ifdef VK_KHR_shared_presentable_image
	    pfvkGetSwapchainStatusKHR = reinterpret_cast<PFN_vkGetSwapchainStatusKHR>(vkGetInstanceProcAddr(instance, "vkGetSwapchainStatusKHR"));
#endif
#ifdef VK_KHR_external_fence_capabilities
	    pfvkGetPhysicalDeviceExternalFencePropertiesKHR = reinterpret_cast<PFN_vkGetPhysicalDeviceExternalFencePropertiesKHR>(vkGetInstanceProcAddr(instance, "vkGetPhysicalDeviceExternalFencePropertiesKHR"));
#endif
#ifdef VK_KHR_external_fence_win32
	    pfvkImportFenceWin32HandleKHR = reinterpret_cast<PFN_vkImportFenceWin32HandleKHR>(vkGetInstanceProcAddr(instance, "vkImportFenceWin32HandleKHR"));
#endif
#ifdef VK_KHR_external_fence_win32
	    pfvkGetFenceWin32HandleKHR = reinterpret_cast<PFN_vkGetFenceWin32HandleKHR>(vkGetInstanceProcAddr(instance, "vkGetFenceWin32HandleKHR"));
#endif
#ifdef VK_KHR_external_fence_fd
	    pfvkImportFenceFdKHR = reinterpret_cast<PFN_vkImportFenceFdKHR>(vkGetInstanceProcAddr(instance, "vkImportFenceFdKHR"));
#endif
#ifdef VK_KHR_external_fence_fd
	    pfvkGetFenceFdKHR = reinterpret_cast<PFN_vkGetFenceFdKHR>(vkGetInstanceProcAddr(instance, "vkGetFenceFdKHR"));
#endif
#ifdef VK_KHR_get_surface_capabilities2
	    pfvkGetPhysicalDeviceSurfaceCapabilities2KHR = reinterpret_cast<PFN_vkGetPhysicalDeviceSurfaceCapabilities2KHR>(vkGetInstanceProcAddr(instance, "vkGetPhysicalDeviceSurfaceCapabilities2KHR"));
#endif
#ifdef VK_KHR_get_surface_capabilities2
	    pfvkGetPhysicalDeviceSurfaceFormats2KHR = reinterpret_cast<PFN_vkGetPhysicalDeviceSurfaceFormats2KHR>(vkGetInstanceProcAddr(instance, "vkGetPhysicalDeviceSurfaceFormats2KHR"));
#endif
#ifdef VK_KHR_get_memory_requirements2
	    pfvkGetImageMemoryRequirements2KHR = reinterpret_cast<PFN_vkGetImageMemoryRequirements2KHR>(vkGetInstanceProcAddr(instance, "vkGetImageMemoryRequirements2KHR"));
#endif
#ifdef VK_KHR_get_memory_requirements2
	    pfvkGetBufferMemoryRequirements2KHR = reinterpret_cast<PFN_vkGetBufferMemoryRequirements2KHR>(vkGetInstanceProcAddr(instance, "vkGetBufferMemoryRequirements2KHR"));
#endif
#ifdef VK_KHR_get_memory_requirements2
	    pfvkGetImageSparseMemoryRequirements2KHR = reinterpret_cast<PFN_vkGetImageSparseMemoryRequirements2KHR>(vkGetInstanceProcAddr(instance, "vkGetImageSparseMemoryRequirements2KHR"));
#endif
#ifdef VK_KHR_sampler_ycbcr_conversion
	    pfvkCreateSamplerYcbcrConversionKHR = reinterpret_cast<PFN_vkCreateSamplerYcbcrConversionKHR>(vkGetInstanceProcAddr(instance, "vkCreateSamplerYcbcrConversionKHR"));
#endif
#ifdef VK_KHR_sampler_ycbcr_conversion
	    pfvkDestroySamplerYcbcrConversionKHR = reinterpret_cast<PFN_vkDestroySamplerYcbcrConversionKHR>(vkGetInstanceProcAddr(instance, "vkDestroySamplerYcbcrConversionKHR"));
#endif
#ifdef VK_KHR_bind_memory2
	    pfvkBindBufferMemory2KHR = reinterpret_cast<PFN_vkBindBufferMemory2KHR>(vkGetInstanceProcAddr(instance, "vkBindBufferMemory2KHR"));
#endif
#ifdef VK_KHR_bind_memory2
	    pfvkBindImageMemory2KHR = reinterpret_cast<PFN_vkBindImageMemory2KHR>(vkGetInstanceProcAddr(instance, "vkBindImageMemory2KHR"));
#endif
#ifdef VK_EXT_debug_report
	    pfvkCreateDebugReportCallbackEXT = reinterpret_cast<PFN_vkCreateDebugReportCallbackEXT>(vkGetInstanceProcAddr(instance, "vkCreateDebugReportCallbackEXT"));
#endif
#ifdef VK_EXT_debug_report
	    pfvkDestroyDebugReportCallbackEXT = reinterpret_cast<PFN_vkDestroyDebugReportCallbackEXT>(vkGetInstanceProcAddr(instance, "vkDestroyDebugReportCallbackEXT"));
#endif
#ifdef VK_EXT_debug_report
	    pfvkDebugReportMessageEXT = reinterpret_cast<PFN_vkDebugReportMessageEXT>(vkGetInstanceProcAddr(instance, "vkDebugReportMessageEXT"));
#endif
#ifdef VK_EXT_debug_marker
	    pfvkDebugMarkerSetObjectTagEXT = reinterpret_cast<PFN_vkDebugMarkerSetObjectTagEXT>(vkGetInstanceProcAddr(instance, "vkDebugMarkerSetObjectTagEXT"));
#endif
#ifdef VK_EXT_debug_marker
	    pfvkDebugMarkerSetObjectNameEXT = reinterpret_cast<PFN_vkDebugMarkerSetObjectNameEXT>(vkGetInstanceProcAddr(instance, "vkDebugMarkerSetObjectNameEXT"));
#endif
#ifdef VK_EXT_debug_marker
	    pfvkCmdDebugMarkerBeginEXT = reinterpret_cast<PFN_vkCmdDebugMarkerBeginEXT>(vkGetInstanceProcAddr(instance, "vkCmdDebugMarkerBeginEXT"));
#endif
#ifdef VK_EXT_debug_marker
	    pfvkCmdDebugMarkerEndEXT = reinterpret_cast<PFN_vkCmdDebugMarkerEndEXT>(vkGetInstanceProcAddr(instance, "vkCmdDebugMarkerEndEXT"));
#endif
#ifdef VK_EXT_debug_marker
	    pfvkCmdDebugMarkerInsertEXT = reinterpret_cast<PFN_vkCmdDebugMarkerInsertEXT>(vkGetInstanceProcAddr(instance, "vkCmdDebugMarkerInsertEXT"));
#endif
#ifdef VK_AMD_draw_indirect_count
	    pfvkCmdDrawIndirectCountAMD = reinterpret_cast<PFN_vkCmdDrawIndirectCountAMD>(vkGetInstanceProcAddr(instance, "vkCmdDrawIndirectCountAMD"));
#endif
#ifdef VK_AMD_draw_indirect_count
	    pfvkCmdDrawIndexedIndirectCountAMD = reinterpret_cast<PFN_vkCmdDrawIndexedIndirectCountAMD>(vkGetInstanceProcAddr(instance, "vkCmdDrawIndexedIndirectCountAMD"));
#endif
#ifdef VK_AMD_shader_info
	    pfvkGetShaderInfoAMD = reinterpret_cast<PFN_vkGetShaderInfoAMD>(vkGetInstanceProcAddr(instance, "vkGetShaderInfoAMD"));
#endif
#ifdef VK_NV_external_memory_capabilities
	    pfvkGetPhysicalDeviceExternalImageFormatPropertiesNV = reinterpret_cast<PFN_vkGetPhysicalDeviceExternalImageFormatPropertiesNV>(vkGetInstanceProcAddr(instance, "vkGetPhysicalDeviceExternalImageFormatPropertiesNV"));
#endif
#ifdef VK_NV_external_memory_win32
	    pfvkGetMemoryWin32HandleNV = reinterpret_cast<PFN_vkGetMemoryWin32HandleNV>(vkGetInstanceProcAddr(instance, "vkGetMemoryWin32HandleNV"));
#endif
#ifdef VK_KHX_device_group
	    pfvkGetDeviceGroupPeerMemoryFeaturesKHX = reinterpret_cast<PFN_vkGetDeviceGroupPeerMemoryFeaturesKHX>(vkGetInstanceProcAddr(instance, "vkGetDeviceGroupPeerMemoryFeaturesKHX"));
#endif
#ifdef VK_KHX_device_group
	    pfvkCmdSetDeviceMaskKHX = reinterpret_cast<PFN_vkCmdSetDeviceMaskKHX>(vkGetInstanceProcAddr(instance, "vkCmdSetDeviceMaskKHX"));
#endif
#ifdef VK_KHX_device_group
	    pfvkCmdDispatchBaseKHX = reinterpret_cast<PFN_vkCmdDispatchBaseKHX>(vkGetInstanceProcAddr(instance, "vkCmdDispatchBaseKHX"));
#endif
#ifdef VK_KHX_device_group
	    pfvkGetDeviceGroupPresentCapabilitiesKHX = reinterpret_cast<PFN_vkGetDeviceGroupPresentCapabilitiesKHX>(vkGetInstanceProcAddr(instance, "vkGetDeviceGroupPresentCapabilitiesKHX"));
#endif
#ifdef VK_KHX_device_group
	    pfvkGetDeviceGroupSurfacePresentModesKHX = reinterpret_cast<PFN_vkGetDeviceGroupSurfacePresentModesKHX>(vkGetInstanceProcAddr(instance, "vkGetDeviceGroupSurfacePresentModesKHX"));
#endif
#ifdef VK_KHX_device_group
	    pfvkGetPhysicalDevicePresentRectanglesKHX = reinterpret_cast<PFN_vkGetPhysicalDevicePresentRectanglesKHX>(vkGetInstanceProcAddr(instance, "vkGetPhysicalDevicePresentRectanglesKHX"));
#endif
#ifdef VK_KHX_device_group
	    pfvkAcquireNextImage2KHX = reinterpret_cast<PFN_vkAcquireNextImage2KHX>(vkGetInstanceProcAddr(instance, "vkAcquireNextImage2KHX"));
#endif
#ifdef VK_NN_vi_surface
	    pfvkCreateViSurfaceNN = reinterpret_cast<PFN_vkCreateViSurfaceNN>(vkGetInstanceProcAddr(instance, "vkCreateViSurfaceNN"));
#endif
#ifdef VK_KHX_device_group_creation
	    pfvkEnumeratePhysicalDeviceGroupsKHX = reinterpret_cast<PFN_vkEnumeratePhysicalDeviceGroupsKHX>(vkGetInstanceProcAddr(instance, "vkEnumeratePhysicalDeviceGroupsKHX"));
#endif
#ifdef VK_NVX_device_generated_commands
	    pfvkCmdProcessCommandsNVX = reinterpret_cast<PFN_vkCmdProcessCommandsNVX>(vkGetInstanceProcAddr(instance, "vkCmdProcessCommandsNVX"));
#endif
#ifdef VK_NVX_device_generated_commands
	    pfvkCmdReserveSpaceForCommandsNVX = reinterpret_cast<PFN_vkCmdReserveSpaceForCommandsNVX>(vkGetInstanceProcAddr(instance, "vkCmdReserveSpaceForCommandsNVX"));
#endif
#ifdef VK_NVX_device_generated_commands
	    pfvkCreateIndirectCommandsLayoutNVX = reinterpret_cast<PFN_vkCreateIndirectCommandsLayoutNVX>(vkGetInstanceProcAddr(instance, "vkCreateIndirectCommandsLayoutNVX"));
#endif
#ifdef VK_NVX_device_generated_commands
	    pfvkDestroyIndirectCommandsLayoutNVX = reinterpret_cast<PFN_vkDestroyIndirectCommandsLayoutNVX>(vkGetInstanceProcAddr(instance, "vkDestroyIndirectCommandsLayoutNVX"));
#endif
#ifdef VK_NVX_device_generated_commands
	    pfvkCreateObjectTableNVX = reinterpret_cast<PFN_vkCreateObjectTableNVX>(vkGetInstanceProcAddr(instance, "vkCreateObjectTableNVX"));
#endif
#ifdef VK_NVX_device_generated_commands
	    pfvkDestroyObjectTableNVX = reinterpret_cast<PFN_vkDestroyObjectTableNVX>(vkGetInstanceProcAddr(instance, "vkDestroyObjectTableNVX"));
#endif
#ifdef VK_NVX_device_generated_commands
	    pfvkRegisterObjectsNVX = reinterpret_cast<PFN_vkRegisterObjectsNVX>(vkGetInstanceProcAddr(instance, "vkRegisterObjectsNVX"));
#endif
#ifdef VK_NVX_device_generated_commands
	    pfvkUnregisterObjectsNVX = reinterpret_cast<PFN_vkUnregisterObjectsNVX>(vkGetInstanceProcAddr(instance, "vkUnregisterObjectsNVX"));
#endif
#ifdef VK_NVX_device_generated_commands
	    pfvkGetPhysicalDeviceGeneratedCommandsPropertiesNVX = reinterpret_cast<PFN_vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX>(vkGetInstanceProcAddr(instance, "vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX"));
#endif
#ifdef VK_NV_clip_space_w_scaling
	    pfvkCmdSetViewportWScalingNV = reinterpret_cast<PFN_vkCmdSetViewportWScalingNV>(vkGetInstanceProcAddr(instance, "vkCmdSetViewportWScalingNV"));
#endif
#ifdef VK_EXT_direct_mode_display
	    pfvkReleaseDisplayEXT = reinterpret_cast<PFN_vkReleaseDisplayEXT>(vkGetInstanceProcAddr(instance, "vkReleaseDisplayEXT"));
#endif
#ifdef VK_EXT_acquire_xlib_display
	    pfvkAcquireXlibDisplayEXT = reinterpret_cast<PFN_vkAcquireXlibDisplayEXT>(vkGetInstanceProcAddr(instance, "vkAcquireXlibDisplayEXT"));
#endif
#ifdef VK_EXT_acquire_xlib_display
	    pfvkGetRandROutputDisplayEXT = reinterpret_cast<PFN_vkGetRandROutputDisplayEXT>(vkGetInstanceProcAddr(instance, "vkGetRandROutputDisplayEXT"));
#endif
#ifdef VK_EXT_display_surface_counter
	    pfvkGetPhysicalDeviceSurfaceCapabilities2EXT = reinterpret_cast<PFN_vkGetPhysicalDeviceSurfaceCapabilities2EXT>(vkGetInstanceProcAddr(instance, "vkGetPhysicalDeviceSurfaceCapabilities2EXT"));
#endif
#ifdef VK_EXT_display_control
	    pfvkDisplayPowerControlEXT = reinterpret_cast<PFN_vkDisplayPowerControlEXT>(vkGetInstanceProcAddr(instance, "vkDisplayPowerControlEXT"));
#endif
#ifdef VK_EXT_display_control
	    pfvkRegisterDeviceEventEXT = reinterpret_cast<PFN_vkRegisterDeviceEventEXT>(vkGetInstanceProcAddr(instance, "vkRegisterDeviceEventEXT"));
#endif
#ifdef VK_EXT_display_control
	    pfvkDestroyFence = reinterpret_cast<PFN_vkDestroyFence>(vkGetInstanceProcAddr(instance, "vkDestroyFence"));
#endif
#ifdef VK_EXT_display_control
	    pfvkRegisterDisplayEventEXT = reinterpret_cast<PFN_vkRegisterDisplayEventEXT>(vkGetInstanceProcAddr(instance, "vkRegisterDisplayEventEXT"));
#endif
#ifdef VK_EXT_display_control
	    pfvkGetSwapchainCounterEXT = reinterpret_cast<PFN_vkGetSwapchainCounterEXT>(vkGetInstanceProcAddr(instance, "vkGetSwapchainCounterEXT"));
#endif
#ifdef VK_GOOGLE_display_timing
	    pfvkGetRefreshCycleDurationGOOGLE = reinterpret_cast<PFN_vkGetRefreshCycleDurationGOOGLE>(vkGetInstanceProcAddr(instance, "vkGetRefreshCycleDurationGOOGLE"));
#endif
#ifdef VK_GOOGLE_display_timing
	    pfvkGetPastPresentationTimingGOOGLE = reinterpret_cast<PFN_vkGetPastPresentationTimingGOOGLE>(vkGetInstanceProcAddr(instance, "vkGetPastPresentationTimingGOOGLE"));
#endif
#ifdef VK_EXT_discard_rectangles
	    pfvkCmdSetDiscardRectangleEXT = reinterpret_cast<PFN_vkCmdSetDiscardRectangleEXT>(vkGetInstanceProcAddr(instance, "vkCmdSetDiscardRectangleEXT"));
#endif
#ifdef VK_EXT_hdr_metadata
	    pfvkSetHdrMetadataEXT = reinterpret_cast<PFN_vkSetHdrMetadataEXT>(vkGetInstanceProcAddr(instance, "vkSetHdrMetadataEXT"));
#endif
#ifdef VK_MVK_ios_surface
	    pfvkCreateIOSSurfaceMVK = reinterpret_cast<PFN_vkCreateIOSSurfaceMVK>(vkGetInstanceProcAddr(instance, "vkCreateIOSSurfaceMVK"));
#endif
#ifdef VK_MVK_macos_surface
	    pfvkCreateMacOSSurfaceMVK = reinterpret_cast<PFN_vkCreateMacOSSurfaceMVK>(vkGetInstanceProcAddr(instance, "vkCreateMacOSSurfaceMVK"));
#endif
#ifdef VK_EXT_sample_locations
	    pfvkCmdSetSampleLocationsEXT = reinterpret_cast<PFN_vkCmdSetSampleLocationsEXT>(vkGetInstanceProcAddr(instance, "vkCmdSetSampleLocationsEXT"));
#endif
#ifdef VK_EXT_sample_locations
	    pfvkGetPhysicalDeviceMultisamplePropertiesEXT = reinterpret_cast<PFN_vkGetPhysicalDeviceMultisamplePropertiesEXT>(vkGetInstanceProcAddr(instance, "vkGetPhysicalDeviceMultisamplePropertiesEXT"));
#endif
#ifdef VK_EXT_validation_cache
	    pfvkCreateValidationCacheEXT = reinterpret_cast<PFN_vkCreateValidationCacheEXT>(vkGetInstanceProcAddr(instance, "vkCreateValidationCacheEXT"));
#endif
#ifdef VK_EXT_validation_cache
	    pfvkDestroyValidationCacheEXT = reinterpret_cast<PFN_vkDestroyValidationCacheEXT>(vkGetInstanceProcAddr(instance, "vkDestroyValidationCacheEXT"));
#endif
#ifdef VK_EXT_validation_cache
	    pfvkMergeValidationCachesEXT = reinterpret_cast<PFN_vkMergeValidationCachesEXT>(vkGetInstanceProcAddr(instance, "vkMergeValidationCachesEXT"));
#endif
#ifdef VK_EXT_validation_cache
	    pfvkGetValidationCacheDataEXT = reinterpret_cast<PFN_vkGetValidationCacheDataEXT>(vkGetInstanceProcAddr(instance, "vkGetValidationCacheDataEXT"));
#endif
  }
%}

%{

struct VkApplicationInfoRAII {
   VkApplicationInfo nonRaiiObj;
    std::string                                 strApplicationName;
    std::string                                 strEngineName;
};

std::shared_ptr<VkApplicationInfoRAII> ApplicationInfo(
    const std::string &                         strApplicationName,
    uint32_t                                    applicationVersion,
    const std::string &                         strEngineName,
    uint32_t                                    engineVersion,
    uint32_t                                    apiVersion)
   {
      std::shared_ptr<VkApplicationInfoRAII> raii_obj(new VkApplicationInfoRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_APPLICATION_INFO;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->strApplicationName = strApplicationName;
      raii_obj->nonRaiiObj.pApplicationName = &raii_obj->strApplicationName[0];
      raii_obj->nonRaiiObj.applicationVersion = applicationVersion;
      raii_obj->strEngineName = strEngineName;
      raii_obj->nonRaiiObj.pEngineName = &raii_obj->strEngineName[0];
      raii_obj->nonRaiiObj.engineVersion = engineVersion;
      raii_obj->nonRaiiObj.apiVersion = apiVersion;
      return raii_obj;
   }

struct VkInstanceCreateInfoRAII {
   VkInstanceCreateInfo nonRaiiObj;
    std::shared_ptr<VkApplicationInfoRAII>      pApplicationInfo;
    std::vector<std::string>                    vecEnabledLayerNames;
    std::vector<const char *>                   vecPtrEnabledLayerNames;
    std::vector<std::string>                    vecEnabledExtensionNames;
    std::vector<const char *>                   vecPtrEnabledExtensionNames;
};

std::shared_ptr<VkInstanceCreateInfoRAII> InstanceCreateInfo(
    VkInstanceCreateFlags                       flags,
    const std::shared_ptr<VkApplicationInfoRAII> &pApplicationInfo,
    const std::vector<std::string> &            vecEnabledLayerNames,
    const std::vector<std::string> &            vecEnabledExtensionNames)
   {
      std::shared_ptr<VkInstanceCreateInfoRAII> raii_obj(new VkInstanceCreateInfoRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.flags = flags;
      raii_obj->pApplicationInfo = pApplicationInfo;
      if ( pApplicationInfo ) 
      {
          raii_obj->nonRaiiObj.pApplicationInfo = &(pApplicationInfo->nonRaiiObj);
      }
      else
      {
          raii_obj->nonRaiiObj.pApplicationInfo = nullptr;
      }
      raii_obj->nonRaiiObj.enabledLayerCount = static_cast<uint32_t>(vecEnabledLayerNames.size());
      raii_obj->vecEnabledLayerNames = vecEnabledLayerNames;
      raii_obj->vecPtrEnabledLayerNames.resize(vecEnabledLayerNames.size());
      for (size_t i=0; i<vecEnabledLayerNames.size(); ++i) 
           raii_obj->vecPtrEnabledLayerNames[i] = raii_obj->vecEnabledLayerNames[i].c_str();
      raii_obj->nonRaiiObj.ppEnabledLayerNames = &raii_obj->vecPtrEnabledLayerNames[0];
      raii_obj->nonRaiiObj.enabledExtensionCount = static_cast<uint32_t>(vecEnabledExtensionNames.size());
      raii_obj->vecEnabledExtensionNames = vecEnabledExtensionNames;
      raii_obj->vecPtrEnabledExtensionNames.resize(vecEnabledExtensionNames.size());
      for (size_t i=0; i<vecEnabledExtensionNames.size(); ++i) 
           raii_obj->vecPtrEnabledExtensionNames[i] = raii_obj->vecEnabledExtensionNames[i].c_str();
      raii_obj->nonRaiiObj.ppEnabledExtensionNames = &raii_obj->vecPtrEnabledExtensionNames[0];
      return raii_obj;
   }

VkAllocationCallbacks AllocationCallbacks(
    PFN_vkAllocationFunction                    pfnAllocation,
    PFN_vkReallocationFunction                  pfnReallocation,
    PFN_vkFreeFunction                          pfnFree,
    PFN_vkInternalAllocationNotification        pfnInternalAllocation,
    PFN_vkInternalFreeNotification              pfnInternalFree)
   {
      VkAllocationCallbacks obj;
      obj.pUserData = nullptr;
      obj.pfnAllocation = pfnAllocation;
      obj.pfnReallocation = pfnReallocation;
      obj.pfnFree = pfnFree;
      obj.pfnInternalAllocation = pfnInternalAllocation;
      obj.pfnInternalFree = pfnInternalFree;
      return obj;
   }

std::shared_ptr<VkInstance_T> createInstance(
        const VkInstanceCreateInfo & pCreateInfo)
   {
      VkInstance hInstance; 
      V( vkCreateInstance(
          &pCreateInfo,
          nullptr,
          &hInstance  ));
      return std::shared_ptr<VkInstance_T>(hInstance, 
              [=](VkInstance to_free) {vkDestroyInstance( to_free, nullptr);});
   }

std::vector< VkPhysicalDevice > enumeratePhysicalDevices(
        VkInstance instance)
   {
      std::vector<VkPhysicalDevice> vecpPhysicalDevices; 
      uint32_t pPhysicalDevicesCount; 
      V( vkEnumeratePhysicalDevices(
          instance,
          &pPhysicalDevicesCount,
          nullptr  ));

      vecpPhysicalDevices.resize(pPhysicalDevicesCount); 

      V( vkEnumeratePhysicalDevices(
          instance,
          &pPhysicalDevicesCount,
          &vecpPhysicalDevices[0]  ));
      return vecpPhysicalDevices; 
   }

VkPhysicalDeviceFeatures PhysicalDeviceFeatures(
    VkBool32                                    robustBufferAccess,
    VkBool32                                    fullDrawIndexUint32,
    VkBool32                                    imageCubeArray,
    VkBool32                                    independentBlend,
    VkBool32                                    geometryShader,
    VkBool32                                    tessellationShader,
    VkBool32                                    sampleRateShading,
    VkBool32                                    dualSrcBlend,
    VkBool32                                    logicOp,
    VkBool32                                    multiDrawIndirect,
    VkBool32                                    drawIndirectFirstInstance,
    VkBool32                                    depthClamp,
    VkBool32                                    depthBiasClamp,
    VkBool32                                    fillModeNonSolid,
    VkBool32                                    depthBounds,
    VkBool32                                    wideLines,
    VkBool32                                    largePoints,
    VkBool32                                    alphaToOne,
    VkBool32                                    multiViewport,
    VkBool32                                    samplerAnisotropy,
    VkBool32                                    textureCompressionETC2,
    VkBool32                                    textureCompressionASTC_LDR,
    VkBool32                                    textureCompressionBC,
    VkBool32                                    occlusionQueryPrecise,
    VkBool32                                    pipelineStatisticsQuery,
    VkBool32                                    vertexPipelineStoresAndAtomics,
    VkBool32                                    fragmentStoresAndAtomics,
    VkBool32                                    shaderTessellationAndGeometryPointSize,
    VkBool32                                    shaderImageGatherExtended,
    VkBool32                                    shaderStorageImageExtendedFormats,
    VkBool32                                    shaderStorageImageMultisample,
    VkBool32                                    shaderStorageImageReadWithoutFormat,
    VkBool32                                    shaderStorageImageWriteWithoutFormat,
    VkBool32                                    shaderUniformBufferArrayDynamicIndexing,
    VkBool32                                    shaderSampledImageArrayDynamicIndexing,
    VkBool32                                    shaderStorageBufferArrayDynamicIndexing,
    VkBool32                                    shaderStorageImageArrayDynamicIndexing,
    VkBool32                                    shaderClipDistance,
    VkBool32                                    shaderCullDistance,
    VkBool32                                    shaderFloat64,
    VkBool32                                    shaderInt64,
    VkBool32                                    shaderInt16,
    VkBool32                                    shaderResourceResidency,
    VkBool32                                    shaderResourceMinLod,
    VkBool32                                    sparseBinding,
    VkBool32                                    sparseResidencyBuffer,
    VkBool32                                    sparseResidencyImage2D,
    VkBool32                                    sparseResidencyImage3D,
    VkBool32                                    sparseResidency2Samples,
    VkBool32                                    sparseResidency4Samples,
    VkBool32                                    sparseResidency8Samples,
    VkBool32                                    sparseResidency16Samples,
    VkBool32                                    sparseResidencyAliased,
    VkBool32                                    variableMultisampleRate,
    VkBool32                                    inheritedQueries)
   {
      VkPhysicalDeviceFeatures obj;
      obj.robustBufferAccess = robustBufferAccess;
      obj.fullDrawIndexUint32 = fullDrawIndexUint32;
      obj.imageCubeArray = imageCubeArray;
      obj.independentBlend = independentBlend;
      obj.geometryShader = geometryShader;
      obj.tessellationShader = tessellationShader;
      obj.sampleRateShading = sampleRateShading;
      obj.dualSrcBlend = dualSrcBlend;
      obj.logicOp = logicOp;
      obj.multiDrawIndirect = multiDrawIndirect;
      obj.drawIndirectFirstInstance = drawIndirectFirstInstance;
      obj.depthClamp = depthClamp;
      obj.depthBiasClamp = depthBiasClamp;
      obj.fillModeNonSolid = fillModeNonSolid;
      obj.depthBounds = depthBounds;
      obj.wideLines = wideLines;
      obj.largePoints = largePoints;
      obj.alphaToOne = alphaToOne;
      obj.multiViewport = multiViewport;
      obj.samplerAnisotropy = samplerAnisotropy;
      obj.textureCompressionETC2 = textureCompressionETC2;
      obj.textureCompressionASTC_LDR = textureCompressionASTC_LDR;
      obj.textureCompressionBC = textureCompressionBC;
      obj.occlusionQueryPrecise = occlusionQueryPrecise;
      obj.pipelineStatisticsQuery = pipelineStatisticsQuery;
      obj.vertexPipelineStoresAndAtomics = vertexPipelineStoresAndAtomics;
      obj.fragmentStoresAndAtomics = fragmentStoresAndAtomics;
      obj.shaderTessellationAndGeometryPointSize = shaderTessellationAndGeometryPointSize;
      obj.shaderImageGatherExtended = shaderImageGatherExtended;
      obj.shaderStorageImageExtendedFormats = shaderStorageImageExtendedFormats;
      obj.shaderStorageImageMultisample = shaderStorageImageMultisample;
      obj.shaderStorageImageReadWithoutFormat = shaderStorageImageReadWithoutFormat;
      obj.shaderStorageImageWriteWithoutFormat = shaderStorageImageWriteWithoutFormat;
      obj.shaderUniformBufferArrayDynamicIndexing = shaderUniformBufferArrayDynamicIndexing;
      obj.shaderSampledImageArrayDynamicIndexing = shaderSampledImageArrayDynamicIndexing;
      obj.shaderStorageBufferArrayDynamicIndexing = shaderStorageBufferArrayDynamicIndexing;
      obj.shaderStorageImageArrayDynamicIndexing = shaderStorageImageArrayDynamicIndexing;
      obj.shaderClipDistance = shaderClipDistance;
      obj.shaderCullDistance = shaderCullDistance;
      obj.shaderFloat64 = shaderFloat64;
      obj.shaderInt64 = shaderInt64;
      obj.shaderInt16 = shaderInt16;
      obj.shaderResourceResidency = shaderResourceResidency;
      obj.shaderResourceMinLod = shaderResourceMinLod;
      obj.sparseBinding = sparseBinding;
      obj.sparseResidencyBuffer = sparseResidencyBuffer;
      obj.sparseResidencyImage2D = sparseResidencyImage2D;
      obj.sparseResidencyImage3D = sparseResidencyImage3D;
      obj.sparseResidency2Samples = sparseResidency2Samples;
      obj.sparseResidency4Samples = sparseResidency4Samples;
      obj.sparseResidency8Samples = sparseResidency8Samples;
      obj.sparseResidency16Samples = sparseResidency16Samples;
      obj.sparseResidencyAliased = sparseResidencyAliased;
      obj.variableMultisampleRate = variableMultisampleRate;
      obj.inheritedQueries = inheritedQueries;
      return obj;
   }

VkPhysicalDeviceFeatures getPhysicalDeviceFeatures(
        VkPhysicalDevice physicalDevice)
   {
      VkPhysicalDeviceFeatures pFeatures; 
      vkGetPhysicalDeviceFeatures(
          physicalDevice,
          &pFeatures  );
      return pFeatures; 
   }

VkFormatProperties FormatProperties(
    VkFormatFeatureFlags                        linearTilingFeatures,
    VkFormatFeatureFlags                        optimalTilingFeatures,
    VkFormatFeatureFlags                        bufferFeatures)
   {
      VkFormatProperties obj;
      obj.linearTilingFeatures = linearTilingFeatures;
      obj.optimalTilingFeatures = optimalTilingFeatures;
      obj.bufferFeatures = bufferFeatures;
      return obj;
   }

VkFormatProperties getPhysicalDeviceFormatProperties(
        VkPhysicalDevice physicalDevice,
        VkFormat format)
   {
      VkFormatProperties pFormatProperties; 
      vkGetPhysicalDeviceFormatProperties(
          physicalDevice,
          format,
          &pFormatProperties  );
      return pFormatProperties; 
   }

VkExtent3D Extent3D(
    uint32_t                                    width,
    uint32_t                                    height,
    uint32_t                                    depth)
   {
      VkExtent3D obj;
      obj.width = width;
      obj.height = height;
      obj.depth = depth;
      return obj;
   }

VkImageFormatProperties ImageFormatProperties(
    VkExtent3D                                  maxExtent,
    uint32_t                                    maxMipLevels,
    uint32_t                                    maxArrayLayers,
    VkSampleCountFlags                          sampleCounts,
    VkDeviceSize                                maxResourceSize)
   {
      VkImageFormatProperties obj;
      obj.maxExtent = maxExtent;
      obj.maxMipLevels = maxMipLevels;
      obj.maxArrayLayers = maxArrayLayers;
      obj.sampleCounts = sampleCounts;
      obj.maxResourceSize = maxResourceSize;
      return obj;
   }

VkImageFormatProperties getPhysicalDeviceImageFormatProperties(
        VkPhysicalDevice physicalDevice,
        VkFormat format,
        VkImageType type,
        VkImageTiling tiling,
        VkImageUsageFlags usage,
        VkImageCreateFlags flags)
   {
      VkImageFormatProperties pImageFormatProperties; 
      V( vkGetPhysicalDeviceImageFormatProperties(
          physicalDevice,
          format,
          type,
          tiling,
          usage,
          flags,
          &pImageFormatProperties  ));
      return pImageFormatProperties; 
   }

VkPhysicalDeviceLimits PhysicalDeviceLimits(
    uint32_t                                    maxImageDimension1D,
    uint32_t                                    maxImageDimension2D,
    uint32_t                                    maxImageDimension3D,
    uint32_t                                    maxImageDimensionCube,
    uint32_t                                    maxImageArrayLayers,
    uint32_t                                    maxTexelBufferElements,
    uint32_t                                    maxUniformBufferRange,
    uint32_t                                    maxStorageBufferRange,
    uint32_t                                    maxPushConstantsSize,
    uint32_t                                    maxMemoryAllocationCount,
    uint32_t                                    maxSamplerAllocationCount,
    VkDeviceSize                                bufferImageGranularity,
    VkDeviceSize                                sparseAddressSpaceSize,
    uint32_t                                    maxBoundDescriptorSets,
    uint32_t                                    maxPerStageDescriptorSamplers,
    uint32_t                                    maxPerStageDescriptorUniformBuffers,
    uint32_t                                    maxPerStageDescriptorStorageBuffers,
    uint32_t                                    maxPerStageDescriptorSampledImages,
    uint32_t                                    maxPerStageDescriptorStorageImages,
    uint32_t                                    maxPerStageDescriptorInputAttachments,
    uint32_t                                    maxPerStageResources,
    uint32_t                                    maxDescriptorSetSamplers,
    uint32_t                                    maxDescriptorSetUniformBuffers,
    uint32_t                                    maxDescriptorSetUniformBuffersDynamic,
    uint32_t                                    maxDescriptorSetStorageBuffers,
    uint32_t                                    maxDescriptorSetStorageBuffersDynamic,
    uint32_t                                    maxDescriptorSetSampledImages,
    uint32_t                                    maxDescriptorSetStorageImages,
    uint32_t                                    maxDescriptorSetInputAttachments,
    uint32_t                                    maxVertexInputAttributes,
    uint32_t                                    maxVertexInputBindings,
    uint32_t                                    maxVertexInputAttributeOffset,
    uint32_t                                    maxVertexInputBindingStride,
    uint32_t                                    maxVertexOutputComponents,
    uint32_t                                    maxTessellationGenerationLevel,
    uint32_t                                    maxTessellationPatchSize,
    uint32_t                                    maxTessellationControlPerVertexInputComponents,
    uint32_t                                    maxTessellationControlPerVertexOutputComponents,
    uint32_t                                    maxTessellationControlPerPatchOutputComponents,
    uint32_t                                    maxTessellationControlTotalOutputComponents,
    uint32_t                                    maxTessellationEvaluationInputComponents,
    uint32_t                                    maxTessellationEvaluationOutputComponents,
    uint32_t                                    maxGeometryShaderInvocations,
    uint32_t                                    maxGeometryInputComponents,
    uint32_t                                    maxGeometryOutputComponents,
    uint32_t                                    maxGeometryOutputVertices,
    uint32_t                                    maxGeometryTotalOutputComponents,
    uint32_t                                    maxFragmentInputComponents,
    uint32_t                                    maxFragmentOutputAttachments,
    uint32_t                                    maxFragmentDualSrcAttachments,
    uint32_t                                    maxFragmentCombinedOutputResources,
    uint32_t                                    maxComputeSharedMemorySize,
    uint32_t                                    maxComputeWorkGroupCount[3],
    uint32_t                                    maxComputeWorkGroupInvocations,
    uint32_t                                    maxComputeWorkGroupSize[3],
    uint32_t                                    subPixelPrecisionBits,
    uint32_t                                    subTexelPrecisionBits,
    uint32_t                                    mipmapPrecisionBits,
    uint32_t                                    maxDrawIndexedIndexValue,
    uint32_t                                    maxDrawIndirectCount,
    float                                       maxSamplerLodBias,
    float                                       maxSamplerAnisotropy,
    uint32_t                                    maxViewports,
    uint32_t                                    maxViewportDimensions[2],
    float                                       viewportBoundsRange[2],
    uint32_t                                    viewportSubPixelBits,
    size_t                                      minMemoryMapAlignment,
    VkDeviceSize                                minTexelBufferOffsetAlignment,
    VkDeviceSize                                minUniformBufferOffsetAlignment,
    VkDeviceSize                                minStorageBufferOffsetAlignment,
    int32_t                                     minTexelOffset,
    uint32_t                                    maxTexelOffset,
    int32_t                                     minTexelGatherOffset,
    uint32_t                                    maxTexelGatherOffset,
    float                                       minInterpolationOffset,
    float                                       maxInterpolationOffset,
    uint32_t                                    subPixelInterpolationOffsetBits,
    uint32_t                                    maxFramebufferWidth,
    uint32_t                                    maxFramebufferHeight,
    uint32_t                                    maxFramebufferLayers,
    VkSampleCountFlags                          framebufferColorSampleCounts,
    VkSampleCountFlags                          framebufferDepthSampleCounts,
    VkSampleCountFlags                          framebufferStencilSampleCounts,
    VkSampleCountFlags                          framebufferNoAttachmentsSampleCounts,
    uint32_t                                    maxColorAttachments,
    VkSampleCountFlags                          sampledImageColorSampleCounts,
    VkSampleCountFlags                          sampledImageIntegerSampleCounts,
    VkSampleCountFlags                          sampledImageDepthSampleCounts,
    VkSampleCountFlags                          sampledImageStencilSampleCounts,
    VkSampleCountFlags                          storageImageSampleCounts,
    uint32_t                                    maxSampleMaskWords,
    VkBool32                                    timestampComputeAndGraphics,
    float                                       timestampPeriod,
    uint32_t                                    maxClipDistances,
    uint32_t                                    maxCullDistances,
    uint32_t                                    maxCombinedClipAndCullDistances,
    uint32_t                                    discreteQueuePriorities,
    float                                       pointSizeRange[2],
    float                                       lineWidthRange[2],
    float                                       pointSizeGranularity,
    float                                       lineWidthGranularity,
    VkBool32                                    strictLines,
    VkBool32                                    standardSampleLocations,
    VkDeviceSize                                optimalBufferCopyOffsetAlignment,
    VkDeviceSize                                optimalBufferCopyRowPitchAlignment,
    VkDeviceSize                                nonCoherentAtomSize)
   {
      VkPhysicalDeviceLimits obj;
      obj.maxImageDimension1D = maxImageDimension1D;
      obj.maxImageDimension2D = maxImageDimension2D;
      obj.maxImageDimension3D = maxImageDimension3D;
      obj.maxImageDimensionCube = maxImageDimensionCube;
      obj.maxImageArrayLayers = maxImageArrayLayers;
      obj.maxTexelBufferElements = maxTexelBufferElements;
      obj.maxUniformBufferRange = maxUniformBufferRange;
      obj.maxStorageBufferRange = maxStorageBufferRange;
      obj.maxPushConstantsSize = maxPushConstantsSize;
      obj.maxMemoryAllocationCount = maxMemoryAllocationCount;
      obj.maxSamplerAllocationCount = maxSamplerAllocationCount;
      obj.bufferImageGranularity = bufferImageGranularity;
      obj.sparseAddressSpaceSize = sparseAddressSpaceSize;
      obj.maxBoundDescriptorSets = maxBoundDescriptorSets;
      obj.maxPerStageDescriptorSamplers = maxPerStageDescriptorSamplers;
      obj.maxPerStageDescriptorUniformBuffers = maxPerStageDescriptorUniformBuffers;
      obj.maxPerStageDescriptorStorageBuffers = maxPerStageDescriptorStorageBuffers;
      obj.maxPerStageDescriptorSampledImages = maxPerStageDescriptorSampledImages;
      obj.maxPerStageDescriptorStorageImages = maxPerStageDescriptorStorageImages;
      obj.maxPerStageDescriptorInputAttachments = maxPerStageDescriptorInputAttachments;
      obj.maxPerStageResources = maxPerStageResources;
      obj.maxDescriptorSetSamplers = maxDescriptorSetSamplers;
      obj.maxDescriptorSetUniformBuffers = maxDescriptorSetUniformBuffers;
      obj.maxDescriptorSetUniformBuffersDynamic = maxDescriptorSetUniformBuffersDynamic;
      obj.maxDescriptorSetStorageBuffers = maxDescriptorSetStorageBuffers;
      obj.maxDescriptorSetStorageBuffersDynamic = maxDescriptorSetStorageBuffersDynamic;
      obj.maxDescriptorSetSampledImages = maxDescriptorSetSampledImages;
      obj.maxDescriptorSetStorageImages = maxDescriptorSetStorageImages;
      obj.maxDescriptorSetInputAttachments = maxDescriptorSetInputAttachments;
      obj.maxVertexInputAttributes = maxVertexInputAttributes;
      obj.maxVertexInputBindings = maxVertexInputBindings;
      obj.maxVertexInputAttributeOffset = maxVertexInputAttributeOffset;
      obj.maxVertexInputBindingStride = maxVertexInputBindingStride;
      obj.maxVertexOutputComponents = maxVertexOutputComponents;
      obj.maxTessellationGenerationLevel = maxTessellationGenerationLevel;
      obj.maxTessellationPatchSize = maxTessellationPatchSize;
      obj.maxTessellationControlPerVertexInputComponents = maxTessellationControlPerVertexInputComponents;
      obj.maxTessellationControlPerVertexOutputComponents = maxTessellationControlPerVertexOutputComponents;
      obj.maxTessellationControlPerPatchOutputComponents = maxTessellationControlPerPatchOutputComponents;
      obj.maxTessellationControlTotalOutputComponents = maxTessellationControlTotalOutputComponents;
      obj.maxTessellationEvaluationInputComponents = maxTessellationEvaluationInputComponents;
      obj.maxTessellationEvaluationOutputComponents = maxTessellationEvaluationOutputComponents;
      obj.maxGeometryShaderInvocations = maxGeometryShaderInvocations;
      obj.maxGeometryInputComponents = maxGeometryInputComponents;
      obj.maxGeometryOutputComponents = maxGeometryOutputComponents;
      obj.maxGeometryOutputVertices = maxGeometryOutputVertices;
      obj.maxGeometryTotalOutputComponents = maxGeometryTotalOutputComponents;
      obj.maxFragmentInputComponents = maxFragmentInputComponents;
      obj.maxFragmentOutputAttachments = maxFragmentOutputAttachments;
      obj.maxFragmentDualSrcAttachments = maxFragmentDualSrcAttachments;
      obj.maxFragmentCombinedOutputResources = maxFragmentCombinedOutputResources;
      obj.maxComputeSharedMemorySize = maxComputeSharedMemorySize;
      std::copy(maxComputeWorkGroupCount, maxComputeWorkGroupCount + 3, obj.maxComputeWorkGroupCount);
      obj.maxComputeWorkGroupInvocations = maxComputeWorkGroupInvocations;
      std::copy(maxComputeWorkGroupSize, maxComputeWorkGroupSize + 3, obj.maxComputeWorkGroupSize);
      obj.subPixelPrecisionBits = subPixelPrecisionBits;
      obj.subTexelPrecisionBits = subTexelPrecisionBits;
      obj.mipmapPrecisionBits = mipmapPrecisionBits;
      obj.maxDrawIndexedIndexValue = maxDrawIndexedIndexValue;
      obj.maxDrawIndirectCount = maxDrawIndirectCount;
      obj.maxSamplerLodBias = maxSamplerLodBias;
      obj.maxSamplerAnisotropy = maxSamplerAnisotropy;
      obj.maxViewports = maxViewports;
      std::copy(maxViewportDimensions, maxViewportDimensions + 2, obj.maxViewportDimensions);
      std::copy(viewportBoundsRange, viewportBoundsRange + 2, obj.viewportBoundsRange);
      obj.viewportSubPixelBits = viewportSubPixelBits;
      obj.minMemoryMapAlignment = minMemoryMapAlignment;
      obj.minTexelBufferOffsetAlignment = minTexelBufferOffsetAlignment;
      obj.minUniformBufferOffsetAlignment = minUniformBufferOffsetAlignment;
      obj.minStorageBufferOffsetAlignment = minStorageBufferOffsetAlignment;
      obj.minTexelOffset = minTexelOffset;
      obj.maxTexelOffset = maxTexelOffset;
      obj.minTexelGatherOffset = minTexelGatherOffset;
      obj.maxTexelGatherOffset = maxTexelGatherOffset;
      obj.minInterpolationOffset = minInterpolationOffset;
      obj.maxInterpolationOffset = maxInterpolationOffset;
      obj.subPixelInterpolationOffsetBits = subPixelInterpolationOffsetBits;
      obj.maxFramebufferWidth = maxFramebufferWidth;
      obj.maxFramebufferHeight = maxFramebufferHeight;
      obj.maxFramebufferLayers = maxFramebufferLayers;
      obj.framebufferColorSampleCounts = framebufferColorSampleCounts;
      obj.framebufferDepthSampleCounts = framebufferDepthSampleCounts;
      obj.framebufferStencilSampleCounts = framebufferStencilSampleCounts;
      obj.framebufferNoAttachmentsSampleCounts = framebufferNoAttachmentsSampleCounts;
      obj.maxColorAttachments = maxColorAttachments;
      obj.sampledImageColorSampleCounts = sampledImageColorSampleCounts;
      obj.sampledImageIntegerSampleCounts = sampledImageIntegerSampleCounts;
      obj.sampledImageDepthSampleCounts = sampledImageDepthSampleCounts;
      obj.sampledImageStencilSampleCounts = sampledImageStencilSampleCounts;
      obj.storageImageSampleCounts = storageImageSampleCounts;
      obj.maxSampleMaskWords = maxSampleMaskWords;
      obj.timestampComputeAndGraphics = timestampComputeAndGraphics;
      obj.timestampPeriod = timestampPeriod;
      obj.maxClipDistances = maxClipDistances;
      obj.maxCullDistances = maxCullDistances;
      obj.maxCombinedClipAndCullDistances = maxCombinedClipAndCullDistances;
      obj.discreteQueuePriorities = discreteQueuePriorities;
      std::copy(pointSizeRange, pointSizeRange + 2, obj.pointSizeRange);
      std::copy(lineWidthRange, lineWidthRange + 2, obj.lineWidthRange);
      obj.pointSizeGranularity = pointSizeGranularity;
      obj.lineWidthGranularity = lineWidthGranularity;
      obj.strictLines = strictLines;
      obj.standardSampleLocations = standardSampleLocations;
      obj.optimalBufferCopyOffsetAlignment = optimalBufferCopyOffsetAlignment;
      obj.optimalBufferCopyRowPitchAlignment = optimalBufferCopyRowPitchAlignment;
      obj.nonCoherentAtomSize = nonCoherentAtomSize;
      return obj;
   }

VkPhysicalDeviceSparseProperties PhysicalDeviceSparseProperties(
    VkBool32                                    residencyStandard2DBlockShape,
    VkBool32                                    residencyStandard2DMultisampleBlockShape,
    VkBool32                                    residencyStandard3DBlockShape,
    VkBool32                                    residencyAlignedMipSize,
    VkBool32                                    residencyNonResidentStrict)
   {
      VkPhysicalDeviceSparseProperties obj;
      obj.residencyStandard2DBlockShape = residencyStandard2DBlockShape;
      obj.residencyStandard2DMultisampleBlockShape = residencyStandard2DMultisampleBlockShape;
      obj.residencyStandard3DBlockShape = residencyStandard3DBlockShape;
      obj.residencyAlignedMipSize = residencyAlignedMipSize;
      obj.residencyNonResidentStrict = residencyNonResidentStrict;
      return obj;
   }

VkPhysicalDeviceProperties PhysicalDeviceProperties(
    uint32_t                                    apiVersion,
    uint32_t                                    driverVersion,
    uint32_t                                    vendorID,
    uint32_t                                    deviceID,
    VkPhysicalDeviceType                        deviceType,
    char                                        deviceName[VK_MAX_PHYSICAL_DEVICE_NAME_SIZE],
    uint8_t                                     pipelineCacheUUID[VK_UUID_SIZE],
    VkPhysicalDeviceLimits                      limits,
    VkPhysicalDeviceSparseProperties            sparseProperties)
   {
      VkPhysicalDeviceProperties obj;
      obj.apiVersion = apiVersion;
      obj.driverVersion = driverVersion;
      obj.vendorID = vendorID;
      obj.deviceID = deviceID;
      obj.deviceType = deviceType;
      std::copy(deviceName, deviceName + VK_MAX_PHYSICAL_DEVICE_NAME_SIZE, obj.deviceName);
      std::copy(pipelineCacheUUID, pipelineCacheUUID + VK_UUID_SIZE, obj.pipelineCacheUUID);
      obj.limits = limits;
      obj.sparseProperties = sparseProperties;
      return obj;
   }

VkPhysicalDeviceProperties getPhysicalDeviceProperties(
        VkPhysicalDevice physicalDevice)
   {
      VkPhysicalDeviceProperties pProperties; 
      vkGetPhysicalDeviceProperties(
          physicalDevice,
          &pProperties  );
      return pProperties; 
   }

VkQueueFamilyProperties QueueFamilyProperties(
    VkQueueFlags                                queueFlags,
    uint32_t                                    queueCount,
    uint32_t                                    timestampValidBits,
    VkExtent3D                                  minImageTransferGranularity)
   {
      VkQueueFamilyProperties obj;
      obj.queueFlags = queueFlags;
      obj.queueCount = queueCount;
      obj.timestampValidBits = timestampValidBits;
      obj.minImageTransferGranularity = minImageTransferGranularity;
      return obj;
   }

std::vector< VkQueueFamilyProperties > getPhysicalDeviceQueueFamilyProperties(
        VkPhysicalDevice physicalDevice)
   {
      std::vector<VkQueueFamilyProperties> vecpQueueFamilyProperties; 
      uint32_t pQueueFamilyPropertiesCount; 
      vkGetPhysicalDeviceQueueFamilyProperties(
          physicalDevice,
          &pQueueFamilyPropertiesCount,
          nullptr  );

      vecpQueueFamilyProperties.resize(pQueueFamilyPropertiesCount); 

      vkGetPhysicalDeviceQueueFamilyProperties(
          physicalDevice,
          &pQueueFamilyPropertiesCount,
          &vecpQueueFamilyProperties[0]  );
      return vecpQueueFamilyProperties; 
   }

VkMemoryType MemoryType(
    VkMemoryPropertyFlags                       propertyFlags,
    uint32_t                                    heapIndex)
   {
      VkMemoryType obj;
      obj.propertyFlags = propertyFlags;
      obj.heapIndex = heapIndex;
      return obj;
   }

VkMemoryHeap MemoryHeap(
    VkDeviceSize                                size,
    VkMemoryHeapFlags                           flags)
   {
      VkMemoryHeap obj;
      obj.size = size;
      obj.flags = flags;
      return obj;
   }

VkPhysicalDeviceMemoryProperties PhysicalDeviceMemoryProperties(
    uint32_t                                    memoryTypeCount,
    VkMemoryType                                memoryTypes[VK_MAX_MEMORY_TYPES],
    uint32_t                                    memoryHeapCount,
    VkMemoryHeap                                memoryHeaps[VK_MAX_MEMORY_HEAPS])
   {
      VkPhysicalDeviceMemoryProperties obj;
      obj.memoryTypeCount = memoryTypeCount;
      std::copy(memoryTypes, memoryTypes + VK_MAX_MEMORY_TYPES, obj.memoryTypes);
      obj.memoryHeapCount = memoryHeapCount;
      std::copy(memoryHeaps, memoryHeaps + VK_MAX_MEMORY_HEAPS, obj.memoryHeaps);
      return obj;
   }

VkPhysicalDeviceMemoryProperties getPhysicalDeviceMemoryProperties(
        VkPhysicalDevice physicalDevice)
   {
      VkPhysicalDeviceMemoryProperties pMemoryProperties; 
      vkGetPhysicalDeviceMemoryProperties(
          physicalDevice,
          &pMemoryProperties  );
      return pMemoryProperties; 
   }

struct VkDeviceQueueCreateInfoRAII {
   VkDeviceQueueCreateInfo nonRaiiObj;
    std::vector<float>                          vecQueuePriorities;
};

std::shared_ptr<VkDeviceQueueCreateInfoRAII> DeviceQueueCreateInfo(
    VkDeviceQueueCreateFlags                    flags,
    uint32_t                                    queueFamilyIndex,
    float* pQueuePriorities_in_array1, int pQueuePriorities_dim1)
   {
      std::shared_ptr<VkDeviceQueueCreateInfoRAII> raii_obj(new VkDeviceQueueCreateInfoRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.flags = flags;
      raii_obj->nonRaiiObj.queueFamilyIndex = queueFamilyIndex;
      raii_obj->nonRaiiObj.queueCount = static_cast<uint32_t>(pQueuePriorities_dim1);
      raii_obj->vecQueuePriorities.assign(pQueuePriorities_in_array1, pQueuePriorities_in_array1 + pQueuePriorities_dim1);
      if ( raii_obj->vecQueuePriorities.size() > 0)
      {
          raii_obj->nonRaiiObj.pQueuePriorities = &raii_obj->vecQueuePriorities[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pQueuePriorities = nullptr;
      }
      return raii_obj;
   }

struct VkDeviceCreateInfoRAII {
   VkDeviceCreateInfo nonRaiiObj;
    std::vector<VkDeviceQueueCreateInfo>        vecQueueCreateInfos;
    std::vector<std::string>                    vecEnabledLayerNames;
    std::vector<const char *>                   vecPtrEnabledLayerNames;
    std::vector<std::string>                    vecEnabledExtensionNames;
    std::vector<const char *>                   vecPtrEnabledExtensionNames;
    std::shared_ptr<VkPhysicalDeviceFeatures>   pEnabledFeatures;
};

std::shared_ptr<VkDeviceCreateInfoRAII> DeviceCreateInfo(
    VkDeviceCreateFlags                         flags,
    const std::vector<VkDeviceQueueCreateInfo> &vecQueueCreateInfos,
    const std::vector<std::string> &            vecEnabledLayerNames,
    const std::vector<std::string> &            vecEnabledExtensionNames,
    const VkPhysicalDeviceFeatures *            pEnabledFeatures)
   {
      std::shared_ptr<VkDeviceCreateInfoRAII> raii_obj(new VkDeviceCreateInfoRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.flags = flags;
      raii_obj->nonRaiiObj.queueCreateInfoCount = static_cast<uint32_t>(vecQueueCreateInfos.size());
      raii_obj->vecQueueCreateInfos = vecQueueCreateInfos;
      if ( raii_obj->vecQueueCreateInfos.size() > 0)
      {
          raii_obj->nonRaiiObj.pQueueCreateInfos = &raii_obj->vecQueueCreateInfos[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pQueueCreateInfos = nullptr;
      }
      raii_obj->nonRaiiObj.enabledLayerCount = static_cast<uint32_t>(vecEnabledLayerNames.size());
      raii_obj->vecEnabledLayerNames = vecEnabledLayerNames;
      raii_obj->vecPtrEnabledLayerNames.resize(vecEnabledLayerNames.size());
      for (size_t i=0; i<vecEnabledLayerNames.size(); ++i) 
           raii_obj->vecPtrEnabledLayerNames[i] = raii_obj->vecEnabledLayerNames[i].c_str();
      raii_obj->nonRaiiObj.ppEnabledLayerNames = &raii_obj->vecPtrEnabledLayerNames[0];
      raii_obj->nonRaiiObj.enabledExtensionCount = static_cast<uint32_t>(vecEnabledExtensionNames.size());
      raii_obj->vecEnabledExtensionNames = vecEnabledExtensionNames;
      raii_obj->vecPtrEnabledExtensionNames.resize(vecEnabledExtensionNames.size());
      for (size_t i=0; i<vecEnabledExtensionNames.size(); ++i) 
           raii_obj->vecPtrEnabledExtensionNames[i] = raii_obj->vecEnabledExtensionNames[i].c_str();
      raii_obj->nonRaiiObj.ppEnabledExtensionNames = &raii_obj->vecPtrEnabledExtensionNames[0];
      raii_obj->nonRaiiObj.pEnabledFeatures = nullptr;
      if ( pEnabledFeatures ) 
      { 
          raii_obj->pEnabledFeatures.reset( new VkPhysicalDeviceFeatures );
          *raii_obj->pEnabledFeatures = *pEnabledFeatures;
          raii_obj->nonRaiiObj.pEnabledFeatures = raii_obj->pEnabledFeatures.get();
      } 
      return raii_obj;
   }

std::shared_ptr<VkDevice_T> createDevice(
        VkPhysicalDevice physicalDevice,
        const VkDeviceCreateInfo & pCreateInfo)
   {
      VkDevice hDevice; 
      V( vkCreateDevice(
          physicalDevice,
          &pCreateInfo,
          nullptr,
          &hDevice  ));
      return std::shared_ptr<VkDevice_T>(hDevice, 
              [=](VkDevice to_free) {vkDestroyDevice( to_free, nullptr);});
   }

VkExtensionProperties ExtensionProperties(
    char                                        extensionName[VK_MAX_EXTENSION_NAME_SIZE],
    uint32_t                                    specVersion)
   {
      VkExtensionProperties obj;
      std::copy(extensionName, extensionName + VK_MAX_EXTENSION_NAME_SIZE, obj.extensionName);
      obj.specVersion = specVersion;
      return obj;
   }

std::vector< VkExtensionProperties > enumerateInstanceExtensionProperties(
        const char* pLayerName)
   {
      std::vector<VkExtensionProperties> vecpProperties; 
      uint32_t pPropertiesCount; 
      V( vkEnumerateInstanceExtensionProperties(
          pLayerName,
          &pPropertiesCount,
          nullptr  ));

      vecpProperties.resize(pPropertiesCount); 

      V( vkEnumerateInstanceExtensionProperties(
          pLayerName,
          &pPropertiesCount,
          &vecpProperties[0]  ));
      return vecpProperties; 
   }

std::vector< VkExtensionProperties > enumerateDeviceExtensionProperties(
        VkPhysicalDevice physicalDevice,
        const char* pLayerName)
   {
      std::vector<VkExtensionProperties> vecpProperties; 
      uint32_t pPropertiesCount; 
      V( vkEnumerateDeviceExtensionProperties(
          physicalDevice,
          pLayerName,
          &pPropertiesCount,
          nullptr  ));

      vecpProperties.resize(pPropertiesCount); 

      V( vkEnumerateDeviceExtensionProperties(
          physicalDevice,
          pLayerName,
          &pPropertiesCount,
          &vecpProperties[0]  ));
      return vecpProperties; 
   }

VkLayerProperties LayerProperties(
    char                                        layerName[VK_MAX_EXTENSION_NAME_SIZE],
    uint32_t                                    specVersion,
    uint32_t                                    implementationVersion,
    char                                        description[VK_MAX_DESCRIPTION_SIZE])
   {
      VkLayerProperties obj;
      std::copy(layerName, layerName + VK_MAX_EXTENSION_NAME_SIZE, obj.layerName);
      obj.specVersion = specVersion;
      obj.implementationVersion = implementationVersion;
      std::copy(description, description + VK_MAX_DESCRIPTION_SIZE, obj.description);
      return obj;
   }

std::vector< VkLayerProperties > enumerateInstanceLayerProperties(void)
   {
      std::vector<VkLayerProperties> vecpProperties; 
      uint32_t pPropertiesCount; 
      V( vkEnumerateInstanceLayerProperties(
          &pPropertiesCount,
          nullptr  ));

      vecpProperties.resize(pPropertiesCount); 

      V( vkEnumerateInstanceLayerProperties(
          &pPropertiesCount,
          &vecpProperties[0]  ));
      return vecpProperties; 
   }

std::vector< VkLayerProperties > enumerateDeviceLayerProperties(
        VkPhysicalDevice physicalDevice)
   {
      std::vector<VkLayerProperties> vecpProperties; 
      uint32_t pPropertiesCount; 
      V( vkEnumerateDeviceLayerProperties(
          physicalDevice,
          &pPropertiesCount,
          nullptr  ));

      vecpProperties.resize(pPropertiesCount); 

      V( vkEnumerateDeviceLayerProperties(
          physicalDevice,
          &pPropertiesCount,
          &vecpProperties[0]  ));
      return vecpProperties; 
   }

VkQueue getDeviceQueue(
        VkDevice device,
        uint32_t queueFamilyIndex,
        uint32_t queueIndex)
   {
      VkQueue hQueue; 
      vkGetDeviceQueue(
          device,
          queueFamilyIndex,
          queueIndex,
          &hQueue  );
      return hQueue; 
   }

struct VkSubmitInfoRAII {
   VkSubmitInfo nonRaiiObj;
    std::vector<VkSemaphore>                    vecWaitSemaphores;
    std::vector<VkPipelineStageFlags>           vecWaitDstStageMask;
    std::vector<VkCommandBuffer>                vecCommandBuffers;
    std::vector<VkSemaphore>                    vecSignalSemaphores;
};

std::shared_ptr<VkSubmitInfoRAII> SubmitInfo(
    const std::vector<VkSemaphore> &            vecWaitSemaphores,
    const std::vector<VkPipelineStageFlags> &   vecWaitDstStageMask,
    const std::vector<VkCommandBuffer> &        vecCommandBuffers,
    const std::vector<VkSemaphore> &            vecSignalSemaphores)
   {
      std::shared_ptr<VkSubmitInfoRAII> raii_obj(new VkSubmitInfoRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.waitSemaphoreCount = static_cast<uint32_t>(vecWaitSemaphores.size());
      raii_obj->vecWaitSemaphores = vecWaitSemaphores;
      if ( raii_obj->vecWaitSemaphores.size() > 0)
      {
          raii_obj->nonRaiiObj.pWaitSemaphores = &raii_obj->vecWaitSemaphores[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pWaitSemaphores = nullptr;
      }
      raii_obj->vecWaitDstStageMask = vecWaitDstStageMask;
      if ( raii_obj->vecWaitDstStageMask.size() > 0)
      {
          raii_obj->nonRaiiObj.pWaitDstStageMask = &raii_obj->vecWaitDstStageMask[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pWaitDstStageMask = nullptr;
      }
      raii_obj->nonRaiiObj.commandBufferCount = static_cast<uint32_t>(vecCommandBuffers.size());
      raii_obj->vecCommandBuffers = vecCommandBuffers;
      if ( raii_obj->vecCommandBuffers.size() > 0)
      {
          raii_obj->nonRaiiObj.pCommandBuffers = &raii_obj->vecCommandBuffers[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pCommandBuffers = nullptr;
      }
      raii_obj->nonRaiiObj.signalSemaphoreCount = static_cast<uint32_t>(vecSignalSemaphores.size());
      raii_obj->vecSignalSemaphores = vecSignalSemaphores;
      if ( raii_obj->vecSignalSemaphores.size() > 0)
      {
          raii_obj->nonRaiiObj.pSignalSemaphores = &raii_obj->vecSignalSemaphores[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pSignalSemaphores = nullptr;
      }
      return raii_obj;
   }

void  queueSubmit(
        VkQueue queue,
        const std::vector<VkSubmitInfo> & pSubmits,
        VkFence fence)
   {
      V( vkQueueSubmit(
          queue,
          static_cast<uint32_t>(pSubmits.size()),
          &pSubmits[0],
          fence  ));
   }

void  queueWaitIdle(
        VkQueue queue)
   {
      V( vkQueueWaitIdle(
          queue  ));
   }

void  deviceWaitIdle(
        VkDevice device)
   {
      V( vkDeviceWaitIdle(
          device  ));
   }

VkMemoryAllocateInfo MemoryAllocateInfo(
    VkDeviceSize                                allocationSize,
    uint32_t                                    memoryTypeIndex)
   {
      VkMemoryAllocateInfo obj;
      obj.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
      obj.pNext = nullptr;
      obj.allocationSize = allocationSize;
      obj.memoryTypeIndex = memoryTypeIndex;
      return obj;
   }

std::shared_ptr<VkDeviceMemory_T> allocateMemory(
        VkDevice device,
        const VkMemoryAllocateInfo & pAllocateInfo)
   {
      VkDeviceMemory hMemory; 
      V( vkAllocateMemory(
          device,
          &pAllocateInfo,
          nullptr,
          &hMemory  ));
      return std::shared_ptr<VkDeviceMemory_T>(hMemory, 
              [=](VkDeviceMemory to_free) {vkFreeMemory(device, to_free, nullptr);});
   }

void  unmapMemory(
        VkDevice device,
        VkDeviceMemory memory)
   {
      vkUnmapMemory(
          device,
          memory  );
   }

VkMappedMemoryRange MappedMemoryRange(
    VkDeviceMemory                              memory,
    VkDeviceSize                                offset,
    VkDeviceSize                                size)
   {
      VkMappedMemoryRange obj;
      obj.sType = VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE;
      obj.pNext = nullptr;
      obj.memory = memory;
      obj.offset = offset;
      obj.size = size;
      return obj;
   }

void  flushMappedMemoryRanges(
        VkDevice device,
        const std::vector<VkMappedMemoryRange> & pMemoryRanges)
   {
      V( vkFlushMappedMemoryRanges(
          device,
          static_cast<uint32_t>(pMemoryRanges.size()),
          &pMemoryRanges[0]  ));
   }

void  invalidateMappedMemoryRanges(
        VkDevice device,
        const std::vector<VkMappedMemoryRange> & pMemoryRanges)
   {
      V( vkInvalidateMappedMemoryRanges(
          device,
          static_cast<uint32_t>(pMemoryRanges.size()),
          &pMemoryRanges[0]  ));
   }

VkDeviceSize getDeviceMemoryCommitment(
        VkDevice device,
        VkDeviceMemory memory)
   {
      VkDeviceSize pCommittedMemoryInBytes; 
      vkGetDeviceMemoryCommitment(
          device,
          memory,
          &pCommittedMemoryInBytes  );
      return pCommittedMemoryInBytes; 
   }

void  bindBufferMemory(
        VkDevice device,
        VkBuffer buffer,
        VkDeviceMemory memory,
        VkDeviceSize memoryOffset)
   {
      V( vkBindBufferMemory(
          device,
          buffer,
          memory,
          memoryOffset  ));
   }

void  bindImageMemory(
        VkDevice device,
        VkImage image,
        VkDeviceMemory memory,
        VkDeviceSize memoryOffset)
   {
      V( vkBindImageMemory(
          device,
          image,
          memory,
          memoryOffset  ));
   }

VkMemoryRequirements MemoryRequirements(
    VkDeviceSize                                size,
    VkDeviceSize                                alignment,
    uint32_t                                    memoryTypeBits)
   {
      VkMemoryRequirements obj;
      obj.size = size;
      obj.alignment = alignment;
      obj.memoryTypeBits = memoryTypeBits;
      return obj;
   }

VkMemoryRequirements getBufferMemoryRequirements(
        VkDevice device,
        VkBuffer buffer)
   {
      VkMemoryRequirements pMemoryRequirements; 
      vkGetBufferMemoryRequirements(
          device,
          buffer,
          &pMemoryRequirements  );
      return pMemoryRequirements; 
   }

VkMemoryRequirements getImageMemoryRequirements(
        VkDevice device,
        VkImage image)
   {
      VkMemoryRequirements pMemoryRequirements; 
      vkGetImageMemoryRequirements(
          device,
          image,
          &pMemoryRequirements  );
      return pMemoryRequirements; 
   }

VkSparseImageFormatProperties SparseImageFormatProperties(
    VkImageAspectFlags                          aspectMask,
    VkExtent3D                                  imageGranularity,
    VkSparseImageFormatFlags                    flags)
   {
      VkSparseImageFormatProperties obj;
      obj.aspectMask = aspectMask;
      obj.imageGranularity = imageGranularity;
      obj.flags = flags;
      return obj;
   }

VkSparseImageMemoryRequirements SparseImageMemoryRequirements(
    VkSparseImageFormatProperties               formatProperties,
    uint32_t                                    imageMipTailFirstLod,
    VkDeviceSize                                imageMipTailSize,
    VkDeviceSize                                imageMipTailOffset,
    VkDeviceSize                                imageMipTailStride)
   {
      VkSparseImageMemoryRequirements obj;
      obj.formatProperties = formatProperties;
      obj.imageMipTailFirstLod = imageMipTailFirstLod;
      obj.imageMipTailSize = imageMipTailSize;
      obj.imageMipTailOffset = imageMipTailOffset;
      obj.imageMipTailStride = imageMipTailStride;
      return obj;
   }

std::vector< VkSparseImageMemoryRequirements > getImageSparseMemoryRequirements(
        VkDevice device,
        VkImage image)
   {
      std::vector<VkSparseImageMemoryRequirements> vecpSparseMemoryRequirements; 
      uint32_t pSparseMemoryRequirementsCount; 
      vkGetImageSparseMemoryRequirements(
          device,
          image,
          &pSparseMemoryRequirementsCount,
          nullptr  );

      vecpSparseMemoryRequirements.resize(pSparseMemoryRequirementsCount); 

      vkGetImageSparseMemoryRequirements(
          device,
          image,
          &pSparseMemoryRequirementsCount,
          &vecpSparseMemoryRequirements[0]  );
      return vecpSparseMemoryRequirements; 
   }

std::vector< VkSparseImageFormatProperties > getPhysicalDeviceSparseImageFormatProperties(
        VkPhysicalDevice physicalDevice,
        VkFormat format,
        VkImageType type,
        VkSampleCountFlagBits samples,
        VkImageUsageFlags usage,
        VkImageTiling tiling)
   {
      std::vector<VkSparseImageFormatProperties> vecpProperties; 
      uint32_t pPropertiesCount; 
      vkGetPhysicalDeviceSparseImageFormatProperties(
          physicalDevice,
          format,
          type,
          samples,
          usage,
          tiling,
          &pPropertiesCount,
          nullptr  );

      vecpProperties.resize(pPropertiesCount); 

      vkGetPhysicalDeviceSparseImageFormatProperties(
          physicalDevice,
          format,
          type,
          samples,
          usage,
          tiling,
          &pPropertiesCount,
          &vecpProperties[0]  );
      return vecpProperties; 
   }

VkSparseMemoryBind SparseMemoryBind(
    VkDeviceSize                                resourceOffset,
    VkDeviceSize                                size,
    VkDeviceMemory                              memory,
    VkDeviceSize                                memoryOffset,
    VkSparseMemoryBindFlags                     flags)
   {
      VkSparseMemoryBind obj;
      obj.resourceOffset = resourceOffset;
      obj.size = size;
      obj.memory = memory;
      obj.memoryOffset = memoryOffset;
      obj.flags = flags;
      return obj;
   }

struct VkSparseBufferMemoryBindInfoRAII {
   VkSparseBufferMemoryBindInfo nonRaiiObj;
    std::vector<VkSparseMemoryBind>             vecBinds;
};

std::shared_ptr<VkSparseBufferMemoryBindInfoRAII> SparseBufferMemoryBindInfo(
    VkBuffer                                    buffer,
    const std::vector<VkSparseMemoryBind> &     vecBinds)
   {
      std::shared_ptr<VkSparseBufferMemoryBindInfoRAII> raii_obj(new VkSparseBufferMemoryBindInfoRAII);
      raii_obj->nonRaiiObj.buffer = buffer;
      raii_obj->nonRaiiObj.bindCount = static_cast<uint32_t>(vecBinds.size());
      raii_obj->vecBinds = vecBinds;
      if ( raii_obj->vecBinds.size() > 0)
      {
          raii_obj->nonRaiiObj.pBinds = &raii_obj->vecBinds[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pBinds = nullptr;
      }
      return raii_obj;
   }

struct VkSparseImageOpaqueMemoryBindInfoRAII {
   VkSparseImageOpaqueMemoryBindInfo nonRaiiObj;
    std::vector<VkSparseMemoryBind>             vecBinds;
};

std::shared_ptr<VkSparseImageOpaqueMemoryBindInfoRAII> SparseImageOpaqueMemoryBindInfo(
    VkImage                                     image,
    const std::vector<VkSparseMemoryBind> &     vecBinds)
   {
      std::shared_ptr<VkSparseImageOpaqueMemoryBindInfoRAII> raii_obj(new VkSparseImageOpaqueMemoryBindInfoRAII);
      raii_obj->nonRaiiObj.image = image;
      raii_obj->nonRaiiObj.bindCount = static_cast<uint32_t>(vecBinds.size());
      raii_obj->vecBinds = vecBinds;
      if ( raii_obj->vecBinds.size() > 0)
      {
          raii_obj->nonRaiiObj.pBinds = &raii_obj->vecBinds[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pBinds = nullptr;
      }
      return raii_obj;
   }

VkImageSubresource ImageSubresource(
    VkImageAspectFlags                          aspectMask,
    uint32_t                                    mipLevel,
    uint32_t                                    arrayLayer)
   {
      VkImageSubresource obj;
      obj.aspectMask = aspectMask;
      obj.mipLevel = mipLevel;
      obj.arrayLayer = arrayLayer;
      return obj;
   }

VkOffset3D Offset3D(
    int32_t                                     x,
    int32_t                                     y,
    int32_t                                     z)
   {
      VkOffset3D obj;
      obj.x = x;
      obj.y = y;
      obj.z = z;
      return obj;
   }

VkSparseImageMemoryBind SparseImageMemoryBind(
    VkImageSubresource                          subresource,
    VkOffset3D                                  offset,
    VkExtent3D                                  extent,
    VkDeviceMemory                              memory,
    VkDeviceSize                                memoryOffset,
    VkSparseMemoryBindFlags                     flags)
   {
      VkSparseImageMemoryBind obj;
      obj.subresource = subresource;
      obj.offset = offset;
      obj.extent = extent;
      obj.memory = memory;
      obj.memoryOffset = memoryOffset;
      obj.flags = flags;
      return obj;
   }

struct VkSparseImageMemoryBindInfoRAII {
   VkSparseImageMemoryBindInfo nonRaiiObj;
    std::vector<VkSparseImageMemoryBind>        vecBinds;
};

std::shared_ptr<VkSparseImageMemoryBindInfoRAII> SparseImageMemoryBindInfo(
    VkImage                                     image,
    const std::vector<VkSparseImageMemoryBind> &vecBinds)
   {
      std::shared_ptr<VkSparseImageMemoryBindInfoRAII> raii_obj(new VkSparseImageMemoryBindInfoRAII);
      raii_obj->nonRaiiObj.image = image;
      raii_obj->nonRaiiObj.bindCount = static_cast<uint32_t>(vecBinds.size());
      raii_obj->vecBinds = vecBinds;
      if ( raii_obj->vecBinds.size() > 0)
      {
          raii_obj->nonRaiiObj.pBinds = &raii_obj->vecBinds[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pBinds = nullptr;
      }
      return raii_obj;
   }

struct VkBindSparseInfoRAII {
   VkBindSparseInfo nonRaiiObj;
    std::vector<VkSemaphore>                    vecWaitSemaphores;
    std::vector<VkSparseBufferMemoryBindInfo>   vecBufferBinds;
    std::vector<VkSparseImageOpaqueMemoryBindInfo>vecImageOpaqueBinds;
    std::vector<VkSparseImageMemoryBindInfo>    vecImageBinds;
    std::vector<VkSemaphore>                    vecSignalSemaphores;
};

std::shared_ptr<VkBindSparseInfoRAII> BindSparseInfo(
    const std::vector<VkSemaphore> &            vecWaitSemaphores,
    const std::vector<VkSparseBufferMemoryBindInfo> &vecBufferBinds,
    const std::vector<VkSparseImageOpaqueMemoryBindInfo> &vecImageOpaqueBinds,
    const std::vector<VkSparseImageMemoryBindInfo> &vecImageBinds,
    const std::vector<VkSemaphore> &            vecSignalSemaphores)
   {
      std::shared_ptr<VkBindSparseInfoRAII> raii_obj(new VkBindSparseInfoRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_BIND_SPARSE_INFO;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.waitSemaphoreCount = static_cast<uint32_t>(vecWaitSemaphores.size());
      raii_obj->vecWaitSemaphores = vecWaitSemaphores;
      if ( raii_obj->vecWaitSemaphores.size() > 0)
      {
          raii_obj->nonRaiiObj.pWaitSemaphores = &raii_obj->vecWaitSemaphores[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pWaitSemaphores = nullptr;
      }
      raii_obj->nonRaiiObj.bufferBindCount = static_cast<uint32_t>(vecBufferBinds.size());
      raii_obj->vecBufferBinds = vecBufferBinds;
      if ( raii_obj->vecBufferBinds.size() > 0)
      {
          raii_obj->nonRaiiObj.pBufferBinds = &raii_obj->vecBufferBinds[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pBufferBinds = nullptr;
      }
      raii_obj->nonRaiiObj.imageOpaqueBindCount = static_cast<uint32_t>(vecImageOpaqueBinds.size());
      raii_obj->vecImageOpaqueBinds = vecImageOpaqueBinds;
      if ( raii_obj->vecImageOpaqueBinds.size() > 0)
      {
          raii_obj->nonRaiiObj.pImageOpaqueBinds = &raii_obj->vecImageOpaqueBinds[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pImageOpaqueBinds = nullptr;
      }
      raii_obj->nonRaiiObj.imageBindCount = static_cast<uint32_t>(vecImageBinds.size());
      raii_obj->vecImageBinds = vecImageBinds;
      if ( raii_obj->vecImageBinds.size() > 0)
      {
          raii_obj->nonRaiiObj.pImageBinds = &raii_obj->vecImageBinds[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pImageBinds = nullptr;
      }
      raii_obj->nonRaiiObj.signalSemaphoreCount = static_cast<uint32_t>(vecSignalSemaphores.size());
      raii_obj->vecSignalSemaphores = vecSignalSemaphores;
      if ( raii_obj->vecSignalSemaphores.size() > 0)
      {
          raii_obj->nonRaiiObj.pSignalSemaphores = &raii_obj->vecSignalSemaphores[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pSignalSemaphores = nullptr;
      }
      return raii_obj;
   }

void  queueBindSparse(
        VkQueue queue,
        const std::vector<VkBindSparseInfo> & pBindInfo,
        VkFence fence)
   {
      V( vkQueueBindSparse(
          queue,
          static_cast<uint32_t>(pBindInfo.size()),
          &pBindInfo[0],
          fence  ));
   }

VkFenceCreateInfo FenceCreateInfo(
    VkFenceCreateFlags                          flags)
   {
      VkFenceCreateInfo obj;
      obj.sType = VK_STRUCTURE_TYPE_FENCE_CREATE_INFO;
      obj.pNext = nullptr;
      obj.flags = flags;
      return obj;
   }

std::shared_ptr<VkFence_T> createFence(
        VkDevice device,
        const VkFenceCreateInfo & pCreateInfo)
   {
      VkFence hFence; 
      V( vkCreateFence(
          device,
          &pCreateInfo,
          nullptr,
          &hFence  ));
      return std::shared_ptr<VkFence_T>(hFence, 
              [=](VkFence to_free) {vkDestroyFence(device, to_free, nullptr);});
   }

void  resetFences(
        VkDevice device,
        const std::vector<VkFence> & pFences)
   {
      V( vkResetFences(
          device,
          static_cast<uint32_t>(pFences.size()),
          &pFences[0]  ));
   }

void  getFenceStatus(
        VkDevice device,
        VkFence fence)
   {
      V( vkGetFenceStatus(
          device,
          fence  ));
   }

void  waitForFences(
        VkDevice device,
        const std::vector<VkFence> & pFences,
        VkBool32 waitAll,
        uint64_t timeout)
   {
      V( vkWaitForFences(
          device,
          static_cast<uint32_t>(pFences.size()),
          &pFences[0],
          waitAll,
          timeout  ));
   }

VkSemaphoreCreateInfo SemaphoreCreateInfo(
    VkSemaphoreCreateFlags                      flags)
   {
      VkSemaphoreCreateInfo obj;
      obj.sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO;
      obj.pNext = nullptr;
      obj.flags = flags;
      return obj;
   }

std::shared_ptr<VkSemaphore_T> createSemaphore(
        VkDevice device,
        const VkSemaphoreCreateInfo & pCreateInfo)
   {
      VkSemaphore hSemaphore; 
      V( vkCreateSemaphore(
          device,
          &pCreateInfo,
          nullptr,
          &hSemaphore  ));
      return std::shared_ptr<VkSemaphore_T>(hSemaphore, 
              [=](VkSemaphore to_free) {vkDestroySemaphore(device, to_free, nullptr);});
   }

VkEventCreateInfo EventCreateInfo(
    VkEventCreateFlags                          flags)
   {
      VkEventCreateInfo obj;
      obj.sType = VK_STRUCTURE_TYPE_EVENT_CREATE_INFO;
      obj.pNext = nullptr;
      obj.flags = flags;
      return obj;
   }

std::shared_ptr<VkEvent_T> createEvent(
        VkDevice device,
        const VkEventCreateInfo & pCreateInfo)
   {
      VkEvent hEvent; 
      V( vkCreateEvent(
          device,
          &pCreateInfo,
          nullptr,
          &hEvent  ));
      return std::shared_ptr<VkEvent_T>(hEvent, 
              [=](VkEvent to_free) {vkDestroyEvent(device, to_free, nullptr);});
   }

void  getEventStatus(
        VkDevice device,
        VkEvent event)
   {
      V( vkGetEventStatus(
          device,
          event  ));
   }

void  setEvent(
        VkDevice device,
        VkEvent event)
   {
      V( vkSetEvent(
          device,
          event  ));
   }

void  resetEvent(
        VkDevice device,
        VkEvent event)
   {
      V( vkResetEvent(
          device,
          event  ));
   }

VkQueryPoolCreateInfo QueryPoolCreateInfo(
    VkQueryPoolCreateFlags                      flags,
    VkQueryType                                 queryType,
    uint32_t                                    queryCount,
    VkQueryPipelineStatisticFlags               pipelineStatistics)
   {
      VkQueryPoolCreateInfo obj;
      obj.sType = VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO;
      obj.pNext = nullptr;
      obj.flags = flags;
      obj.queryType = queryType;
      obj.queryCount = queryCount;
      obj.pipelineStatistics = pipelineStatistics;
      return obj;
   }

std::shared_ptr<VkQueryPool_T> createQueryPool(
        VkDevice device,
        const VkQueryPoolCreateInfo & pCreateInfo)
   {
      VkQueryPool hQueryPool; 
      V( vkCreateQueryPool(
          device,
          &pCreateInfo,
          nullptr,
          &hQueryPool  ));
      return std::shared_ptr<VkQueryPool_T>(hQueryPool, 
              [=](VkQueryPool to_free) {vkDestroyQueryPool(device, to_free, nullptr);});
   }

void  getQueryPoolResults(
        VkDevice device,
        VkQueryPool queryPool,
        uint32_t firstQuery,
        uint32_t queryCount,
        size_t dataSize,
        VkDeviceSize stride,
        VkQueryResultFlags flags)
   {
      V( vkGetQueryPoolResults(
          device,
          queryPool,
          firstQuery,
          queryCount,
          dataSize,
          nullptr,
          stride,
          flags  ));
   }

struct VkBufferCreateInfoRAII {
   VkBufferCreateInfo nonRaiiObj;
    std::vector<uint32_t>                       vecQueueFamilyIndices;
};

std::shared_ptr<VkBufferCreateInfoRAII> BufferCreateInfo(
    VkBufferCreateFlags                         flags,
    VkDeviceSize                                size,
    VkBufferUsageFlags                          usage,
    VkSharingMode                               sharingMode,
    unsigned int* pQueueFamilyIndices_in_array1, int pQueueFamilyIndices_dim1)
   {
      std::shared_ptr<VkBufferCreateInfoRAII> raii_obj(new VkBufferCreateInfoRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.flags = flags;
      raii_obj->nonRaiiObj.size = size;
      raii_obj->nonRaiiObj.usage = usage;
      raii_obj->nonRaiiObj.sharingMode = sharingMode;
      raii_obj->nonRaiiObj.queueFamilyIndexCount = static_cast<uint32_t>(pQueueFamilyIndices_dim1);
      raii_obj->vecQueueFamilyIndices.assign(pQueueFamilyIndices_in_array1, pQueueFamilyIndices_in_array1 + pQueueFamilyIndices_dim1);
      if ( raii_obj->vecQueueFamilyIndices.size() > 0)
      {
          raii_obj->nonRaiiObj.pQueueFamilyIndices = &raii_obj->vecQueueFamilyIndices[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pQueueFamilyIndices = nullptr;
      }
      return raii_obj;
   }

std::shared_ptr<VkBuffer_T> createBuffer(
        VkDevice device,
        const VkBufferCreateInfo & pCreateInfo)
   {
      VkBuffer hBuffer; 
      V( vkCreateBuffer(
          device,
          &pCreateInfo,
          nullptr,
          &hBuffer  ));
      return std::shared_ptr<VkBuffer_T>(hBuffer, 
              [=](VkBuffer to_free) {vkDestroyBuffer(device, to_free, nullptr);});
   }

VkBufferViewCreateInfo BufferViewCreateInfo(
    VkBufferViewCreateFlags                     flags,
    VkBuffer                                    buffer,
    VkFormat                                    format,
    VkDeviceSize                                offset,
    VkDeviceSize                                range)
   {
      VkBufferViewCreateInfo obj;
      obj.sType = VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO;
      obj.pNext = nullptr;
      obj.flags = flags;
      obj.buffer = buffer;
      obj.format = format;
      obj.offset = offset;
      obj.range = range;
      return obj;
   }

std::shared_ptr<VkBufferView_T> createBufferView(
        VkDevice device,
        const VkBufferViewCreateInfo & pCreateInfo)
   {
      VkBufferView hView; 
      V( vkCreateBufferView(
          device,
          &pCreateInfo,
          nullptr,
          &hView  ));
      return std::shared_ptr<VkBufferView_T>(hView, 
              [=](VkBufferView to_free) {vkDestroyBufferView(device, to_free, nullptr);});
   }

struct VkImageCreateInfoRAII {
   VkImageCreateInfo nonRaiiObj;
    std::vector<uint32_t>                       vecQueueFamilyIndices;
};

std::shared_ptr<VkImageCreateInfoRAII> ImageCreateInfo(
    VkImageCreateFlags                          flags,
    VkImageType                                 imageType,
    VkFormat                                    format,
    VkExtent3D                                  extent,
    uint32_t                                    mipLevels,
    uint32_t                                    arrayLayers,
    VkSampleCountFlagBits                       samples,
    VkImageTiling                               tiling,
    VkImageUsageFlags                           usage,
    VkSharingMode                               sharingMode,
    unsigned int* pQueueFamilyIndices_in_array1, int pQueueFamilyIndices_dim1,
    VkImageLayout                               initialLayout)
   {
      std::shared_ptr<VkImageCreateInfoRAII> raii_obj(new VkImageCreateInfoRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.flags = flags;
      raii_obj->nonRaiiObj.imageType = imageType;
      raii_obj->nonRaiiObj.format = format;
      raii_obj->nonRaiiObj.extent = extent;
      raii_obj->nonRaiiObj.mipLevels = mipLevels;
      raii_obj->nonRaiiObj.arrayLayers = arrayLayers;
      raii_obj->nonRaiiObj.samples = samples;
      raii_obj->nonRaiiObj.tiling = tiling;
      raii_obj->nonRaiiObj.usage = usage;
      raii_obj->nonRaiiObj.sharingMode = sharingMode;
      raii_obj->nonRaiiObj.queueFamilyIndexCount = static_cast<uint32_t>(pQueueFamilyIndices_dim1);
      raii_obj->vecQueueFamilyIndices.assign(pQueueFamilyIndices_in_array1, pQueueFamilyIndices_in_array1 + pQueueFamilyIndices_dim1);
      if ( raii_obj->vecQueueFamilyIndices.size() > 0)
      {
          raii_obj->nonRaiiObj.pQueueFamilyIndices = &raii_obj->vecQueueFamilyIndices[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pQueueFamilyIndices = nullptr;
      }
      raii_obj->nonRaiiObj.initialLayout = initialLayout;
      return raii_obj;
   }

std::shared_ptr<VkImage_T> createImage(
        VkDevice device,
        const VkImageCreateInfo & pCreateInfo)
   {
      VkImage hImage; 
      V( vkCreateImage(
          device,
          &pCreateInfo,
          nullptr,
          &hImage  ));
      return std::shared_ptr<VkImage_T>(hImage, 
              [=](VkImage to_free) {vkDestroyImage(device, to_free, nullptr);});
   }

VkSubresourceLayout SubresourceLayout(
    VkDeviceSize                                offset,
    VkDeviceSize                                size,
    VkDeviceSize                                rowPitch,
    VkDeviceSize                                arrayPitch,
    VkDeviceSize                                depthPitch)
   {
      VkSubresourceLayout obj;
      obj.offset = offset;
      obj.size = size;
      obj.rowPitch = rowPitch;
      obj.arrayPitch = arrayPitch;
      obj.depthPitch = depthPitch;
      return obj;
   }

VkSubresourceLayout getImageSubresourceLayout(
        VkDevice device,
        VkImage image,
        const VkImageSubresource & pSubresource)
   {
      VkSubresourceLayout pLayout; 
      vkGetImageSubresourceLayout(
          device,
          image,
          &pSubresource,
          &pLayout  );
      return pLayout; 
   }

VkComponentMapping ComponentMapping(
    VkComponentSwizzle                          r,
    VkComponentSwizzle                          g,
    VkComponentSwizzle                          b,
    VkComponentSwizzle                          a)
   {
      VkComponentMapping obj;
      obj.r = r;
      obj.g = g;
      obj.b = b;
      obj.a = a;
      return obj;
   }

VkImageSubresourceRange ImageSubresourceRange(
    VkImageAspectFlags                          aspectMask,
    uint32_t                                    baseMipLevel,
    uint32_t                                    levelCount,
    uint32_t                                    baseArrayLayer,
    uint32_t                                    layerCount)
   {
      VkImageSubresourceRange obj;
      obj.aspectMask = aspectMask;
      obj.baseMipLevel = baseMipLevel;
      obj.levelCount = levelCount;
      obj.baseArrayLayer = baseArrayLayer;
      obj.layerCount = layerCount;
      return obj;
   }

VkImageViewCreateInfo ImageViewCreateInfo(
    VkImageViewCreateFlags                      flags,
    VkImage                                     image,
    VkImageViewType                             viewType,
    VkFormat                                    format,
    VkComponentMapping                          components,
    VkImageSubresourceRange                     subresourceRange)
   {
      VkImageViewCreateInfo obj;
      obj.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO;
      obj.pNext = nullptr;
      obj.flags = flags;
      obj.image = image;
      obj.viewType = viewType;
      obj.format = format;
      obj.components = components;
      obj.subresourceRange = subresourceRange;
      return obj;
   }

std::shared_ptr<VkImageView_T> createImageView(
        VkDevice device,
        const VkImageViewCreateInfo & pCreateInfo)
   {
      VkImageView hView; 
      V( vkCreateImageView(
          device,
          &pCreateInfo,
          nullptr,
          &hView  ));
      return std::shared_ptr<VkImageView_T>(hView, 
              [=](VkImageView to_free) {vkDestroyImageView(device, to_free, nullptr);});
   }

struct VkShaderModuleCreateInfoRAII {
   VkShaderModuleCreateInfo nonRaiiObj;
    std::vector<uint32_t>                       vecCode;
};

std::shared_ptr<VkShaderModuleCreateInfoRAII> ShaderModuleCreateInfo(
    VkShaderModuleCreateFlags                   flags,
    unsigned int* pCode_in_array1, int pCode_dim1)
   {
      std::shared_ptr<VkShaderModuleCreateInfoRAII> raii_obj(new VkShaderModuleCreateInfoRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.flags = flags;
      raii_obj->nonRaiiObj.codeSize = static_cast<size_t>(pCode_dim1) * sizeof(unsigned int);
      raii_obj->vecCode.assign(pCode_in_array1, pCode_in_array1 + pCode_dim1);
      if ( raii_obj->vecCode.size() > 0)
      {
          raii_obj->nonRaiiObj.pCode = &raii_obj->vecCode[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pCode = nullptr;
      }
      return raii_obj;
   }

std::shared_ptr<VkShaderModule_T> createShaderModule(
        VkDevice device,
        const VkShaderModuleCreateInfo & pCreateInfo)
   {
      VkShaderModule hShaderModule; 
      V( vkCreateShaderModule(
          device,
          &pCreateInfo,
          nullptr,
          &hShaderModule  ));
      return std::shared_ptr<VkShaderModule_T>(hShaderModule, 
              [=](VkShaderModule to_free) {vkDestroyShaderModule(device, to_free, nullptr);});
   }

struct VkPipelineCacheCreateInfoRAII {
   VkPipelineCacheCreateInfo nonRaiiObj;
    std::vector<uint8_t>                        vecInitialData;
};

std::shared_ptr<VkPipelineCacheCreateInfoRAII> PipelineCacheCreateInfo(
    VkPipelineCacheCreateFlags                  flags,
    const std::vector<uint8_t> &                vecInitialData)
   {
      std::shared_ptr<VkPipelineCacheCreateInfoRAII> raii_obj(new VkPipelineCacheCreateInfoRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.flags = flags;
      raii_obj->nonRaiiObj.initialDataSize = static_cast<size_t>(vecInitialData.size());
      raii_obj->vecInitialData = vecInitialData;
      if ( raii_obj->vecInitialData.size() > 0)
      {
          raii_obj->nonRaiiObj.pInitialData = &raii_obj->vecInitialData[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pInitialData = nullptr;
      }
      return raii_obj;
   }

std::shared_ptr<VkPipelineCache_T> createPipelineCache(
        VkDevice device,
        const VkPipelineCacheCreateInfo & pCreateInfo)
   {
      VkPipelineCache hPipelineCache; 
      V( vkCreatePipelineCache(
          device,
          &pCreateInfo,
          nullptr,
          &hPipelineCache  ));
      return std::shared_ptr<VkPipelineCache_T>(hPipelineCache, 
              [=](VkPipelineCache to_free) {vkDestroyPipelineCache(device, to_free, nullptr);});
   }

size_t getPipelineCacheData(
        VkDevice device,
        VkPipelineCache pipelineCache)
   {
      size_t pDataSize; 
      V( vkGetPipelineCacheData(
          device,
          pipelineCache,
          &pDataSize,
          nullptr  ));
      return pDataSize; 
   }

void  mergePipelineCaches(
        VkDevice device,
        VkPipelineCache dstCache,
        const std::vector<VkPipelineCache> & pSrcCaches)
   {
      V( vkMergePipelineCaches(
          device,
          dstCache,
          static_cast<uint32_t>(pSrcCaches.size()),
          &pSrcCaches[0]  ));
   }

VkSpecializationMapEntry SpecializationMapEntry(
    uint32_t                                    constantID,
    uint32_t                                    offset,
    size_t                                      size)
   {
      VkSpecializationMapEntry obj;
      obj.constantID = constantID;
      obj.offset = offset;
      obj.size = size;
      return obj;
   }

struct VkSpecializationInfoRAII {
   VkSpecializationInfo nonRaiiObj;
    std::vector<VkSpecializationMapEntry>       vecMapEntries;
    std::vector<uint8_t>                        vecData;
};

std::shared_ptr<VkSpecializationInfoRAII> SpecializationInfo(
    const std::vector<VkSpecializationMapEntry> &vecMapEntries,
    const std::vector<uint8_t> &                vecData)
   {
      std::shared_ptr<VkSpecializationInfoRAII> raii_obj(new VkSpecializationInfoRAII);
      raii_obj->nonRaiiObj.mapEntryCount = static_cast<uint32_t>(vecMapEntries.size());
      raii_obj->vecMapEntries = vecMapEntries;
      if ( raii_obj->vecMapEntries.size() > 0)
      {
          raii_obj->nonRaiiObj.pMapEntries = &raii_obj->vecMapEntries[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pMapEntries = nullptr;
      }
      raii_obj->nonRaiiObj.dataSize = static_cast<size_t>(vecData.size());
      raii_obj->vecData = vecData;
      if ( raii_obj->vecData.size() > 0)
      {
          raii_obj->nonRaiiObj.pData = &raii_obj->vecData[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pData = nullptr;
      }
      return raii_obj;
   }

struct VkPipelineShaderStageCreateInfoRAII {
   VkPipelineShaderStageCreateInfo nonRaiiObj;
    std::string                                 strName;
    std::shared_ptr<VkSpecializationInfoRAII>   pSpecializationInfo;
};

std::shared_ptr<VkPipelineShaderStageCreateInfoRAII> PipelineShaderStageCreateInfo(
    VkPipelineShaderStageCreateFlags            flags,
    VkShaderStageFlagBits                       stage,
    VkShaderModule                              module,
    const std::string &                         strName,
    const std::shared_ptr<VkSpecializationInfoRAII> &pSpecializationInfo)
   {
      std::shared_ptr<VkPipelineShaderStageCreateInfoRAII> raii_obj(new VkPipelineShaderStageCreateInfoRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.flags = flags;
      raii_obj->nonRaiiObj.stage = stage;
      raii_obj->nonRaiiObj.module = module;
      raii_obj->strName = strName;
      raii_obj->nonRaiiObj.pName = &raii_obj->strName[0];
      raii_obj->pSpecializationInfo = pSpecializationInfo;
      if ( pSpecializationInfo ) 
      {
          raii_obj->nonRaiiObj.pSpecializationInfo = &(pSpecializationInfo->nonRaiiObj);
      }
      else
      {
          raii_obj->nonRaiiObj.pSpecializationInfo = nullptr;
      }
      return raii_obj;
   }

VkVertexInputBindingDescription VertexInputBindingDescription(
    uint32_t                                    binding,
    uint32_t                                    stride,
    VkVertexInputRate                           inputRate)
   {
      VkVertexInputBindingDescription obj;
      obj.binding = binding;
      obj.stride = stride;
      obj.inputRate = inputRate;
      return obj;
   }

VkVertexInputAttributeDescription VertexInputAttributeDescription(
    uint32_t                                    location,
    uint32_t                                    binding,
    VkFormat                                    format,
    uint32_t                                    offset)
   {
      VkVertexInputAttributeDescription obj;
      obj.location = location;
      obj.binding = binding;
      obj.format = format;
      obj.offset = offset;
      return obj;
   }

struct VkPipelineVertexInputStateCreateInfoRAII {
   VkPipelineVertexInputStateCreateInfo nonRaiiObj;
    std::vector<VkVertexInputBindingDescription>vecVertexBindingDescriptions;
    std::vector<VkVertexInputAttributeDescription>vecVertexAttributeDescriptions;
};

std::shared_ptr<VkPipelineVertexInputStateCreateInfoRAII> PipelineVertexInputStateCreateInfo(
    VkPipelineVertexInputStateCreateFlags       flags,
    const std::vector<VkVertexInputBindingDescription> &vecVertexBindingDescriptions,
    const std::vector<VkVertexInputAttributeDescription> &vecVertexAttributeDescriptions)
   {
      std::shared_ptr<VkPipelineVertexInputStateCreateInfoRAII> raii_obj(new VkPipelineVertexInputStateCreateInfoRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.flags = flags;
      raii_obj->nonRaiiObj.vertexBindingDescriptionCount = static_cast<uint32_t>(vecVertexBindingDescriptions.size());
      raii_obj->vecVertexBindingDescriptions = vecVertexBindingDescriptions;
      if ( raii_obj->vecVertexBindingDescriptions.size() > 0)
      {
          raii_obj->nonRaiiObj.pVertexBindingDescriptions = &raii_obj->vecVertexBindingDescriptions[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pVertexBindingDescriptions = nullptr;
      }
      raii_obj->nonRaiiObj.vertexAttributeDescriptionCount = static_cast<uint32_t>(vecVertexAttributeDescriptions.size());
      raii_obj->vecVertexAttributeDescriptions = vecVertexAttributeDescriptions;
      if ( raii_obj->vecVertexAttributeDescriptions.size() > 0)
      {
          raii_obj->nonRaiiObj.pVertexAttributeDescriptions = &raii_obj->vecVertexAttributeDescriptions[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pVertexAttributeDescriptions = nullptr;
      }
      return raii_obj;
   }

VkPipelineInputAssemblyStateCreateInfo PipelineInputAssemblyStateCreateInfo(
    VkPipelineInputAssemblyStateCreateFlags     flags,
    VkPrimitiveTopology                         topology,
    VkBool32                                    primitiveRestartEnable)
   {
      VkPipelineInputAssemblyStateCreateInfo obj;
      obj.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
      obj.pNext = nullptr;
      obj.flags = flags;
      obj.topology = topology;
      obj.primitiveRestartEnable = primitiveRestartEnable;
      return obj;
   }

VkPipelineTessellationStateCreateInfo PipelineTessellationStateCreateInfo(
    VkPipelineTessellationStateCreateFlags      flags,
    uint32_t                                    patchControlPoints)
   {
      VkPipelineTessellationStateCreateInfo obj;
      obj.sType = VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO;
      obj.pNext = nullptr;
      obj.flags = flags;
      obj.patchControlPoints = patchControlPoints;
      return obj;
   }

VkViewport Viewport(
    float                                       x,
    float                                       y,
    float                                       width,
    float                                       height,
    float                                       minDepth,
    float                                       maxDepth)
   {
      VkViewport obj;
      obj.x = x;
      obj.y = y;
      obj.width = width;
      obj.height = height;
      obj.minDepth = minDepth;
      obj.maxDepth = maxDepth;
      return obj;
   }

VkOffset2D Offset2D(
    int32_t                                     x,
    int32_t                                     y)
   {
      VkOffset2D obj;
      obj.x = x;
      obj.y = y;
      return obj;
   }

VkExtent2D Extent2D(
    uint32_t                                    width,
    uint32_t                                    height)
   {
      VkExtent2D obj;
      obj.width = width;
      obj.height = height;
      return obj;
   }

VkRect2D Rect2D(
    VkOffset2D                                  offset,
    VkExtent2D                                  extent)
   {
      VkRect2D obj;
      obj.offset = offset;
      obj.extent = extent;
      return obj;
   }

struct VkPipelineViewportStateCreateInfoRAII {
   VkPipelineViewportStateCreateInfo nonRaiiObj;
    std::vector<VkViewport>                     vecViewports;
    std::vector<VkRect2D>                       vecScissors;
};

std::shared_ptr<VkPipelineViewportStateCreateInfoRAII> PipelineViewportStateCreateInfo(
    VkPipelineViewportStateCreateFlags          flags,
    const std::vector<VkViewport> &             vecViewports,
    const std::vector<VkRect2D> &               vecScissors)
   {
      std::shared_ptr<VkPipelineViewportStateCreateInfoRAII> raii_obj(new VkPipelineViewportStateCreateInfoRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.flags = flags;
      raii_obj->nonRaiiObj.viewportCount = static_cast<uint32_t>(vecViewports.size());
      raii_obj->vecViewports = vecViewports;
      if ( raii_obj->vecViewports.size() > 0)
      {
          raii_obj->nonRaiiObj.pViewports = &raii_obj->vecViewports[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pViewports = nullptr;
      }
      raii_obj->nonRaiiObj.scissorCount = static_cast<uint32_t>(vecScissors.size());
      raii_obj->vecScissors = vecScissors;
      if ( raii_obj->vecScissors.size() > 0)
      {
          raii_obj->nonRaiiObj.pScissors = &raii_obj->vecScissors[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pScissors = nullptr;
      }
      return raii_obj;
   }

VkPipelineRasterizationStateCreateInfo PipelineRasterizationStateCreateInfo(
    VkPipelineRasterizationStateCreateFlags     flags,
    VkBool32                                    depthClampEnable,
    VkBool32                                    rasterizerDiscardEnable,
    VkPolygonMode                               polygonMode,
    VkCullModeFlags                             cullMode,
    VkFrontFace                                 frontFace,
    VkBool32                                    depthBiasEnable,
    float                                       depthBiasConstantFactor,
    float                                       depthBiasClamp,
    float                                       depthBiasSlopeFactor,
    float                                       lineWidth)
   {
      VkPipelineRasterizationStateCreateInfo obj;
      obj.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
      obj.pNext = nullptr;
      obj.flags = flags;
      obj.depthClampEnable = depthClampEnable;
      obj.rasterizerDiscardEnable = rasterizerDiscardEnable;
      obj.polygonMode = polygonMode;
      obj.cullMode = cullMode;
      obj.frontFace = frontFace;
      obj.depthBiasEnable = depthBiasEnable;
      obj.depthBiasConstantFactor = depthBiasConstantFactor;
      obj.depthBiasClamp = depthBiasClamp;
      obj.depthBiasSlopeFactor = depthBiasSlopeFactor;
      obj.lineWidth = lineWidth;
      return obj;
   }

VkPipelineMultisampleStateCreateInfo PipelineMultisampleStateCreateInfo(
    VkPipelineMultisampleStateCreateFlags       flags,
    VkSampleCountFlagBits                       rasterizationSamples,
    VkBool32                                    sampleShadingEnable,
    float                                       minSampleShading,
    const VkSampleMask*                         pSampleMask,
    VkBool32                                    alphaToCoverageEnable,
    VkBool32                                    alphaToOneEnable)
   {
      VkPipelineMultisampleStateCreateInfo obj;
      obj.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
      obj.pNext = nullptr;
      obj.flags = flags;
      obj.rasterizationSamples = rasterizationSamples;
      obj.sampleShadingEnable = sampleShadingEnable;
      obj.minSampleShading = minSampleShading;
      obj.pSampleMask = pSampleMask;
      obj.alphaToCoverageEnable = alphaToCoverageEnable;
      obj.alphaToOneEnable = alphaToOneEnable;
      return obj;
   }

VkStencilOpState StencilOpState(
    VkStencilOp                                 failOp,
    VkStencilOp                                 passOp,
    VkStencilOp                                 depthFailOp,
    VkCompareOp                                 compareOp,
    uint32_t                                    compareMask,
    uint32_t                                    writeMask,
    uint32_t                                    reference)
   {
      VkStencilOpState obj;
      obj.failOp = failOp;
      obj.passOp = passOp;
      obj.depthFailOp = depthFailOp;
      obj.compareOp = compareOp;
      obj.compareMask = compareMask;
      obj.writeMask = writeMask;
      obj.reference = reference;
      return obj;
   }

VkPipelineDepthStencilStateCreateInfo PipelineDepthStencilStateCreateInfo(
    VkPipelineDepthStencilStateCreateFlags      flags,
    VkBool32                                    depthTestEnable,
    VkBool32                                    depthWriteEnable,
    VkCompareOp                                 depthCompareOp,
    VkBool32                                    depthBoundsTestEnable,
    VkBool32                                    stencilTestEnable,
    VkStencilOpState                            front,
    VkStencilOpState                            back,
    float                                       minDepthBounds,
    float                                       maxDepthBounds)
   {
      VkPipelineDepthStencilStateCreateInfo obj;
      obj.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
      obj.pNext = nullptr;
      obj.flags = flags;
      obj.depthTestEnable = depthTestEnable;
      obj.depthWriteEnable = depthWriteEnable;
      obj.depthCompareOp = depthCompareOp;
      obj.depthBoundsTestEnable = depthBoundsTestEnable;
      obj.stencilTestEnable = stencilTestEnable;
      obj.front = front;
      obj.back = back;
      obj.minDepthBounds = minDepthBounds;
      obj.maxDepthBounds = maxDepthBounds;
      return obj;
   }

VkPipelineColorBlendAttachmentState PipelineColorBlendAttachmentState(
    VkBool32                                    blendEnable,
    VkBlendFactor                               srcColorBlendFactor,
    VkBlendFactor                               dstColorBlendFactor,
    VkBlendOp                                   colorBlendOp,
    VkBlendFactor                               srcAlphaBlendFactor,
    VkBlendFactor                               dstAlphaBlendFactor,
    VkBlendOp                                   alphaBlendOp,
    VkColorComponentFlags                       colorWriteMask)
   {
      VkPipelineColorBlendAttachmentState obj;
      obj.blendEnable = blendEnable;
      obj.srcColorBlendFactor = srcColorBlendFactor;
      obj.dstColorBlendFactor = dstColorBlendFactor;
      obj.colorBlendOp = colorBlendOp;
      obj.srcAlphaBlendFactor = srcAlphaBlendFactor;
      obj.dstAlphaBlendFactor = dstAlphaBlendFactor;
      obj.alphaBlendOp = alphaBlendOp;
      obj.colorWriteMask = colorWriteMask;
      return obj;
   }

struct VkPipelineColorBlendStateCreateInfoRAII {
   VkPipelineColorBlendStateCreateInfo nonRaiiObj;
    std::vector<VkPipelineColorBlendAttachmentState>vecAttachments;
};

std::shared_ptr<VkPipelineColorBlendStateCreateInfoRAII> PipelineColorBlendStateCreateInfo(
    VkPipelineColorBlendStateCreateFlags        flags,
    VkBool32                                    logicOpEnable,
    VkLogicOp                                   logicOp,
    const std::vector<VkPipelineColorBlendAttachmentState> &vecAttachments,
    float                                       blendConstants[4])
   {
      std::shared_ptr<VkPipelineColorBlendStateCreateInfoRAII> raii_obj(new VkPipelineColorBlendStateCreateInfoRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.flags = flags;
      raii_obj->nonRaiiObj.logicOpEnable = logicOpEnable;
      raii_obj->nonRaiiObj.logicOp = logicOp;
      raii_obj->nonRaiiObj.attachmentCount = static_cast<uint32_t>(vecAttachments.size());
      raii_obj->vecAttachments = vecAttachments;
      if ( raii_obj->vecAttachments.size() > 0)
      {
          raii_obj->nonRaiiObj.pAttachments = &raii_obj->vecAttachments[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pAttachments = nullptr;
      }
      std::copy(blendConstants, blendConstants + 4, raii_obj->nonRaiiObj.blendConstants);
      return raii_obj;
   }

struct VkPipelineDynamicStateCreateInfoRAII {
   VkPipelineDynamicStateCreateInfo nonRaiiObj;
    std::vector<VkDynamicState>                 vecDynamicStates;
};

std::shared_ptr<VkPipelineDynamicStateCreateInfoRAII> PipelineDynamicStateCreateInfo(
    VkPipelineDynamicStateCreateFlags           flags,
    const std::vector<VkDynamicState> &         vecDynamicStates)
   {
      std::shared_ptr<VkPipelineDynamicStateCreateInfoRAII> raii_obj(new VkPipelineDynamicStateCreateInfoRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.flags = flags;
      raii_obj->nonRaiiObj.dynamicStateCount = static_cast<uint32_t>(vecDynamicStates.size());
      raii_obj->vecDynamicStates = vecDynamicStates;
      if ( raii_obj->vecDynamicStates.size() > 0)
      {
          raii_obj->nonRaiiObj.pDynamicStates = &raii_obj->vecDynamicStates[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pDynamicStates = nullptr;
      }
      return raii_obj;
   }

struct VkGraphicsPipelineCreateInfoRAII {
   VkGraphicsPipelineCreateInfo nonRaiiObj;
    std::vector<VkPipelineShaderStageCreateInfo>vecStages;
    std::shared_ptr<VkPipelineVertexInputStateCreateInfoRAII>pVertexInputState;
    std::shared_ptr<VkPipelineInputAssemblyStateCreateInfo>pInputAssemblyState;
    std::shared_ptr<VkPipelineTessellationStateCreateInfo>pTessellationState;
    std::shared_ptr<VkPipelineViewportStateCreateInfoRAII>pViewportState;
    std::shared_ptr<VkPipelineRasterizationStateCreateInfo>pRasterizationState;
    std::shared_ptr<VkPipelineMultisampleStateCreateInfo>pMultisampleState;
    std::shared_ptr<VkPipelineDepthStencilStateCreateInfo>pDepthStencilState;
    std::shared_ptr<VkPipelineColorBlendStateCreateInfoRAII>pColorBlendState;
    std::shared_ptr<VkPipelineDynamicStateCreateInfoRAII>pDynamicState;
};

std::shared_ptr<VkGraphicsPipelineCreateInfoRAII> GraphicsPipelineCreateInfo(
    VkPipelineCreateFlags                       flags,
    const std::vector<VkPipelineShaderStageCreateInfo> &vecStages,
    const std::shared_ptr<VkPipelineVertexInputStateCreateInfoRAII> &pVertexInputState,
    const VkPipelineInputAssemblyStateCreateInfo *pInputAssemblyState,
    const VkPipelineTessellationStateCreateInfo *pTessellationState,
    const std::shared_ptr<VkPipelineViewportStateCreateInfoRAII> &pViewportState,
    const VkPipelineRasterizationStateCreateInfo *pRasterizationState,
    const VkPipelineMultisampleStateCreateInfo *pMultisampleState,
    const VkPipelineDepthStencilStateCreateInfo *pDepthStencilState,
    const std::shared_ptr<VkPipelineColorBlendStateCreateInfoRAII> &pColorBlendState,
    const std::shared_ptr<VkPipelineDynamicStateCreateInfoRAII> &pDynamicState,
    VkPipelineLayout                            layout,
    VkRenderPass                                renderPass,
    uint32_t                                    subpass,
    VkPipeline                                  basePipelineHandle,
    int32_t                                     basePipelineIndex)
   {
      std::shared_ptr<VkGraphicsPipelineCreateInfoRAII> raii_obj(new VkGraphicsPipelineCreateInfoRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.flags = flags;
      raii_obj->nonRaiiObj.stageCount = static_cast<uint32_t>(vecStages.size());
      raii_obj->vecStages = vecStages;
      if ( raii_obj->vecStages.size() > 0)
      {
          raii_obj->nonRaiiObj.pStages = &raii_obj->vecStages[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pStages = nullptr;
      }
      raii_obj->pVertexInputState = pVertexInputState;
      if ( pVertexInputState ) 
      {
          raii_obj->nonRaiiObj.pVertexInputState = &(pVertexInputState->nonRaiiObj);
      }
      else
      {
          raii_obj->nonRaiiObj.pVertexInputState = nullptr;
      }
      raii_obj->nonRaiiObj.pInputAssemblyState = nullptr;
      if ( pInputAssemblyState ) 
      { 
          raii_obj->pInputAssemblyState.reset( new VkPipelineInputAssemblyStateCreateInfo );
          *raii_obj->pInputAssemblyState = *pInputAssemblyState;
          raii_obj->nonRaiiObj.pInputAssemblyState = raii_obj->pInputAssemblyState.get();
      } 
      raii_obj->nonRaiiObj.pTessellationState = nullptr;
      if ( pTessellationState ) 
      { 
          raii_obj->pTessellationState.reset( new VkPipelineTessellationStateCreateInfo );
          *raii_obj->pTessellationState = *pTessellationState;
          raii_obj->nonRaiiObj.pTessellationState = raii_obj->pTessellationState.get();
      } 
      raii_obj->pViewportState = pViewportState;
      if ( pViewportState ) 
      {
          raii_obj->nonRaiiObj.pViewportState = &(pViewportState->nonRaiiObj);
      }
      else
      {
          raii_obj->nonRaiiObj.pViewportState = nullptr;
      }
      raii_obj->nonRaiiObj.pRasterizationState = nullptr;
      if ( pRasterizationState ) 
      { 
          raii_obj->pRasterizationState.reset( new VkPipelineRasterizationStateCreateInfo );
          *raii_obj->pRasterizationState = *pRasterizationState;
          raii_obj->nonRaiiObj.pRasterizationState = raii_obj->pRasterizationState.get();
      } 
      raii_obj->nonRaiiObj.pMultisampleState = nullptr;
      if ( pMultisampleState ) 
      { 
          raii_obj->pMultisampleState.reset( new VkPipelineMultisampleStateCreateInfo );
          *raii_obj->pMultisampleState = *pMultisampleState;
          raii_obj->nonRaiiObj.pMultisampleState = raii_obj->pMultisampleState.get();
      } 
      raii_obj->nonRaiiObj.pDepthStencilState = nullptr;
      if ( pDepthStencilState ) 
      { 
          raii_obj->pDepthStencilState.reset( new VkPipelineDepthStencilStateCreateInfo );
          *raii_obj->pDepthStencilState = *pDepthStencilState;
          raii_obj->nonRaiiObj.pDepthStencilState = raii_obj->pDepthStencilState.get();
      } 
      raii_obj->pColorBlendState = pColorBlendState;
      if ( pColorBlendState ) 
      {
          raii_obj->nonRaiiObj.pColorBlendState = &(pColorBlendState->nonRaiiObj);
      }
      else
      {
          raii_obj->nonRaiiObj.pColorBlendState = nullptr;
      }
      raii_obj->pDynamicState = pDynamicState;
      if ( pDynamicState ) 
      {
          raii_obj->nonRaiiObj.pDynamicState = &(pDynamicState->nonRaiiObj);
      }
      else
      {
          raii_obj->nonRaiiObj.pDynamicState = nullptr;
      }
      raii_obj->nonRaiiObj.layout = layout;
      raii_obj->nonRaiiObj.renderPass = renderPass;
      raii_obj->nonRaiiObj.subpass = subpass;
      raii_obj->nonRaiiObj.basePipelineHandle = basePipelineHandle;
      raii_obj->nonRaiiObj.basePipelineIndex = basePipelineIndex;
      return raii_obj;
   }

std::vector< std::shared_ptr<VkPipeline_T> > createGraphicsPipelines(
        VkDevice device,
        VkPipelineCache pipelineCache,
        const std::vector<VkGraphicsPipelineCreateInfo> & pCreateInfos)
   {
      std::vector<VkPipeline> vecpPipelines( pCreateInfos.size(), nullptr ); 
      V( vkCreateGraphicsPipelines(
          device,
          pipelineCache,
          static_cast<uint32_t>(pCreateInfos.size()),
          &pCreateInfos[0],
          nullptr,
          &vecpPipelines[0]  ));
      std::vector< std::shared_ptr<VkPipeline_T> > retval; 
      retval.reserve(vecpPipelines.size()); 
      for (auto allocated_handle : vecpPipelines ) 
      {
          retval.push_back(std::shared_ptr<VkPipeline_T>(allocated_handle, 
              [=](VkPipeline to_free) {vkDestroyPipeline(device, to_free, nullptr);}));
      }
      return retval; 
   }

VkComputePipelineCreateInfo ComputePipelineCreateInfo(
    VkPipelineCreateFlags                       flags,
    VkPipelineShaderStageCreateInfo             stage,
    VkPipelineLayout                            layout,
    VkPipeline                                  basePipelineHandle,
    int32_t                                     basePipelineIndex)
   {
      VkComputePipelineCreateInfo obj;
      obj.sType = VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO;
      obj.pNext = nullptr;
      obj.flags = flags;
      obj.stage = stage;
      obj.layout = layout;
      obj.basePipelineHandle = basePipelineHandle;
      obj.basePipelineIndex = basePipelineIndex;
      return obj;
   }

std::vector< std::shared_ptr<VkPipeline_T> > createComputePipelines(
        VkDevice device,
        VkPipelineCache pipelineCache,
        const std::vector<VkComputePipelineCreateInfo> & pCreateInfos)
   {
      std::vector<VkPipeline> vecpPipelines( pCreateInfos.size(), nullptr ); 
      V( vkCreateComputePipelines(
          device,
          pipelineCache,
          static_cast<uint32_t>(pCreateInfos.size()),
          &pCreateInfos[0],
          nullptr,
          &vecpPipelines[0]  ));
      std::vector< std::shared_ptr<VkPipeline_T> > retval; 
      retval.reserve(vecpPipelines.size()); 
      for (auto allocated_handle : vecpPipelines ) 
      {
          retval.push_back(std::shared_ptr<VkPipeline_T>(allocated_handle, 
              [=](VkPipeline to_free) {vkDestroyPipeline(device, to_free, nullptr);}));
      }
      return retval; 
   }

VkPushConstantRange PushConstantRange(
    VkShaderStageFlags                          stageFlags,
    uint32_t                                    offset,
    uint32_t                                    size)
   {
      VkPushConstantRange obj;
      obj.stageFlags = stageFlags;
      obj.offset = offset;
      obj.size = size;
      return obj;
   }

struct VkPipelineLayoutCreateInfoRAII {
   VkPipelineLayoutCreateInfo nonRaiiObj;
    std::vector<VkDescriptorSetLayout>          vecSetLayouts;
    std::vector<VkPushConstantRange>            vecPushConstantRanges;
};

std::shared_ptr<VkPipelineLayoutCreateInfoRAII> PipelineLayoutCreateInfo(
    VkPipelineLayoutCreateFlags                 flags,
    const std::vector<VkDescriptorSetLayout> &  vecSetLayouts,
    const std::vector<VkPushConstantRange> &    vecPushConstantRanges)
   {
      std::shared_ptr<VkPipelineLayoutCreateInfoRAII> raii_obj(new VkPipelineLayoutCreateInfoRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.flags = flags;
      raii_obj->nonRaiiObj.setLayoutCount = static_cast<uint32_t>(vecSetLayouts.size());
      raii_obj->vecSetLayouts = vecSetLayouts;
      if ( raii_obj->vecSetLayouts.size() > 0)
      {
          raii_obj->nonRaiiObj.pSetLayouts = &raii_obj->vecSetLayouts[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pSetLayouts = nullptr;
      }
      raii_obj->nonRaiiObj.pushConstantRangeCount = static_cast<uint32_t>(vecPushConstantRanges.size());
      raii_obj->vecPushConstantRanges = vecPushConstantRanges;
      if ( raii_obj->vecPushConstantRanges.size() > 0)
      {
          raii_obj->nonRaiiObj.pPushConstantRanges = &raii_obj->vecPushConstantRanges[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pPushConstantRanges = nullptr;
      }
      return raii_obj;
   }

std::shared_ptr<VkPipelineLayout_T> createPipelineLayout(
        VkDevice device,
        const VkPipelineLayoutCreateInfo & pCreateInfo)
   {
      VkPipelineLayout hPipelineLayout; 
      V( vkCreatePipelineLayout(
          device,
          &pCreateInfo,
          nullptr,
          &hPipelineLayout  ));
      return std::shared_ptr<VkPipelineLayout_T>(hPipelineLayout, 
              [=](VkPipelineLayout to_free) {vkDestroyPipelineLayout(device, to_free, nullptr);});
   }

VkSamplerCreateInfo SamplerCreateInfo(
    VkSamplerCreateFlags                        flags,
    VkFilter                                    magFilter,
    VkFilter                                    minFilter,
    VkSamplerMipmapMode                         mipmapMode,
    VkSamplerAddressMode                        addressModeU,
    VkSamplerAddressMode                        addressModeV,
    VkSamplerAddressMode                        addressModeW,
    float                                       mipLodBias,
    VkBool32                                    anisotropyEnable,
    float                                       maxAnisotropy,
    VkBool32                                    compareEnable,
    VkCompareOp                                 compareOp,
    float                                       minLod,
    float                                       maxLod,
    VkBorderColor                               borderColor,
    VkBool32                                    unnormalizedCoordinates)
   {
      VkSamplerCreateInfo obj;
      obj.sType = VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO;
      obj.pNext = nullptr;
      obj.flags = flags;
      obj.magFilter = magFilter;
      obj.minFilter = minFilter;
      obj.mipmapMode = mipmapMode;
      obj.addressModeU = addressModeU;
      obj.addressModeV = addressModeV;
      obj.addressModeW = addressModeW;
      obj.mipLodBias = mipLodBias;
      obj.anisotropyEnable = anisotropyEnable;
      obj.maxAnisotropy = maxAnisotropy;
      obj.compareEnable = compareEnable;
      obj.compareOp = compareOp;
      obj.minLod = minLod;
      obj.maxLod = maxLod;
      obj.borderColor = borderColor;
      obj.unnormalizedCoordinates = unnormalizedCoordinates;
      return obj;
   }

std::shared_ptr<VkSampler_T> createSampler(
        VkDevice device,
        const VkSamplerCreateInfo & pCreateInfo)
   {
      VkSampler hSampler; 
      V( vkCreateSampler(
          device,
          &pCreateInfo,
          nullptr,
          &hSampler  ));
      return std::shared_ptr<VkSampler_T>(hSampler, 
              [=](VkSampler to_free) {vkDestroySampler(device, to_free, nullptr);});
   }

struct VkDescriptorSetLayoutBindingRAII {
   VkDescriptorSetLayoutBinding nonRaiiObj;
    std::vector<VkSampler>                      vecImmutableSamplers;
};

std::shared_ptr<VkDescriptorSetLayoutBindingRAII> DescriptorSetLayoutBinding(
    uint32_t                                    binding,
    VkDescriptorType                            descriptorType,
    uint32_t                                    descriptorCount,
    VkShaderStageFlags                          stageFlags,
    const std::vector<VkSampler> &              vecImmutableSamplers)
   {
      std::shared_ptr<VkDescriptorSetLayoutBindingRAII> raii_obj(new VkDescriptorSetLayoutBindingRAII);
      raii_obj->nonRaiiObj.binding = binding;
      raii_obj->nonRaiiObj.descriptorType = descriptorType;
      raii_obj->nonRaiiObj.descriptorCount = descriptorCount;
      raii_obj->nonRaiiObj.stageFlags = stageFlags;
      raii_obj->vecImmutableSamplers = vecImmutableSamplers;
      if ( raii_obj->vecImmutableSamplers.size() > 0)
      {
          raii_obj->nonRaiiObj.pImmutableSamplers = &raii_obj->vecImmutableSamplers[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pImmutableSamplers = nullptr;
      }
      return raii_obj;
   }

struct VkDescriptorSetLayoutCreateInfoRAII {
   VkDescriptorSetLayoutCreateInfo nonRaiiObj;
    std::vector<VkDescriptorSetLayoutBinding>   vecBindings;
};

std::shared_ptr<VkDescriptorSetLayoutCreateInfoRAII> DescriptorSetLayoutCreateInfo(
    VkDescriptorSetLayoutCreateFlags            flags,
    const std::vector<VkDescriptorSetLayoutBinding> &vecBindings)
   {
      std::shared_ptr<VkDescriptorSetLayoutCreateInfoRAII> raii_obj(new VkDescriptorSetLayoutCreateInfoRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.flags = flags;
      raii_obj->nonRaiiObj.bindingCount = static_cast<uint32_t>(vecBindings.size());
      raii_obj->vecBindings = vecBindings;
      if ( raii_obj->vecBindings.size() > 0)
      {
          raii_obj->nonRaiiObj.pBindings = &raii_obj->vecBindings[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pBindings = nullptr;
      }
      return raii_obj;
   }

std::shared_ptr<VkDescriptorSetLayout_T> createDescriptorSetLayout(
        VkDevice device,
        const VkDescriptorSetLayoutCreateInfo & pCreateInfo)
   {
      VkDescriptorSetLayout hSetLayout; 
      V( vkCreateDescriptorSetLayout(
          device,
          &pCreateInfo,
          nullptr,
          &hSetLayout  ));
      return std::shared_ptr<VkDescriptorSetLayout_T>(hSetLayout, 
              [=](VkDescriptorSetLayout to_free) {vkDestroyDescriptorSetLayout(device, to_free, nullptr);});
   }

VkDescriptorPoolSize DescriptorPoolSize(
    VkDescriptorType                            type,
    uint32_t                                    descriptorCount)
   {
      VkDescriptorPoolSize obj;
      obj.type = type;
      obj.descriptorCount = descriptorCount;
      return obj;
   }

struct VkDescriptorPoolCreateInfoRAII {
   VkDescriptorPoolCreateInfo nonRaiiObj;
    std::vector<VkDescriptorPoolSize>           vecPoolSizes;
};

std::shared_ptr<VkDescriptorPoolCreateInfoRAII> DescriptorPoolCreateInfo(
    VkDescriptorPoolCreateFlags                 flags,
    uint32_t                                    maxSets,
    const std::vector<VkDescriptorPoolSize> &   vecPoolSizes)
   {
      std::shared_ptr<VkDescriptorPoolCreateInfoRAII> raii_obj(new VkDescriptorPoolCreateInfoRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.flags = flags;
      raii_obj->nonRaiiObj.maxSets = maxSets;
      raii_obj->nonRaiiObj.poolSizeCount = static_cast<uint32_t>(vecPoolSizes.size());
      raii_obj->vecPoolSizes = vecPoolSizes;
      if ( raii_obj->vecPoolSizes.size() > 0)
      {
          raii_obj->nonRaiiObj.pPoolSizes = &raii_obj->vecPoolSizes[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pPoolSizes = nullptr;
      }
      return raii_obj;
   }

std::shared_ptr<VkDescriptorPool_T> createDescriptorPool(
        VkDevice device,
        const VkDescriptorPoolCreateInfo & pCreateInfo)
   {
      VkDescriptorPool hDescriptorPool; 
      V( vkCreateDescriptorPool(
          device,
          &pCreateInfo,
          nullptr,
          &hDescriptorPool  ));
      return std::shared_ptr<VkDescriptorPool_T>(hDescriptorPool, 
              [=](VkDescriptorPool to_free) {vkDestroyDescriptorPool(device, to_free, nullptr);});
   }

void  resetDescriptorPool(
        VkDevice device,
        VkDescriptorPool descriptorPool,
        VkDescriptorPoolResetFlags flags)
   {
      V( vkResetDescriptorPool(
          device,
          descriptorPool,
          flags  ));
   }

struct VkDescriptorSetAllocateInfoRAII {
   VkDescriptorSetAllocateInfo nonRaiiObj;
    std::vector<VkDescriptorSetLayout>          vecSetLayouts;
};

std::shared_ptr<VkDescriptorSetAllocateInfoRAII> DescriptorSetAllocateInfo(
    VkDescriptorPool                            descriptorPool,
    const std::vector<VkDescriptorSetLayout> &  vecSetLayouts)
   {
      std::shared_ptr<VkDescriptorSetAllocateInfoRAII> raii_obj(new VkDescriptorSetAllocateInfoRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.descriptorPool = descriptorPool;
      raii_obj->nonRaiiObj.descriptorSetCount = static_cast<uint32_t>(vecSetLayouts.size());
      raii_obj->vecSetLayouts = vecSetLayouts;
      if ( raii_obj->vecSetLayouts.size() > 0)
      {
          raii_obj->nonRaiiObj.pSetLayouts = &raii_obj->vecSetLayouts[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pSetLayouts = nullptr;
      }
      return raii_obj;
   }

VkDescriptorImageInfo DescriptorImageInfo(
    VkSampler                                   sampler,
    VkImageView                                 imageView,
    VkImageLayout                               imageLayout)
   {
      VkDescriptorImageInfo obj;
      obj.sampler = sampler;
      obj.imageView = imageView;
      obj.imageLayout = imageLayout;
      return obj;
   }

VkDescriptorBufferInfo DescriptorBufferInfo(
    VkBuffer                                    buffer,
    VkDeviceSize                                offset,
    VkDeviceSize                                range)
   {
      VkDescriptorBufferInfo obj;
      obj.buffer = buffer;
      obj.offset = offset;
      obj.range = range;
      return obj;
   }

struct VkWriteDescriptorSetRAII {
   VkWriteDescriptorSet nonRaiiObj;
    std::vector<VkDescriptorImageInfo>          vecImageInfo;
    std::vector<VkDescriptorBufferInfo>         vecBufferInfo;
    std::vector<VkBufferView>                   vecTexelBufferView;
};

std::shared_ptr<VkWriteDescriptorSetRAII> WriteDescriptorSet(
    VkDescriptorSet                             dstSet,
    uint32_t                                    dstBinding,
    uint32_t                                    dstArrayElement,
    uint32_t                                    descriptorCount,
    VkDescriptorType                            descriptorType,
    const std::vector<VkDescriptorImageInfo> &  vecImageInfo,
    const std::vector<VkDescriptorBufferInfo> & vecBufferInfo,
    const std::vector<VkBufferView> &           vecTexelBufferView)
   {
      std::shared_ptr<VkWriteDescriptorSetRAII> raii_obj(new VkWriteDescriptorSetRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.dstSet = dstSet;
      raii_obj->nonRaiiObj.dstBinding = dstBinding;
      raii_obj->nonRaiiObj.dstArrayElement = dstArrayElement;
      raii_obj->nonRaiiObj.descriptorCount = descriptorCount;
      raii_obj->nonRaiiObj.descriptorType = descriptorType;
      raii_obj->vecImageInfo = vecImageInfo;
      if ( raii_obj->vecImageInfo.size() > 0)
      {
          raii_obj->nonRaiiObj.pImageInfo = &raii_obj->vecImageInfo[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pImageInfo = nullptr;
      }
      raii_obj->vecBufferInfo = vecBufferInfo;
      if ( raii_obj->vecBufferInfo.size() > 0)
      {
          raii_obj->nonRaiiObj.pBufferInfo = &raii_obj->vecBufferInfo[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pBufferInfo = nullptr;
      }
      raii_obj->vecTexelBufferView = vecTexelBufferView;
      if ( raii_obj->vecTexelBufferView.size() > 0)
      {
          raii_obj->nonRaiiObj.pTexelBufferView = &raii_obj->vecTexelBufferView[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pTexelBufferView = nullptr;
      }
      return raii_obj;
   }

VkCopyDescriptorSet CopyDescriptorSet(
    VkDescriptorSet                             srcSet,
    uint32_t                                    srcBinding,
    uint32_t                                    srcArrayElement,
    VkDescriptorSet                             dstSet,
    uint32_t                                    dstBinding,
    uint32_t                                    dstArrayElement,
    uint32_t                                    descriptorCount)
   {
      VkCopyDescriptorSet obj;
      obj.sType = VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET;
      obj.pNext = nullptr;
      obj.srcSet = srcSet;
      obj.srcBinding = srcBinding;
      obj.srcArrayElement = srcArrayElement;
      obj.dstSet = dstSet;
      obj.dstBinding = dstBinding;
      obj.dstArrayElement = dstArrayElement;
      obj.descriptorCount = descriptorCount;
      return obj;
   }

void  updateDescriptorSets(
        VkDevice device,
        const std::vector<VkWriteDescriptorSet> & pDescriptorWrites,
        const std::vector<VkCopyDescriptorSet> & pDescriptorCopies)
   {
      vkUpdateDescriptorSets(
          device,
          static_cast<uint32_t>(pDescriptorWrites.size()),
          &pDescriptorWrites[0],
          static_cast<uint32_t>(pDescriptorCopies.size()),
          &pDescriptorCopies[0]  );
   }

struct VkFramebufferCreateInfoRAII {
   VkFramebufferCreateInfo nonRaiiObj;
    std::vector<VkImageView>                    vecAttachments;
};

std::shared_ptr<VkFramebufferCreateInfoRAII> FramebufferCreateInfo(
    VkFramebufferCreateFlags                    flags,
    VkRenderPass                                renderPass,
    const std::vector<VkImageView> &            vecAttachments,
    uint32_t                                    width,
    uint32_t                                    height,
    uint32_t                                    layers)
   {
      std::shared_ptr<VkFramebufferCreateInfoRAII> raii_obj(new VkFramebufferCreateInfoRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.flags = flags;
      raii_obj->nonRaiiObj.renderPass = renderPass;
      raii_obj->nonRaiiObj.attachmentCount = static_cast<uint32_t>(vecAttachments.size());
      raii_obj->vecAttachments = vecAttachments;
      if ( raii_obj->vecAttachments.size() > 0)
      {
          raii_obj->nonRaiiObj.pAttachments = &raii_obj->vecAttachments[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pAttachments = nullptr;
      }
      raii_obj->nonRaiiObj.width = width;
      raii_obj->nonRaiiObj.height = height;
      raii_obj->nonRaiiObj.layers = layers;
      return raii_obj;
   }

std::shared_ptr<VkFramebuffer_T> createFramebuffer(
        VkDevice device,
        const VkFramebufferCreateInfo & pCreateInfo)
   {
      VkFramebuffer hFramebuffer; 
      V( vkCreateFramebuffer(
          device,
          &pCreateInfo,
          nullptr,
          &hFramebuffer  ));
      return std::shared_ptr<VkFramebuffer_T>(hFramebuffer, 
              [=](VkFramebuffer to_free) {vkDestroyFramebuffer(device, to_free, nullptr);});
   }

VkAttachmentDescription AttachmentDescription(
    VkAttachmentDescriptionFlags                flags,
    VkFormat                                    format,
    VkSampleCountFlagBits                       samples,
    VkAttachmentLoadOp                          loadOp,
    VkAttachmentStoreOp                         storeOp,
    VkAttachmentLoadOp                          stencilLoadOp,
    VkAttachmentStoreOp                         stencilStoreOp,
    VkImageLayout                               initialLayout,
    VkImageLayout                               finalLayout)
   {
      VkAttachmentDescription obj;
      obj.flags = flags;
      obj.format = format;
      obj.samples = samples;
      obj.loadOp = loadOp;
      obj.storeOp = storeOp;
      obj.stencilLoadOp = stencilLoadOp;
      obj.stencilStoreOp = stencilStoreOp;
      obj.initialLayout = initialLayout;
      obj.finalLayout = finalLayout;
      return obj;
   }

VkAttachmentReference AttachmentReference(
    uint32_t                                    attachment,
    VkImageLayout                               layout)
   {
      VkAttachmentReference obj;
      obj.attachment = attachment;
      obj.layout = layout;
      return obj;
   }

struct VkSubpassDescriptionRAII {
   VkSubpassDescription nonRaiiObj;
    std::vector<VkAttachmentReference>          vecInputAttachments;
    std::vector<VkAttachmentReference>          vecColorAttachments;
    std::vector<VkAttachmentReference>          vecResolveAttachments;
    std::shared_ptr<VkAttachmentReference>      pDepthStencilAttachment;
    std::vector<uint32_t>                       vecPreserveAttachments;
};

std::shared_ptr<VkSubpassDescriptionRAII> SubpassDescription(
    VkSubpassDescriptionFlags                   flags,
    VkPipelineBindPoint                         pipelineBindPoint,
    const std::vector<VkAttachmentReference> &  vecInputAttachments,
    const std::vector<VkAttachmentReference> &  vecColorAttachments,
    const std::vector<VkAttachmentReference> &  vecResolveAttachments,
    const VkAttachmentReference *               pDepthStencilAttachment,
    unsigned int* pPreserveAttachments_in_array1, int pPreserveAttachments_dim1)
   {
      std::shared_ptr<VkSubpassDescriptionRAII> raii_obj(new VkSubpassDescriptionRAII);
      raii_obj->nonRaiiObj.flags = flags;
      raii_obj->nonRaiiObj.pipelineBindPoint = pipelineBindPoint;
      raii_obj->nonRaiiObj.inputAttachmentCount = static_cast<uint32_t>(vecInputAttachments.size());
      raii_obj->vecInputAttachments = vecInputAttachments;
      if ( raii_obj->vecInputAttachments.size() > 0)
      {
          raii_obj->nonRaiiObj.pInputAttachments = &raii_obj->vecInputAttachments[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pInputAttachments = nullptr;
      }
      raii_obj->nonRaiiObj.colorAttachmentCount = static_cast<uint32_t>(vecColorAttachments.size());
      raii_obj->vecColorAttachments = vecColorAttachments;
      if ( raii_obj->vecColorAttachments.size() > 0)
      {
          raii_obj->nonRaiiObj.pColorAttachments = &raii_obj->vecColorAttachments[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pColorAttachments = nullptr;
      }
      raii_obj->vecResolveAttachments = vecResolveAttachments;
      if ( raii_obj->vecResolveAttachments.size() > 0)
      {
          raii_obj->nonRaiiObj.pResolveAttachments = &raii_obj->vecResolveAttachments[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pResolveAttachments = nullptr;
      }
      raii_obj->nonRaiiObj.pDepthStencilAttachment = nullptr;
      if ( pDepthStencilAttachment ) 
      { 
          raii_obj->pDepthStencilAttachment.reset( new VkAttachmentReference );
          *raii_obj->pDepthStencilAttachment = *pDepthStencilAttachment;
          raii_obj->nonRaiiObj.pDepthStencilAttachment = raii_obj->pDepthStencilAttachment.get();
      } 
      raii_obj->nonRaiiObj.preserveAttachmentCount = static_cast<uint32_t>(pPreserveAttachments_dim1);
      raii_obj->vecPreserveAttachments.assign(pPreserveAttachments_in_array1, pPreserveAttachments_in_array1 + pPreserveAttachments_dim1);
      if ( raii_obj->vecPreserveAttachments.size() > 0)
      {
          raii_obj->nonRaiiObj.pPreserveAttachments = &raii_obj->vecPreserveAttachments[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pPreserveAttachments = nullptr;
      }
      return raii_obj;
   }

VkSubpassDependency SubpassDependency(
    uint32_t                                    srcSubpass,
    uint32_t                                    dstSubpass,
    VkPipelineStageFlags                        srcStageMask,
    VkPipelineStageFlags                        dstStageMask,
    VkAccessFlags                               srcAccessMask,
    VkAccessFlags                               dstAccessMask,
    VkDependencyFlags                           dependencyFlags)
   {
      VkSubpassDependency obj;
      obj.srcSubpass = srcSubpass;
      obj.dstSubpass = dstSubpass;
      obj.srcStageMask = srcStageMask;
      obj.dstStageMask = dstStageMask;
      obj.srcAccessMask = srcAccessMask;
      obj.dstAccessMask = dstAccessMask;
      obj.dependencyFlags = dependencyFlags;
      return obj;
   }

struct VkRenderPassCreateInfoRAII {
   VkRenderPassCreateInfo nonRaiiObj;
    std::vector<VkAttachmentDescription>        vecAttachments;
    std::vector<VkSubpassDescription>           vecSubpasses;
    std::vector<VkSubpassDependency>            vecDependencies;
};

std::shared_ptr<VkRenderPassCreateInfoRAII> RenderPassCreateInfo(
    VkRenderPassCreateFlags                     flags,
    const std::vector<VkAttachmentDescription> &vecAttachments,
    const std::vector<VkSubpassDescription> &   vecSubpasses,
    const std::vector<VkSubpassDependency> &    vecDependencies)
   {
      std::shared_ptr<VkRenderPassCreateInfoRAII> raii_obj(new VkRenderPassCreateInfoRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.flags = flags;
      raii_obj->nonRaiiObj.attachmentCount = static_cast<uint32_t>(vecAttachments.size());
      raii_obj->vecAttachments = vecAttachments;
      if ( raii_obj->vecAttachments.size() > 0)
      {
          raii_obj->nonRaiiObj.pAttachments = &raii_obj->vecAttachments[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pAttachments = nullptr;
      }
      raii_obj->nonRaiiObj.subpassCount = static_cast<uint32_t>(vecSubpasses.size());
      raii_obj->vecSubpasses = vecSubpasses;
      if ( raii_obj->vecSubpasses.size() > 0)
      {
          raii_obj->nonRaiiObj.pSubpasses = &raii_obj->vecSubpasses[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pSubpasses = nullptr;
      }
      raii_obj->nonRaiiObj.dependencyCount = static_cast<uint32_t>(vecDependencies.size());
      raii_obj->vecDependencies = vecDependencies;
      if ( raii_obj->vecDependencies.size() > 0)
      {
          raii_obj->nonRaiiObj.pDependencies = &raii_obj->vecDependencies[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pDependencies = nullptr;
      }
      return raii_obj;
   }

std::shared_ptr<VkRenderPass_T> createRenderPass(
        VkDevice device,
        const VkRenderPassCreateInfo & pCreateInfo)
   {
      VkRenderPass hRenderPass; 
      V( vkCreateRenderPass(
          device,
          &pCreateInfo,
          nullptr,
          &hRenderPass  ));
      return std::shared_ptr<VkRenderPass_T>(hRenderPass, 
              [=](VkRenderPass to_free) {vkDestroyRenderPass(device, to_free, nullptr);});
   }

VkExtent2D getRenderAreaGranularity(
        VkDevice device,
        VkRenderPass renderPass)
   {
      VkExtent2D pGranularity; 
      vkGetRenderAreaGranularity(
          device,
          renderPass,
          &pGranularity  );
      return pGranularity; 
   }

VkCommandPoolCreateInfo CommandPoolCreateInfo(
    VkCommandPoolCreateFlags                    flags,
    uint32_t                                    queueFamilyIndex)
   {
      VkCommandPoolCreateInfo obj;
      obj.sType = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO;
      obj.pNext = nullptr;
      obj.flags = flags;
      obj.queueFamilyIndex = queueFamilyIndex;
      return obj;
   }

std::shared_ptr<VkCommandPool_T> createCommandPool(
        VkDevice device,
        const VkCommandPoolCreateInfo & pCreateInfo)
   {
      VkCommandPool hCommandPool; 
      V( vkCreateCommandPool(
          device,
          &pCreateInfo,
          nullptr,
          &hCommandPool  ));
      return std::shared_ptr<VkCommandPool_T>(hCommandPool, 
              [=](VkCommandPool to_free) {vkDestroyCommandPool(device, to_free, nullptr);});
   }

void  resetCommandPool(
        VkDevice device,
        VkCommandPool commandPool,
        VkCommandPoolResetFlags flags)
   {
      V( vkResetCommandPool(
          device,
          commandPool,
          flags  ));
   }

VkCommandBufferAllocateInfo CommandBufferAllocateInfo(
    VkCommandPool                               commandPool,
    VkCommandBufferLevel                        level,
    uint32_t                                    commandBufferCount)
   {
      VkCommandBufferAllocateInfo obj;
      obj.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;
      obj.pNext = nullptr;
      obj.commandPool = commandPool;
      obj.level = level;
      obj.commandBufferCount = commandBufferCount;
      return obj;
   }

VkCommandBufferInheritanceInfo CommandBufferInheritanceInfo(
    VkRenderPass                                renderPass,
    uint32_t                                    subpass,
    VkFramebuffer                               framebuffer,
    VkBool32                                    occlusionQueryEnable,
    VkQueryControlFlags                         queryFlags,
    VkQueryPipelineStatisticFlags               pipelineStatistics)
   {
      VkCommandBufferInheritanceInfo obj;
      obj.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO;
      obj.pNext = nullptr;
      obj.renderPass = renderPass;
      obj.subpass = subpass;
      obj.framebuffer = framebuffer;
      obj.occlusionQueryEnable = occlusionQueryEnable;
      obj.queryFlags = queryFlags;
      obj.pipelineStatistics = pipelineStatistics;
      return obj;
   }

struct VkCommandBufferBeginInfoRAII {
   VkCommandBufferBeginInfo nonRaiiObj;
    std::shared_ptr<VkCommandBufferInheritanceInfo>pInheritanceInfo;
};

std::shared_ptr<VkCommandBufferBeginInfoRAII> CommandBufferBeginInfo(
    VkCommandBufferUsageFlags                   flags,
    const VkCommandBufferInheritanceInfo *      pInheritanceInfo)
   {
      std::shared_ptr<VkCommandBufferBeginInfoRAII> raii_obj(new VkCommandBufferBeginInfoRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.flags = flags;
      raii_obj->nonRaiiObj.pInheritanceInfo = nullptr;
      if ( pInheritanceInfo ) 
      { 
          raii_obj->pInheritanceInfo.reset( new VkCommandBufferInheritanceInfo );
          *raii_obj->pInheritanceInfo = *pInheritanceInfo;
          raii_obj->nonRaiiObj.pInheritanceInfo = raii_obj->pInheritanceInfo.get();
      } 
      return raii_obj;
   }

void  beginCommandBuffer(
        VkCommandBuffer commandBuffer,
        const VkCommandBufferBeginInfo & pBeginInfo)
   {
      V( vkBeginCommandBuffer(
          commandBuffer,
          &pBeginInfo  ));
   }

void  endCommandBuffer(
        VkCommandBuffer commandBuffer)
   {
      V( vkEndCommandBuffer(
          commandBuffer  ));
   }

void  resetCommandBuffer(
        VkCommandBuffer commandBuffer,
        VkCommandBufferResetFlags flags)
   {
      V( vkResetCommandBuffer(
          commandBuffer,
          flags  ));
   }

void  cmdBindPipeline(
        VkCommandBuffer commandBuffer,
        VkPipelineBindPoint pipelineBindPoint,
        VkPipeline pipeline)
   {
      vkCmdBindPipeline(
          commandBuffer,
          pipelineBindPoint,
          pipeline  );
   }

void  cmdSetViewport(
        VkCommandBuffer commandBuffer,
        uint32_t firstViewport,
        const std::vector<VkViewport> & pViewports)
   {
      vkCmdSetViewport(
          commandBuffer,
          firstViewport,
          static_cast<uint32_t>(pViewports.size()),
          &pViewports[0]  );
   }

void  cmdSetScissor(
        VkCommandBuffer commandBuffer,
        uint32_t firstScissor,
        const std::vector<VkRect2D> & pScissors)
   {
      vkCmdSetScissor(
          commandBuffer,
          firstScissor,
          static_cast<uint32_t>(pScissors.size()),
          &pScissors[0]  );
   }

void  cmdSetLineWidth(
        VkCommandBuffer commandBuffer,
        float lineWidth)
   {
      vkCmdSetLineWidth(
          commandBuffer,
          lineWidth  );
   }

void  cmdSetDepthBias(
        VkCommandBuffer commandBuffer,
        float depthBiasConstantFactor,
        float depthBiasClamp,
        float depthBiasSlopeFactor)
   {
      vkCmdSetDepthBias(
          commandBuffer,
          depthBiasConstantFactor,
          depthBiasClamp,
          depthBiasSlopeFactor  );
   }

void  cmdSetBlendConstants(
        VkCommandBuffer commandBuffer,
        const float blendConstants[4])
   {
      vkCmdSetBlendConstants(
          commandBuffer,
          blendConstants  );
   }

void  cmdSetDepthBounds(
        VkCommandBuffer commandBuffer,
        float minDepthBounds,
        float maxDepthBounds)
   {
      vkCmdSetDepthBounds(
          commandBuffer,
          minDepthBounds,
          maxDepthBounds  );
   }

void  cmdSetStencilCompareMask(
        VkCommandBuffer commandBuffer,
        VkStencilFaceFlags faceMask,
        uint32_t compareMask)
   {
      vkCmdSetStencilCompareMask(
          commandBuffer,
          faceMask,
          compareMask  );
   }

void  cmdSetStencilWriteMask(
        VkCommandBuffer commandBuffer,
        VkStencilFaceFlags faceMask,
        uint32_t writeMask)
   {
      vkCmdSetStencilWriteMask(
          commandBuffer,
          faceMask,
          writeMask  );
   }

void  cmdSetStencilReference(
        VkCommandBuffer commandBuffer,
        VkStencilFaceFlags faceMask,
        uint32_t reference)
   {
      vkCmdSetStencilReference(
          commandBuffer,
          faceMask,
          reference  );
   }

void  cmdBindDescriptorSets(
        VkCommandBuffer commandBuffer,
        VkPipelineBindPoint pipelineBindPoint,
        VkPipelineLayout layout,
        uint32_t firstSet,
        const std::vector<VkDescriptorSet> & pDescriptorSets,
        unsigned int* pDynamicOffsets_in_array1, int pDynamicOffsets_dim1)
   {
      vkCmdBindDescriptorSets(
          commandBuffer,
          pipelineBindPoint,
          layout,
          firstSet,
          static_cast<uint32_t>(pDescriptorSets.size()),
          &pDescriptorSets[0],
          static_cast<uint32_t>(pDynamicOffsets_dim1),
          pDynamicOffsets_in_array1  );
   }

void  cmdBindIndexBuffer(
        VkCommandBuffer commandBuffer,
        VkBuffer buffer,
        VkDeviceSize offset,
        VkIndexType indexType)
   {
      vkCmdBindIndexBuffer(
          commandBuffer,
          buffer,
          offset,
          indexType  );
   }

void  cmdBindVertexBuffers(
        VkCommandBuffer commandBuffer,
        uint32_t firstBinding,
        const std::vector<VkBuffer> & pBuffers,
        const std::vector<VkDeviceSize> & pOffsets)
   {
      vkCmdBindVertexBuffers(
          commandBuffer,
          firstBinding,
          static_cast<uint32_t>(pOffsets.size()),
          &pBuffers[0],
          &pOffsets[0]  );
   }

void  cmdDraw(
        VkCommandBuffer commandBuffer,
        uint32_t vertexCount,
        uint32_t instanceCount,
        uint32_t firstVertex,
        uint32_t firstInstance)
   {
      vkCmdDraw(
          commandBuffer,
          vertexCount,
          instanceCount,
          firstVertex,
          firstInstance  );
   }

void  cmdDrawIndexed(
        VkCommandBuffer commandBuffer,
        uint32_t indexCount,
        uint32_t instanceCount,
        uint32_t firstIndex,
        int32_t vertexOffset,
        uint32_t firstInstance)
   {
      vkCmdDrawIndexed(
          commandBuffer,
          indexCount,
          instanceCount,
          firstIndex,
          vertexOffset,
          firstInstance  );
   }

void  cmdDrawIndirect(
        VkCommandBuffer commandBuffer,
        VkBuffer buffer,
        VkDeviceSize offset,
        uint32_t drawCount,
        uint32_t stride)
   {
      vkCmdDrawIndirect(
          commandBuffer,
          buffer,
          offset,
          drawCount,
          stride  );
   }

void  cmdDrawIndexedIndirect(
        VkCommandBuffer commandBuffer,
        VkBuffer buffer,
        VkDeviceSize offset,
        uint32_t drawCount,
        uint32_t stride)
   {
      vkCmdDrawIndexedIndirect(
          commandBuffer,
          buffer,
          offset,
          drawCount,
          stride  );
   }

void  cmdDispatch(
        VkCommandBuffer commandBuffer,
        uint32_t groupCountX,
        uint32_t groupCountY,
        uint32_t groupCountZ)
   {
      vkCmdDispatch(
          commandBuffer,
          groupCountX,
          groupCountY,
          groupCountZ  );
   }

void  cmdDispatchIndirect(
        VkCommandBuffer commandBuffer,
        VkBuffer buffer,
        VkDeviceSize offset)
   {
      vkCmdDispatchIndirect(
          commandBuffer,
          buffer,
          offset  );
   }

VkBufferCopy BufferCopy(
    VkDeviceSize                                srcOffset,
    VkDeviceSize                                dstOffset,
    VkDeviceSize                                size)
   {
      VkBufferCopy obj;
      obj.srcOffset = srcOffset;
      obj.dstOffset = dstOffset;
      obj.size = size;
      return obj;
   }

void  cmdCopyBuffer(
        VkCommandBuffer commandBuffer,
        VkBuffer srcBuffer,
        VkBuffer dstBuffer,
        const std::vector<VkBufferCopy> & pRegions)
   {
      vkCmdCopyBuffer(
          commandBuffer,
          srcBuffer,
          dstBuffer,
          static_cast<uint32_t>(pRegions.size()),
          &pRegions[0]  );
   }

VkImageSubresourceLayers ImageSubresourceLayers(
    VkImageAspectFlags                          aspectMask,
    uint32_t                                    mipLevel,
    uint32_t                                    baseArrayLayer,
    uint32_t                                    layerCount)
   {
      VkImageSubresourceLayers obj;
      obj.aspectMask = aspectMask;
      obj.mipLevel = mipLevel;
      obj.baseArrayLayer = baseArrayLayer;
      obj.layerCount = layerCount;
      return obj;
   }

VkImageCopy ImageCopy(
    VkImageSubresourceLayers                    srcSubresource,
    VkOffset3D                                  srcOffset,
    VkImageSubresourceLayers                    dstSubresource,
    VkOffset3D                                  dstOffset,
    VkExtent3D                                  extent)
   {
      VkImageCopy obj;
      obj.srcSubresource = srcSubresource;
      obj.srcOffset = srcOffset;
      obj.dstSubresource = dstSubresource;
      obj.dstOffset = dstOffset;
      obj.extent = extent;
      return obj;
   }

void  cmdCopyImage(
        VkCommandBuffer commandBuffer,
        VkImage srcImage,
        VkImageLayout srcImageLayout,
        VkImage dstImage,
        VkImageLayout dstImageLayout,
        const std::vector<VkImageCopy> & pRegions)
   {
      vkCmdCopyImage(
          commandBuffer,
          srcImage,
          srcImageLayout,
          dstImage,
          dstImageLayout,
          static_cast<uint32_t>(pRegions.size()),
          &pRegions[0]  );
   }

VkImageBlit ImageBlit(
    VkImageSubresourceLayers                    srcSubresource,
    VkOffset3D                                  srcOffsets[2],
    VkImageSubresourceLayers                    dstSubresource,
    VkOffset3D                                  dstOffsets[2])
   {
      VkImageBlit obj;
      obj.srcSubresource = srcSubresource;
      std::copy(srcOffsets, srcOffsets + 2, obj.srcOffsets);
      obj.dstSubresource = dstSubresource;
      std::copy(dstOffsets, dstOffsets + 2, obj.dstOffsets);
      return obj;
   }

void  cmdBlitImage(
        VkCommandBuffer commandBuffer,
        VkImage srcImage,
        VkImageLayout srcImageLayout,
        VkImage dstImage,
        VkImageLayout dstImageLayout,
        const std::vector<VkImageBlit> & pRegions,
        VkFilter filter)
   {
      vkCmdBlitImage(
          commandBuffer,
          srcImage,
          srcImageLayout,
          dstImage,
          dstImageLayout,
          static_cast<uint32_t>(pRegions.size()),
          &pRegions[0],
          filter  );
   }

VkBufferImageCopy BufferImageCopy(
    VkDeviceSize                                bufferOffset,
    uint32_t                                    bufferRowLength,
    uint32_t                                    bufferImageHeight,
    VkImageSubresourceLayers                    imageSubresource,
    VkOffset3D                                  imageOffset,
    VkExtent3D                                  imageExtent)
   {
      VkBufferImageCopy obj;
      obj.bufferOffset = bufferOffset;
      obj.bufferRowLength = bufferRowLength;
      obj.bufferImageHeight = bufferImageHeight;
      obj.imageSubresource = imageSubresource;
      obj.imageOffset = imageOffset;
      obj.imageExtent = imageExtent;
      return obj;
   }

void  cmdCopyBufferToImage(
        VkCommandBuffer commandBuffer,
        VkBuffer srcBuffer,
        VkImage dstImage,
        VkImageLayout dstImageLayout,
        const std::vector<VkBufferImageCopy> & pRegions)
   {
      vkCmdCopyBufferToImage(
          commandBuffer,
          srcBuffer,
          dstImage,
          dstImageLayout,
          static_cast<uint32_t>(pRegions.size()),
          &pRegions[0]  );
   }

void  cmdCopyImageToBuffer(
        VkCommandBuffer commandBuffer,
        VkImage srcImage,
        VkImageLayout srcImageLayout,
        VkBuffer dstBuffer,
        const std::vector<VkBufferImageCopy> & pRegions)
   {
      vkCmdCopyImageToBuffer(
          commandBuffer,
          srcImage,
          srcImageLayout,
          dstBuffer,
          static_cast<uint32_t>(pRegions.size()),
          &pRegions[0]  );
   }

void  cmdFillBuffer(
        VkCommandBuffer commandBuffer,
        VkBuffer dstBuffer,
        VkDeviceSize dstOffset,
        VkDeviceSize size,
        uint32_t data)
   {
      vkCmdFillBuffer(
          commandBuffer,
          dstBuffer,
          dstOffset,
          size,
          data  );
   }

void  cmdClearColorImage(
        VkCommandBuffer commandBuffer,
        VkImage image,
        VkImageLayout imageLayout,
        const VkClearColorValue & pColor,
        const std::vector<VkImageSubresourceRange> & pRanges)
   {
      vkCmdClearColorImage(
          commandBuffer,
          image,
          imageLayout,
          &pColor,
          static_cast<uint32_t>(pRanges.size()),
          &pRanges[0]  );
   }

VkClearDepthStencilValue ClearDepthStencilValue(
    float                                       depth,
    uint32_t                                    stencil)
   {
      VkClearDepthStencilValue obj;
      obj.depth = depth;
      obj.stencil = stencil;
      return obj;
   }

void  cmdClearDepthStencilImage(
        VkCommandBuffer commandBuffer,
        VkImage image,
        VkImageLayout imageLayout,
        const VkClearDepthStencilValue & pDepthStencil,
        const std::vector<VkImageSubresourceRange> & pRanges)
   {
      vkCmdClearDepthStencilImage(
          commandBuffer,
          image,
          imageLayout,
          &pDepthStencil,
          static_cast<uint32_t>(pRanges.size()),
          &pRanges[0]  );
   }

VkClearAttachment ClearAttachment(
    VkImageAspectFlags                          aspectMask,
    uint32_t                                    colorAttachment,
    VkClearValue                                clearValue)
   {
      VkClearAttachment obj;
      obj.aspectMask = aspectMask;
      obj.colorAttachment = colorAttachment;
      obj.clearValue = clearValue;
      return obj;
   }

VkClearRect ClearRect(
    VkRect2D                                    rect,
    uint32_t                                    baseArrayLayer,
    uint32_t                                    layerCount)
   {
      VkClearRect obj;
      obj.rect = rect;
      obj.baseArrayLayer = baseArrayLayer;
      obj.layerCount = layerCount;
      return obj;
   }

void  cmdClearAttachments(
        VkCommandBuffer commandBuffer,
        const std::vector<VkClearAttachment> & pAttachments,
        const std::vector<VkClearRect> & pRects)
   {
      vkCmdClearAttachments(
          commandBuffer,
          static_cast<uint32_t>(pAttachments.size()),
          &pAttachments[0],
          static_cast<uint32_t>(pRects.size()),
          &pRects[0]  );
   }

VkImageResolve ImageResolve(
    VkImageSubresourceLayers                    srcSubresource,
    VkOffset3D                                  srcOffset,
    VkImageSubresourceLayers                    dstSubresource,
    VkOffset3D                                  dstOffset,
    VkExtent3D                                  extent)
   {
      VkImageResolve obj;
      obj.srcSubresource = srcSubresource;
      obj.srcOffset = srcOffset;
      obj.dstSubresource = dstSubresource;
      obj.dstOffset = dstOffset;
      obj.extent = extent;
      return obj;
   }

void  cmdResolveImage(
        VkCommandBuffer commandBuffer,
        VkImage srcImage,
        VkImageLayout srcImageLayout,
        VkImage dstImage,
        VkImageLayout dstImageLayout,
        const std::vector<VkImageResolve> & pRegions)
   {
      vkCmdResolveImage(
          commandBuffer,
          srcImage,
          srcImageLayout,
          dstImage,
          dstImageLayout,
          static_cast<uint32_t>(pRegions.size()),
          &pRegions[0]  );
   }

void  cmdSetEvent(
        VkCommandBuffer commandBuffer,
        VkEvent event,
        VkPipelineStageFlags stageMask)
   {
      vkCmdSetEvent(
          commandBuffer,
          event,
          stageMask  );
   }

void  cmdResetEvent(
        VkCommandBuffer commandBuffer,
        VkEvent event,
        VkPipelineStageFlags stageMask)
   {
      vkCmdResetEvent(
          commandBuffer,
          event,
          stageMask  );
   }

VkMemoryBarrier MemoryBarrier(
    VkAccessFlags                               srcAccessMask,
    VkAccessFlags                               dstAccessMask)
   {
      VkMemoryBarrier obj;
      obj.sType = VK_STRUCTURE_TYPE_MEMORY_BARRIER;
      obj.pNext = nullptr;
      obj.srcAccessMask = srcAccessMask;
      obj.dstAccessMask = dstAccessMask;
      return obj;
   }

VkBufferMemoryBarrier BufferMemoryBarrier(
    VkAccessFlags                               srcAccessMask,
    VkAccessFlags                               dstAccessMask,
    uint32_t                                    srcQueueFamilyIndex,
    uint32_t                                    dstQueueFamilyIndex,
    VkBuffer                                    buffer,
    VkDeviceSize                                offset,
    VkDeviceSize                                size)
   {
      VkBufferMemoryBarrier obj;
      obj.sType = VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER;
      obj.pNext = nullptr;
      obj.srcAccessMask = srcAccessMask;
      obj.dstAccessMask = dstAccessMask;
      obj.srcQueueFamilyIndex = srcQueueFamilyIndex;
      obj.dstQueueFamilyIndex = dstQueueFamilyIndex;
      obj.buffer = buffer;
      obj.offset = offset;
      obj.size = size;
      return obj;
   }

VkImageMemoryBarrier ImageMemoryBarrier(
    VkAccessFlags                               srcAccessMask,
    VkAccessFlags                               dstAccessMask,
    VkImageLayout                               oldLayout,
    VkImageLayout                               newLayout,
    uint32_t                                    srcQueueFamilyIndex,
    uint32_t                                    dstQueueFamilyIndex,
    VkImage                                     image,
    VkImageSubresourceRange                     subresourceRange)
   {
      VkImageMemoryBarrier obj;
      obj.sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER;
      obj.pNext = nullptr;
      obj.srcAccessMask = srcAccessMask;
      obj.dstAccessMask = dstAccessMask;
      obj.oldLayout = oldLayout;
      obj.newLayout = newLayout;
      obj.srcQueueFamilyIndex = srcQueueFamilyIndex;
      obj.dstQueueFamilyIndex = dstQueueFamilyIndex;
      obj.image = image;
      obj.subresourceRange = subresourceRange;
      return obj;
   }

void  cmdWaitEvents(
        VkCommandBuffer commandBuffer,
        const std::vector<VkEvent> & pEvents,
        VkPipelineStageFlags srcStageMask,
        VkPipelineStageFlags dstStageMask,
        const std::vector<VkMemoryBarrier> & pMemoryBarriers,
        const std::vector<VkBufferMemoryBarrier> & pBufferMemoryBarriers,
        const std::vector<VkImageMemoryBarrier> & pImageMemoryBarriers)
   {
      vkCmdWaitEvents(
          commandBuffer,
          static_cast<uint32_t>(pEvents.size()),
          &pEvents[0],
          srcStageMask,
          dstStageMask,
          static_cast<uint32_t>(pMemoryBarriers.size()),
          &pMemoryBarriers[0],
          static_cast<uint32_t>(pBufferMemoryBarriers.size()),
          &pBufferMemoryBarriers[0],
          static_cast<uint32_t>(pImageMemoryBarriers.size()),
          &pImageMemoryBarriers[0]  );
   }

void  cmdPipelineBarrier(
        VkCommandBuffer commandBuffer,
        VkPipelineStageFlags srcStageMask,
        VkPipelineStageFlags dstStageMask,
        VkDependencyFlags dependencyFlags,
        const std::vector<VkMemoryBarrier> & pMemoryBarriers,
        const std::vector<VkBufferMemoryBarrier> & pBufferMemoryBarriers,
        const std::vector<VkImageMemoryBarrier> & pImageMemoryBarriers)
   {
      vkCmdPipelineBarrier(
          commandBuffer,
          srcStageMask,
          dstStageMask,
          dependencyFlags,
          static_cast<uint32_t>(pMemoryBarriers.size()),
          &pMemoryBarriers[0],
          static_cast<uint32_t>(pBufferMemoryBarriers.size()),
          &pBufferMemoryBarriers[0],
          static_cast<uint32_t>(pImageMemoryBarriers.size()),
          &pImageMemoryBarriers[0]  );
   }

void  cmdBeginQuery(
        VkCommandBuffer commandBuffer,
        VkQueryPool queryPool,
        uint32_t query,
        VkQueryControlFlags flags)
   {
      vkCmdBeginQuery(
          commandBuffer,
          queryPool,
          query,
          flags  );
   }

void  cmdEndQuery(
        VkCommandBuffer commandBuffer,
        VkQueryPool queryPool,
        uint32_t query)
   {
      vkCmdEndQuery(
          commandBuffer,
          queryPool,
          query  );
   }

void  cmdResetQueryPool(
        VkCommandBuffer commandBuffer,
        VkQueryPool queryPool,
        uint32_t firstQuery,
        uint32_t queryCount)
   {
      vkCmdResetQueryPool(
          commandBuffer,
          queryPool,
          firstQuery,
          queryCount  );
   }

void  cmdWriteTimestamp(
        VkCommandBuffer commandBuffer,
        VkPipelineStageFlagBits pipelineStage,
        VkQueryPool queryPool,
        uint32_t query)
   {
      vkCmdWriteTimestamp(
          commandBuffer,
          pipelineStage,
          queryPool,
          query  );
   }

void  cmdCopyQueryPoolResults(
        VkCommandBuffer commandBuffer,
        VkQueryPool queryPool,
        uint32_t firstQuery,
        uint32_t queryCount,
        VkBuffer dstBuffer,
        VkDeviceSize dstOffset,
        VkDeviceSize stride,
        VkQueryResultFlags flags)
   {
      vkCmdCopyQueryPoolResults(
          commandBuffer,
          queryPool,
          firstQuery,
          queryCount,
          dstBuffer,
          dstOffset,
          stride,
          flags  );
   }

struct VkRenderPassBeginInfoRAII {
   VkRenderPassBeginInfo nonRaiiObj;
    std::vector<VkClearValue>                   vecClearValues;
};

std::shared_ptr<VkRenderPassBeginInfoRAII> RenderPassBeginInfo(
    VkRenderPass                                renderPass,
    VkFramebuffer                               framebuffer,
    VkRect2D                                    renderArea,
    const std::vector<VkClearValue> &           vecClearValues)
   {
      std::shared_ptr<VkRenderPassBeginInfoRAII> raii_obj(new VkRenderPassBeginInfoRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.renderPass = renderPass;
      raii_obj->nonRaiiObj.framebuffer = framebuffer;
      raii_obj->nonRaiiObj.renderArea = renderArea;
      raii_obj->nonRaiiObj.clearValueCount = static_cast<uint32_t>(vecClearValues.size());
      raii_obj->vecClearValues = vecClearValues;
      if ( raii_obj->vecClearValues.size() > 0)
      {
          raii_obj->nonRaiiObj.pClearValues = &raii_obj->vecClearValues[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pClearValues = nullptr;
      }
      return raii_obj;
   }

void  cmdBeginRenderPass(
        VkCommandBuffer commandBuffer,
        const VkRenderPassBeginInfo & pRenderPassBegin,
        VkSubpassContents contents)
   {
      vkCmdBeginRenderPass(
          commandBuffer,
          &pRenderPassBegin,
          contents  );
   }

void  cmdNextSubpass(
        VkCommandBuffer commandBuffer,
        VkSubpassContents contents)
   {
      vkCmdNextSubpass(
          commandBuffer,
          contents  );
   }

void  cmdEndRenderPass(
        VkCommandBuffer commandBuffer)
   {
      vkCmdEndRenderPass(
          commandBuffer  );
   }

void  cmdExecuteCommands(
        VkCommandBuffer commandBuffer,
        const std::vector<VkCommandBuffer> & pCommandBuffers)
   {
      vkCmdExecuteCommands(
          commandBuffer,
          static_cast<uint32_t>(pCommandBuffers.size()),
          &pCommandBuffers[0]  );
   }

VkDispatchIndirectCommand DispatchIndirectCommand(
    uint32_t                                    x,
    uint32_t                                    y,
    uint32_t                                    z)
   {
      VkDispatchIndirectCommand obj;
      obj.x = x;
      obj.y = y;
      obj.z = z;
      return obj;
   }

VkDrawIndexedIndirectCommand DrawIndexedIndirectCommand(
    uint32_t                                    indexCount,
    uint32_t                                    instanceCount,
    uint32_t                                    firstIndex,
    int32_t                                     vertexOffset,
    uint32_t                                    firstInstance)
   {
      VkDrawIndexedIndirectCommand obj;
      obj.indexCount = indexCount;
      obj.instanceCount = instanceCount;
      obj.firstIndex = firstIndex;
      obj.vertexOffset = vertexOffset;
      obj.firstInstance = firstInstance;
      return obj;
   }

VkDrawIndirectCommand DrawIndirectCommand(
    uint32_t                                    vertexCount,
    uint32_t                                    instanceCount,
    uint32_t                                    firstVertex,
    uint32_t                                    firstInstance)
   {
      VkDrawIndirectCommand obj;
      obj.vertexCount = vertexCount;
      obj.instanceCount = instanceCount;
      obj.firstVertex = firstVertex;
      obj.firstInstance = firstInstance;
      return obj;
   }

VkBool32 getPhysicalDeviceSurfaceSupportKHR(
        VkPhysicalDevice physicalDevice,
        uint32_t queueFamilyIndex,
        VkSurfaceKHR surface)
   {
      VkBool32 pSupported; 
      V( vkGetPhysicalDeviceSurfaceSupportKHR(
          physicalDevice,
          queueFamilyIndex,
          surface,
          &pSupported  ));
      return pSupported; 
   }

VkSurfaceCapabilitiesKHR SurfaceCapabilitiesKHR(
    uint32_t                                    minImageCount,
    uint32_t                                    maxImageCount,
    VkExtent2D                                  currentExtent,
    VkExtent2D                                  minImageExtent,
    VkExtent2D                                  maxImageExtent,
    uint32_t                                    maxImageArrayLayers,
    VkSurfaceTransformFlagsKHR                  supportedTransforms,
    VkSurfaceTransformFlagBitsKHR               currentTransform,
    VkCompositeAlphaFlagsKHR                    supportedCompositeAlpha,
    VkImageUsageFlags                           supportedUsageFlags)
   {
      VkSurfaceCapabilitiesKHR obj;
      obj.minImageCount = minImageCount;
      obj.maxImageCount = maxImageCount;
      obj.currentExtent = currentExtent;
      obj.minImageExtent = minImageExtent;
      obj.maxImageExtent = maxImageExtent;
      obj.maxImageArrayLayers = maxImageArrayLayers;
      obj.supportedTransforms = supportedTransforms;
      obj.currentTransform = currentTransform;
      obj.supportedCompositeAlpha = supportedCompositeAlpha;
      obj.supportedUsageFlags = supportedUsageFlags;
      return obj;
   }

VkSurfaceCapabilitiesKHR getPhysicalDeviceSurfaceCapabilitiesKHR(
        VkPhysicalDevice physicalDevice,
        VkSurfaceKHR surface)
   {
      VkSurfaceCapabilitiesKHR pSurfaceCapabilities; 
      V( vkGetPhysicalDeviceSurfaceCapabilitiesKHR(
          physicalDevice,
          surface,
          &pSurfaceCapabilities  ));
      return pSurfaceCapabilities; 
   }

VkSurfaceFormatKHR SurfaceFormatKHR(
    VkFormat                                    format,
    VkColorSpaceKHR                             colorSpace)
   {
      VkSurfaceFormatKHR obj;
      obj.format = format;
      obj.colorSpace = colorSpace;
      return obj;
   }

std::vector< VkSurfaceFormatKHR > getPhysicalDeviceSurfaceFormatsKHR(
        VkPhysicalDevice physicalDevice,
        VkSurfaceKHR surface)
   {
      std::vector<VkSurfaceFormatKHR> vecpSurfaceFormats; 
      uint32_t pSurfaceFormatsCount; 
      V( vkGetPhysicalDeviceSurfaceFormatsKHR(
          physicalDevice,
          surface,
          &pSurfaceFormatsCount,
          nullptr  ));

      vecpSurfaceFormats.resize(pSurfaceFormatsCount); 

      V( vkGetPhysicalDeviceSurfaceFormatsKHR(
          physicalDevice,
          surface,
          &pSurfaceFormatsCount,
          &vecpSurfaceFormats[0]  ));
      return vecpSurfaceFormats; 
   }

std::vector< VkPresentModeKHR > getPhysicalDeviceSurfacePresentModesKHR(
        VkPhysicalDevice physicalDevice,
        VkSurfaceKHR surface)
   {
      std::vector<VkPresentModeKHR> vecpPresentModes; 
      uint32_t pPresentModesCount; 
      V( vkGetPhysicalDeviceSurfacePresentModesKHR(
          physicalDevice,
          surface,
          &pPresentModesCount,
          nullptr  ));

      vecpPresentModes.resize(pPresentModesCount); 

      V( vkGetPhysicalDeviceSurfacePresentModesKHR(
          physicalDevice,
          surface,
          &pPresentModesCount,
          &vecpPresentModes[0]  ));
      return vecpPresentModes; 
   }

struct VkSwapchainCreateInfoKHRRAII {
   VkSwapchainCreateInfoKHR nonRaiiObj;
    std::vector<uint32_t>                       vecQueueFamilyIndices;
};

std::shared_ptr<VkSwapchainCreateInfoKHRRAII> SwapchainCreateInfoKHR(
    VkSwapchainCreateFlagsKHR                   flags,
    VkSurfaceKHR                                surface,
    uint32_t                                    minImageCount,
    VkFormat                                    imageFormat,
    VkColorSpaceKHR                             imageColorSpace,
    VkExtent2D                                  imageExtent,
    uint32_t                                    imageArrayLayers,
    VkImageUsageFlags                           imageUsage,
    VkSharingMode                               imageSharingMode,
    unsigned int* pQueueFamilyIndices_in_array1, int pQueueFamilyIndices_dim1,
    VkSurfaceTransformFlagBitsKHR               preTransform,
    VkCompositeAlphaFlagBitsKHR                 compositeAlpha,
    VkPresentModeKHR                            presentMode,
    VkBool32                                    clipped,
    VkSwapchainKHR                              oldSwapchain)
   {
      std::shared_ptr<VkSwapchainCreateInfoKHRRAII> raii_obj(new VkSwapchainCreateInfoKHRRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.flags = flags;
      raii_obj->nonRaiiObj.surface = surface;
      raii_obj->nonRaiiObj.minImageCount = minImageCount;
      raii_obj->nonRaiiObj.imageFormat = imageFormat;
      raii_obj->nonRaiiObj.imageColorSpace = imageColorSpace;
      raii_obj->nonRaiiObj.imageExtent = imageExtent;
      raii_obj->nonRaiiObj.imageArrayLayers = imageArrayLayers;
      raii_obj->nonRaiiObj.imageUsage = imageUsage;
      raii_obj->nonRaiiObj.imageSharingMode = imageSharingMode;
      raii_obj->nonRaiiObj.queueFamilyIndexCount = static_cast<uint32_t>(pQueueFamilyIndices_dim1);
      raii_obj->vecQueueFamilyIndices.assign(pQueueFamilyIndices_in_array1, pQueueFamilyIndices_in_array1 + pQueueFamilyIndices_dim1);
      if ( raii_obj->vecQueueFamilyIndices.size() > 0)
      {
          raii_obj->nonRaiiObj.pQueueFamilyIndices = &raii_obj->vecQueueFamilyIndices[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pQueueFamilyIndices = nullptr;
      }
      raii_obj->nonRaiiObj.preTransform = preTransform;
      raii_obj->nonRaiiObj.compositeAlpha = compositeAlpha;
      raii_obj->nonRaiiObj.presentMode = presentMode;
      raii_obj->nonRaiiObj.clipped = clipped;
      raii_obj->nonRaiiObj.oldSwapchain = oldSwapchain;
      return raii_obj;
   }

std::shared_ptr<VkSwapchainKHR_T> createSwapchainKHR(
        VkDevice device,
        const VkSwapchainCreateInfoKHR & pCreateInfo)
   {
      VkSwapchainKHR hSwapchain; 
      V( vkCreateSwapchainKHR(
          device,
          &pCreateInfo,
          nullptr,
          &hSwapchain  ));
      return std::shared_ptr<VkSwapchainKHR_T>(hSwapchain, 
              [=](VkSwapchainKHR to_free) {vkDestroySwapchainKHR(device, to_free, nullptr);});
   }

std::vector< VkImage > getSwapchainImagesKHR(
        VkDevice device,
        VkSwapchainKHR swapchain)
   {
      std::vector<VkImage> vecpSwapchainImages; 
      uint32_t pSwapchainImagesCount; 
      V( vkGetSwapchainImagesKHR(
          device,
          swapchain,
          &pSwapchainImagesCount,
          nullptr  ));

      vecpSwapchainImages.resize(pSwapchainImagesCount); 

      V( vkGetSwapchainImagesKHR(
          device,
          swapchain,
          &pSwapchainImagesCount,
          &vecpSwapchainImages[0]  ));
      return vecpSwapchainImages; 
   }

uint32_t acquireNextImageKHR(
        VkDevice device,
        VkSwapchainKHR swapchain,
        uint64_t timeout,
        VkSemaphore semaphore,
        VkFence fence)
   {
      uint32_t pImageIndex; 
      V( vkAcquireNextImageKHR(
          device,
          swapchain,
          timeout,
          semaphore,
          fence,
          &pImageIndex  ));
      return pImageIndex; 
   }

struct VkPresentInfoKHRRAII {
   VkPresentInfoKHR nonRaiiObj;
    std::vector<VkSemaphore>                    vecWaitSemaphores;
    std::vector<VkSwapchainKHR>                 vecSwapchains;
    std::vector<uint32_t>                       vecImageIndices;
    std::vector<VkResult>                       vecResults;
};

std::shared_ptr<VkPresentInfoKHRRAII> PresentInfoKHR(
    const std::vector<VkSemaphore> &            vecWaitSemaphores,
    const std::vector<VkSwapchainKHR> &         vecSwapchains,
    unsigned int* pImageIndices_in_array1, int pImageIndices_dim1,
    const std::vector<VkResult> &               vecResults)
   {
      std::shared_ptr<VkPresentInfoKHRRAII> raii_obj(new VkPresentInfoKHRRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.waitSemaphoreCount = static_cast<uint32_t>(vecWaitSemaphores.size());
      raii_obj->vecWaitSemaphores = vecWaitSemaphores;
      if ( raii_obj->vecWaitSemaphores.size() > 0)
      {
          raii_obj->nonRaiiObj.pWaitSemaphores = &raii_obj->vecWaitSemaphores[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pWaitSemaphores = nullptr;
      }
      raii_obj->nonRaiiObj.swapchainCount = static_cast<uint32_t>(vecSwapchains.size());
      raii_obj->vecSwapchains = vecSwapchains;
      if ( raii_obj->vecSwapchains.size() > 0)
      {
          raii_obj->nonRaiiObj.pSwapchains = &raii_obj->vecSwapchains[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pSwapchains = nullptr;
      }
      raii_obj->vecImageIndices.assign(pImageIndices_in_array1, pImageIndices_in_array1 + pImageIndices_dim1);
      if ( raii_obj->vecImageIndices.size() > 0)
      {
          raii_obj->nonRaiiObj.pImageIndices = &raii_obj->vecImageIndices[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pImageIndices = nullptr;
      }
      raii_obj->vecResults = vecResults;
      if ( raii_obj->vecResults.size() > 0)
      {
          raii_obj->nonRaiiObj.pResults = &raii_obj->vecResults[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pResults = nullptr;
      }
      return raii_obj;
   }

void  queuePresentKHR(
        VkQueue queue,
        const VkPresentInfoKHR & pPresentInfo)
   {
      V( vkQueuePresentKHR(
          queue,
          &pPresentInfo  ));
   }

struct VkDisplayPropertiesKHRRAII {
   VkDisplayPropertiesKHR nonRaiiObj;
    std::string                                 strisplayName;
};

std::shared_ptr<VkDisplayPropertiesKHRRAII> DisplayPropertiesKHR(
    VkDisplayKHR                                display,
    const std::string &                         strisplayName,
    VkExtent2D                                  physicalDimensions,
    VkExtent2D                                  physicalResolution,
    VkSurfaceTransformFlagsKHR                  supportedTransforms,
    VkBool32                                    planeReorderPossible,
    VkBool32                                    persistentContent)
   {
      std::shared_ptr<VkDisplayPropertiesKHRRAII> raii_obj(new VkDisplayPropertiesKHRRAII);
      raii_obj->nonRaiiObj.display = display;
      raii_obj->strisplayName = strisplayName;
      raii_obj->nonRaiiObj.displayName = &raii_obj->strisplayName[0];
      raii_obj->nonRaiiObj.physicalDimensions = physicalDimensions;
      raii_obj->nonRaiiObj.physicalResolution = physicalResolution;
      raii_obj->nonRaiiObj.supportedTransforms = supportedTransforms;
      raii_obj->nonRaiiObj.planeReorderPossible = planeReorderPossible;
      raii_obj->nonRaiiObj.persistentContent = persistentContent;
      return raii_obj;
   }

VkDisplayModeParametersKHR DisplayModeParametersKHR(
    VkExtent2D                                  visibleRegion,
    uint32_t                                    refreshRate)
   {
      VkDisplayModeParametersKHR obj;
      obj.visibleRegion = visibleRegion;
      obj.refreshRate = refreshRate;
      return obj;
   }

VkDisplayModePropertiesKHR DisplayModePropertiesKHR(
    VkDisplayModeKHR                            displayMode,
    VkDisplayModeParametersKHR                  parameters)
   {
      VkDisplayModePropertiesKHR obj;
      obj.displayMode = displayMode;
      obj.parameters = parameters;
      return obj;
   }

VkDisplayModeCreateInfoKHR DisplayModeCreateInfoKHR(
    VkDisplayModeCreateFlagsKHR                 flags,
    VkDisplayModeParametersKHR                  parameters)
   {
      VkDisplayModeCreateInfoKHR obj;
      obj.sType = VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR;
      obj.pNext = nullptr;
      obj.flags = flags;
      obj.parameters = parameters;
      return obj;
   }

VkDisplayPlaneCapabilitiesKHR DisplayPlaneCapabilitiesKHR(
    VkDisplayPlaneAlphaFlagsKHR                 supportedAlpha,
    VkOffset2D                                  minSrcPosition,
    VkOffset2D                                  maxSrcPosition,
    VkExtent2D                                  minSrcExtent,
    VkExtent2D                                  maxSrcExtent,
    VkOffset2D                                  minDstPosition,
    VkOffset2D                                  maxDstPosition,
    VkExtent2D                                  minDstExtent,
    VkExtent2D                                  maxDstExtent)
   {
      VkDisplayPlaneCapabilitiesKHR obj;
      obj.supportedAlpha = supportedAlpha;
      obj.minSrcPosition = minSrcPosition;
      obj.maxSrcPosition = maxSrcPosition;
      obj.minSrcExtent = minSrcExtent;
      obj.maxSrcExtent = maxSrcExtent;
      obj.minDstPosition = minDstPosition;
      obj.maxDstPosition = maxDstPosition;
      obj.minDstExtent = minDstExtent;
      obj.maxDstExtent = maxDstExtent;
      return obj;
   }

VkDisplayPlanePropertiesKHR DisplayPlanePropertiesKHR(
    VkDisplayKHR                                currentDisplay,
    uint32_t                                    currentStackIndex)
   {
      VkDisplayPlanePropertiesKHR obj;
      obj.currentDisplay = currentDisplay;
      obj.currentStackIndex = currentStackIndex;
      return obj;
   }

VkDisplaySurfaceCreateInfoKHR DisplaySurfaceCreateInfoKHR(
    VkDisplaySurfaceCreateFlagsKHR              flags,
    VkDisplayModeKHR                            displayMode,
    uint32_t                                    planeIndex,
    uint32_t                                    planeStackIndex,
    VkSurfaceTransformFlagBitsKHR               transform,
    float                                       globalAlpha,
    VkDisplayPlaneAlphaFlagBitsKHR              alphaMode,
    VkExtent2D                                  imageExtent)
   {
      VkDisplaySurfaceCreateInfoKHR obj;
      obj.sType = VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR;
      obj.pNext = nullptr;
      obj.flags = flags;
      obj.displayMode = displayMode;
      obj.planeIndex = planeIndex;
      obj.planeStackIndex = planeStackIndex;
      obj.transform = transform;
      obj.globalAlpha = globalAlpha;
      obj.alphaMode = alphaMode;
      obj.imageExtent = imageExtent;
      return obj;
   }

std::vector< VkDisplayPropertiesKHR > getPhysicalDeviceDisplayPropertiesKHR(
        VkPhysicalDevice physicalDevice)
   {
      if ( nullptr == pfvkGetPhysicalDeviceDisplayPropertiesKHR )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      std::vector<VkDisplayPropertiesKHR> vecpProperties; 
      uint32_t pPropertiesCount; 
      V( pfvkGetPhysicalDeviceDisplayPropertiesKHR(
          physicalDevice,
          &pPropertiesCount,
          nullptr  ));

      vecpProperties.resize(pPropertiesCount); 

      V( pfvkGetPhysicalDeviceDisplayPropertiesKHR(
          physicalDevice,
          &pPropertiesCount,
          &vecpProperties[0]  ));
      return vecpProperties; 
   }

std::vector< VkDisplayPlanePropertiesKHR > getPhysicalDeviceDisplayPlanePropertiesKHR(
        VkPhysicalDevice physicalDevice)
   {
      if ( nullptr == pfvkGetPhysicalDeviceDisplayPlanePropertiesKHR )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      std::vector<VkDisplayPlanePropertiesKHR> vecpProperties; 
      uint32_t pPropertiesCount; 
      V( pfvkGetPhysicalDeviceDisplayPlanePropertiesKHR(
          physicalDevice,
          &pPropertiesCount,
          nullptr  ));

      vecpProperties.resize(pPropertiesCount); 

      V( pfvkGetPhysicalDeviceDisplayPlanePropertiesKHR(
          physicalDevice,
          &pPropertiesCount,
          &vecpProperties[0]  ));
      return vecpProperties; 
   }

std::vector< VkDisplayKHR > getDisplayPlaneSupportedDisplaysKHR(
        VkPhysicalDevice physicalDevice,
        uint32_t planeIndex)
   {
      if ( nullptr == pfvkGetDisplayPlaneSupportedDisplaysKHR )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      std::vector<VkDisplayKHR> vecpDisplays; 
      uint32_t pDisplaysCount; 
      V( pfvkGetDisplayPlaneSupportedDisplaysKHR(
          physicalDevice,
          planeIndex,
          &pDisplaysCount,
          nullptr  ));

      vecpDisplays.resize(pDisplaysCount); 

      V( pfvkGetDisplayPlaneSupportedDisplaysKHR(
          physicalDevice,
          planeIndex,
          &pDisplaysCount,
          &vecpDisplays[0]  ));
      return vecpDisplays; 
   }

std::vector< VkDisplayModePropertiesKHR > getDisplayModePropertiesKHR(
        VkPhysicalDevice physicalDevice,
        VkDisplayKHR display)
   {
      if ( nullptr == pfvkGetDisplayModePropertiesKHR )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      std::vector<VkDisplayModePropertiesKHR> vecpProperties; 
      uint32_t pPropertiesCount; 
      V( pfvkGetDisplayModePropertiesKHR(
          physicalDevice,
          display,
          &pPropertiesCount,
          nullptr  ));

      vecpProperties.resize(pPropertiesCount); 

      V( pfvkGetDisplayModePropertiesKHR(
          physicalDevice,
          display,
          &pPropertiesCount,
          &vecpProperties[0]  ));
      return vecpProperties; 
   }

std::shared_ptr<VkDisplayModeKHR_T> createDisplayModeKHR(
        VkPhysicalDevice physicalDevice,
        VkDisplayKHR display,
        const VkDisplayModeCreateInfoKHR & pCreateInfo)
   {
      if ( nullptr == pfvkCreateDisplayModeKHR )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      VkDisplayModeKHR hMode; 
      V( pfvkCreateDisplayModeKHR(
          physicalDevice,
          display,
          &pCreateInfo,
          nullptr,
          &hMode  ));
      return std::shared_ptr<VkDisplayModeKHR_T>(hMode, 
              [](VkDisplayModeKHR) {});
   }

VkDisplayPlaneCapabilitiesKHR getDisplayPlaneCapabilitiesKHR(
        VkPhysicalDevice physicalDevice,
        VkDisplayModeKHR mode,
        uint32_t planeIndex)
   {
      if ( nullptr == pfvkGetDisplayPlaneCapabilitiesKHR )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      VkDisplayPlaneCapabilitiesKHR pCapabilities; 
      V( pfvkGetDisplayPlaneCapabilitiesKHR(
          physicalDevice,
          mode,
          planeIndex,
          &pCapabilities  ));
      return pCapabilities; 
   }

std::shared_ptr<VkSurfaceKHR_T> createDisplayPlaneSurfaceKHR(
        VkInstance instance,
        const VkDisplaySurfaceCreateInfoKHR & pCreateInfo)
   {
      if ( nullptr == pfvkCreateDisplayPlaneSurfaceKHR )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      VkSurfaceKHR hSurface; 
      V( pfvkCreateDisplayPlaneSurfaceKHR(
          instance,
          &pCreateInfo,
          nullptr,
          &hSurface  ));
      return std::shared_ptr<VkSurfaceKHR_T>(hSurface, 
              [=](VkSurfaceKHR to_free) {pfvkDestroySurfaceKHR(instance, to_free, nullptr);});
   }

VkDisplayPresentInfoKHR DisplayPresentInfoKHR(
    VkRect2D                                    srcRect,
    VkRect2D                                    dstRect,
    VkBool32                                    persistent)
   {
      VkDisplayPresentInfoKHR obj;
      obj.sType = VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR;
      obj.pNext = nullptr;
      obj.srcRect = srcRect;
      obj.dstRect = dstRect;
      obj.persistent = persistent;
      return obj;
   }

std::vector< std::shared_ptr<VkSwapchainKHR_T> > createSharedSwapchainsKHR(
        VkDevice device,
        const std::vector<VkSwapchainCreateInfoKHR> & pCreateInfos)
   {
      if ( nullptr == pfvkCreateSharedSwapchainsKHR )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      std::vector<VkSwapchainKHR> vecpSwapchains( pCreateInfos.size(), nullptr ); 
      V( pfvkCreateSharedSwapchainsKHR(
          device,
          static_cast<uint32_t>(pCreateInfos.size()),
          &pCreateInfos[0],
          nullptr,
          &vecpSwapchains[0]  ));
      std::vector< std::shared_ptr<VkSwapchainKHR_T> > retval; 
      retval.reserve(vecpSwapchains.size()); 
      for (auto allocated_handle : vecpSwapchains ) 
      {
          retval.push_back(std::shared_ptr<VkSwapchainKHR_T>(allocated_handle, 
              [](VkSwapchainKHR) {}));
      }
      return retval; 
   }

#ifdef VK_USE_PLATFORM_XLIB_KHR
VkXlibSurfaceCreateInfoKHR XlibSurfaceCreateInfoKHR(
    VkXlibSurfaceCreateFlagsKHR                 flags,
    Display*                                    dpy,
    Window                                      window)
   {
      VkXlibSurfaceCreateInfoKHR obj;
      obj.sType = VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR;
      obj.pNext = nullptr;
      obj.flags = flags;
      obj.dpy = dpy;
      obj.window = window;
      return obj;
   }

std::shared_ptr<VkSurfaceKHR_T> createXlibSurfaceKHR(
        VkInstance instance,
        const VkXlibSurfaceCreateInfoKHR & pCreateInfo)
   {
      VkSurfaceKHR hSurface; 
      V( vkCreateXlibSurfaceKHR(
          instance,
          &pCreateInfo,
          nullptr,
          &hSurface  ));
      return std::shared_ptr<VkSurfaceKHR_T>(hSurface, 
              [=](VkSurfaceKHR to_free) {pfvkDestroySurfaceKHR(instance, to_free, nullptr);});
   }

Display getPhysicalDeviceXlibPresentationSupportKHR(
        VkPhysicalDevice physicalDevice,
        uint32_t queueFamilyIndex,
        VisualID visualID)
   {
      Display dpy; 
      vkGetPhysicalDeviceXlibPresentationSupportKHR(
          physicalDevice,
          queueFamilyIndex,
          &dpy,
          visualID  );
      return dpy; 
   }

#endif /* VK_USE_PLATFORM_XLIB_KHR*/
#ifdef VK_USE_PLATFORM_XCB_KHR
VkXcbSurfaceCreateInfoKHR XcbSurfaceCreateInfoKHR(
    VkXcbSurfaceCreateFlagsKHR                  flags,
    xcb_connection_t*                           connection,
    xcb_window_t                                window)
   {
      VkXcbSurfaceCreateInfoKHR obj;
      obj.sType = VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR;
      obj.pNext = nullptr;
      obj.flags = flags;
      obj.connection = connection;
      obj.window = window;
      return obj;
   }

std::shared_ptr<VkSurfaceKHR_T> createXcbSurfaceKHR(
        VkInstance instance,
        const VkXcbSurfaceCreateInfoKHR & pCreateInfo)
   {
      VkSurfaceKHR hSurface; 
      V( vkCreateXcbSurfaceKHR(
          instance,
          &pCreateInfo,
          nullptr,
          &hSurface  ));
      return std::shared_ptr<VkSurfaceKHR_T>(hSurface, 
              [=](VkSurfaceKHR to_free) {pfvkDestroySurfaceKHR(instance, to_free, nullptr);});
   }

xcb_connection_t getPhysicalDeviceXcbPresentationSupportKHR(
        VkPhysicalDevice physicalDevice,
        uint32_t queueFamilyIndex,
        xcb_visualid_t visual_id)
   {
      xcb_connection_t connection; 
      vkGetPhysicalDeviceXcbPresentationSupportKHR(
          physicalDevice,
          queueFamilyIndex,
          &connection,
          visual_id  );
      return connection; 
   }

#endif /* VK_USE_PLATFORM_XCB_KHR*/
#ifdef VK_USE_PLATFORM_WAYLAND_KHR
VkWaylandSurfaceCreateInfoKHR WaylandSurfaceCreateInfoKHR(
    VkWaylandSurfaceCreateFlagsKHR              flags,
    struct wl_display*                          display,
    struct wl_surface*                          surface)
   {
      VkWaylandSurfaceCreateInfoKHR obj;
      obj.sType = VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR;
      obj.pNext = nullptr;
      obj.flags = flags;
      obj.display = display;
      obj.surface = surface;
      return obj;
   }

std::shared_ptr<VkSurfaceKHR_T> createWaylandSurfaceKHR(
        VkInstance instance,
        const VkWaylandSurfaceCreateInfoKHR & pCreateInfo)
   {
      VkSurfaceKHR hSurface; 
      V( vkCreateWaylandSurfaceKHR(
          instance,
          &pCreateInfo,
          nullptr,
          &hSurface  ));
      return std::shared_ptr<VkSurfaceKHR_T>(hSurface, 
              [=](VkSurfaceKHR to_free) {pfvkDestroySurfaceKHR(instance, to_free, nullptr);});
   }

wl_display getPhysicalDeviceWaylandPresentationSupportKHR(
        VkPhysicalDevice physicalDevice,
        uint32_t queueFamilyIndex)
   {
      wl_display display; 
      vkGetPhysicalDeviceWaylandPresentationSupportKHR(
          physicalDevice,
          queueFamilyIndex,
          &display  );
      return display; 
   }

#endif /* VK_USE_PLATFORM_WAYLAND_KHR*/
#ifdef VK_USE_PLATFORM_MIR_KHR
VkMirSurfaceCreateInfoKHR MirSurfaceCreateInfoKHR(
    VkMirSurfaceCreateFlagsKHR                  flags,
    MirConnection*                              connection,
    MirSurface*                                 mirSurface)
   {
      VkMirSurfaceCreateInfoKHR obj;
      obj.sType = VK_STRUCTURE_TYPE_MIR_SURFACE_CREATE_INFO_KHR;
      obj.pNext = nullptr;
      obj.flags = flags;
      obj.connection = connection;
      obj.mirSurface = mirSurface;
      return obj;
   }

std::shared_ptr<VkSurfaceKHR_T> createMirSurfaceKHR(
        VkInstance instance,
        const VkMirSurfaceCreateInfoKHR & pCreateInfo)
   {
      VkSurfaceKHR hSurface; 
      V( vkCreateMirSurfaceKHR(
          instance,
          &pCreateInfo,
          nullptr,
          &hSurface  ));
      return std::shared_ptr<VkSurfaceKHR_T>(hSurface, 
              [=](VkSurfaceKHR to_free) {pfvkDestroySurfaceKHR(instance, to_free, nullptr);});
   }

MirConnection getPhysicalDeviceMirPresentationSupportKHR(
        VkPhysicalDevice physicalDevice,
        uint32_t queueFamilyIndex)
   {
      MirConnection connection; 
      vkGetPhysicalDeviceMirPresentationSupportKHR(
          physicalDevice,
          queueFamilyIndex,
          &connection  );
      return connection; 
   }

#endif /* VK_USE_PLATFORM_MIR_KHR*/
#ifdef VK_USE_PLATFORM_ANDROID_KHR
VkAndroidSurfaceCreateInfoKHR AndroidSurfaceCreateInfoKHR(
    VkAndroidSurfaceCreateFlagsKHR              flags,
    ANativeWindow*                              window)
   {
      VkAndroidSurfaceCreateInfoKHR obj;
      obj.sType = VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR;
      obj.pNext = nullptr;
      obj.flags = flags;
      obj.window = window;
      return obj;
   }

std::shared_ptr<VkSurfaceKHR_T> createAndroidSurfaceKHR(
        VkInstance instance,
        const VkAndroidSurfaceCreateInfoKHR & pCreateInfo)
   {
      VkSurfaceKHR hSurface; 
      V( vkCreateAndroidSurfaceKHR(
          instance,
          &pCreateInfo,
          nullptr,
          &hSurface  ));
      return std::shared_ptr<VkSurfaceKHR_T>(hSurface, 
              [=](VkSurfaceKHR to_free) {pfvkDestroySurfaceKHR(instance, to_free, nullptr);});
   }

#endif /* VK_USE_PLATFORM_ANDROID_KHR*/
#ifdef VK_USE_PLATFORM_WIN32_KHR
VkWin32SurfaceCreateInfoKHR Win32SurfaceCreateInfoKHR(
    VkWin32SurfaceCreateFlagsKHR                flags,
    HINSTANCE                                   hinstance,
    HWND                                        hwnd)
   {
      VkWin32SurfaceCreateInfoKHR obj;
      obj.sType = VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR;
      obj.pNext = nullptr;
      obj.flags = flags;
      obj.hinstance = hinstance;
      obj.hwnd = hwnd;
      return obj;
   }

std::shared_ptr<VkSurfaceKHR_T> createWin32SurfaceKHR(
        VkInstance instance,
        const VkWin32SurfaceCreateInfoKHR & pCreateInfo)
   {
      VkSurfaceKHR hSurface; 
      V( vkCreateWin32SurfaceKHR(
          instance,
          &pCreateInfo,
          nullptr,
          &hSurface  ));
      return std::shared_ptr<VkSurfaceKHR_T>(hSurface, 
              [=](VkSurfaceKHR to_free) {pfvkDestroySurfaceKHR(instance, to_free, nullptr);});
   }

void  getPhysicalDeviceWin32PresentationSupportKHR(
        VkPhysicalDevice physicalDevice,
        uint32_t queueFamilyIndex)
   {
      vkGetPhysicalDeviceWin32PresentationSupportKHR(
          physicalDevice,
          queueFamilyIndex  );
   }

#endif /* VK_USE_PLATFORM_WIN32_KHR*/
VkPhysicalDeviceFeatures2KHR PhysicalDeviceFeatures2KHR(
    VkPhysicalDeviceFeatures                    features)
   {
      VkPhysicalDeviceFeatures2KHR obj;
      obj.sType = VK_STRUCTURE_TYPE_MAX_ENUM;
      obj.pNext = nullptr;
      obj.features = features;
      return obj;
   }

VkPhysicalDeviceProperties2KHR PhysicalDeviceProperties2KHR(
    VkPhysicalDeviceProperties                  properties)
   {
      VkPhysicalDeviceProperties2KHR obj;
      obj.sType = VK_STRUCTURE_TYPE_MAX_ENUM;
      obj.pNext = nullptr;
      obj.properties = properties;
      return obj;
   }

VkFormatProperties2KHR FormatProperties2KHR(
    VkFormatProperties                          formatProperties)
   {
      VkFormatProperties2KHR obj;
      obj.sType = VK_STRUCTURE_TYPE_MAX_ENUM;
      obj.pNext = nullptr;
      obj.formatProperties = formatProperties;
      return obj;
   }

VkImageFormatProperties2KHR ImageFormatProperties2KHR(
    VkImageFormatProperties                     imageFormatProperties)
   {
      VkImageFormatProperties2KHR obj;
      obj.sType = VK_STRUCTURE_TYPE_MAX_ENUM;
      obj.pNext = nullptr;
      obj.imageFormatProperties = imageFormatProperties;
      return obj;
   }

VkPhysicalDeviceImageFormatInfo2KHR PhysicalDeviceImageFormatInfo2KHR(
    VkFormat                                    format,
    VkImageType                                 type,
    VkImageTiling                               tiling,
    VkImageUsageFlags                           usage,
    VkImageCreateFlags                          flags)
   {
      VkPhysicalDeviceImageFormatInfo2KHR obj;
      obj.sType = VK_STRUCTURE_TYPE_MAX_ENUM;
      obj.pNext = nullptr;
      obj.format = format;
      obj.type = type;
      obj.tiling = tiling;
      obj.usage = usage;
      obj.flags = flags;
      return obj;
   }

VkQueueFamilyProperties2KHR QueueFamilyProperties2KHR(
    VkQueueFamilyProperties                     queueFamilyProperties)
   {
      VkQueueFamilyProperties2KHR obj;
      obj.sType = VK_STRUCTURE_TYPE_MAX_ENUM;
      obj.pNext = nullptr;
      obj.queueFamilyProperties = queueFamilyProperties;
      return obj;
   }

VkPhysicalDeviceMemoryProperties2KHR PhysicalDeviceMemoryProperties2KHR(
    VkPhysicalDeviceMemoryProperties            memoryProperties)
   {
      VkPhysicalDeviceMemoryProperties2KHR obj;
      obj.sType = VK_STRUCTURE_TYPE_MAX_ENUM;
      obj.pNext = nullptr;
      obj.memoryProperties = memoryProperties;
      return obj;
   }

VkSparseImageFormatProperties2KHR SparseImageFormatProperties2KHR(
    VkSparseImageFormatProperties               properties)
   {
      VkSparseImageFormatProperties2KHR obj;
      obj.sType = VK_STRUCTURE_TYPE_MAX_ENUM;
      obj.pNext = nullptr;
      obj.properties = properties;
      return obj;
   }

VkPhysicalDeviceSparseImageFormatInfo2KHR PhysicalDeviceSparseImageFormatInfo2KHR(
    VkFormat                                    format,
    VkImageType                                 type,
    VkSampleCountFlagBits                       samples,
    VkImageUsageFlags                           usage,
    VkImageTiling                               tiling)
   {
      VkPhysicalDeviceSparseImageFormatInfo2KHR obj;
      obj.sType = VK_STRUCTURE_TYPE_MAX_ENUM;
      obj.pNext = nullptr;
      obj.format = format;
      obj.type = type;
      obj.samples = samples;
      obj.usage = usage;
      obj.tiling = tiling;
      return obj;
   }

VkPhysicalDeviceFeatures2KHR getPhysicalDeviceFeatures2KHR(
        VkPhysicalDevice physicalDevice)
   {
      if ( nullptr == pfvkGetPhysicalDeviceFeatures2KHR )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      VkPhysicalDeviceFeatures2KHR pFeatures; 
      pfvkGetPhysicalDeviceFeatures2KHR(
          physicalDevice,
          &pFeatures  );
      return pFeatures; 
   }

VkPhysicalDeviceProperties2KHR getPhysicalDeviceProperties2KHR(
        VkPhysicalDevice physicalDevice)
   {
      if ( nullptr == pfvkGetPhysicalDeviceProperties2KHR )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      VkPhysicalDeviceProperties2KHR pProperties; 
      pfvkGetPhysicalDeviceProperties2KHR(
          physicalDevice,
          &pProperties  );
      return pProperties; 
   }

VkFormatProperties2KHR getPhysicalDeviceFormatProperties2KHR(
        VkPhysicalDevice physicalDevice,
        VkFormat format)
   {
      if ( nullptr == pfvkGetPhysicalDeviceFormatProperties2KHR )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      VkFormatProperties2KHR pFormatProperties; 
      pfvkGetPhysicalDeviceFormatProperties2KHR(
          physicalDevice,
          format,
          &pFormatProperties  );
      return pFormatProperties; 
   }

VkImageFormatProperties2KHR getPhysicalDeviceImageFormatProperties2KHR(
        VkPhysicalDevice physicalDevice,
        const VkPhysicalDeviceImageFormatInfo2KHR & pImageFormatInfo)
   {
      if ( nullptr == pfvkGetPhysicalDeviceImageFormatProperties2KHR )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      VkImageFormatProperties2KHR pImageFormatProperties; 
      V( pfvkGetPhysicalDeviceImageFormatProperties2KHR(
          physicalDevice,
          &pImageFormatInfo,
          &pImageFormatProperties  ));
      return pImageFormatProperties; 
   }

std::vector< VkQueueFamilyProperties2KHR > getPhysicalDeviceQueueFamilyProperties2KHR(
        VkPhysicalDevice physicalDevice)
   {
      if ( nullptr == pfvkGetPhysicalDeviceQueueFamilyProperties2KHR )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      std::vector<VkQueueFamilyProperties2KHR> vecpQueueFamilyProperties; 
      uint32_t pQueueFamilyPropertiesCount; 
      pfvkGetPhysicalDeviceQueueFamilyProperties2KHR(
          physicalDevice,
          &pQueueFamilyPropertiesCount,
          nullptr  );

      vecpQueueFamilyProperties.resize(pQueueFamilyPropertiesCount); 

      pfvkGetPhysicalDeviceQueueFamilyProperties2KHR(
          physicalDevice,
          &pQueueFamilyPropertiesCount,
          &vecpQueueFamilyProperties[0]  );
      return vecpQueueFamilyProperties; 
   }

VkPhysicalDeviceMemoryProperties2KHR getPhysicalDeviceMemoryProperties2KHR(
        VkPhysicalDevice physicalDevice)
   {
      if ( nullptr == pfvkGetPhysicalDeviceMemoryProperties2KHR )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      VkPhysicalDeviceMemoryProperties2KHR pMemoryProperties; 
      pfvkGetPhysicalDeviceMemoryProperties2KHR(
          physicalDevice,
          &pMemoryProperties  );
      return pMemoryProperties; 
   }

std::vector< VkSparseImageFormatProperties2KHR > getPhysicalDeviceSparseImageFormatProperties2KHR(
        VkPhysicalDevice physicalDevice,
        const VkPhysicalDeviceSparseImageFormatInfo2KHR & pFormatInfo)
   {
      if ( nullptr == pfvkGetPhysicalDeviceSparseImageFormatProperties2KHR )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      std::vector<VkSparseImageFormatProperties2KHR> vecpProperties; 
      uint32_t pPropertiesCount; 
      pfvkGetPhysicalDeviceSparseImageFormatProperties2KHR(
          physicalDevice,
          &pFormatInfo,
          &pPropertiesCount,
          nullptr  );

      vecpProperties.resize(pPropertiesCount); 

      pfvkGetPhysicalDeviceSparseImageFormatProperties2KHR(
          physicalDevice,
          &pFormatInfo,
          &pPropertiesCount,
          &vecpProperties[0]  );
      return vecpProperties; 
   }

void  trimCommandPoolKHR(
        VkDevice device,
        VkCommandPool commandPool,
        VkCommandPoolTrimFlagsKHR flags)
   {
      if ( nullptr == pfvkTrimCommandPoolKHR )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      pfvkTrimCommandPoolKHR(
          device,
          commandPool,
          flags  );
   }

VkExternalMemoryPropertiesKHR ExternalMemoryPropertiesKHR(
    VkExternalMemoryFeatureFlagsKHR             externalMemoryFeatures,
    VkExternalMemoryHandleTypeFlagsKHR          exportFromImportedHandleTypes,
    VkExternalMemoryHandleTypeFlagsKHR          compatibleHandleTypes)
   {
      VkExternalMemoryPropertiesKHR obj;
      obj.externalMemoryFeatures = externalMemoryFeatures;
      obj.exportFromImportedHandleTypes = exportFromImportedHandleTypes;
      obj.compatibleHandleTypes = compatibleHandleTypes;
      return obj;
   }

VkPhysicalDeviceExternalImageFormatInfoKHR PhysicalDeviceExternalImageFormatInfoKHR(
    VkExternalMemoryHandleTypeFlagBitsKHR       handleType)
   {
      VkPhysicalDeviceExternalImageFormatInfoKHR obj;
      obj.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO_KHR;
      obj.pNext = nullptr;
      obj.handleType = handleType;
      return obj;
   }

VkExternalImageFormatPropertiesKHR ExternalImageFormatPropertiesKHR(
    VkExternalMemoryPropertiesKHR               externalMemoryProperties)
   {
      VkExternalImageFormatPropertiesKHR obj;
      obj.sType = VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES_KHR;
      obj.pNext = nullptr;
      obj.externalMemoryProperties = externalMemoryProperties;
      return obj;
   }

VkPhysicalDeviceExternalBufferInfoKHR PhysicalDeviceExternalBufferInfoKHR(
    VkBufferCreateFlags                         flags,
    VkBufferUsageFlags                          usage,
    VkExternalMemoryHandleTypeFlagBitsKHR       handleType)
   {
      VkPhysicalDeviceExternalBufferInfoKHR obj;
      obj.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO_KHR;
      obj.pNext = nullptr;
      obj.flags = flags;
      obj.usage = usage;
      obj.handleType = handleType;
      return obj;
   }

VkExternalBufferPropertiesKHR ExternalBufferPropertiesKHR(
    VkExternalMemoryPropertiesKHR               externalMemoryProperties)
   {
      VkExternalBufferPropertiesKHR obj;
      obj.sType = VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES_KHR;
      obj.pNext = nullptr;
      obj.externalMemoryProperties = externalMemoryProperties;
      return obj;
   }

VkPhysicalDeviceIDPropertiesKHR PhysicalDeviceIDPropertiesKHR(
    uint8_t                                     deviceUUID[VK_UUID_SIZE],
    uint8_t                                     driverUUID[VK_UUID_SIZE],
    uint8_t                                     deviceLUID[VK_LUID_SIZE_KHR],
    uint32_t                                    deviceNodeMask,
    VkBool32                                    deviceLUIDValid)
   {
      VkPhysicalDeviceIDPropertiesKHR obj;
      obj.sType = VK_STRUCTURE_TYPE_MAX_ENUM;
      obj.pNext = nullptr;
      std::copy(deviceUUID, deviceUUID + VK_UUID_SIZE, obj.deviceUUID);
      std::copy(driverUUID, driverUUID + VK_UUID_SIZE, obj.driverUUID);
      std::copy(deviceLUID, deviceLUID + VK_LUID_SIZE_KHR, obj.deviceLUID);
      obj.deviceNodeMask = deviceNodeMask;
      obj.deviceLUIDValid = deviceLUIDValid;
      return obj;
   }

VkExternalBufferPropertiesKHR getPhysicalDeviceExternalBufferPropertiesKHR(
        VkPhysicalDevice physicalDevice,
        const VkPhysicalDeviceExternalBufferInfoKHR & pExternalBufferInfo)
   {
      if ( nullptr == pfvkGetPhysicalDeviceExternalBufferPropertiesKHR )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      VkExternalBufferPropertiesKHR pExternalBufferProperties; 
      pfvkGetPhysicalDeviceExternalBufferPropertiesKHR(
          physicalDevice,
          &pExternalBufferInfo,
          &pExternalBufferProperties  );
      return pExternalBufferProperties; 
   }

VkExternalMemoryImageCreateInfoKHR ExternalMemoryImageCreateInfoKHR(
    VkExternalMemoryHandleTypeFlagsKHR          handleTypes)
   {
      VkExternalMemoryImageCreateInfoKHR obj;
      obj.sType = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_KHR;
      obj.pNext = nullptr;
      obj.handleTypes = handleTypes;
      return obj;
   }

VkExternalMemoryBufferCreateInfoKHR ExternalMemoryBufferCreateInfoKHR(
    VkExternalMemoryHandleTypeFlagsKHR          handleTypes)
   {
      VkExternalMemoryBufferCreateInfoKHR obj;
      obj.sType = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO_KHR;
      obj.pNext = nullptr;
      obj.handleTypes = handleTypes;
      return obj;
   }

VkExportMemoryAllocateInfoKHR ExportMemoryAllocateInfoKHR(
    VkExternalMemoryHandleTypeFlagsKHR          handleTypes)
   {
      VkExportMemoryAllocateInfoKHR obj;
      obj.sType = VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_KHR;
      obj.pNext = nullptr;
      obj.handleTypes = handleTypes;
      return obj;
   }

#ifdef VK_USE_PLATFORM_WIN32_KHR
VkImportMemoryWin32HandleInfoKHR ImportMemoryWin32HandleInfoKHR(
    VkExternalMemoryHandleTypeFlagBitsKHR       handleType,
    HANDLE                                      handle,
    LPCWSTR                                     name)
   {
      VkImportMemoryWin32HandleInfoKHR obj;
      obj.sType = VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR;
      obj.pNext = nullptr;
      obj.handleType = handleType;
      obj.handle = handle;
      obj.name = name;
      return obj;
   }

struct VkExportMemoryWin32HandleInfoKHRRAII {
   VkExportMemoryWin32HandleInfoKHR nonRaiiObj;
    std::shared_ptr<SECURITY_ATTRIBUTES>        pAttributes;
};

std::shared_ptr<VkExportMemoryWin32HandleInfoKHRRAII> ExportMemoryWin32HandleInfoKHR(
    const SECURITY_ATTRIBUTES *                 pAttributes,
    DWORD                                       dwAccess,
    LPCWSTR                                     name)
   {
      std::shared_ptr<VkExportMemoryWin32HandleInfoKHRRAII> raii_obj(new VkExportMemoryWin32HandleInfoKHRRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.pAttributes = nullptr;
      if ( pAttributes ) 
      { 
          raii_obj->pAttributes.reset( new SECURITY_ATTRIBUTES );
          *raii_obj->pAttributes = *pAttributes;
          raii_obj->nonRaiiObj.pAttributes = raii_obj->pAttributes.get();
      } 
      raii_obj->nonRaiiObj.dwAccess = dwAccess;
      raii_obj->nonRaiiObj.name = name;
      return raii_obj;
   }

VkMemoryWin32HandlePropertiesKHR MemoryWin32HandlePropertiesKHR(
    uint32_t                                    memoryTypeBits)
   {
      VkMemoryWin32HandlePropertiesKHR obj;
      obj.sType = VK_STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR;
      obj.pNext = nullptr;
      obj.memoryTypeBits = memoryTypeBits;
      return obj;
   }

VkMemoryGetWin32HandleInfoKHR MemoryGetWin32HandleInfoKHR(
    VkDeviceMemory                              memory,
    VkExternalMemoryHandleTypeFlagBitsKHR       handleType)
   {
      VkMemoryGetWin32HandleInfoKHR obj;
      obj.sType = VK_STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR;
      obj.pNext = nullptr;
      obj.memory = memory;
      obj.handleType = handleType;
      return obj;
   }

HANDLE getMemoryWin32HandleKHR(
        VkDevice device,
        const VkMemoryGetWin32HandleInfoKHR & pGetWin32HandleInfo)
   {
      if ( nullptr == pfvkGetMemoryWin32HandleKHR )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      HANDLE pHandle; 
      V( pfvkGetMemoryWin32HandleKHR(
          device,
          &pGetWin32HandleInfo,
          &pHandle  ));
      return pHandle; 
   }

VkMemoryWin32HandlePropertiesKHR getMemoryWin32HandlePropertiesKHR(
        VkDevice device,
        VkExternalMemoryHandleTypeFlagBitsKHR handleType,
        HANDLE handle)
   {
      if ( nullptr == pfvkGetMemoryWin32HandlePropertiesKHR )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      VkMemoryWin32HandlePropertiesKHR pMemoryWin32HandleProperties; 
      V( pfvkGetMemoryWin32HandlePropertiesKHR(
          device,
          handleType,
          handle,
          &pMemoryWin32HandleProperties  ));
      return pMemoryWin32HandleProperties; 
   }

#endif /* VK_USE_PLATFORM_WIN32_KHR*/
VkImportMemoryFdInfoKHR ImportMemoryFdInfoKHR(
    VkExternalMemoryHandleTypeFlagBitsKHR       handleType,
    int                                         fd)
   {
      VkImportMemoryFdInfoKHR obj;
      obj.sType = VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR;
      obj.pNext = nullptr;
      obj.handleType = handleType;
      obj.fd = fd;
      return obj;
   }

VkMemoryFdPropertiesKHR MemoryFdPropertiesKHR(
    uint32_t                                    memoryTypeBits)
   {
      VkMemoryFdPropertiesKHR obj;
      obj.sType = VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR;
      obj.pNext = nullptr;
      obj.memoryTypeBits = memoryTypeBits;
      return obj;
   }

VkMemoryGetFdInfoKHR MemoryGetFdInfoKHR(
    VkDeviceMemory                              memory,
    VkExternalMemoryHandleTypeFlagBitsKHR       handleType)
   {
      VkMemoryGetFdInfoKHR obj;
      obj.sType = VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR;
      obj.pNext = nullptr;
      obj.memory = memory;
      obj.handleType = handleType;
      return obj;
   }

int getMemoryFdKHR(
        VkDevice device,
        const VkMemoryGetFdInfoKHR & pGetFdInfo)
   {
      if ( nullptr == pfvkGetMemoryFdKHR )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      int pFd; 
      V( pfvkGetMemoryFdKHR(
          device,
          &pGetFdInfo,
          &pFd  ));
      return pFd; 
   }

VkMemoryFdPropertiesKHR getMemoryFdPropertiesKHR(
        VkDevice device,
        VkExternalMemoryHandleTypeFlagBitsKHR handleType,
        int fd)
   {
      if ( nullptr == pfvkGetMemoryFdPropertiesKHR )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      VkMemoryFdPropertiesKHR pMemoryFdProperties; 
      V( pfvkGetMemoryFdPropertiesKHR(
          device,
          handleType,
          fd,
          &pMemoryFdProperties  ));
      return pMemoryFdProperties; 
   }

#ifdef VK_USE_PLATFORM_WIN32_KHR
struct VkWin32KeyedMutexAcquireReleaseInfoKHRRAII {
   VkWin32KeyedMutexAcquireReleaseInfoKHR nonRaiiObj;
    std::vector<VkDeviceMemory>                 vecAcquireSyncs;
    std::vector<uint64_t>                       vecAcquireKeys;
    std::vector<uint32_t>                       vecAcquireTimeouts;
    std::vector<VkDeviceMemory>                 vecReleaseSyncs;
    std::vector<uint64_t>                       vecReleaseKeys;
};

std::shared_ptr<VkWin32KeyedMutexAcquireReleaseInfoKHRRAII> Win32KeyedMutexAcquireReleaseInfoKHR(
    const std::vector<VkDeviceMemory> &         vecAcquireSyncs,
    const std::vector<uint64_t> &               vecAcquireKeys,
    unsigned int* pAcquireTimeouts_in_array1, int pAcquireTimeouts_dim1,
    const std::vector<VkDeviceMemory> &         vecReleaseSyncs,
    const std::vector<uint64_t> &               vecReleaseKeys)
   {
      std::shared_ptr<VkWin32KeyedMutexAcquireReleaseInfoKHRRAII> raii_obj(new VkWin32KeyedMutexAcquireReleaseInfoKHRRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.acquireCount = static_cast<uint32_t>(vecAcquireSyncs.size());
      raii_obj->vecAcquireSyncs = vecAcquireSyncs;
      if ( raii_obj->vecAcquireSyncs.size() > 0)
      {
          raii_obj->nonRaiiObj.pAcquireSyncs = &raii_obj->vecAcquireSyncs[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pAcquireSyncs = nullptr;
      }
      raii_obj->vecAcquireKeys = vecAcquireKeys;
      if ( raii_obj->vecAcquireKeys.size() > 0)
      {
          raii_obj->nonRaiiObj.pAcquireKeys = &raii_obj->vecAcquireKeys[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pAcquireKeys = nullptr;
      }
      raii_obj->vecAcquireTimeouts.assign(pAcquireTimeouts_in_array1, pAcquireTimeouts_in_array1 + pAcquireTimeouts_dim1);
      if ( raii_obj->vecAcquireTimeouts.size() > 0)
      {
          raii_obj->nonRaiiObj.pAcquireTimeouts = &raii_obj->vecAcquireTimeouts[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pAcquireTimeouts = nullptr;
      }
      raii_obj->nonRaiiObj.releaseCount = static_cast<uint32_t>(vecReleaseSyncs.size());
      raii_obj->vecReleaseSyncs = vecReleaseSyncs;
      if ( raii_obj->vecReleaseSyncs.size() > 0)
      {
          raii_obj->nonRaiiObj.pReleaseSyncs = &raii_obj->vecReleaseSyncs[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pReleaseSyncs = nullptr;
      }
      raii_obj->vecReleaseKeys = vecReleaseKeys;
      if ( raii_obj->vecReleaseKeys.size() > 0)
      {
          raii_obj->nonRaiiObj.pReleaseKeys = &raii_obj->vecReleaseKeys[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pReleaseKeys = nullptr;
      }
      return raii_obj;
   }

#endif /* VK_USE_PLATFORM_WIN32_KHR*/
VkPhysicalDeviceExternalSemaphoreInfoKHR PhysicalDeviceExternalSemaphoreInfoKHR(
    VkExternalSemaphoreHandleTypeFlagBitsKHR    handleType)
   {
      VkPhysicalDeviceExternalSemaphoreInfoKHR obj;
      obj.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO_KHR;
      obj.pNext = nullptr;
      obj.handleType = handleType;
      return obj;
   }

VkExternalSemaphorePropertiesKHR ExternalSemaphorePropertiesKHR(
    VkExternalSemaphoreHandleTypeFlagsKHR       exportFromImportedHandleTypes,
    VkExternalSemaphoreHandleTypeFlagsKHR       compatibleHandleTypes,
    VkExternalSemaphoreFeatureFlagsKHR          externalSemaphoreFeatures)
   {
      VkExternalSemaphorePropertiesKHR obj;
      obj.sType = VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES_KHR;
      obj.pNext = nullptr;
      obj.exportFromImportedHandleTypes = exportFromImportedHandleTypes;
      obj.compatibleHandleTypes = compatibleHandleTypes;
      obj.externalSemaphoreFeatures = externalSemaphoreFeatures;
      return obj;
   }

VkExternalSemaphorePropertiesKHR getPhysicalDeviceExternalSemaphorePropertiesKHR(
        VkPhysicalDevice physicalDevice,
        const VkPhysicalDeviceExternalSemaphoreInfoKHR & pExternalSemaphoreInfo)
   {
      if ( nullptr == pfvkGetPhysicalDeviceExternalSemaphorePropertiesKHR )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      VkExternalSemaphorePropertiesKHR pExternalSemaphoreProperties; 
      pfvkGetPhysicalDeviceExternalSemaphorePropertiesKHR(
          physicalDevice,
          &pExternalSemaphoreInfo,
          &pExternalSemaphoreProperties  );
      return pExternalSemaphoreProperties; 
   }

VkExportSemaphoreCreateInfoKHR ExportSemaphoreCreateInfoKHR(
    VkExternalSemaphoreHandleTypeFlagsKHR       handleTypes)
   {
      VkExportSemaphoreCreateInfoKHR obj;
      obj.sType = VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO_KHR;
      obj.pNext = nullptr;
      obj.handleTypes = handleTypes;
      return obj;
   }

#ifdef VK_USE_PLATFORM_WIN32_KHR
VkImportSemaphoreWin32HandleInfoKHR ImportSemaphoreWin32HandleInfoKHR(
    VkSemaphore                                 semaphore,
    VkSemaphoreImportFlagsKHR                   flags,
    VkExternalSemaphoreHandleTypeFlagBitsKHR    handleType,
    HANDLE                                      handle,
    LPCWSTR                                     name)
   {
      VkImportSemaphoreWin32HandleInfoKHR obj;
      obj.sType = VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR;
      obj.pNext = nullptr;
      obj.semaphore = semaphore;
      obj.flags = flags;
      obj.handleType = handleType;
      obj.handle = handle;
      obj.name = name;
      return obj;
   }

struct VkExportSemaphoreWin32HandleInfoKHRRAII {
   VkExportSemaphoreWin32HandleInfoKHR nonRaiiObj;
    std::shared_ptr<SECURITY_ATTRIBUTES>        pAttributes;
};

std::shared_ptr<VkExportSemaphoreWin32HandleInfoKHRRAII> ExportSemaphoreWin32HandleInfoKHR(
    const SECURITY_ATTRIBUTES *                 pAttributes,
    DWORD                                       dwAccess,
    LPCWSTR                                     name)
   {
      std::shared_ptr<VkExportSemaphoreWin32HandleInfoKHRRAII> raii_obj(new VkExportSemaphoreWin32HandleInfoKHRRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.pAttributes = nullptr;
      if ( pAttributes ) 
      { 
          raii_obj->pAttributes.reset( new SECURITY_ATTRIBUTES );
          *raii_obj->pAttributes = *pAttributes;
          raii_obj->nonRaiiObj.pAttributes = raii_obj->pAttributes.get();
      } 
      raii_obj->nonRaiiObj.dwAccess = dwAccess;
      raii_obj->nonRaiiObj.name = name;
      return raii_obj;
   }

struct VkD3D12FenceSubmitInfoKHRRAII {
   VkD3D12FenceSubmitInfoKHR nonRaiiObj;
    std::vector<uint64_t>                       vecWaitSemaphoreValues;
    std::vector<uint64_t>                       vecSignalSemaphoreValues;
};

std::shared_ptr<VkD3D12FenceSubmitInfoKHRRAII> D3D12FenceSubmitInfoKHR(
    const std::vector<uint64_t> &               vecWaitSemaphoreValues,
    const std::vector<uint64_t> &               vecSignalSemaphoreValues)
   {
      std::shared_ptr<VkD3D12FenceSubmitInfoKHRRAII> raii_obj(new VkD3D12FenceSubmitInfoKHRRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_MAX_ENUM;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.waitSemaphoreValuesCount = static_cast<uint32_t>(vecWaitSemaphoreValues.size());
      raii_obj->vecWaitSemaphoreValues = vecWaitSemaphoreValues;
      if ( raii_obj->vecWaitSemaphoreValues.size() > 0)
      {
          raii_obj->nonRaiiObj.pWaitSemaphoreValues = &raii_obj->vecWaitSemaphoreValues[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pWaitSemaphoreValues = nullptr;
      }
      raii_obj->nonRaiiObj.signalSemaphoreValuesCount = static_cast<uint32_t>(vecSignalSemaphoreValues.size());
      raii_obj->vecSignalSemaphoreValues = vecSignalSemaphoreValues;
      if ( raii_obj->vecSignalSemaphoreValues.size() > 0)
      {
          raii_obj->nonRaiiObj.pSignalSemaphoreValues = &raii_obj->vecSignalSemaphoreValues[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pSignalSemaphoreValues = nullptr;
      }
      return raii_obj;
   }

VkSemaphoreGetWin32HandleInfoKHR SemaphoreGetWin32HandleInfoKHR(
    VkSemaphore                                 semaphore,
    VkExternalSemaphoreHandleTypeFlagBitsKHR    handleType)
   {
      VkSemaphoreGetWin32HandleInfoKHR obj;
      obj.sType = VK_STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR;
      obj.pNext = nullptr;
      obj.semaphore = semaphore;
      obj.handleType = handleType;
      return obj;
   }

void  importSemaphoreWin32HandleKHR(
        VkDevice device,
        const VkImportSemaphoreWin32HandleInfoKHR & pImportSemaphoreWin32HandleInfo)
   {
      if ( nullptr == pfvkImportSemaphoreWin32HandleKHR )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      V( pfvkImportSemaphoreWin32HandleKHR(
          device,
          &pImportSemaphoreWin32HandleInfo  ));
   }

HANDLE getSemaphoreWin32HandleKHR(
        VkDevice device,
        const VkSemaphoreGetWin32HandleInfoKHR & pGetWin32HandleInfo)
   {
      if ( nullptr == pfvkGetSemaphoreWin32HandleKHR )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      HANDLE pHandle; 
      V( pfvkGetSemaphoreWin32HandleKHR(
          device,
          &pGetWin32HandleInfo,
          &pHandle  ));
      return pHandle; 
   }

#endif /* VK_USE_PLATFORM_WIN32_KHR*/
VkImportSemaphoreFdInfoKHR ImportSemaphoreFdInfoKHR(
    VkSemaphore                                 semaphore,
    VkSemaphoreImportFlagsKHR                   flags,
    VkExternalSemaphoreHandleTypeFlagBitsKHR    handleType,
    int                                         fd)
   {
      VkImportSemaphoreFdInfoKHR obj;
      obj.sType = VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR;
      obj.pNext = nullptr;
      obj.semaphore = semaphore;
      obj.flags = flags;
      obj.handleType = handleType;
      obj.fd = fd;
      return obj;
   }

VkSemaphoreGetFdInfoKHR SemaphoreGetFdInfoKHR(
    VkSemaphore                                 semaphore,
    VkExternalSemaphoreHandleTypeFlagBitsKHR    handleType)
   {
      VkSemaphoreGetFdInfoKHR obj;
      obj.sType = VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR;
      obj.pNext = nullptr;
      obj.semaphore = semaphore;
      obj.handleType = handleType;
      return obj;
   }

void  importSemaphoreFdKHR(
        VkDevice device,
        const VkImportSemaphoreFdInfoKHR & pImportSemaphoreFdInfo)
   {
      if ( nullptr == pfvkImportSemaphoreFdKHR )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      V( pfvkImportSemaphoreFdKHR(
          device,
          &pImportSemaphoreFdInfo  ));
   }

int getSemaphoreFdKHR(
        VkDevice device,
        const VkSemaphoreGetFdInfoKHR & pGetFdInfo)
   {
      if ( nullptr == pfvkGetSemaphoreFdKHR )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      int pFd; 
      V( pfvkGetSemaphoreFdKHR(
          device,
          &pGetFdInfo,
          &pFd  ));
      return pFd; 
   }

VkPhysicalDevicePushDescriptorPropertiesKHR PhysicalDevicePushDescriptorPropertiesKHR(
    uint32_t                                    maxPushDescriptors)
   {
      VkPhysicalDevicePushDescriptorPropertiesKHR obj;
      obj.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR;
      obj.pNext = nullptr;
      obj.maxPushDescriptors = maxPushDescriptors;
      return obj;
   }

void  cmdPushDescriptorSetKHR(
        VkCommandBuffer commandBuffer,
        VkPipelineBindPoint pipelineBindPoint,
        VkPipelineLayout layout,
        uint32_t set,
        const std::vector<VkWriteDescriptorSet> & pDescriptorWrites)
   {
      if ( nullptr == pfvkCmdPushDescriptorSetKHR )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      pfvkCmdPushDescriptorSetKHR(
          commandBuffer,
          pipelineBindPoint,
          layout,
          set,
          static_cast<uint32_t>(pDescriptorWrites.size()),
          &pDescriptorWrites[0]  );
   }

VkPhysicalDevice16BitStorageFeaturesKHR PhysicalDevice16BitStorageFeaturesKHR(
    VkBool32                                    storageBuffer16BitAccess,
    VkBool32                                    uniformAndStorageBuffer16BitAccess,
    VkBool32                                    storagePushConstant16,
    VkBool32                                    storageInputOutput16)
   {
      VkPhysicalDevice16BitStorageFeaturesKHR obj;
      obj.sType = VK_STRUCTURE_TYPE_MAX_ENUM;
      obj.pNext = nullptr;
      obj.storageBuffer16BitAccess = storageBuffer16BitAccess;
      obj.uniformAndStorageBuffer16BitAccess = uniformAndStorageBuffer16BitAccess;
      obj.storagePushConstant16 = storagePushConstant16;
      obj.storageInputOutput16 = storageInputOutput16;
      return obj;
   }

VkRectLayerKHR RectLayerKHR(
    VkOffset2D                                  offset,
    VkExtent2D                                  extent,
    uint32_t                                    layer)
   {
      VkRectLayerKHR obj;
      obj.offset = offset;
      obj.extent = extent;
      obj.layer = layer;
      return obj;
   }

struct VkPresentRegionKHRRAII {
   VkPresentRegionKHR nonRaiiObj;
    std::vector<VkRectLayerKHR>                 vecRectangles;
};

std::shared_ptr<VkPresentRegionKHRRAII> PresentRegionKHR(
    const std::vector<VkRectLayerKHR> &         vecRectangles)
   {
      std::shared_ptr<VkPresentRegionKHRRAII> raii_obj(new VkPresentRegionKHRRAII);
      raii_obj->nonRaiiObj.rectangleCount = static_cast<uint32_t>(vecRectangles.size());
      raii_obj->vecRectangles = vecRectangles;
      if ( raii_obj->vecRectangles.size() > 0)
      {
          raii_obj->nonRaiiObj.pRectangles = &raii_obj->vecRectangles[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pRectangles = nullptr;
      }
      return raii_obj;
   }

struct VkPresentRegionsKHRRAII {
   VkPresentRegionsKHR nonRaiiObj;
    std::vector<VkPresentRegionKHR>             vecRegions;
};

std::shared_ptr<VkPresentRegionsKHRRAII> PresentRegionsKHR(
    const std::vector<VkPresentRegionKHR> &     vecRegions)
   {
      std::shared_ptr<VkPresentRegionsKHRRAII> raii_obj(new VkPresentRegionsKHRRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.swapchainCount = static_cast<uint32_t>(vecRegions.size());
      raii_obj->vecRegions = vecRegions;
      if ( raii_obj->vecRegions.size() > 0)
      {
          raii_obj->nonRaiiObj.pRegions = &raii_obj->vecRegions[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pRegions = nullptr;
      }
      return raii_obj;
   }

VkDescriptorUpdateTemplateEntryKHR DescriptorUpdateTemplateEntryKHR(
    uint32_t                                    dstBinding,
    uint32_t                                    dstArrayElement,
    uint32_t                                    descriptorCount,
    VkDescriptorType                            descriptorType,
    size_t                                      offset,
    size_t                                      stride)
   {
      VkDescriptorUpdateTemplateEntryKHR obj;
      obj.dstBinding = dstBinding;
      obj.dstArrayElement = dstArrayElement;
      obj.descriptorCount = descriptorCount;
      obj.descriptorType = descriptorType;
      obj.offset = offset;
      obj.stride = stride;
      return obj;
   }

struct VkDescriptorUpdateTemplateCreateInfoKHRRAII {
   VkDescriptorUpdateTemplateCreateInfoKHR nonRaiiObj;
    std::vector<VkDescriptorUpdateTemplateEntryKHR>vecDescriptorUpdateEntries;
};

std::shared_ptr<VkDescriptorUpdateTemplateCreateInfoKHRRAII> DescriptorUpdateTemplateCreateInfoKHR(
    VkDescriptorUpdateTemplateCreateFlagsKHR    flags,
    const std::vector<VkDescriptorUpdateTemplateEntryKHR> &vecDescriptorUpdateEntries,
    VkDescriptorUpdateTemplateTypeKHR           templateType,
    VkDescriptorSetLayout                       descriptorSetLayout,
    VkPipelineBindPoint                         pipelineBindPoint,
    VkPipelineLayout                            pipelineLayout,
    uint32_t                                    set)
   {
      std::shared_ptr<VkDescriptorUpdateTemplateCreateInfoKHRRAII> raii_obj(new VkDescriptorUpdateTemplateCreateInfoKHRRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO_KHR;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.flags = flags;
      raii_obj->nonRaiiObj.descriptorUpdateEntryCount = static_cast<uint32_t>(vecDescriptorUpdateEntries.size());
      raii_obj->vecDescriptorUpdateEntries = vecDescriptorUpdateEntries;
      if ( raii_obj->vecDescriptorUpdateEntries.size() > 0)
      {
          raii_obj->nonRaiiObj.pDescriptorUpdateEntries = &raii_obj->vecDescriptorUpdateEntries[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pDescriptorUpdateEntries = nullptr;
      }
      raii_obj->nonRaiiObj.templateType = templateType;
      raii_obj->nonRaiiObj.descriptorSetLayout = descriptorSetLayout;
      raii_obj->nonRaiiObj.pipelineBindPoint = pipelineBindPoint;
      raii_obj->nonRaiiObj.pipelineLayout = pipelineLayout;
      raii_obj->nonRaiiObj.set = set;
      return raii_obj;
   }

std::shared_ptr<VkDescriptorUpdateTemplateKHR_T> createDescriptorUpdateTemplateKHR(
        VkDevice device,
        const VkDescriptorUpdateTemplateCreateInfoKHR & pCreateInfo)
   {
      if ( nullptr == pfvkCreateDescriptorUpdateTemplateKHR )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      VkDescriptorUpdateTemplateKHR hDescriptorUpdateTemplate; 
      V( pfvkCreateDescriptorUpdateTemplateKHR(
          device,
          &pCreateInfo,
          nullptr,
          &hDescriptorUpdateTemplate  ));
      return std::shared_ptr<VkDescriptorUpdateTemplateKHR_T>(hDescriptorUpdateTemplate, 
              [=](VkDescriptorUpdateTemplateKHR to_free) {pfvkDestroyDescriptorUpdateTemplateKHR(device, to_free, nullptr);});
   }

VkSharedPresentSurfaceCapabilitiesKHR SharedPresentSurfaceCapabilitiesKHR(
    VkImageUsageFlags                           sharedPresentSupportedUsageFlags)
   {
      VkSharedPresentSurfaceCapabilitiesKHR obj;
      obj.sType = VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR;
      obj.pNext = nullptr;
      obj.sharedPresentSupportedUsageFlags = sharedPresentSupportedUsageFlags;
      return obj;
   }

void  getSwapchainStatusKHR(
        VkDevice device,
        VkSwapchainKHR swapchain)
   {
      if ( nullptr == pfvkGetSwapchainStatusKHR )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      V( pfvkGetSwapchainStatusKHR(
          device,
          swapchain  ));
   }

VkPhysicalDeviceExternalFenceInfoKHR PhysicalDeviceExternalFenceInfoKHR(
    VkExternalFenceHandleTypeFlagBitsKHR        handleType)
   {
      VkPhysicalDeviceExternalFenceInfoKHR obj;
      obj.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO_KHR;
      obj.pNext = nullptr;
      obj.handleType = handleType;
      return obj;
   }

VkExternalFencePropertiesKHR ExternalFencePropertiesKHR(
    VkExternalFenceHandleTypeFlagsKHR           exportFromImportedHandleTypes,
    VkExternalFenceHandleTypeFlagsKHR           compatibleHandleTypes,
    VkExternalFenceFeatureFlagsKHR              externalFenceFeatures)
   {
      VkExternalFencePropertiesKHR obj;
      obj.sType = VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES_KHR;
      obj.pNext = nullptr;
      obj.exportFromImportedHandleTypes = exportFromImportedHandleTypes;
      obj.compatibleHandleTypes = compatibleHandleTypes;
      obj.externalFenceFeatures = externalFenceFeatures;
      return obj;
   }

VkExternalFencePropertiesKHR getPhysicalDeviceExternalFencePropertiesKHR(
        VkPhysicalDevice physicalDevice,
        const VkPhysicalDeviceExternalFenceInfoKHR & pExternalFenceInfo)
   {
      if ( nullptr == pfvkGetPhysicalDeviceExternalFencePropertiesKHR )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      VkExternalFencePropertiesKHR pExternalFenceProperties; 
      pfvkGetPhysicalDeviceExternalFencePropertiesKHR(
          physicalDevice,
          &pExternalFenceInfo,
          &pExternalFenceProperties  );
      return pExternalFenceProperties; 
   }

VkExportFenceCreateInfoKHR ExportFenceCreateInfoKHR(
    VkExternalFenceHandleTypeFlagsKHR           handleTypes)
   {
      VkExportFenceCreateInfoKHR obj;
      obj.sType = VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO_KHR;
      obj.pNext = nullptr;
      obj.handleTypes = handleTypes;
      return obj;
   }

#ifdef VK_USE_PLATFORM_WIN32_KHR
VkImportFenceWin32HandleInfoKHR ImportFenceWin32HandleInfoKHR(
    VkFence                                     fence,
    VkFenceImportFlagsKHR                       flags,
    VkExternalFenceHandleTypeFlagBitsKHR        handleType,
    HANDLE                                      handle,
    LPCWSTR                                     name)
   {
      VkImportFenceWin32HandleInfoKHR obj;
      obj.sType = VK_STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR;
      obj.pNext = nullptr;
      obj.fence = fence;
      obj.flags = flags;
      obj.handleType = handleType;
      obj.handle = handle;
      obj.name = name;
      return obj;
   }

struct VkExportFenceWin32HandleInfoKHRRAII {
   VkExportFenceWin32HandleInfoKHR nonRaiiObj;
    std::shared_ptr<SECURITY_ATTRIBUTES>        pAttributes;
};

std::shared_ptr<VkExportFenceWin32HandleInfoKHRRAII> ExportFenceWin32HandleInfoKHR(
    const SECURITY_ATTRIBUTES *                 pAttributes,
    DWORD                                       dwAccess,
    LPCWSTR                                     name)
   {
      std::shared_ptr<VkExportFenceWin32HandleInfoKHRRAII> raii_obj(new VkExportFenceWin32HandleInfoKHRRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.pAttributes = nullptr;
      if ( pAttributes ) 
      { 
          raii_obj->pAttributes.reset( new SECURITY_ATTRIBUTES );
          *raii_obj->pAttributes = *pAttributes;
          raii_obj->nonRaiiObj.pAttributes = raii_obj->pAttributes.get();
      } 
      raii_obj->nonRaiiObj.dwAccess = dwAccess;
      raii_obj->nonRaiiObj.name = name;
      return raii_obj;
   }

VkFenceGetWin32HandleInfoKHR FenceGetWin32HandleInfoKHR(
    VkFence                                     fence,
    VkExternalFenceHandleTypeFlagBitsKHR        handleType)
   {
      VkFenceGetWin32HandleInfoKHR obj;
      obj.sType = VK_STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR;
      obj.pNext = nullptr;
      obj.fence = fence;
      obj.handleType = handleType;
      return obj;
   }

void  importFenceWin32HandleKHR(
        VkDevice device,
        const VkImportFenceWin32HandleInfoKHR & pImportFenceWin32HandleInfo)
   {
      if ( nullptr == pfvkImportFenceWin32HandleKHR )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      V( pfvkImportFenceWin32HandleKHR(
          device,
          &pImportFenceWin32HandleInfo  ));
   }

HANDLE getFenceWin32HandleKHR(
        VkDevice device,
        const VkFenceGetWin32HandleInfoKHR & pGetWin32HandleInfo)
   {
      if ( nullptr == pfvkGetFenceWin32HandleKHR )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      HANDLE pHandle; 
      V( pfvkGetFenceWin32HandleKHR(
          device,
          &pGetWin32HandleInfo,
          &pHandle  ));
      return pHandle; 
   }

#endif /* VK_USE_PLATFORM_WIN32_KHR*/
VkImportFenceFdInfoKHR ImportFenceFdInfoKHR(
    VkFence                                     fence,
    VkFenceImportFlagsKHR                       flags,
    VkExternalFenceHandleTypeFlagBitsKHR        handleType,
    int                                         fd)
   {
      VkImportFenceFdInfoKHR obj;
      obj.sType = VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR;
      obj.pNext = nullptr;
      obj.fence = fence;
      obj.flags = flags;
      obj.handleType = handleType;
      obj.fd = fd;
      return obj;
   }

VkFenceGetFdInfoKHR FenceGetFdInfoKHR(
    VkFence                                     fence,
    VkExternalFenceHandleTypeFlagBitsKHR        handleType)
   {
      VkFenceGetFdInfoKHR obj;
      obj.sType = VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR;
      obj.pNext = nullptr;
      obj.fence = fence;
      obj.handleType = handleType;
      return obj;
   }

void  importFenceFdKHR(
        VkDevice device,
        const VkImportFenceFdInfoKHR & pImportFenceFdInfo)
   {
      if ( nullptr == pfvkImportFenceFdKHR )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      V( pfvkImportFenceFdKHR(
          device,
          &pImportFenceFdInfo  ));
   }

int getFenceFdKHR(
        VkDevice device,
        const VkFenceGetFdInfoKHR & pGetFdInfo)
   {
      if ( nullptr == pfvkGetFenceFdKHR )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      int pFd; 
      V( pfvkGetFenceFdKHR(
          device,
          &pGetFdInfo,
          &pFd  ));
      return pFd; 
   }

VkPhysicalDevicePointClippingPropertiesKHR PhysicalDevicePointClippingPropertiesKHR(
    VkPointClippingBehaviorKHR                  pointClippingBehavior)
   {
      VkPhysicalDevicePointClippingPropertiesKHR obj;
      obj.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES_KHR;
      obj.pNext = nullptr;
      obj.pointClippingBehavior = pointClippingBehavior;
      return obj;
   }

VkInputAttachmentAspectReferenceKHR InputAttachmentAspectReferenceKHR(
    uint32_t                                    subpass,
    uint32_t                                    inputAttachmentIndex,
    VkImageAspectFlags                          aspectMask)
   {
      VkInputAttachmentAspectReferenceKHR obj;
      obj.subpass = subpass;
      obj.inputAttachmentIndex = inputAttachmentIndex;
      obj.aspectMask = aspectMask;
      return obj;
   }

struct VkRenderPassInputAttachmentAspectCreateInfoKHRRAII {
   VkRenderPassInputAttachmentAspectCreateInfoKHR nonRaiiObj;
    std::vector<VkInputAttachmentAspectReferenceKHR>vecAspectReferences;
};

std::shared_ptr<VkRenderPassInputAttachmentAspectCreateInfoKHRRAII> RenderPassInputAttachmentAspectCreateInfoKHR(
    const std::vector<VkInputAttachmentAspectReferenceKHR> &vecAspectReferences)
   {
      std::shared_ptr<VkRenderPassInputAttachmentAspectCreateInfoKHRRAII> raii_obj(new VkRenderPassInputAttachmentAspectCreateInfoKHRRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO_KHR;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.aspectReferenceCount = static_cast<uint32_t>(vecAspectReferences.size());
      raii_obj->vecAspectReferences = vecAspectReferences;
      if ( raii_obj->vecAspectReferences.size() > 0)
      {
          raii_obj->nonRaiiObj.pAspectReferences = &raii_obj->vecAspectReferences[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pAspectReferences = nullptr;
      }
      return raii_obj;
   }

VkImageViewUsageCreateInfoKHR ImageViewUsageCreateInfoKHR(
    VkImageUsageFlags                           usage)
   {
      VkImageViewUsageCreateInfoKHR obj;
      obj.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO_KHR;
      obj.pNext = nullptr;
      obj.usage = usage;
      return obj;
   }

VkPipelineTessellationDomainOriginStateCreateInfoKHR PipelineTessellationDomainOriginStateCreateInfoKHR(
    VkTessellationDomainOriginKHR               domainOrigin)
   {
      VkPipelineTessellationDomainOriginStateCreateInfoKHR obj;
      obj.sType = VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO_KHR;
      obj.pNext = nullptr;
      obj.domainOrigin = domainOrigin;
      return obj;
   }

VkPhysicalDeviceSurfaceInfo2KHR PhysicalDeviceSurfaceInfo2KHR(
    VkSurfaceKHR                                surface)
   {
      VkPhysicalDeviceSurfaceInfo2KHR obj;
      obj.sType = VK_STRUCTURE_TYPE_MAX_ENUM;
      obj.pNext = nullptr;
      obj.surface = surface;
      return obj;
   }

VkSurfaceCapabilities2KHR SurfaceCapabilities2KHR(
    VkSurfaceCapabilitiesKHR                    surfaceCapabilities)
   {
      VkSurfaceCapabilities2KHR obj;
      obj.sType = VK_STRUCTURE_TYPE_MAX_ENUM;
      obj.pNext = nullptr;
      obj.surfaceCapabilities = surfaceCapabilities;
      return obj;
   }

VkSurfaceFormat2KHR SurfaceFormat2KHR(
    VkSurfaceFormatKHR                          surfaceFormat)
   {
      VkSurfaceFormat2KHR obj;
      obj.sType = VK_STRUCTURE_TYPE_MAX_ENUM;
      obj.pNext = nullptr;
      obj.surfaceFormat = surfaceFormat;
      return obj;
   }

VkSurfaceCapabilities2KHR getPhysicalDeviceSurfaceCapabilities2KHR(
        VkPhysicalDevice physicalDevice,
        const VkPhysicalDeviceSurfaceInfo2KHR & pSurfaceInfo)
   {
      if ( nullptr == pfvkGetPhysicalDeviceSurfaceCapabilities2KHR )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      VkSurfaceCapabilities2KHR pSurfaceCapabilities; 
      V( pfvkGetPhysicalDeviceSurfaceCapabilities2KHR(
          physicalDevice,
          &pSurfaceInfo,
          &pSurfaceCapabilities  ));
      return pSurfaceCapabilities; 
   }

std::vector< VkSurfaceFormat2KHR > getPhysicalDeviceSurfaceFormats2KHR(
        VkPhysicalDevice physicalDevice,
        const VkPhysicalDeviceSurfaceInfo2KHR & pSurfaceInfo)
   {
      if ( nullptr == pfvkGetPhysicalDeviceSurfaceFormats2KHR )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      std::vector<VkSurfaceFormat2KHR> vecpSurfaceFormats; 
      uint32_t pSurfaceFormatsCount; 
      V( pfvkGetPhysicalDeviceSurfaceFormats2KHR(
          physicalDevice,
          &pSurfaceInfo,
          &pSurfaceFormatsCount,
          nullptr  ));

      vecpSurfaceFormats.resize(pSurfaceFormatsCount); 

      V( pfvkGetPhysicalDeviceSurfaceFormats2KHR(
          physicalDevice,
          &pSurfaceInfo,
          &pSurfaceFormatsCount,
          &vecpSurfaceFormats[0]  ));
      return vecpSurfaceFormats; 
   }

VkPhysicalDeviceVariablePointerFeaturesKHR PhysicalDeviceVariablePointerFeaturesKHR(
    VkBool32                                    variablePointersStorageBuffer,
    VkBool32                                    variablePointers)
   {
      VkPhysicalDeviceVariablePointerFeaturesKHR obj;
      obj.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES_KHR;
      obj.pNext = nullptr;
      obj.variablePointersStorageBuffer = variablePointersStorageBuffer;
      obj.variablePointers = variablePointers;
      return obj;
   }

VkMemoryDedicatedRequirementsKHR MemoryDedicatedRequirementsKHR(
    VkBool32                                    prefersDedicatedAllocation,
    VkBool32                                    requiresDedicatedAllocation)
   {
      VkMemoryDedicatedRequirementsKHR obj;
      obj.sType = VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS_KHR;
      obj.pNext = nullptr;
      obj.prefersDedicatedAllocation = prefersDedicatedAllocation;
      obj.requiresDedicatedAllocation = requiresDedicatedAllocation;
      return obj;
   }

VkMemoryDedicatedAllocateInfoKHR MemoryDedicatedAllocateInfoKHR(
    VkImage                                     image,
    VkBuffer                                    buffer)
   {
      VkMemoryDedicatedAllocateInfoKHR obj;
      obj.sType = VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO_KHR;
      obj.pNext = nullptr;
      obj.image = image;
      obj.buffer = buffer;
      return obj;
   }

VkBufferMemoryRequirementsInfo2KHR BufferMemoryRequirementsInfo2KHR(
    VkBuffer                                    buffer)
   {
      VkBufferMemoryRequirementsInfo2KHR obj;
      obj.sType = VK_STRUCTURE_TYPE_MAX_ENUM;
      obj.pNext = nullptr;
      obj.buffer = buffer;
      return obj;
   }

VkImageMemoryRequirementsInfo2KHR ImageMemoryRequirementsInfo2KHR(
    VkImage                                     image)
   {
      VkImageMemoryRequirementsInfo2KHR obj;
      obj.sType = VK_STRUCTURE_TYPE_MAX_ENUM;
      obj.pNext = nullptr;
      obj.image = image;
      return obj;
   }

VkImageSparseMemoryRequirementsInfo2KHR ImageSparseMemoryRequirementsInfo2KHR(
    VkImage                                     image)
   {
      VkImageSparseMemoryRequirementsInfo2KHR obj;
      obj.sType = VK_STRUCTURE_TYPE_MAX_ENUM;
      obj.pNext = nullptr;
      obj.image = image;
      return obj;
   }

VkMemoryRequirements2KHR MemoryRequirements2KHR(
    VkMemoryRequirements                        memoryRequirements)
   {
      VkMemoryRequirements2KHR obj;
      obj.sType = VK_STRUCTURE_TYPE_MAX_ENUM;
      obj.pNext = nullptr;
      obj.memoryRequirements = memoryRequirements;
      return obj;
   }

VkSparseImageMemoryRequirements2KHR SparseImageMemoryRequirements2KHR(
    VkSparseImageMemoryRequirements             memoryRequirements)
   {
      VkSparseImageMemoryRequirements2KHR obj;
      obj.sType = VK_STRUCTURE_TYPE_MAX_ENUM;
      obj.pNext = nullptr;
      obj.memoryRequirements = memoryRequirements;
      return obj;
   }

VkMemoryRequirements2KHR getImageMemoryRequirements2KHR(
        VkDevice device,
        const VkImageMemoryRequirementsInfo2KHR & pInfo)
   {
      if ( nullptr == pfvkGetImageMemoryRequirements2KHR )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      VkMemoryRequirements2KHR pMemoryRequirements; 
      pfvkGetImageMemoryRequirements2KHR(
          device,
          &pInfo,
          &pMemoryRequirements  );
      return pMemoryRequirements; 
   }

VkMemoryRequirements2KHR getBufferMemoryRequirements2KHR(
        VkDevice device,
        const VkBufferMemoryRequirementsInfo2KHR & pInfo)
   {
      if ( nullptr == pfvkGetBufferMemoryRequirements2KHR )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      VkMemoryRequirements2KHR pMemoryRequirements; 
      pfvkGetBufferMemoryRequirements2KHR(
          device,
          &pInfo,
          &pMemoryRequirements  );
      return pMemoryRequirements; 
   }

std::vector< VkSparseImageMemoryRequirements2KHR > getImageSparseMemoryRequirements2KHR(
        VkDevice device,
        const VkImageSparseMemoryRequirementsInfo2KHR & pInfo)
   {
      if ( nullptr == pfvkGetImageSparseMemoryRequirements2KHR )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      std::vector<VkSparseImageMemoryRequirements2KHR> vecpSparseMemoryRequirements; 
      uint32_t pSparseMemoryRequirementsCount; 
      pfvkGetImageSparseMemoryRequirements2KHR(
          device,
          &pInfo,
          &pSparseMemoryRequirementsCount,
          nullptr  );

      vecpSparseMemoryRequirements.resize(pSparseMemoryRequirementsCount); 

      pfvkGetImageSparseMemoryRequirements2KHR(
          device,
          &pInfo,
          &pSparseMemoryRequirementsCount,
          &vecpSparseMemoryRequirements[0]  );
      return vecpSparseMemoryRequirements; 
   }

struct VkImageFormatListCreateInfoKHRRAII {
   VkImageFormatListCreateInfoKHR nonRaiiObj;
    std::vector<VkFormat>                       vecViewFormats;
};

std::shared_ptr<VkImageFormatListCreateInfoKHRRAII> ImageFormatListCreateInfoKHR(
    const std::vector<VkFormat> &               vecViewFormats)
   {
      std::shared_ptr<VkImageFormatListCreateInfoKHRRAII> raii_obj(new VkImageFormatListCreateInfoKHRRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO_KHR;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.viewFormatCount = static_cast<uint32_t>(vecViewFormats.size());
      raii_obj->vecViewFormats = vecViewFormats;
      if ( raii_obj->vecViewFormats.size() > 0)
      {
          raii_obj->nonRaiiObj.pViewFormats = &raii_obj->vecViewFormats[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pViewFormats = nullptr;
      }
      return raii_obj;
   }

VkSamplerYcbcrConversionCreateInfoKHR SamplerYcbcrConversionCreateInfoKHR(
    VkFormat                                    format,
    VkSamplerYcbcrModelConversionKHR            ycbcrModel,
    VkSamplerYcbcrRangeKHR                      ycbcrRange,
    VkComponentMapping                          components,
    VkChromaLocationKHR                         xChromaOffset,
    VkChromaLocationKHR                         yChromaOffset,
    VkFilter                                    chromaFilter,
    VkBool32                                    forceExplicitReconstruction)
   {
      VkSamplerYcbcrConversionCreateInfoKHR obj;
      obj.sType = VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO_KHR;
      obj.pNext = nullptr;
      obj.format = format;
      obj.ycbcrModel = ycbcrModel;
      obj.ycbcrRange = ycbcrRange;
      obj.components = components;
      obj.xChromaOffset = xChromaOffset;
      obj.yChromaOffset = yChromaOffset;
      obj.chromaFilter = chromaFilter;
      obj.forceExplicitReconstruction = forceExplicitReconstruction;
      return obj;
   }

VkSamplerYcbcrConversionInfoKHR SamplerYcbcrConversionInfoKHR(
    VkSamplerYcbcrConversionKHR                 conversion)
   {
      VkSamplerYcbcrConversionInfoKHR obj;
      obj.sType = VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO_KHR;
      obj.pNext = nullptr;
      obj.conversion = conversion;
      return obj;
   }

VkBindImagePlaneMemoryInfoKHR BindImagePlaneMemoryInfoKHR(
    VkImageAspectFlagBits                       planeAspect)
   {
      VkBindImagePlaneMemoryInfoKHR obj;
      obj.sType = VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO_KHR;
      obj.pNext = nullptr;
      obj.planeAspect = planeAspect;
      return obj;
   }

VkImagePlaneMemoryRequirementsInfoKHR ImagePlaneMemoryRequirementsInfoKHR(
    VkImageAspectFlagBits                       planeAspect)
   {
      VkImagePlaneMemoryRequirementsInfoKHR obj;
      obj.sType = VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO_KHR;
      obj.pNext = nullptr;
      obj.planeAspect = planeAspect;
      return obj;
   }

VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR PhysicalDeviceSamplerYcbcrConversionFeaturesKHR(
    VkBool32                                    samplerYcbcrConversion)
   {
      VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR obj;
      obj.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES_KHR;
      obj.pNext = nullptr;
      obj.samplerYcbcrConversion = samplerYcbcrConversion;
      return obj;
   }

VkSamplerYcbcrConversionImageFormatPropertiesKHR SamplerYcbcrConversionImageFormatPropertiesKHR(
    uint32_t                                    combinedImageSamplerDescriptorCount)
   {
      VkSamplerYcbcrConversionImageFormatPropertiesKHR obj;
      obj.sType = VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES_KHR;
      obj.pNext = nullptr;
      obj.combinedImageSamplerDescriptorCount = combinedImageSamplerDescriptorCount;
      return obj;
   }

std::shared_ptr<VkSamplerYcbcrConversionKHR_T> createSamplerYcbcrConversionKHR(
        VkDevice device,
        const VkSamplerYcbcrConversionCreateInfoKHR & pCreateInfo)
   {
      if ( nullptr == pfvkCreateSamplerYcbcrConversionKHR )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      VkSamplerYcbcrConversionKHR hYcbcrConversion; 
      V( pfvkCreateSamplerYcbcrConversionKHR(
          device,
          &pCreateInfo,
          nullptr,
          &hYcbcrConversion  ));
      return std::shared_ptr<VkSamplerYcbcrConversionKHR_T>(hYcbcrConversion, 
              [=](VkSamplerYcbcrConversionKHR to_free) {pfvkDestroySamplerYcbcrConversionKHR(device, to_free, nullptr);});
   }

VkBindBufferMemoryInfoKHR BindBufferMemoryInfoKHR(
    VkBuffer                                    buffer,
    VkDeviceMemory                              memory,
    VkDeviceSize                                memoryOffset)
   {
      VkBindBufferMemoryInfoKHR obj;
      obj.sType = VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO_KHR;
      obj.pNext = nullptr;
      obj.buffer = buffer;
      obj.memory = memory;
      obj.memoryOffset = memoryOffset;
      return obj;
   }

VkBindImageMemoryInfoKHR BindImageMemoryInfoKHR(
    VkImage                                     image,
    VkDeviceMemory                              memory,
    VkDeviceSize                                memoryOffset)
   {
      VkBindImageMemoryInfoKHR obj;
      obj.sType = VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO_KHR;
      obj.pNext = nullptr;
      obj.image = image;
      obj.memory = memory;
      obj.memoryOffset = memoryOffset;
      return obj;
   }

void  bindBufferMemory2KHR(
        VkDevice device,
        const std::vector<VkBindBufferMemoryInfoKHR> & pBindInfos)
   {
      if ( nullptr == pfvkBindBufferMemory2KHR )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      V( pfvkBindBufferMemory2KHR(
          device,
          static_cast<uint32_t>(pBindInfos.size()),
          &pBindInfos[0]  ));
   }

void  bindImageMemory2KHR(
        VkDevice device,
        const std::vector<VkBindImageMemoryInfoKHR> & pBindInfos)
   {
      if ( nullptr == pfvkBindImageMemory2KHR )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      V( pfvkBindImageMemory2KHR(
          device,
          static_cast<uint32_t>(pBindInfos.size()),
          &pBindInfos[0]  ));
   }

VkDebugReportCallbackCreateInfoEXT DebugReportCallbackCreateInfoEXT(
    VkDebugReportFlagsEXT                       flags,
    PFN_vkDebugReportCallbackEXT                pfnCallback)
   {
      VkDebugReportCallbackCreateInfoEXT obj;
      obj.sType = VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT;
      obj.pNext = nullptr;
      obj.flags = flags;
      obj.pfnCallback = pfnCallback;
      obj.pUserData = nullptr;
      return obj;
   }

std::shared_ptr<VkDebugReportCallbackEXT_T> createDebugReportCallbackEXT(
        VkInstance instance,
        const VkDebugReportCallbackCreateInfoEXT & pCreateInfo)
   {
      if ( nullptr == pfvkCreateDebugReportCallbackEXT )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      VkDebugReportCallbackEXT hCallback; 
      V( pfvkCreateDebugReportCallbackEXT(
          instance,
          &pCreateInfo,
          nullptr,
          &hCallback  ));
      return std::shared_ptr<VkDebugReportCallbackEXT_T>(hCallback, 
              [=](VkDebugReportCallbackEXT to_free) {pfvkDestroyDebugReportCallbackEXT(instance, to_free, nullptr);});
   }

void  debugReportMessageEXT(
        VkInstance instance,
        VkDebugReportFlagsEXT flags,
        VkDebugReportObjectTypeEXT objectType,
        uint64_t object,
        size_t location,
        int32_t messageCode,
        const char* pLayerPrefix,
        const char* pMessage)
   {
      if ( nullptr == pfvkDebugReportMessageEXT )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      pfvkDebugReportMessageEXT(
          instance,
          flags,
          objectType,
          object,
          location,
          messageCode,
          pLayerPrefix,
          pMessage  );
   }

VkPipelineRasterizationStateRasterizationOrderAMD PipelineRasterizationStateRasterizationOrderAMD(
    VkRasterizationOrderAMD                     rasterizationOrder)
   {
      VkPipelineRasterizationStateRasterizationOrderAMD obj;
      obj.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD;
      obj.pNext = nullptr;
      obj.rasterizationOrder = rasterizationOrder;
      return obj;
   }

struct VkDebugMarkerObjectNameInfoEXTRAII {
   VkDebugMarkerObjectNameInfoEXT nonRaiiObj;
    std::string                                 strObjectName;
};

std::shared_ptr<VkDebugMarkerObjectNameInfoEXTRAII> DebugMarkerObjectNameInfoEXT(
    VkDebugReportObjectTypeEXT                  objectType,
    uint64_t                                    object,
    const std::string &                         strObjectName)
   {
      std::shared_ptr<VkDebugMarkerObjectNameInfoEXTRAII> raii_obj(new VkDebugMarkerObjectNameInfoEXTRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.objectType = objectType;
      raii_obj->nonRaiiObj.object = object;
      raii_obj->strObjectName = strObjectName;
      raii_obj->nonRaiiObj.pObjectName = &raii_obj->strObjectName[0];
      return raii_obj;
   }

struct VkDebugMarkerObjectTagInfoEXTRAII {
   VkDebugMarkerObjectTagInfoEXT nonRaiiObj;
    std::vector<uint8_t>                        vecTag;
};

std::shared_ptr<VkDebugMarkerObjectTagInfoEXTRAII> DebugMarkerObjectTagInfoEXT(
    VkDebugReportObjectTypeEXT                  objectType,
    uint64_t                                    object,
    uint64_t                                    tagName,
    const std::vector<uint8_t> &                vecTag)
   {
      std::shared_ptr<VkDebugMarkerObjectTagInfoEXTRAII> raii_obj(new VkDebugMarkerObjectTagInfoEXTRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.objectType = objectType;
      raii_obj->nonRaiiObj.object = object;
      raii_obj->nonRaiiObj.tagName = tagName;
      raii_obj->nonRaiiObj.tagSize = static_cast<size_t>(vecTag.size());
      raii_obj->vecTag = vecTag;
      if ( raii_obj->vecTag.size() > 0)
      {
          raii_obj->nonRaiiObj.pTag = &raii_obj->vecTag[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pTag = nullptr;
      }
      return raii_obj;
   }

struct VkDebugMarkerMarkerInfoEXTRAII {
   VkDebugMarkerMarkerInfoEXT nonRaiiObj;
    std::string                                 strMarkerName;
};

std::shared_ptr<VkDebugMarkerMarkerInfoEXTRAII> DebugMarkerMarkerInfoEXT(
    const std::string &                         strMarkerName,
    float                                       color[4])
   {
      std::shared_ptr<VkDebugMarkerMarkerInfoEXTRAII> raii_obj(new VkDebugMarkerMarkerInfoEXTRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->strMarkerName = strMarkerName;
      raii_obj->nonRaiiObj.pMarkerName = &raii_obj->strMarkerName[0];
      std::copy(color, color + 4, raii_obj->nonRaiiObj.color);
      return raii_obj;
   }

void  debugMarkerSetObjectTagEXT(
        VkDevice device,
        const VkDebugMarkerObjectTagInfoEXT & pTagInfo)
   {
      if ( nullptr == pfvkDebugMarkerSetObjectTagEXT )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      V( pfvkDebugMarkerSetObjectTagEXT(
          device,
          &pTagInfo  ));
   }

void  debugMarkerSetObjectNameEXT(
        VkDevice device,
        const VkDebugMarkerObjectNameInfoEXT & pNameInfo)
   {
      if ( nullptr == pfvkDebugMarkerSetObjectNameEXT )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      V( pfvkDebugMarkerSetObjectNameEXT(
          device,
          &pNameInfo  ));
   }

void  cmdDebugMarkerBeginEXT(
        VkCommandBuffer commandBuffer,
        const VkDebugMarkerMarkerInfoEXT & pMarkerInfo)
   {
      if ( nullptr == pfvkCmdDebugMarkerBeginEXT )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      pfvkCmdDebugMarkerBeginEXT(
          commandBuffer,
          &pMarkerInfo  );
   }

void  cmdDebugMarkerEndEXT(
        VkCommandBuffer commandBuffer)
   {
      if ( nullptr == pfvkCmdDebugMarkerEndEXT )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      pfvkCmdDebugMarkerEndEXT(
          commandBuffer  );
   }

void  cmdDebugMarkerInsertEXT(
        VkCommandBuffer commandBuffer,
        const VkDebugMarkerMarkerInfoEXT & pMarkerInfo)
   {
      if ( nullptr == pfvkCmdDebugMarkerInsertEXT )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      pfvkCmdDebugMarkerInsertEXT(
          commandBuffer,
          &pMarkerInfo  );
   }

VkDedicatedAllocationImageCreateInfoNV DedicatedAllocationImageCreateInfoNV(
    VkBool32                                    dedicatedAllocation)
   {
      VkDedicatedAllocationImageCreateInfoNV obj;
      obj.sType = VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV;
      obj.pNext = nullptr;
      obj.dedicatedAllocation = dedicatedAllocation;
      return obj;
   }

VkDedicatedAllocationBufferCreateInfoNV DedicatedAllocationBufferCreateInfoNV(
    VkBool32                                    dedicatedAllocation)
   {
      VkDedicatedAllocationBufferCreateInfoNV obj;
      obj.sType = VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV;
      obj.pNext = nullptr;
      obj.dedicatedAllocation = dedicatedAllocation;
      return obj;
   }

VkDedicatedAllocationMemoryAllocateInfoNV DedicatedAllocationMemoryAllocateInfoNV(
    VkImage                                     image,
    VkBuffer                                    buffer)
   {
      VkDedicatedAllocationMemoryAllocateInfoNV obj;
      obj.sType = VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV;
      obj.pNext = nullptr;
      obj.image = image;
      obj.buffer = buffer;
      return obj;
   }

void  cmdDrawIndirectCountAMD(
        VkCommandBuffer commandBuffer,
        VkBuffer buffer,
        VkDeviceSize offset,
        VkBuffer countBuffer,
        VkDeviceSize countBufferOffset,
        uint32_t maxDrawCount,
        uint32_t stride)
   {
      if ( nullptr == pfvkCmdDrawIndirectCountAMD )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      pfvkCmdDrawIndirectCountAMD(
          commandBuffer,
          buffer,
          offset,
          countBuffer,
          countBufferOffset,
          maxDrawCount,
          stride  );
   }

void  cmdDrawIndexedIndirectCountAMD(
        VkCommandBuffer commandBuffer,
        VkBuffer buffer,
        VkDeviceSize offset,
        VkBuffer countBuffer,
        VkDeviceSize countBufferOffset,
        uint32_t maxDrawCount,
        uint32_t stride)
   {
      if ( nullptr == pfvkCmdDrawIndexedIndirectCountAMD )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      pfvkCmdDrawIndexedIndirectCountAMD(
          commandBuffer,
          buffer,
          offset,
          countBuffer,
          countBufferOffset,
          maxDrawCount,
          stride  );
   }

VkTextureLODGatherFormatPropertiesAMD TextureLODGatherFormatPropertiesAMD(
    VkBool32                                    supportsTextureGatherLODBiasAMD)
   {
      VkTextureLODGatherFormatPropertiesAMD obj;
      obj.sType = VK_STRUCTURE_TYPE_MAX_ENUM;
      obj.pNext = nullptr;
      obj.supportsTextureGatherLODBiasAMD = supportsTextureGatherLODBiasAMD;
      return obj;
   }

VkShaderResourceUsageAMD ShaderResourceUsageAMD(
    uint32_t                                    numUsedVgprs,
    uint32_t                                    numUsedSgprs,
    uint32_t                                    ldsSizePerLocalWorkGroup,
    size_t                                      ldsUsageSizeInBytes,
    size_t                                      scratchMemUsageInBytes)
   {
      VkShaderResourceUsageAMD obj;
      obj.numUsedVgprs = numUsedVgprs;
      obj.numUsedSgprs = numUsedSgprs;
      obj.ldsSizePerLocalWorkGroup = ldsSizePerLocalWorkGroup;
      obj.ldsUsageSizeInBytes = ldsUsageSizeInBytes;
      obj.scratchMemUsageInBytes = scratchMemUsageInBytes;
      return obj;
   }

VkShaderStatisticsInfoAMD ShaderStatisticsInfoAMD(
    VkShaderStageFlags                          shaderStageMask,
    VkShaderResourceUsageAMD                    resourceUsage,
    uint32_t                                    numPhysicalVgprs,
    uint32_t                                    numPhysicalSgprs,
    uint32_t                                    numAvailableVgprs,
    uint32_t                                    numAvailableSgprs,
    uint32_t                                    computeWorkGroupSize[3])
   {
      VkShaderStatisticsInfoAMD obj;
      obj.shaderStageMask = shaderStageMask;
      obj.resourceUsage = resourceUsage;
      obj.numPhysicalVgprs = numPhysicalVgprs;
      obj.numPhysicalSgprs = numPhysicalSgprs;
      obj.numAvailableVgprs = numAvailableVgprs;
      obj.numAvailableSgprs = numAvailableSgprs;
      std::copy(computeWorkGroupSize, computeWorkGroupSize + 3, obj.computeWorkGroupSize);
      return obj;
   }

size_t getShaderInfoAMD(
        VkDevice device,
        VkPipeline pipeline,
        VkShaderStageFlagBits shaderStage,
        VkShaderInfoTypeAMD infoType)
   {
      if ( nullptr == pfvkGetShaderInfoAMD )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      size_t pInfoSize; 
      V( pfvkGetShaderInfoAMD(
          device,
          pipeline,
          shaderStage,
          infoType,
          &pInfoSize,
          nullptr  ));
      return pInfoSize; 
   }

struct VkRenderPassMultiviewCreateInfoKHXRAII {
   VkRenderPassMultiviewCreateInfoKHX nonRaiiObj;
    std::vector<uint32_t>                       vecViewMasks;
    std::vector<int32_t>                        vecViewOffsets;
    std::vector<uint32_t>                       vecCorrelationMasks;
};

std::shared_ptr<VkRenderPassMultiviewCreateInfoKHXRAII> RenderPassMultiviewCreateInfoKHX(
    unsigned int* pViewMasks_in_array1, int pViewMasks_dim1,
    int* pViewOffsets_in_array1, int pViewOffsets_dim1,
    unsigned int* pCorrelationMasks_in_array1, int pCorrelationMasks_dim1)
   {
      std::shared_ptr<VkRenderPassMultiviewCreateInfoKHXRAII> raii_obj(new VkRenderPassMultiviewCreateInfoKHXRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO_KHX;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.subpassCount = static_cast<uint32_t>(pViewMasks_dim1);
      raii_obj->vecViewMasks.assign(pViewMasks_in_array1, pViewMasks_in_array1 + pViewMasks_dim1);
      if ( raii_obj->vecViewMasks.size() > 0)
      {
          raii_obj->nonRaiiObj.pViewMasks = &raii_obj->vecViewMasks[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pViewMasks = nullptr;
      }
      raii_obj->nonRaiiObj.dependencyCount = static_cast<uint32_t>(pViewOffsets_dim1);
      raii_obj->vecViewOffsets.assign(pViewOffsets_in_array1, pViewOffsets_in_array1 + pViewOffsets_dim1);
      if ( raii_obj->vecViewOffsets.size() > 0)
      {
          raii_obj->nonRaiiObj.pViewOffsets = &raii_obj->vecViewOffsets[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pViewOffsets = nullptr;
      }
      raii_obj->nonRaiiObj.correlationMaskCount = static_cast<uint32_t>(pCorrelationMasks_dim1);
      raii_obj->vecCorrelationMasks.assign(pCorrelationMasks_in_array1, pCorrelationMasks_in_array1 + pCorrelationMasks_dim1);
      if ( raii_obj->vecCorrelationMasks.size() > 0)
      {
          raii_obj->nonRaiiObj.pCorrelationMasks = &raii_obj->vecCorrelationMasks[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pCorrelationMasks = nullptr;
      }
      return raii_obj;
   }

VkPhysicalDeviceMultiviewFeaturesKHX PhysicalDeviceMultiviewFeaturesKHX(
    VkBool32                                    multiview,
    VkBool32                                    multiviewGeometryShader,
    VkBool32                                    multiviewTessellationShader)
   {
      VkPhysicalDeviceMultiviewFeaturesKHX obj;
      obj.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES_KHX;
      obj.pNext = nullptr;
      obj.multiview = multiview;
      obj.multiviewGeometryShader = multiviewGeometryShader;
      obj.multiviewTessellationShader = multiviewTessellationShader;
      return obj;
   }

VkPhysicalDeviceMultiviewPropertiesKHX PhysicalDeviceMultiviewPropertiesKHX(
    uint32_t                                    maxMultiviewViewCount,
    uint32_t                                    maxMultiviewInstanceIndex)
   {
      VkPhysicalDeviceMultiviewPropertiesKHX obj;
      obj.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES_KHX;
      obj.pNext = nullptr;
      obj.maxMultiviewViewCount = maxMultiviewViewCount;
      obj.maxMultiviewInstanceIndex = maxMultiviewInstanceIndex;
      return obj;
   }

VkExternalImageFormatPropertiesNV ExternalImageFormatPropertiesNV(
    VkImageFormatProperties                     imageFormatProperties,
    VkExternalMemoryFeatureFlagsNV              externalMemoryFeatures,
    VkExternalMemoryHandleTypeFlagsNV           exportFromImportedHandleTypes,
    VkExternalMemoryHandleTypeFlagsNV           compatibleHandleTypes)
   {
      VkExternalImageFormatPropertiesNV obj;
      obj.imageFormatProperties = imageFormatProperties;
      obj.externalMemoryFeatures = externalMemoryFeatures;
      obj.exportFromImportedHandleTypes = exportFromImportedHandleTypes;
      obj.compatibleHandleTypes = compatibleHandleTypes;
      return obj;
   }

VkExternalImageFormatPropertiesNV getPhysicalDeviceExternalImageFormatPropertiesNV(
        VkPhysicalDevice physicalDevice,
        VkFormat format,
        VkImageType type,
        VkImageTiling tiling,
        VkImageUsageFlags usage,
        VkImageCreateFlags flags,
        VkExternalMemoryHandleTypeFlagsNV externalHandleType)
   {
      if ( nullptr == pfvkGetPhysicalDeviceExternalImageFormatPropertiesNV )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      VkExternalImageFormatPropertiesNV pExternalImageFormatProperties; 
      V( pfvkGetPhysicalDeviceExternalImageFormatPropertiesNV(
          physicalDevice,
          format,
          type,
          tiling,
          usage,
          flags,
          externalHandleType,
          &pExternalImageFormatProperties  ));
      return pExternalImageFormatProperties; 
   }

VkExternalMemoryImageCreateInfoNV ExternalMemoryImageCreateInfoNV(
    VkExternalMemoryHandleTypeFlagsNV           handleTypes)
   {
      VkExternalMemoryImageCreateInfoNV obj;
      obj.sType = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV;
      obj.pNext = nullptr;
      obj.handleTypes = handleTypes;
      return obj;
   }

VkExportMemoryAllocateInfoNV ExportMemoryAllocateInfoNV(
    VkExternalMemoryHandleTypeFlagsNV           handleTypes)
   {
      VkExportMemoryAllocateInfoNV obj;
      obj.sType = VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV;
      obj.pNext = nullptr;
      obj.handleTypes = handleTypes;
      return obj;
   }

#ifdef VK_USE_PLATFORM_WIN32_KHR
VkImportMemoryWin32HandleInfoNV ImportMemoryWin32HandleInfoNV(
    VkExternalMemoryHandleTypeFlagsNV           handleType,
    HANDLE                                      handle)
   {
      VkImportMemoryWin32HandleInfoNV obj;
      obj.sType = VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV;
      obj.pNext = nullptr;
      obj.handleType = handleType;
      obj.handle = handle;
      return obj;
   }

struct VkExportMemoryWin32HandleInfoNVRAII {
   VkExportMemoryWin32HandleInfoNV nonRaiiObj;
    std::shared_ptr<SECURITY_ATTRIBUTES>        pAttributes;
};

std::shared_ptr<VkExportMemoryWin32HandleInfoNVRAII> ExportMemoryWin32HandleInfoNV(
    const SECURITY_ATTRIBUTES *                 pAttributes,
    DWORD                                       dwAccess)
   {
      std::shared_ptr<VkExportMemoryWin32HandleInfoNVRAII> raii_obj(new VkExportMemoryWin32HandleInfoNVRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.pAttributes = nullptr;
      if ( pAttributes ) 
      { 
          raii_obj->pAttributes.reset( new SECURITY_ATTRIBUTES );
          *raii_obj->pAttributes = *pAttributes;
          raii_obj->nonRaiiObj.pAttributes = raii_obj->pAttributes.get();
      } 
      raii_obj->nonRaiiObj.dwAccess = dwAccess;
      return raii_obj;
   }

HANDLE getMemoryWin32HandleNV(
        VkDevice device,
        VkDeviceMemory memory,
        VkExternalMemoryHandleTypeFlagsNV handleType)
   {
      if ( nullptr == pfvkGetMemoryWin32HandleNV )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      HANDLE pHandle; 
      V( pfvkGetMemoryWin32HandleNV(
          device,
          memory,
          handleType,
          &pHandle  ));
      return pHandle; 
   }

#endif /* VK_USE_PLATFORM_WIN32_KHR*/
#ifdef VK_USE_PLATFORM_WIN32_KHR
struct VkWin32KeyedMutexAcquireReleaseInfoNVRAII {
   VkWin32KeyedMutexAcquireReleaseInfoNV nonRaiiObj;
    std::vector<VkDeviceMemory>                 vecAcquireSyncs;
    std::vector<uint64_t>                       vecAcquireKeys;
    std::vector<uint32_t>                       vecAcquireTimeoutMilliseconds;
    std::vector<VkDeviceMemory>                 vecReleaseSyncs;
    std::vector<uint64_t>                       vecReleaseKeys;
};

std::shared_ptr<VkWin32KeyedMutexAcquireReleaseInfoNVRAII> Win32KeyedMutexAcquireReleaseInfoNV(
    const std::vector<VkDeviceMemory> &         vecAcquireSyncs,
    const std::vector<uint64_t> &               vecAcquireKeys,
    unsigned int* pAcquireTimeoutMilliseconds_in_array1, int pAcquireTimeoutMilliseconds_dim1,
    const std::vector<VkDeviceMemory> &         vecReleaseSyncs,
    const std::vector<uint64_t> &               vecReleaseKeys)
   {
      std::shared_ptr<VkWin32KeyedMutexAcquireReleaseInfoNVRAII> raii_obj(new VkWin32KeyedMutexAcquireReleaseInfoNVRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.acquireCount = static_cast<uint32_t>(vecAcquireSyncs.size());
      raii_obj->vecAcquireSyncs = vecAcquireSyncs;
      if ( raii_obj->vecAcquireSyncs.size() > 0)
      {
          raii_obj->nonRaiiObj.pAcquireSyncs = &raii_obj->vecAcquireSyncs[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pAcquireSyncs = nullptr;
      }
      raii_obj->vecAcquireKeys = vecAcquireKeys;
      if ( raii_obj->vecAcquireKeys.size() > 0)
      {
          raii_obj->nonRaiiObj.pAcquireKeys = &raii_obj->vecAcquireKeys[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pAcquireKeys = nullptr;
      }
      raii_obj->vecAcquireTimeoutMilliseconds.assign(pAcquireTimeoutMilliseconds_in_array1, pAcquireTimeoutMilliseconds_in_array1 + pAcquireTimeoutMilliseconds_dim1);
      if ( raii_obj->vecAcquireTimeoutMilliseconds.size() > 0)
      {
          raii_obj->nonRaiiObj.pAcquireTimeoutMilliseconds = &raii_obj->vecAcquireTimeoutMilliseconds[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pAcquireTimeoutMilliseconds = nullptr;
      }
      raii_obj->nonRaiiObj.releaseCount = static_cast<uint32_t>(vecReleaseSyncs.size());
      raii_obj->vecReleaseSyncs = vecReleaseSyncs;
      if ( raii_obj->vecReleaseSyncs.size() > 0)
      {
          raii_obj->nonRaiiObj.pReleaseSyncs = &raii_obj->vecReleaseSyncs[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pReleaseSyncs = nullptr;
      }
      raii_obj->vecReleaseKeys = vecReleaseKeys;
      if ( raii_obj->vecReleaseKeys.size() > 0)
      {
          raii_obj->nonRaiiObj.pReleaseKeys = &raii_obj->vecReleaseKeys[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pReleaseKeys = nullptr;
      }
      return raii_obj;
   }

#endif /* VK_USE_PLATFORM_WIN32_KHR*/
VkMemoryAllocateFlagsInfoKHX MemoryAllocateFlagsInfoKHX(
    VkMemoryAllocateFlagsKHX                    flags,
    uint32_t                                    deviceMask)
   {
      VkMemoryAllocateFlagsInfoKHX obj;
      obj.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO_KHX;
      obj.pNext = nullptr;
      obj.flags = flags;
      obj.deviceMask = deviceMask;
      return obj;
   }

struct VkDeviceGroupRenderPassBeginInfoKHXRAII {
   VkDeviceGroupRenderPassBeginInfoKHX nonRaiiObj;
    std::vector<VkRect2D>                       vecDeviceRenderAreas;
};

std::shared_ptr<VkDeviceGroupRenderPassBeginInfoKHXRAII> DeviceGroupRenderPassBeginInfoKHX(
    uint32_t                                    deviceMask,
    const std::vector<VkRect2D> &               vecDeviceRenderAreas)
   {
      std::shared_ptr<VkDeviceGroupRenderPassBeginInfoKHXRAII> raii_obj(new VkDeviceGroupRenderPassBeginInfoKHXRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO_KHX;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.deviceMask = deviceMask;
      raii_obj->nonRaiiObj.deviceRenderAreaCount = static_cast<uint32_t>(vecDeviceRenderAreas.size());
      raii_obj->vecDeviceRenderAreas = vecDeviceRenderAreas;
      if ( raii_obj->vecDeviceRenderAreas.size() > 0)
      {
          raii_obj->nonRaiiObj.pDeviceRenderAreas = &raii_obj->vecDeviceRenderAreas[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pDeviceRenderAreas = nullptr;
      }
      return raii_obj;
   }

VkDeviceGroupCommandBufferBeginInfoKHX DeviceGroupCommandBufferBeginInfoKHX(
    uint32_t                                    deviceMask)
   {
      VkDeviceGroupCommandBufferBeginInfoKHX obj;
      obj.sType = VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO_KHX;
      obj.pNext = nullptr;
      obj.deviceMask = deviceMask;
      return obj;
   }

struct VkDeviceGroupSubmitInfoKHXRAII {
   VkDeviceGroupSubmitInfoKHX nonRaiiObj;
    std::vector<uint32_t>                       vecWaitSemaphoreDeviceIndices;
    std::vector<uint32_t>                       vecCommandBufferDeviceMasks;
    std::vector<uint32_t>                       vecSignalSemaphoreDeviceIndices;
};

std::shared_ptr<VkDeviceGroupSubmitInfoKHXRAII> DeviceGroupSubmitInfoKHX(
    unsigned int* pWaitSemaphoreDeviceIndices_in_array1, int pWaitSemaphoreDeviceIndices_dim1,
    unsigned int* pCommandBufferDeviceMasks_in_array1, int pCommandBufferDeviceMasks_dim1,
    unsigned int* pSignalSemaphoreDeviceIndices_in_array1, int pSignalSemaphoreDeviceIndices_dim1)
   {
      std::shared_ptr<VkDeviceGroupSubmitInfoKHXRAII> raii_obj(new VkDeviceGroupSubmitInfoKHXRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO_KHX;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.waitSemaphoreCount = static_cast<uint32_t>(pWaitSemaphoreDeviceIndices_dim1);
      raii_obj->vecWaitSemaphoreDeviceIndices.assign(pWaitSemaphoreDeviceIndices_in_array1, pWaitSemaphoreDeviceIndices_in_array1 + pWaitSemaphoreDeviceIndices_dim1);
      if ( raii_obj->vecWaitSemaphoreDeviceIndices.size() > 0)
      {
          raii_obj->nonRaiiObj.pWaitSemaphoreDeviceIndices = &raii_obj->vecWaitSemaphoreDeviceIndices[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pWaitSemaphoreDeviceIndices = nullptr;
      }
      raii_obj->nonRaiiObj.commandBufferCount = static_cast<uint32_t>(pCommandBufferDeviceMasks_dim1);
      raii_obj->vecCommandBufferDeviceMasks.assign(pCommandBufferDeviceMasks_in_array1, pCommandBufferDeviceMasks_in_array1 + pCommandBufferDeviceMasks_dim1);
      if ( raii_obj->vecCommandBufferDeviceMasks.size() > 0)
      {
          raii_obj->nonRaiiObj.pCommandBufferDeviceMasks = &raii_obj->vecCommandBufferDeviceMasks[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pCommandBufferDeviceMasks = nullptr;
      }
      raii_obj->nonRaiiObj.signalSemaphoreCount = static_cast<uint32_t>(pSignalSemaphoreDeviceIndices_dim1);
      raii_obj->vecSignalSemaphoreDeviceIndices.assign(pSignalSemaphoreDeviceIndices_in_array1, pSignalSemaphoreDeviceIndices_in_array1 + pSignalSemaphoreDeviceIndices_dim1);
      if ( raii_obj->vecSignalSemaphoreDeviceIndices.size() > 0)
      {
          raii_obj->nonRaiiObj.pSignalSemaphoreDeviceIndices = &raii_obj->vecSignalSemaphoreDeviceIndices[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pSignalSemaphoreDeviceIndices = nullptr;
      }
      return raii_obj;
   }

VkDeviceGroupBindSparseInfoKHX DeviceGroupBindSparseInfoKHX(
    uint32_t                                    resourceDeviceIndex,
    uint32_t                                    memoryDeviceIndex)
   {
      VkDeviceGroupBindSparseInfoKHX obj;
      obj.sType = VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO_KHX;
      obj.pNext = nullptr;
      obj.resourceDeviceIndex = resourceDeviceIndex;
      obj.memoryDeviceIndex = memoryDeviceIndex;
      return obj;
   }

std::shared_ptr< VkPeerMemoryFeatureFlagsKHX > getDeviceGroupPeerMemoryFeaturesKHX(
        VkDevice device,
        uint32_t heapIndex,
        uint32_t localDeviceIndex,
        uint32_t remoteDeviceIndex)
   {
      if ( nullptr == pfvkGetDeviceGroupPeerMemoryFeaturesKHX )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      std::shared_ptr<VkPeerMemoryFeatureFlagsKHX> ptrpPeerMemoryFeatures(new VkPeerMemoryFeatureFlagsKHX); 
      pfvkGetDeviceGroupPeerMemoryFeaturesKHX(
          device,
          heapIndex,
          localDeviceIndex,
          remoteDeviceIndex,
          ptrpPeerMemoryFeatures.get()  );
      return ptrpPeerMemoryFeatures; 
   }

void  cmdSetDeviceMaskKHX(
        VkCommandBuffer commandBuffer,
        uint32_t deviceMask)
   {
      if ( nullptr == pfvkCmdSetDeviceMaskKHX )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      pfvkCmdSetDeviceMaskKHX(
          commandBuffer,
          deviceMask  );
   }

void  cmdDispatchBaseKHX(
        VkCommandBuffer commandBuffer,
        uint32_t baseGroupX,
        uint32_t baseGroupY,
        uint32_t baseGroupZ,
        uint32_t groupCountX,
        uint32_t groupCountY,
        uint32_t groupCountZ)
   {
      if ( nullptr == pfvkCmdDispatchBaseKHX )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      pfvkCmdDispatchBaseKHX(
          commandBuffer,
          baseGroupX,
          baseGroupY,
          baseGroupZ,
          groupCountX,
          groupCountY,
          groupCountZ  );
   }

struct VkBindBufferMemoryDeviceGroupInfoKHXRAII {
   VkBindBufferMemoryDeviceGroupInfoKHX nonRaiiObj;
    std::vector<uint32_t>                       vecDeviceIndices;
};

std::shared_ptr<VkBindBufferMemoryDeviceGroupInfoKHXRAII> BindBufferMemoryDeviceGroupInfoKHX(
    unsigned int* pDeviceIndices_in_array1, int pDeviceIndices_dim1)
   {
      std::shared_ptr<VkBindBufferMemoryDeviceGroupInfoKHXRAII> raii_obj(new VkBindBufferMemoryDeviceGroupInfoKHXRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO_KHX;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.deviceIndexCount = static_cast<uint32_t>(pDeviceIndices_dim1);
      raii_obj->vecDeviceIndices.assign(pDeviceIndices_in_array1, pDeviceIndices_in_array1 + pDeviceIndices_dim1);
      if ( raii_obj->vecDeviceIndices.size() > 0)
      {
          raii_obj->nonRaiiObj.pDeviceIndices = &raii_obj->vecDeviceIndices[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pDeviceIndices = nullptr;
      }
      return raii_obj;
   }

struct VkBindImageMemoryDeviceGroupInfoKHXRAII {
   VkBindImageMemoryDeviceGroupInfoKHX nonRaiiObj;
    std::vector<uint32_t>                       vecDeviceIndices;
    std::vector<VkRect2D>                       vecSFRRects;
};

std::shared_ptr<VkBindImageMemoryDeviceGroupInfoKHXRAII> BindImageMemoryDeviceGroupInfoKHX(
    unsigned int* pDeviceIndices_in_array1, int pDeviceIndices_dim1,
    const std::vector<VkRect2D> &               vecSFRRects)
   {
      std::shared_ptr<VkBindImageMemoryDeviceGroupInfoKHXRAII> raii_obj(new VkBindImageMemoryDeviceGroupInfoKHXRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO_KHX;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.deviceIndexCount = static_cast<uint32_t>(pDeviceIndices_dim1);
      raii_obj->vecDeviceIndices.assign(pDeviceIndices_in_array1, pDeviceIndices_in_array1 + pDeviceIndices_dim1);
      if ( raii_obj->vecDeviceIndices.size() > 0)
      {
          raii_obj->nonRaiiObj.pDeviceIndices = &raii_obj->vecDeviceIndices[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pDeviceIndices = nullptr;
      }
      raii_obj->nonRaiiObj.SFRRectCount = static_cast<uint32_t>(vecSFRRects.size());
      raii_obj->vecSFRRects = vecSFRRects;
      if ( raii_obj->vecSFRRects.size() > 0)
      {
          raii_obj->nonRaiiObj.pSFRRects = &raii_obj->vecSFRRects[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pSFRRects = nullptr;
      }
      return raii_obj;
   }

VkDeviceGroupPresentCapabilitiesKHX DeviceGroupPresentCapabilitiesKHX(
    uint32_t                                    presentMask[VK_MAX_DEVICE_GROUP_SIZE_KHX],
    VkDeviceGroupPresentModeFlagsKHX            modes)
   {
      VkDeviceGroupPresentCapabilitiesKHX obj;
      obj.sType = VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHX;
      obj.pNext = nullptr;
      std::copy(presentMask, presentMask + VK_MAX_DEVICE_GROUP_SIZE_KHX, obj.presentMask);
      obj.modes = modes;
      return obj;
   }

VkDeviceGroupPresentCapabilitiesKHX getDeviceGroupPresentCapabilitiesKHX(
        VkDevice device)
   {
      if ( nullptr == pfvkGetDeviceGroupPresentCapabilitiesKHX )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      VkDeviceGroupPresentCapabilitiesKHX pDeviceGroupPresentCapabilities; 
      V( pfvkGetDeviceGroupPresentCapabilitiesKHX(
          device,
          &pDeviceGroupPresentCapabilities  ));
      return pDeviceGroupPresentCapabilities; 
   }

std::shared_ptr< VkDeviceGroupPresentModeFlagsKHX > getDeviceGroupSurfacePresentModesKHX(
        VkDevice device,
        VkSurfaceKHR surface)
   {
      if ( nullptr == pfvkGetDeviceGroupSurfacePresentModesKHX )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      std::shared_ptr<VkDeviceGroupPresentModeFlagsKHX> ptrpModes(new VkDeviceGroupPresentModeFlagsKHX); 
      V( pfvkGetDeviceGroupSurfacePresentModesKHX(
          device,
          surface,
          ptrpModes.get()  ));
      return ptrpModes; 
   }

std::vector< VkRect2D > getPhysicalDevicePresentRectanglesKHX(
        VkPhysicalDevice physicalDevice,
        VkSurfaceKHR surface)
   {
      if ( nullptr == pfvkGetPhysicalDevicePresentRectanglesKHX )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      std::vector<VkRect2D> vecpRects; 
      uint32_t pRectsCount; 
      V( pfvkGetPhysicalDevicePresentRectanglesKHX(
          physicalDevice,
          surface,
          &pRectsCount,
          nullptr  ));

      vecpRects.resize(pRectsCount); 

      V( pfvkGetPhysicalDevicePresentRectanglesKHX(
          physicalDevice,
          surface,
          &pRectsCount,
          &vecpRects[0]  ));
      return vecpRects; 
   }

VkImageSwapchainCreateInfoKHX ImageSwapchainCreateInfoKHX(
    VkSwapchainKHR                              swapchain)
   {
      VkImageSwapchainCreateInfoKHX obj;
      obj.sType = VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHX;
      obj.pNext = nullptr;
      obj.swapchain = swapchain;
      return obj;
   }

VkBindImageMemorySwapchainInfoKHX BindImageMemorySwapchainInfoKHX(
    VkSwapchainKHR                              swapchain,
    uint32_t                                    imageIndex)
   {
      VkBindImageMemorySwapchainInfoKHX obj;
      obj.sType = VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHX;
      obj.pNext = nullptr;
      obj.swapchain = swapchain;
      obj.imageIndex = imageIndex;
      return obj;
   }

VkAcquireNextImageInfoKHX AcquireNextImageInfoKHX(
    VkSwapchainKHR                              swapchain,
    uint64_t                                    timeout,
    VkSemaphore                                 semaphore,
    VkFence                                     fence,
    uint32_t                                    deviceMask)
   {
      VkAcquireNextImageInfoKHX obj;
      obj.sType = VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHX;
      obj.pNext = nullptr;
      obj.swapchain = swapchain;
      obj.timeout = timeout;
      obj.semaphore = semaphore;
      obj.fence = fence;
      obj.deviceMask = deviceMask;
      return obj;
   }

struct VkDeviceGroupPresentInfoKHXRAII {
   VkDeviceGroupPresentInfoKHX nonRaiiObj;
    std::vector<uint32_t>                       vecDeviceMasks;
};

std::shared_ptr<VkDeviceGroupPresentInfoKHXRAII> DeviceGroupPresentInfoKHX(
    unsigned int* pDeviceMasks_in_array1, int pDeviceMasks_dim1,
    VkDeviceGroupPresentModeFlagBitsKHX         mode)
   {
      std::shared_ptr<VkDeviceGroupPresentInfoKHXRAII> raii_obj(new VkDeviceGroupPresentInfoKHXRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHX;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.swapchainCount = static_cast<uint32_t>(pDeviceMasks_dim1);
      raii_obj->vecDeviceMasks.assign(pDeviceMasks_in_array1, pDeviceMasks_in_array1 + pDeviceMasks_dim1);
      if ( raii_obj->vecDeviceMasks.size() > 0)
      {
          raii_obj->nonRaiiObj.pDeviceMasks = &raii_obj->vecDeviceMasks[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pDeviceMasks = nullptr;
      }
      raii_obj->nonRaiiObj.mode = mode;
      return raii_obj;
   }

VkDeviceGroupSwapchainCreateInfoKHX DeviceGroupSwapchainCreateInfoKHX(
    VkDeviceGroupPresentModeFlagsKHX            modes)
   {
      VkDeviceGroupSwapchainCreateInfoKHX obj;
      obj.sType = VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHX;
      obj.pNext = nullptr;
      obj.modes = modes;
      return obj;
   }

uint32_t acquireNextImage2KHX(
        VkDevice device,
        const VkAcquireNextImageInfoKHX & pAcquireInfo)
   {
      if ( nullptr == pfvkAcquireNextImage2KHX )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      uint32_t pImageIndex; 
      V( pfvkAcquireNextImage2KHX(
          device,
          &pAcquireInfo,
          &pImageIndex  ));
      return pImageIndex; 
   }

struct VkValidationFlagsEXTRAII {
   VkValidationFlagsEXT nonRaiiObj;
    std::vector<VkValidationCheckEXT>           vecDisabledValidationChecks;
};

std::shared_ptr<VkValidationFlagsEXTRAII> ValidationFlagsEXT(
    const std::vector<VkValidationCheckEXT> &   vecDisabledValidationChecks)
   {
      std::shared_ptr<VkValidationFlagsEXTRAII> raii_obj(new VkValidationFlagsEXTRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.disabledValidationCheckCount = static_cast<uint32_t>(vecDisabledValidationChecks.size());
      raii_obj->vecDisabledValidationChecks = vecDisabledValidationChecks;
      if ( raii_obj->vecDisabledValidationChecks.size() > 0)
      {
          raii_obj->nonRaiiObj.pDisabledValidationChecks = &raii_obj->vecDisabledValidationChecks[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pDisabledValidationChecks = nullptr;
      }
      return raii_obj;
   }

#ifdef VK_USE_PLATFORM_VI_NN
VkViSurfaceCreateInfoNN ViSurfaceCreateInfoNN(
    VkViSurfaceCreateFlagsNN                    flags)
   {
      VkViSurfaceCreateInfoNN obj;
      obj.sType = VK_STRUCTURE_TYPE_VI_SURFACE_CREATE_INFO_NN;
      obj.pNext = nullptr;
      obj.flags = flags;
      obj.window = nullptr;
      return obj;
   }

std::shared_ptr<VkSurfaceKHR_T> createViSurfaceNN(
        VkInstance instance,
        const VkViSurfaceCreateInfoNN & pCreateInfo)
   {
      if ( nullptr == pfvkCreateViSurfaceNN )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      VkSurfaceKHR hSurface; 
      V( pfvkCreateViSurfaceNN(
          instance,
          &pCreateInfo,
          nullptr,
          &hSurface  ));
      return std::shared_ptr<VkSurfaceKHR_T>(hSurface, 
              [](VkSurfaceKHR) {});
   }

#endif /* VK_USE_PLATFORM_VI_NN*/
VkPhysicalDeviceGroupPropertiesKHX PhysicalDeviceGroupPropertiesKHX(
    uint32_t                                    physicalDeviceCount,
    VkPhysicalDevice                            physicalDevices[VK_MAX_DEVICE_GROUP_SIZE_KHX],
    VkBool32                                    subsetAllocation)
   {
      VkPhysicalDeviceGroupPropertiesKHX obj;
      obj.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES_KHX;
      obj.pNext = nullptr;
      obj.physicalDeviceCount = physicalDeviceCount;
      std::copy(physicalDevices, physicalDevices + VK_MAX_DEVICE_GROUP_SIZE_KHX, obj.physicalDevices);
      obj.subsetAllocation = subsetAllocation;
      return obj;
   }

struct VkDeviceGroupDeviceCreateInfoKHXRAII {
   VkDeviceGroupDeviceCreateInfoKHX nonRaiiObj;
    std::vector<VkPhysicalDevice>               vecPhysicalDevices;
};

std::shared_ptr<VkDeviceGroupDeviceCreateInfoKHXRAII> DeviceGroupDeviceCreateInfoKHX(
    const std::vector<VkPhysicalDevice> &       vecPhysicalDevices)
   {
      std::shared_ptr<VkDeviceGroupDeviceCreateInfoKHXRAII> raii_obj(new VkDeviceGroupDeviceCreateInfoKHXRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO_KHX;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.physicalDeviceCount = static_cast<uint32_t>(vecPhysicalDevices.size());
      raii_obj->vecPhysicalDevices = vecPhysicalDevices;
      if ( raii_obj->vecPhysicalDevices.size() > 0)
      {
          raii_obj->nonRaiiObj.pPhysicalDevices = &raii_obj->vecPhysicalDevices[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pPhysicalDevices = nullptr;
      }
      return raii_obj;
   }

std::vector< VkPhysicalDeviceGroupPropertiesKHX > enumeratePhysicalDeviceGroupsKHX(
        VkInstance instance)
   {
      if ( nullptr == pfvkEnumeratePhysicalDeviceGroupsKHX )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      std::vector<VkPhysicalDeviceGroupPropertiesKHX> vecpPhysicalDeviceGroupProperties; 
      uint32_t pPhysicalDeviceGroupPropertiesCount; 
      V( pfvkEnumeratePhysicalDeviceGroupsKHX(
          instance,
          &pPhysicalDeviceGroupPropertiesCount,
          nullptr  ));

      vecpPhysicalDeviceGroupProperties.resize(pPhysicalDeviceGroupPropertiesCount); 

      V( pfvkEnumeratePhysicalDeviceGroupsKHX(
          instance,
          &pPhysicalDeviceGroupPropertiesCount,
          &vecpPhysicalDeviceGroupProperties[0]  ));
      return vecpPhysicalDeviceGroupProperties; 
   }

VkDeviceGeneratedCommandsFeaturesNVX DeviceGeneratedCommandsFeaturesNVX(
    VkBool32                                    computeBindingPointSupport)
   {
      VkDeviceGeneratedCommandsFeaturesNVX obj;
      obj.sType = VK_STRUCTURE_TYPE_DEVICE_GENERATED_COMMANDS_FEATURES_NVX;
      obj.pNext = nullptr;
      obj.computeBindingPointSupport = computeBindingPointSupport;
      return obj;
   }

VkDeviceGeneratedCommandsLimitsNVX DeviceGeneratedCommandsLimitsNVX(
    uint32_t                                    maxIndirectCommandsLayoutTokenCount,
    uint32_t                                    maxObjectEntryCounts,
    uint32_t                                    minSequenceCountBufferOffsetAlignment,
    uint32_t                                    minSequenceIndexBufferOffsetAlignment,
    uint32_t                                    minCommandsTokenBufferOffsetAlignment)
   {
      VkDeviceGeneratedCommandsLimitsNVX obj;
      obj.sType = VK_STRUCTURE_TYPE_DEVICE_GENERATED_COMMANDS_LIMITS_NVX;
      obj.pNext = nullptr;
      obj.maxIndirectCommandsLayoutTokenCount = maxIndirectCommandsLayoutTokenCount;
      obj.maxObjectEntryCounts = maxObjectEntryCounts;
      obj.minSequenceCountBufferOffsetAlignment = minSequenceCountBufferOffsetAlignment;
      obj.minSequenceIndexBufferOffsetAlignment = minSequenceIndexBufferOffsetAlignment;
      obj.minCommandsTokenBufferOffsetAlignment = minCommandsTokenBufferOffsetAlignment;
      return obj;
   }

VkIndirectCommandsTokenNVX IndirectCommandsTokenNVX(
    VkIndirectCommandsTokenTypeNVX              tokenType,
    VkBuffer                                    buffer,
    VkDeviceSize                                offset)
   {
      VkIndirectCommandsTokenNVX obj;
      obj.tokenType = tokenType;
      obj.buffer = buffer;
      obj.offset = offset;
      return obj;
   }

VkIndirectCommandsLayoutTokenNVX IndirectCommandsLayoutTokenNVX(
    VkIndirectCommandsTokenTypeNVX              tokenType,
    uint32_t                                    bindingUnit,
    uint32_t                                    dynamicCount,
    uint32_t                                    divisor)
   {
      VkIndirectCommandsLayoutTokenNVX obj;
      obj.tokenType = tokenType;
      obj.bindingUnit = bindingUnit;
      obj.dynamicCount = dynamicCount;
      obj.divisor = divisor;
      return obj;
   }

struct VkIndirectCommandsLayoutCreateInfoNVXRAII {
   VkIndirectCommandsLayoutCreateInfoNVX nonRaiiObj;
    std::vector<VkIndirectCommandsLayoutTokenNVX>vecTokens;
};

std::shared_ptr<VkIndirectCommandsLayoutCreateInfoNVXRAII> IndirectCommandsLayoutCreateInfoNVX(
    VkPipelineBindPoint                         pipelineBindPoint,
    VkIndirectCommandsLayoutUsageFlagsNVX       flags,
    const std::vector<VkIndirectCommandsLayoutTokenNVX> &vecTokens)
   {
      std::shared_ptr<VkIndirectCommandsLayoutCreateInfoNVXRAII> raii_obj(new VkIndirectCommandsLayoutCreateInfoNVXRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NVX;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.pipelineBindPoint = pipelineBindPoint;
      raii_obj->nonRaiiObj.flags = flags;
      raii_obj->nonRaiiObj.tokenCount = static_cast<uint32_t>(vecTokens.size());
      raii_obj->vecTokens = vecTokens;
      if ( raii_obj->vecTokens.size() > 0)
      {
          raii_obj->nonRaiiObj.pTokens = &raii_obj->vecTokens[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pTokens = nullptr;
      }
      return raii_obj;
   }

struct VkCmdProcessCommandsInfoNVXRAII {
   VkCmdProcessCommandsInfoNVX nonRaiiObj;
    std::vector<VkIndirectCommandsTokenNVX>     vecIndirectCommandsTokens;
};

std::shared_ptr<VkCmdProcessCommandsInfoNVXRAII> CmdProcessCommandsInfoNVX(
    VkObjectTableNVX                            objectTable,
    VkIndirectCommandsLayoutNVX                 indirectCommandsLayout,
    const std::vector<VkIndirectCommandsTokenNVX> &vecIndirectCommandsTokens,
    uint32_t                                    maxSequencesCount,
    VkCommandBuffer                             targetCommandBuffer,
    VkBuffer                                    sequencesCountBuffer,
    VkDeviceSize                                sequencesCountOffset,
    VkBuffer                                    sequencesIndexBuffer,
    VkDeviceSize                                sequencesIndexOffset)
   {
      std::shared_ptr<VkCmdProcessCommandsInfoNVXRAII> raii_obj(new VkCmdProcessCommandsInfoNVXRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_CMD_PROCESS_COMMANDS_INFO_NVX;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.objectTable = objectTable;
      raii_obj->nonRaiiObj.indirectCommandsLayout = indirectCommandsLayout;
      raii_obj->nonRaiiObj.indirectCommandsTokenCount = static_cast<uint32_t>(vecIndirectCommandsTokens.size());
      raii_obj->vecIndirectCommandsTokens = vecIndirectCommandsTokens;
      if ( raii_obj->vecIndirectCommandsTokens.size() > 0)
      {
          raii_obj->nonRaiiObj.pIndirectCommandsTokens = &raii_obj->vecIndirectCommandsTokens[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pIndirectCommandsTokens = nullptr;
      }
      raii_obj->nonRaiiObj.maxSequencesCount = maxSequencesCount;
      raii_obj->nonRaiiObj.targetCommandBuffer = targetCommandBuffer;
      raii_obj->nonRaiiObj.sequencesCountBuffer = sequencesCountBuffer;
      raii_obj->nonRaiiObj.sequencesCountOffset = sequencesCountOffset;
      raii_obj->nonRaiiObj.sequencesIndexBuffer = sequencesIndexBuffer;
      raii_obj->nonRaiiObj.sequencesIndexOffset = sequencesIndexOffset;
      return raii_obj;
   }

VkCmdReserveSpaceForCommandsInfoNVX CmdReserveSpaceForCommandsInfoNVX(
    VkObjectTableNVX                            objectTable,
    VkIndirectCommandsLayoutNVX                 indirectCommandsLayout,
    uint32_t                                    maxSequencesCount)
   {
      VkCmdReserveSpaceForCommandsInfoNVX obj;
      obj.sType = VK_STRUCTURE_TYPE_CMD_RESERVE_SPACE_FOR_COMMANDS_INFO_NVX;
      obj.pNext = nullptr;
      obj.objectTable = objectTable;
      obj.indirectCommandsLayout = indirectCommandsLayout;
      obj.maxSequencesCount = maxSequencesCount;
      return obj;
   }

struct VkObjectTableCreateInfoNVXRAII {
   VkObjectTableCreateInfoNVX nonRaiiObj;
    std::vector<VkObjectEntryTypeNVX>           vecObjectEntryTypes;
    std::vector<uint32_t>                       vecObjectEntryCounts;
    std::vector<VkObjectEntryUsageFlagsNVX>     vecObjectEntryUsageFlags;
};

std::shared_ptr<VkObjectTableCreateInfoNVXRAII> ObjectTableCreateInfoNVX(
    const std::vector<VkObjectEntryTypeNVX> &   vecObjectEntryTypes,
    unsigned int* pObjectEntryCounts_in_array1, int pObjectEntryCounts_dim1,
    const std::vector<VkObjectEntryUsageFlagsNVX> &vecObjectEntryUsageFlags,
    uint32_t                                    maxUniformBuffersPerDescriptor,
    uint32_t                                    maxStorageBuffersPerDescriptor,
    uint32_t                                    maxStorageImagesPerDescriptor,
    uint32_t                                    maxSampledImagesPerDescriptor,
    uint32_t                                    maxPipelineLayouts)
   {
      std::shared_ptr<VkObjectTableCreateInfoNVXRAII> raii_obj(new VkObjectTableCreateInfoNVXRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_OBJECT_TABLE_CREATE_INFO_NVX;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.objectCount = static_cast<uint32_t>(vecObjectEntryTypes.size());
      raii_obj->vecObjectEntryTypes = vecObjectEntryTypes;
      if ( raii_obj->vecObjectEntryTypes.size() > 0)
      {
          raii_obj->nonRaiiObj.pObjectEntryTypes = &raii_obj->vecObjectEntryTypes[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pObjectEntryTypes = nullptr;
      }
      raii_obj->vecObjectEntryCounts.assign(pObjectEntryCounts_in_array1, pObjectEntryCounts_in_array1 + pObjectEntryCounts_dim1);
      if ( raii_obj->vecObjectEntryCounts.size() > 0)
      {
          raii_obj->nonRaiiObj.pObjectEntryCounts = &raii_obj->vecObjectEntryCounts[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pObjectEntryCounts = nullptr;
      }
      raii_obj->vecObjectEntryUsageFlags = vecObjectEntryUsageFlags;
      if ( raii_obj->vecObjectEntryUsageFlags.size() > 0)
      {
          raii_obj->nonRaiiObj.pObjectEntryUsageFlags = &raii_obj->vecObjectEntryUsageFlags[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pObjectEntryUsageFlags = nullptr;
      }
      raii_obj->nonRaiiObj.maxUniformBuffersPerDescriptor = maxUniformBuffersPerDescriptor;
      raii_obj->nonRaiiObj.maxStorageBuffersPerDescriptor = maxStorageBuffersPerDescriptor;
      raii_obj->nonRaiiObj.maxStorageImagesPerDescriptor = maxStorageImagesPerDescriptor;
      raii_obj->nonRaiiObj.maxSampledImagesPerDescriptor = maxSampledImagesPerDescriptor;
      raii_obj->nonRaiiObj.maxPipelineLayouts = maxPipelineLayouts;
      return raii_obj;
   }

VkObjectTableEntryNVX ObjectTableEntryNVX(
    VkObjectEntryTypeNVX                        type,
    VkObjectEntryUsageFlagsNVX                  flags)
   {
      VkObjectTableEntryNVX obj;
      obj.type = type;
      obj.flags = flags;
      return obj;
   }

VkObjectTablePipelineEntryNVX ObjectTablePipelineEntryNVX(
    VkObjectEntryTypeNVX                        type,
    VkObjectEntryUsageFlagsNVX                  flags,
    VkPipeline                                  pipeline)
   {
      VkObjectTablePipelineEntryNVX obj;
      obj.type = type;
      obj.flags = flags;
      obj.pipeline = pipeline;
      return obj;
   }

VkObjectTableDescriptorSetEntryNVX ObjectTableDescriptorSetEntryNVX(
    VkObjectEntryTypeNVX                        type,
    VkObjectEntryUsageFlagsNVX                  flags,
    VkPipelineLayout                            pipelineLayout,
    VkDescriptorSet                             descriptorSet)
   {
      VkObjectTableDescriptorSetEntryNVX obj;
      obj.type = type;
      obj.flags = flags;
      obj.pipelineLayout = pipelineLayout;
      obj.descriptorSet = descriptorSet;
      return obj;
   }

VkObjectTableVertexBufferEntryNVX ObjectTableVertexBufferEntryNVX(
    VkObjectEntryTypeNVX                        type,
    VkObjectEntryUsageFlagsNVX                  flags,
    VkBuffer                                    buffer)
   {
      VkObjectTableVertexBufferEntryNVX obj;
      obj.type = type;
      obj.flags = flags;
      obj.buffer = buffer;
      return obj;
   }

VkObjectTableIndexBufferEntryNVX ObjectTableIndexBufferEntryNVX(
    VkObjectEntryTypeNVX                        type,
    VkObjectEntryUsageFlagsNVX                  flags,
    VkBuffer                                    buffer,
    VkIndexType                                 indexType)
   {
      VkObjectTableIndexBufferEntryNVX obj;
      obj.type = type;
      obj.flags = flags;
      obj.buffer = buffer;
      obj.indexType = indexType;
      return obj;
   }

VkObjectTablePushConstantEntryNVX ObjectTablePushConstantEntryNVX(
    VkObjectEntryTypeNVX                        type,
    VkObjectEntryUsageFlagsNVX                  flags,
    VkPipelineLayout                            pipelineLayout,
    VkShaderStageFlags                          stageFlags)
   {
      VkObjectTablePushConstantEntryNVX obj;
      obj.type = type;
      obj.flags = flags;
      obj.pipelineLayout = pipelineLayout;
      obj.stageFlags = stageFlags;
      return obj;
   }

void  cmdProcessCommandsNVX(
        VkCommandBuffer commandBuffer,
        const VkCmdProcessCommandsInfoNVX & pProcessCommandsInfo)
   {
      if ( nullptr == pfvkCmdProcessCommandsNVX )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      pfvkCmdProcessCommandsNVX(
          commandBuffer,
          &pProcessCommandsInfo  );
   }

void  cmdReserveSpaceForCommandsNVX(
        VkCommandBuffer commandBuffer,
        const VkCmdReserveSpaceForCommandsInfoNVX & pReserveSpaceInfo)
   {
      if ( nullptr == pfvkCmdReserveSpaceForCommandsNVX )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      pfvkCmdReserveSpaceForCommandsNVX(
          commandBuffer,
          &pReserveSpaceInfo  );
   }

std::shared_ptr<VkIndirectCommandsLayoutNVX_T> createIndirectCommandsLayoutNVX(
        VkDevice device,
        const VkIndirectCommandsLayoutCreateInfoNVX & pCreateInfo)
   {
      if ( nullptr == pfvkCreateIndirectCommandsLayoutNVX )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      VkIndirectCommandsLayoutNVX hIndirectCommandsLayout; 
      V( pfvkCreateIndirectCommandsLayoutNVX(
          device,
          &pCreateInfo,
          nullptr,
          &hIndirectCommandsLayout  ));
      return std::shared_ptr<VkIndirectCommandsLayoutNVX_T>(hIndirectCommandsLayout, 
              [=](VkIndirectCommandsLayoutNVX to_free) {pfvkDestroyIndirectCommandsLayoutNVX(device, to_free, nullptr);});
   }

std::shared_ptr<VkObjectTableNVX_T> createObjectTableNVX(
        VkDevice device,
        const VkObjectTableCreateInfoNVX & pCreateInfo)
   {
      if ( nullptr == pfvkCreateObjectTableNVX )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      VkObjectTableNVX hObjectTable; 
      V( pfvkCreateObjectTableNVX(
          device,
          &pCreateInfo,
          nullptr,
          &hObjectTable  ));
      return std::shared_ptr<VkObjectTableNVX_T>(hObjectTable, 
              [=](VkObjectTableNVX to_free) {pfvkDestroyObjectTableNVX(device, to_free, nullptr);});
   }

void  unregisterObjectsNVX(
        VkDevice device,
        VkObjectTableNVX objectTable,
        const std::vector<VkObjectEntryTypeNVX> & pObjectEntryTypes,
        unsigned int* pObjectIndices_in_array1, int pObjectIndices_dim1)
   {
      if ( nullptr == pfvkUnregisterObjectsNVX )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      V( pfvkUnregisterObjectsNVX(
          device,
          objectTable,
          static_cast<uint32_t>(pObjectIndices_dim1),
          &pObjectEntryTypes[0],
          pObjectIndices_in_array1  ));
   }

VkDeviceGeneratedCommandsFeaturesNVX getPhysicalDeviceGeneratedCommandsPropertiesNVX(
        VkPhysicalDevice physicalDevice)
   {
      if ( nullptr == pfvkGetPhysicalDeviceGeneratedCommandsPropertiesNVX )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      VkDeviceGeneratedCommandsFeaturesNVX pFeatures; 
      VkDeviceGeneratedCommandsLimitsNVX pLimits; 
      pfvkGetPhysicalDeviceGeneratedCommandsPropertiesNVX(
          physicalDevice,
          &pFeatures,
          &pLimits  );
      return pFeatures; 
   }

VkViewportWScalingNV ViewportWScalingNV(
    float                                       xcoeff,
    float                                       ycoeff)
   {
      VkViewportWScalingNV obj;
      obj.xcoeff = xcoeff;
      obj.ycoeff = ycoeff;
      return obj;
   }

struct VkPipelineViewportWScalingStateCreateInfoNVRAII {
   VkPipelineViewportWScalingStateCreateInfoNV nonRaiiObj;
    std::vector<VkViewportWScalingNV>           vecViewportWScalings;
};

std::shared_ptr<VkPipelineViewportWScalingStateCreateInfoNVRAII> PipelineViewportWScalingStateCreateInfoNV(
    VkBool32                                    viewportWScalingEnable,
    const std::vector<VkViewportWScalingNV> &   vecViewportWScalings)
   {
      std::shared_ptr<VkPipelineViewportWScalingStateCreateInfoNVRAII> raii_obj(new VkPipelineViewportWScalingStateCreateInfoNVRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_MAX_ENUM;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.viewportWScalingEnable = viewportWScalingEnable;
      raii_obj->nonRaiiObj.viewportCount = static_cast<uint32_t>(vecViewportWScalings.size());
      raii_obj->vecViewportWScalings = vecViewportWScalings;
      if ( raii_obj->vecViewportWScalings.size() > 0)
      {
          raii_obj->nonRaiiObj.pViewportWScalings = &raii_obj->vecViewportWScalings[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pViewportWScalings = nullptr;
      }
      return raii_obj;
   }

void  cmdSetViewportWScalingNV(
        VkCommandBuffer commandBuffer,
        uint32_t firstViewport,
        const std::vector<VkViewportWScalingNV> & pViewportWScalings)
   {
      if ( nullptr == pfvkCmdSetViewportWScalingNV )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      pfvkCmdSetViewportWScalingNV(
          commandBuffer,
          firstViewport,
          static_cast<uint32_t>(pViewportWScalings.size()),
          &pViewportWScalings[0]  );
   }

void  releaseDisplayEXT(
        VkPhysicalDevice physicalDevice,
        VkDisplayKHR display)
   {
      if ( nullptr == pfvkReleaseDisplayEXT )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      V( pfvkReleaseDisplayEXT(
          physicalDevice,
          display  ));
   }

#ifdef VK_USE_PLATFORM_XLIB_XRANDR_EXT
Display acquireXlibDisplayEXT(
        VkPhysicalDevice physicalDevice,
        VkDisplayKHR display)
   {
      if ( nullptr == pfvkAcquireXlibDisplayEXT )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      Display dpy; 
      V( pfvkAcquireXlibDisplayEXT(
          physicalDevice,
          &dpy,
          display  ));
      return dpy; 
   }

VkDisplayKHR getRandROutputDisplayEXT(
        VkPhysicalDevice physicalDevice,
        RROutput rrOutput)
   {
      if ( nullptr == pfvkGetRandROutputDisplayEXT )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      Display dpy; 
      VkDisplayKHR hDisplay; 
      V( pfvkGetRandROutputDisplayEXT(
          physicalDevice,
          &dpy,
          rrOutput,
          &hDisplay  ));
      return hDisplay; 
   }

#endif /* VK_USE_PLATFORM_XLIB_XRANDR_EXT*/
VkSurfaceCapabilities2EXT SurfaceCapabilities2EXT(
    uint32_t                                    minImageCount,
    uint32_t                                    maxImageCount,
    VkExtent2D                                  currentExtent,
    VkExtent2D                                  minImageExtent,
    VkExtent2D                                  maxImageExtent,
    uint32_t                                    maxImageArrayLayers,
    VkSurfaceTransformFlagsKHR                  supportedTransforms,
    VkSurfaceTransformFlagBitsKHR               currentTransform,
    VkCompositeAlphaFlagsKHR                    supportedCompositeAlpha,
    VkImageUsageFlags                           supportedUsageFlags,
    VkSurfaceCounterFlagsEXT                    supportedSurfaceCounters)
   {
      VkSurfaceCapabilities2EXT obj;
      obj.sType = VK_STRUCTURE_TYPE_MAX_ENUM;
      obj.pNext = nullptr;
      obj.minImageCount = minImageCount;
      obj.maxImageCount = maxImageCount;
      obj.currentExtent = currentExtent;
      obj.minImageExtent = minImageExtent;
      obj.maxImageExtent = maxImageExtent;
      obj.maxImageArrayLayers = maxImageArrayLayers;
      obj.supportedTransforms = supportedTransforms;
      obj.currentTransform = currentTransform;
      obj.supportedCompositeAlpha = supportedCompositeAlpha;
      obj.supportedUsageFlags = supportedUsageFlags;
      obj.supportedSurfaceCounters = supportedSurfaceCounters;
      return obj;
   }

VkSurfaceCapabilities2EXT getPhysicalDeviceSurfaceCapabilities2EXT(
        VkPhysicalDevice physicalDevice,
        VkSurfaceKHR surface)
   {
      if ( nullptr == pfvkGetPhysicalDeviceSurfaceCapabilities2EXT )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      VkSurfaceCapabilities2EXT pSurfaceCapabilities; 
      V( pfvkGetPhysicalDeviceSurfaceCapabilities2EXT(
          physicalDevice,
          surface,
          &pSurfaceCapabilities  ));
      return pSurfaceCapabilities; 
   }

VkDisplayPowerInfoEXT DisplayPowerInfoEXT(
    VkDisplayPowerStateEXT                      powerState)
   {
      VkDisplayPowerInfoEXT obj;
      obj.sType = VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT;
      obj.pNext = nullptr;
      obj.powerState = powerState;
      return obj;
   }

VkDeviceEventInfoEXT DeviceEventInfoEXT(
    VkDeviceEventTypeEXT                        deviceEvent)
   {
      VkDeviceEventInfoEXT obj;
      obj.sType = VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT;
      obj.pNext = nullptr;
      obj.deviceEvent = deviceEvent;
      return obj;
   }

VkDisplayEventInfoEXT DisplayEventInfoEXT(
    VkDisplayEventTypeEXT                       displayEvent)
   {
      VkDisplayEventInfoEXT obj;
      obj.sType = VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT;
      obj.pNext = nullptr;
      obj.displayEvent = displayEvent;
      return obj;
   }

VkSwapchainCounterCreateInfoEXT SwapchainCounterCreateInfoEXT(
    VkSurfaceCounterFlagsEXT                    surfaceCounters)
   {
      VkSwapchainCounterCreateInfoEXT obj;
      obj.sType = VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT;
      obj.pNext = nullptr;
      obj.surfaceCounters = surfaceCounters;
      return obj;
   }

void  displayPowerControlEXT(
        VkDevice device,
        VkDisplayKHR display,
        const VkDisplayPowerInfoEXT & pDisplayPowerInfo)
   {
      if ( nullptr == pfvkDisplayPowerControlEXT )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      V( pfvkDisplayPowerControlEXT(
          device,
          display,
          &pDisplayPowerInfo  ));
   }

std::shared_ptr<VkFence_T> registerDeviceEventEXT(
        VkDevice device,
        const VkDeviceEventInfoEXT & pDeviceEventInfo)
   {
      if ( nullptr == pfvkRegisterDeviceEventEXT )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      VkFence hFence; 
      V( pfvkRegisterDeviceEventEXT(
          device,
          &pDeviceEventInfo,
          nullptr,
          &hFence  ));
      return std::shared_ptr<VkFence_T>(hFence, 
              [=](VkFence to_free) {pfvkDestroyFence(device, to_free, nullptr);});
   }

std::shared_ptr<VkFence_T> registerDisplayEventEXT(
        VkDevice device,
        VkDisplayKHR display,
        const VkDisplayEventInfoEXT & pDisplayEventInfo)
   {
      if ( nullptr == pfvkRegisterDisplayEventEXT )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      VkFence hFence; 
      V( pfvkRegisterDisplayEventEXT(
          device,
          display,
          &pDisplayEventInfo,
          nullptr,
          &hFence  ));
      return std::shared_ptr<VkFence_T>(hFence, 
              [=](VkFence to_free) {pfvkDestroyFence(device, to_free, nullptr);});
   }

uint64_t getSwapchainCounterEXT(
        VkDevice device,
        VkSwapchainKHR swapchain,
        VkSurfaceCounterFlagBitsEXT counter)
   {
      if ( nullptr == pfvkGetSwapchainCounterEXT )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      uint64_t pCounterValue; 
      V( pfvkGetSwapchainCounterEXT(
          device,
          swapchain,
          counter,
          &pCounterValue  ));
      return pCounterValue; 
   }

VkRefreshCycleDurationGOOGLE RefreshCycleDurationGOOGLE(
    uint64_t                                    refreshDuration)
   {
      VkRefreshCycleDurationGOOGLE obj;
      obj.refreshDuration = refreshDuration;
      return obj;
   }

VkPastPresentationTimingGOOGLE PastPresentationTimingGOOGLE(
    uint32_t                                    presentID,
    uint64_t                                    desiredPresentTime,
    uint64_t                                    actualPresentTime,
    uint64_t                                    earliestPresentTime,
    uint64_t                                    presentMargin)
   {
      VkPastPresentationTimingGOOGLE obj;
      obj.presentID = presentID;
      obj.desiredPresentTime = desiredPresentTime;
      obj.actualPresentTime = actualPresentTime;
      obj.earliestPresentTime = earliestPresentTime;
      obj.presentMargin = presentMargin;
      return obj;
   }

VkPresentTimeGOOGLE PresentTimeGOOGLE(
    uint32_t                                    presentID,
    uint64_t                                    desiredPresentTime)
   {
      VkPresentTimeGOOGLE obj;
      obj.presentID = presentID;
      obj.desiredPresentTime = desiredPresentTime;
      return obj;
   }

struct VkPresentTimesInfoGOOGLERAII {
   VkPresentTimesInfoGOOGLE nonRaiiObj;
    std::vector<VkPresentTimeGOOGLE>            vecTimes;
};

std::shared_ptr<VkPresentTimesInfoGOOGLERAII> PresentTimesInfoGOOGLE(
    const std::vector<VkPresentTimeGOOGLE> &    vecTimes)
   {
      std::shared_ptr<VkPresentTimesInfoGOOGLERAII> raii_obj(new VkPresentTimesInfoGOOGLERAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.swapchainCount = static_cast<uint32_t>(vecTimes.size());
      raii_obj->vecTimes = vecTimes;
      if ( raii_obj->vecTimes.size() > 0)
      {
          raii_obj->nonRaiiObj.pTimes = &raii_obj->vecTimes[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pTimes = nullptr;
      }
      return raii_obj;
   }

VkRefreshCycleDurationGOOGLE getRefreshCycleDurationGOOGLE(
        VkDevice device,
        VkSwapchainKHR swapchain)
   {
      if ( nullptr == pfvkGetRefreshCycleDurationGOOGLE )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      VkRefreshCycleDurationGOOGLE pDisplayTimingProperties; 
      V( pfvkGetRefreshCycleDurationGOOGLE(
          device,
          swapchain,
          &pDisplayTimingProperties  ));
      return pDisplayTimingProperties; 
   }

std::vector< VkPastPresentationTimingGOOGLE > getPastPresentationTimingGOOGLE(
        VkDevice device,
        VkSwapchainKHR swapchain)
   {
      if ( nullptr == pfvkGetPastPresentationTimingGOOGLE )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      std::vector<VkPastPresentationTimingGOOGLE> vecpPresentationTimings; 
      uint32_t pPresentationTimingsCount; 
      V( pfvkGetPastPresentationTimingGOOGLE(
          device,
          swapchain,
          &pPresentationTimingsCount,
          nullptr  ));

      vecpPresentationTimings.resize(pPresentationTimingsCount); 

      V( pfvkGetPastPresentationTimingGOOGLE(
          device,
          swapchain,
          &pPresentationTimingsCount,
          &vecpPresentationTimings[0]  ));
      return vecpPresentationTimings; 
   }

VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX(
    VkBool32                                    perViewPositionAllComponents)
   {
      VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX obj;
      obj.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX;
      obj.pNext = nullptr;
      obj.perViewPositionAllComponents = perViewPositionAllComponents;
      return obj;
   }

VkViewportSwizzleNV ViewportSwizzleNV(
    VkViewportCoordinateSwizzleNV               x,
    VkViewportCoordinateSwizzleNV               y,
    VkViewportCoordinateSwizzleNV               z,
    VkViewportCoordinateSwizzleNV               w)
   {
      VkViewportSwizzleNV obj;
      obj.x = x;
      obj.y = y;
      obj.z = z;
      obj.w = w;
      return obj;
   }

struct VkPipelineViewportSwizzleStateCreateInfoNVRAII {
   VkPipelineViewportSwizzleStateCreateInfoNV nonRaiiObj;
    std::vector<VkViewportSwizzleNV>            vecViewportSwizzles;
};

std::shared_ptr<VkPipelineViewportSwizzleStateCreateInfoNVRAII> PipelineViewportSwizzleStateCreateInfoNV(
    VkPipelineViewportSwizzleStateCreateFlagsNV flags,
    const std::vector<VkViewportSwizzleNV> &    vecViewportSwizzles)
   {
      std::shared_ptr<VkPipelineViewportSwizzleStateCreateInfoNVRAII> raii_obj(new VkPipelineViewportSwizzleStateCreateInfoNVRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.flags = flags;
      raii_obj->nonRaiiObj.viewportCount = static_cast<uint32_t>(vecViewportSwizzles.size());
      raii_obj->vecViewportSwizzles = vecViewportSwizzles;
      if ( raii_obj->vecViewportSwizzles.size() > 0)
      {
          raii_obj->nonRaiiObj.pViewportSwizzles = &raii_obj->vecViewportSwizzles[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pViewportSwizzles = nullptr;
      }
      return raii_obj;
   }

VkPhysicalDeviceDiscardRectanglePropertiesEXT PhysicalDeviceDiscardRectanglePropertiesEXT(
    uint32_t                                    maxDiscardRectangles)
   {
      VkPhysicalDeviceDiscardRectanglePropertiesEXT obj;
      obj.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT;
      obj.pNext = nullptr;
      obj.maxDiscardRectangles = maxDiscardRectangles;
      return obj;
   }

struct VkPipelineDiscardRectangleStateCreateInfoEXTRAII {
   VkPipelineDiscardRectangleStateCreateInfoEXT nonRaiiObj;
    std::vector<VkRect2D>                       vecDiscardRectangles;
};

std::shared_ptr<VkPipelineDiscardRectangleStateCreateInfoEXTRAII> PipelineDiscardRectangleStateCreateInfoEXT(
    VkPipelineDiscardRectangleStateCreateFlagsEXT flags,
    VkDiscardRectangleModeEXT                   discardRectangleMode,
    const std::vector<VkRect2D> &               vecDiscardRectangles)
   {
      std::shared_ptr<VkPipelineDiscardRectangleStateCreateInfoEXTRAII> raii_obj(new VkPipelineDiscardRectangleStateCreateInfoEXTRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.flags = flags;
      raii_obj->nonRaiiObj.discardRectangleMode = discardRectangleMode;
      raii_obj->nonRaiiObj.discardRectangleCount = static_cast<uint32_t>(vecDiscardRectangles.size());
      raii_obj->vecDiscardRectangles = vecDiscardRectangles;
      if ( raii_obj->vecDiscardRectangles.size() > 0)
      {
          raii_obj->nonRaiiObj.pDiscardRectangles = &raii_obj->vecDiscardRectangles[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pDiscardRectangles = nullptr;
      }
      return raii_obj;
   }

void  cmdSetDiscardRectangleEXT(
        VkCommandBuffer commandBuffer,
        uint32_t firstDiscardRectangle,
        const std::vector<VkRect2D> & pDiscardRectangles)
   {
      if ( nullptr == pfvkCmdSetDiscardRectangleEXT )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      pfvkCmdSetDiscardRectangleEXT(
          commandBuffer,
          firstDiscardRectangle,
          static_cast<uint32_t>(pDiscardRectangles.size()),
          &pDiscardRectangles[0]  );
   }

VkXYColorEXT XYColorEXT(
    float                                       x,
    float                                       y)
   {
      VkXYColorEXT obj;
      obj.x = x;
      obj.y = y;
      return obj;
   }

VkHdrMetadataEXT HdrMetadataEXT(
    VkXYColorEXT                                displayPrimaryRed,
    VkXYColorEXT                                displayPrimaryGreen,
    VkXYColorEXT                                displayPrimaryBlue,
    VkXYColorEXT                                whitePoint,
    float                                       maxLuminance,
    float                                       minLuminance,
    float                                       maxContentLightLevel,
    float                                       maxFrameAverageLightLevel)
   {
      VkHdrMetadataEXT obj;
      obj.sType = VK_STRUCTURE_TYPE_HDR_METADATA_EXT;
      obj.pNext = nullptr;
      obj.displayPrimaryRed = displayPrimaryRed;
      obj.displayPrimaryGreen = displayPrimaryGreen;
      obj.displayPrimaryBlue = displayPrimaryBlue;
      obj.whitePoint = whitePoint;
      obj.maxLuminance = maxLuminance;
      obj.minLuminance = minLuminance;
      obj.maxContentLightLevel = maxContentLightLevel;
      obj.maxFrameAverageLightLevel = maxFrameAverageLightLevel;
      return obj;
   }

void  setHdrMetadataEXT(
        VkDevice device,
        const std::vector<VkSwapchainKHR> & pSwapchains,
        const std::vector<VkHdrMetadataEXT> & pMetadata)
   {
      if ( nullptr == pfvkSetHdrMetadataEXT )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      pfvkSetHdrMetadataEXT(
          device,
          static_cast<uint32_t>(pMetadata.size()),
          &pSwapchains[0],
          &pMetadata[0]  );
   }

#ifdef VK_USE_PLATFORM_IOS_MVK
VkIOSSurfaceCreateInfoMVK IOSSurfaceCreateInfoMVK(
    VkIOSSurfaceCreateFlagsMVK                  flags)
   {
      VkIOSSurfaceCreateInfoMVK obj;
      obj.sType = VK_STRUCTURE_TYPE_MAX_ENUM;
      obj.pNext = nullptr;
      obj.flags = flags;
      obj.pView = nullptr;
      return obj;
   }

std::shared_ptr<VkSurfaceKHR_T> createIOSSurfaceMVK(
        VkInstance instance,
        const VkIOSSurfaceCreateInfoMVK & pCreateInfo)
   {
      if ( nullptr == pfvkCreateIOSSurfaceMVK )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      VkSurfaceKHR hSurface; 
      V( pfvkCreateIOSSurfaceMVK(
          instance,
          &pCreateInfo,
          nullptr,
          &hSurface  ));
      return std::shared_ptr<VkSurfaceKHR_T>(hSurface, 
              [](VkSurfaceKHR) {});
   }

#endif /* VK_USE_PLATFORM_IOS_MVK*/
#ifdef VK_USE_PLATFORM_MACOS_MVK
VkMacOSSurfaceCreateInfoMVK MacOSSurfaceCreateInfoMVK(
    VkMacOSSurfaceCreateFlagsMVK                flags)
   {
      VkMacOSSurfaceCreateInfoMVK obj;
      obj.sType = VK_STRUCTURE_TYPE_MAX_ENUM;
      obj.pNext = nullptr;
      obj.flags = flags;
      obj.pView = nullptr;
      return obj;
   }

std::shared_ptr<VkSurfaceKHR_T> createMacOSSurfaceMVK(
        VkInstance instance,
        const VkMacOSSurfaceCreateInfoMVK & pCreateInfo)
   {
      if ( nullptr == pfvkCreateMacOSSurfaceMVK )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      VkSurfaceKHR hSurface; 
      V( pfvkCreateMacOSSurfaceMVK(
          instance,
          &pCreateInfo,
          nullptr,
          &hSurface  ));
      return std::shared_ptr<VkSurfaceKHR_T>(hSurface, 
              [](VkSurfaceKHR) {});
   }

#endif /* VK_USE_PLATFORM_MACOS_MVK*/
VkSamplerReductionModeCreateInfoEXT SamplerReductionModeCreateInfoEXT(
    VkSamplerReductionModeEXT                   reductionMode)
   {
      VkSamplerReductionModeCreateInfoEXT obj;
      obj.sType = VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT;
      obj.pNext = nullptr;
      obj.reductionMode = reductionMode;
      return obj;
   }

VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT PhysicalDeviceSamplerFilterMinmaxPropertiesEXT(
    VkBool32                                    filterMinmaxSingleComponentFormats,
    VkBool32                                    filterMinmaxImageComponentMapping)
   {
      VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT obj;
      obj.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES_EXT;
      obj.pNext = nullptr;
      obj.filterMinmaxSingleComponentFormats = filterMinmaxSingleComponentFormats;
      obj.filterMinmaxImageComponentMapping = filterMinmaxImageComponentMapping;
      return obj;
   }

VkSampleLocationEXT SampleLocationEXT(
    float                                       x,
    float                                       y)
   {
      VkSampleLocationEXT obj;
      obj.x = x;
      obj.y = y;
      return obj;
   }

struct VkSampleLocationsInfoEXTRAII {
   VkSampleLocationsInfoEXT nonRaiiObj;
    std::vector<VkSampleLocationEXT>            vecSampleLocations;
};

std::shared_ptr<VkSampleLocationsInfoEXTRAII> SampleLocationsInfoEXT(
    VkSampleCountFlagBits                       sampleLocationsPerPixel,
    VkExtent2D                                  sampleLocationGridSize,
    const std::vector<VkSampleLocationEXT> &    vecSampleLocations)
   {
      std::shared_ptr<VkSampleLocationsInfoEXTRAII> raii_obj(new VkSampleLocationsInfoEXTRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.sampleLocationsPerPixel = sampleLocationsPerPixel;
      raii_obj->nonRaiiObj.sampleLocationGridSize = sampleLocationGridSize;
      raii_obj->nonRaiiObj.sampleLocationsCount = static_cast<uint32_t>(vecSampleLocations.size());
      raii_obj->vecSampleLocations = vecSampleLocations;
      if ( raii_obj->vecSampleLocations.size() > 0)
      {
          raii_obj->nonRaiiObj.pSampleLocations = &raii_obj->vecSampleLocations[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pSampleLocations = nullptr;
      }
      return raii_obj;
   }

VkAttachmentSampleLocationsEXT AttachmentSampleLocationsEXT(
    uint32_t                                    attachmentIndex,
    VkSampleLocationsInfoEXT                    sampleLocationsInfo)
   {
      VkAttachmentSampleLocationsEXT obj;
      obj.attachmentIndex = attachmentIndex;
      obj.sampleLocationsInfo = sampleLocationsInfo;
      return obj;
   }

VkSubpassSampleLocationsEXT SubpassSampleLocationsEXT(
    uint32_t                                    subpassIndex,
    VkSampleLocationsInfoEXT                    sampleLocationsInfo)
   {
      VkSubpassSampleLocationsEXT obj;
      obj.subpassIndex = subpassIndex;
      obj.sampleLocationsInfo = sampleLocationsInfo;
      return obj;
   }

struct VkRenderPassSampleLocationsBeginInfoEXTRAII {
   VkRenderPassSampleLocationsBeginInfoEXT nonRaiiObj;
    std::vector<VkAttachmentSampleLocationsEXT> vecAttachmentInitialSampleLocations;
    std::vector<VkSubpassSampleLocationsEXT>    vecPostSubpassSampleLocations;
};

std::shared_ptr<VkRenderPassSampleLocationsBeginInfoEXTRAII> RenderPassSampleLocationsBeginInfoEXT(
    const std::vector<VkAttachmentSampleLocationsEXT> &vecAttachmentInitialSampleLocations,
    const std::vector<VkSubpassSampleLocationsEXT> &vecPostSubpassSampleLocations)
   {
      std::shared_ptr<VkRenderPassSampleLocationsBeginInfoEXTRAII> raii_obj(new VkRenderPassSampleLocationsBeginInfoEXTRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.attachmentInitialSampleLocationsCount = static_cast<uint32_t>(vecAttachmentInitialSampleLocations.size());
      raii_obj->vecAttachmentInitialSampleLocations = vecAttachmentInitialSampleLocations;
      if ( raii_obj->vecAttachmentInitialSampleLocations.size() > 0)
      {
          raii_obj->nonRaiiObj.pAttachmentInitialSampleLocations = &raii_obj->vecAttachmentInitialSampleLocations[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pAttachmentInitialSampleLocations = nullptr;
      }
      raii_obj->nonRaiiObj.postSubpassSampleLocationsCount = static_cast<uint32_t>(vecPostSubpassSampleLocations.size());
      raii_obj->vecPostSubpassSampleLocations = vecPostSubpassSampleLocations;
      if ( raii_obj->vecPostSubpassSampleLocations.size() > 0)
      {
          raii_obj->nonRaiiObj.pPostSubpassSampleLocations = &raii_obj->vecPostSubpassSampleLocations[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pPostSubpassSampleLocations = nullptr;
      }
      return raii_obj;
   }

VkPipelineSampleLocationsStateCreateInfoEXT PipelineSampleLocationsStateCreateInfoEXT(
    VkBool32                                    sampleLocationsEnable,
    VkSampleLocationsInfoEXT                    sampleLocationsInfo)
   {
      VkPipelineSampleLocationsStateCreateInfoEXT obj;
      obj.sType = VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT;
      obj.pNext = nullptr;
      obj.sampleLocationsEnable = sampleLocationsEnable;
      obj.sampleLocationsInfo = sampleLocationsInfo;
      return obj;
   }

VkPhysicalDeviceSampleLocationsPropertiesEXT PhysicalDeviceSampleLocationsPropertiesEXT(
    VkSampleCountFlags                          sampleLocationSampleCounts,
    VkExtent2D                                  maxSampleLocationGridSize,
    float                                       sampleLocationCoordinateRange[2],
    uint32_t                                    sampleLocationSubPixelBits,
    VkBool32                                    variableSampleLocations)
   {
      VkPhysicalDeviceSampleLocationsPropertiesEXT obj;
      obj.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT;
      obj.pNext = nullptr;
      obj.sampleLocationSampleCounts = sampleLocationSampleCounts;
      obj.maxSampleLocationGridSize = maxSampleLocationGridSize;
      std::copy(sampleLocationCoordinateRange, sampleLocationCoordinateRange + 2, obj.sampleLocationCoordinateRange);
      obj.sampleLocationSubPixelBits = sampleLocationSubPixelBits;
      obj.variableSampleLocations = variableSampleLocations;
      return obj;
   }

VkMultisamplePropertiesEXT MultisamplePropertiesEXT(
    VkExtent2D                                  maxSampleLocationGridSize)
   {
      VkMultisamplePropertiesEXT obj;
      obj.sType = VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT;
      obj.pNext = nullptr;
      obj.maxSampleLocationGridSize = maxSampleLocationGridSize;
      return obj;
   }

void  cmdSetSampleLocationsEXT(
        VkCommandBuffer commandBuffer,
        const VkSampleLocationsInfoEXT & pSampleLocationsInfo)
   {
      if ( nullptr == pfvkCmdSetSampleLocationsEXT )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      pfvkCmdSetSampleLocationsEXT(
          commandBuffer,
          &pSampleLocationsInfo  );
   }

VkMultisamplePropertiesEXT getPhysicalDeviceMultisamplePropertiesEXT(
        VkPhysicalDevice physicalDevice,
        VkSampleCountFlagBits samples)
   {
      if ( nullptr == pfvkGetPhysicalDeviceMultisamplePropertiesEXT )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      VkMultisamplePropertiesEXT pMultisampleProperties; 
      pfvkGetPhysicalDeviceMultisamplePropertiesEXT(
          physicalDevice,
          samples,
          &pMultisampleProperties  );
      return pMultisampleProperties; 
   }

VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT PhysicalDeviceBlendOperationAdvancedFeaturesEXT(
    VkBool32                                    advancedBlendCoherentOperations)
   {
      VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT obj;
      obj.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT;
      obj.pNext = nullptr;
      obj.advancedBlendCoherentOperations = advancedBlendCoherentOperations;
      return obj;
   }

VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT PhysicalDeviceBlendOperationAdvancedPropertiesEXT(
    uint32_t                                    advancedBlendMaxColorAttachments,
    VkBool32                                    advancedBlendIndependentBlend,
    VkBool32                                    advancedBlendNonPremultipliedSrcColor,
    VkBool32                                    advancedBlendNonPremultipliedDstColor,
    VkBool32                                    advancedBlendCorrelatedOverlap,
    VkBool32                                    advancedBlendAllOperations)
   {
      VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT obj;
      obj.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT;
      obj.pNext = nullptr;
      obj.advancedBlendMaxColorAttachments = advancedBlendMaxColorAttachments;
      obj.advancedBlendIndependentBlend = advancedBlendIndependentBlend;
      obj.advancedBlendNonPremultipliedSrcColor = advancedBlendNonPremultipliedSrcColor;
      obj.advancedBlendNonPremultipliedDstColor = advancedBlendNonPremultipliedDstColor;
      obj.advancedBlendCorrelatedOverlap = advancedBlendCorrelatedOverlap;
      obj.advancedBlendAllOperations = advancedBlendAllOperations;
      return obj;
   }

VkPipelineColorBlendAdvancedStateCreateInfoEXT PipelineColorBlendAdvancedStateCreateInfoEXT(
    VkBool32                                    srcPremultiplied,
    VkBool32                                    dstPremultiplied,
    VkBlendOverlapEXT                           blendOverlap)
   {
      VkPipelineColorBlendAdvancedStateCreateInfoEXT obj;
      obj.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT;
      obj.pNext = nullptr;
      obj.srcPremultiplied = srcPremultiplied;
      obj.dstPremultiplied = dstPremultiplied;
      obj.blendOverlap = blendOverlap;
      return obj;
   }

VkPipelineCoverageToColorStateCreateInfoNV PipelineCoverageToColorStateCreateInfoNV(
    VkPipelineCoverageToColorStateCreateFlagsNV flags,
    VkBool32                                    coverageToColorEnable,
    uint32_t                                    coverageToColorLocation)
   {
      VkPipelineCoverageToColorStateCreateInfoNV obj;
      obj.sType = VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV;
      obj.pNext = nullptr;
      obj.flags = flags;
      obj.coverageToColorEnable = coverageToColorEnable;
      obj.coverageToColorLocation = coverageToColorLocation;
      return obj;
   }

struct VkPipelineCoverageModulationStateCreateInfoNVRAII {
   VkPipelineCoverageModulationStateCreateInfoNV nonRaiiObj;
    std::vector<float>                          vecCoverageModulationTable;
};

std::shared_ptr<VkPipelineCoverageModulationStateCreateInfoNVRAII> PipelineCoverageModulationStateCreateInfoNV(
    VkPipelineCoverageModulationStateCreateFlagsNV flags,
    VkCoverageModulationModeNV                  coverageModulationMode,
    VkBool32                                    coverageModulationTableEnable,
    float* pCoverageModulationTable_in_array1, int pCoverageModulationTable_dim1)
   {
      std::shared_ptr<VkPipelineCoverageModulationStateCreateInfoNVRAII> raii_obj(new VkPipelineCoverageModulationStateCreateInfoNVRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.flags = flags;
      raii_obj->nonRaiiObj.coverageModulationMode = coverageModulationMode;
      raii_obj->nonRaiiObj.coverageModulationTableEnable = coverageModulationTableEnable;
      raii_obj->nonRaiiObj.coverageModulationTableCount = static_cast<uint32_t>(pCoverageModulationTable_dim1);
      raii_obj->vecCoverageModulationTable.assign(pCoverageModulationTable_in_array1, pCoverageModulationTable_in_array1 + pCoverageModulationTable_dim1);
      if ( raii_obj->vecCoverageModulationTable.size() > 0)
      {
          raii_obj->nonRaiiObj.pCoverageModulationTable = &raii_obj->vecCoverageModulationTable[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pCoverageModulationTable = nullptr;
      }
      return raii_obj;
   }

struct VkValidationCacheCreateInfoEXTRAII {
   VkValidationCacheCreateInfoEXT nonRaiiObj;
    std::vector<uint8_t>                        vecInitialData;
};

std::shared_ptr<VkValidationCacheCreateInfoEXTRAII> ValidationCacheCreateInfoEXT(
    VkValidationCacheCreateFlagsEXT             flags,
    const std::vector<uint8_t> &                vecInitialData)
   {
      std::shared_ptr<VkValidationCacheCreateInfoEXTRAII> raii_obj(new VkValidationCacheCreateInfoEXTRAII);
      raii_obj->nonRaiiObj.sType = VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT;
      raii_obj->nonRaiiObj.pNext = nullptr;
      raii_obj->nonRaiiObj.flags = flags;
      raii_obj->nonRaiiObj.initialDataSize = static_cast<size_t>(vecInitialData.size());
      raii_obj->vecInitialData = vecInitialData;
      if ( raii_obj->vecInitialData.size() > 0)
      {
          raii_obj->nonRaiiObj.pInitialData = &raii_obj->vecInitialData[0];
      }
      else
      {
          raii_obj->nonRaiiObj.pInitialData = nullptr;
      }
      return raii_obj;
   }

VkShaderModuleValidationCacheCreateInfoEXT ShaderModuleValidationCacheCreateInfoEXT(
    VkValidationCacheEXT                        validationCache)
   {
      VkShaderModuleValidationCacheCreateInfoEXT obj;
      obj.sType = VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT;
      obj.pNext = nullptr;
      obj.validationCache = validationCache;
      return obj;
   }

std::shared_ptr<VkValidationCacheEXT_T> createValidationCacheEXT(
        VkDevice device,
        const VkValidationCacheCreateInfoEXT & pCreateInfo)
   {
      if ( nullptr == pfvkCreateValidationCacheEXT )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      VkValidationCacheEXT hValidationCache; 
      V( pfvkCreateValidationCacheEXT(
          device,
          &pCreateInfo,
          nullptr,
          &hValidationCache  ));
      return std::shared_ptr<VkValidationCacheEXT_T>(hValidationCache, 
              [=](VkValidationCacheEXT to_free) {pfvkDestroyValidationCacheEXT(device, to_free, nullptr);});
   }

void  mergeValidationCachesEXT(
        VkDevice device,
        VkValidationCacheEXT dstCache,
        const std::vector<VkValidationCacheEXT> & pSrcCaches)
   {
      if ( nullptr == pfvkMergeValidationCachesEXT )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      V( pfvkMergeValidationCachesEXT(
          device,
          dstCache,
          static_cast<uint32_t>(pSrcCaches.size()),
          &pSrcCaches[0]  ));
   }

size_t getValidationCacheDataEXT(
        VkDevice device,
        VkValidationCacheEXT validationCache)
   {
      if ( nullptr == pfvkGetValidationCacheDataEXT )
          throw std::runtime_error("Trying to use an unavailable function\n"
                                   "Review you instance create info\n"
                                   "and call load_vulkan_fct_ptrs() with the new instance");

      size_t pDataSize; 
      V( pfvkGetValidationCacheDataEXT(
          device,
          validationCache,
          &pDataSize,
          nullptr  ));
      return pDataSize; 
   }

VkDeviceQueueGlobalPriorityCreateInfoEXT DeviceQueueGlobalPriorityCreateInfoEXT(
    VkQueueGlobalPriorityEXT                    globalPriority)
   {
      VkDeviceQueueGlobalPriorityCreateInfoEXT obj;
      obj.sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT;
      obj.pNext = nullptr;
      obj.globalPriority = globalPriority;
      return obj;
   }
%}

#ifdef VK_NVX_device_generated_commands

%template (VkCmdProcessCommandsInfoNVXPtr) std::shared_ptr<VkCmdProcessCommandsInfoNVXRAII>;

#endif

#ifdef VK_KHX_multiview

%template (VkRenderPassMultiviewCreateInfoKHXPtr) std::shared_ptr<VkRenderPassMultiviewCreateInfoKHXRAII>;

#endif

#ifdef VK_KHX_device_group

%template (VkBindBufferMemoryDeviceGroupInfoKHXPtr) std::shared_ptr<VkBindBufferMemoryDeviceGroupInfoKHXRAII>;

#endif

#ifdef VK_KHR_incremental_present

%template (VkPresentRegionsKHRPtr) std::shared_ptr<VkPresentRegionsKHRRAII>;

#endif

%template (VkSparseImageMemoryBindInfoPtr) std::shared_ptr<VkSparseImageMemoryBindInfoRAII>;

#ifdef VK_KHR_external_semaphore_win32

%template (VkD3D12FenceSubmitInfoKHRPtr) std::shared_ptr<VkD3D12FenceSubmitInfoKHRRAII>;

#endif

#ifdef VK_EXT_sample_locations

%template (VkSampleLocationsInfoEXTPtr) std::shared_ptr<VkSampleLocationsInfoEXTRAII>;

#endif

%template (VkPipelineColorBlendStateCreateInfoPtr) std::shared_ptr<VkPipelineColorBlendStateCreateInfoRAII>;

#ifdef VK_NVX_device_generated_commands

%template (VkIndirectCommandsLayoutCreateInfoNVXPtr) std::shared_ptr<VkIndirectCommandsLayoutCreateInfoNVXRAII>;

#endif

%template (VkPipelineShaderStageCreateInfoPtr) std::shared_ptr<VkPipelineShaderStageCreateInfoRAII>;

%template (VkPipelineVertexInputStateCreateInfoPtr) std::shared_ptr<VkPipelineVertexInputStateCreateInfoRAII>;

%template (VkFramebufferCreateInfoPtr) std::shared_ptr<VkFramebufferCreateInfoRAII>;

%template (VkDeviceCreateInfoPtr) std::shared_ptr<VkDeviceCreateInfoRAII>;

%template (VkBindSparseInfoPtr) std::shared_ptr<VkBindSparseInfoRAII>;

%template (VkDeviceQueueCreateInfoPtr) std::shared_ptr<VkDeviceQueueCreateInfoRAII>;

%template (VkImageCreateInfoPtr) std::shared_ptr<VkImageCreateInfoRAII>;

#ifdef VK_KHR_incremental_present

%template (VkPresentRegionKHRPtr) std::shared_ptr<VkPresentRegionKHRRAII>;

#endif

#ifdef VK_EXT_debug_marker

%template (VkDebugMarkerObjectNameInfoEXTPtr) std::shared_ptr<VkDebugMarkerObjectNameInfoEXTRAII>;

#endif

%template (VkShaderModuleCreateInfoPtr) std::shared_ptr<VkShaderModuleCreateInfoRAII>;

%template (VkRenderPassCreateInfoPtr) std::shared_ptr<VkRenderPassCreateInfoRAII>;

#ifdef VK_NV_external_memory_win32

%template (VkExportMemoryWin32HandleInfoNVPtr) std::shared_ptr<VkExportMemoryWin32HandleInfoNVRAII>;

#endif

%template (VkRenderPassBeginInfoPtr) std::shared_ptr<VkRenderPassBeginInfoRAII>;

%template (VkSpecializationInfoPtr) std::shared_ptr<VkSpecializationInfoRAII>;

#ifdef VK_NVX_device_generated_commands

%template (VkObjectTableCreateInfoNVXPtr) std::shared_ptr<VkObjectTableCreateInfoNVXRAII>;

#endif

#ifdef VK_KHX_device_group_creation

%template (VkDeviceGroupDeviceCreateInfoKHXPtr) std::shared_ptr<VkDeviceGroupDeviceCreateInfoKHXRAII>;

#endif

%template (VkDescriptorSetLayoutBindingPtr) std::shared_ptr<VkDescriptorSetLayoutBindingRAII>;

%template (VkPipelineViewportStateCreateInfoPtr) std::shared_ptr<VkPipelineViewportStateCreateInfoRAII>;

%template (VkSwapchainCreateInfoKHRPtr) std::shared_ptr<VkSwapchainCreateInfoKHRRAII>;

%template (VkGraphicsPipelineCreateInfoPtr) std::shared_ptr<VkGraphicsPipelineCreateInfoRAII>;

%template (VkPipelineLayoutCreateInfoPtr) std::shared_ptr<VkPipelineLayoutCreateInfoRAII>;

#ifdef VK_NV_viewport_swizzle

%template (VkPipelineViewportSwizzleStateCreateInfoNVPtr) std::shared_ptr<VkPipelineViewportSwizzleStateCreateInfoNVRAII>;

#endif

#ifdef VK_EXT_sample_locations

%template (VkRenderPassSampleLocationsBeginInfoEXTPtr) std::shared_ptr<VkRenderPassSampleLocationsBeginInfoEXTRAII>;

#endif

%template (VkSparseBufferMemoryBindInfoPtr) std::shared_ptr<VkSparseBufferMemoryBindInfoRAII>;

%template (VkDescriptorPoolCreateInfoPtr) std::shared_ptr<VkDescriptorPoolCreateInfoRAII>;

#ifdef VK_EXT_discard_rectangles

%template (VkPipelineDiscardRectangleStateCreateInfoEXTPtr) std::shared_ptr<VkPipelineDiscardRectangleStateCreateInfoEXTRAII>;

#endif

#ifdef VK_EXT_debug_marker

%template (VkDebugMarkerObjectTagInfoEXTPtr) std::shared_ptr<VkDebugMarkerObjectTagInfoEXTRAII>;

#endif

%template (VkPipelineDynamicStateCreateInfoPtr) std::shared_ptr<VkPipelineDynamicStateCreateInfoRAII>;

#ifdef VK_KHR_maintenance2

%template (VkRenderPassInputAttachmentAspectCreateInfoKHRPtr) std::shared_ptr<VkRenderPassInputAttachmentAspectCreateInfoKHRRAII>;

#endif

#ifdef VK_KHR_win32_keyed_mutex

%template (VkWin32KeyedMutexAcquireReleaseInfoKHRPtr) std::shared_ptr<VkWin32KeyedMutexAcquireReleaseInfoKHRRAII>;

#endif

#ifdef VK_KHR_external_fence_win32

%template (VkExportFenceWin32HandleInfoKHRPtr) std::shared_ptr<VkExportFenceWin32HandleInfoKHRRAII>;

#endif

%template (VkApplicationInfoPtr) std::shared_ptr<VkApplicationInfoRAII>;

%template (VkWriteDescriptorSetPtr) std::shared_ptr<VkWriteDescriptorSetRAII>;

#ifdef VK_EXT_validation_flags

%template (VkValidationFlagsEXTPtr) std::shared_ptr<VkValidationFlagsEXTRAII>;

#endif

%template (VkPresentInfoKHRPtr) std::shared_ptr<VkPresentInfoKHRRAII>;

#ifdef VK_NV_clip_space_w_scaling

%template (VkPipelineViewportWScalingStateCreateInfoNVPtr) std::shared_ptr<VkPipelineViewportWScalingStateCreateInfoNVRAII>;

#endif

%template (VkPipelineCacheCreateInfoPtr) std::shared_ptr<VkPipelineCacheCreateInfoRAII>;

#ifdef VK_KHR_external_semaphore_win32

%template (VkExportSemaphoreWin32HandleInfoKHRPtr) std::shared_ptr<VkExportSemaphoreWin32HandleInfoKHRRAII>;

#endif

#ifdef VK_KHX_device_group

%template (VkBindImageMemoryDeviceGroupInfoKHXPtr) std::shared_ptr<VkBindImageMemoryDeviceGroupInfoKHXRAII>;

#endif

#ifdef VK_KHX_device_group

%template (VkDeviceGroupRenderPassBeginInfoKHXPtr) std::shared_ptr<VkDeviceGroupRenderPassBeginInfoKHXRAII>;

#endif

#ifdef VK_KHR_descriptor_update_template

%template (VkDescriptorUpdateTemplateCreateInfoKHRPtr) std::shared_ptr<VkDescriptorUpdateTemplateCreateInfoKHRRAII>;

#endif

%template (VkSubmitInfoPtr) std::shared_ptr<VkSubmitInfoRAII>;

#ifdef VK_NV_win32_keyed_mutex

%template (VkWin32KeyedMutexAcquireReleaseInfoNVPtr) std::shared_ptr<VkWin32KeyedMutexAcquireReleaseInfoNVRAII>;

#endif

%template (VkBufferCreateInfoPtr) std::shared_ptr<VkBufferCreateInfoRAII>;

#ifdef VK_NV_framebuffer_mixed_samples

%template (VkPipelineCoverageModulationStateCreateInfoNVPtr) std::shared_ptr<VkPipelineCoverageModulationStateCreateInfoNVRAII>;

#endif

#ifdef VK_GOOGLE_display_timing

%template (VkPresentTimesInfoGOOGLEPtr) std::shared_ptr<VkPresentTimesInfoGOOGLERAII>;

#endif

%template (VkSparseImageOpaqueMemoryBindInfoPtr) std::shared_ptr<VkSparseImageOpaqueMemoryBindInfoRAII>;

%template (VkInstanceCreateInfoPtr) std::shared_ptr<VkInstanceCreateInfoRAII>;

%template (VkDescriptorSetAllocateInfoPtr) std::shared_ptr<VkDescriptorSetAllocateInfoRAII>;

%template (VkCommandBufferBeginInfoPtr) std::shared_ptr<VkCommandBufferBeginInfoRAII>;

#ifdef VK_KHR_image_format_list

%template (VkImageFormatListCreateInfoKHRPtr) std::shared_ptr<VkImageFormatListCreateInfoKHRRAII>;

#endif

%template (VkDescriptorSetLayoutCreateInfoPtr) std::shared_ptr<VkDescriptorSetLayoutCreateInfoRAII>;

%template (VkSubpassDescriptionPtr) std::shared_ptr<VkSubpassDescriptionRAII>;

#ifdef VK_KHX_device_group

%template (VkDeviceGroupPresentInfoKHXPtr) std::shared_ptr<VkDeviceGroupPresentInfoKHXRAII>;

#endif

#ifdef VK_EXT_validation_cache

%template (VkValidationCacheCreateInfoEXTPtr) std::shared_ptr<VkValidationCacheCreateInfoEXTRAII>;

#endif

#ifdef VK_EXT_debug_marker

%template (VkDebugMarkerMarkerInfoEXTPtr) std::shared_ptr<VkDebugMarkerMarkerInfoEXTRAII>;

#endif

#ifdef VK_KHR_external_memory_win32

%template (VkExportMemoryWin32HandleInfoKHRPtr) std::shared_ptr<VkExportMemoryWin32HandleInfoKHRRAII>;

#endif

#ifdef VK_KHX_device_group

%template (VkDeviceGroupSubmitInfoKHXPtr) std::shared_ptr<VkDeviceGroupSubmitInfoKHXRAII>;

#endif

#ifdef VK_KHR_display

%template (VkDisplayPropertiesKHRPtr) std::shared_ptr<VkDisplayPropertiesKHRRAII>;

#endif

%template (VkClearAttachmentVector) std::vector<VkClearAttachment>;

%template (VkSparseImageMemoryBindInfoVector) std::vector< std::shared_ptr<VkSparseImageMemoryBindInfoRAII> >;

%template (VkPipelineShaderStageCreateInfoVector) std::vector< std::shared_ptr<VkPipelineShaderStageCreateInfoRAII> >;

%template (VkSwapchainKHRVector) std::vector<VkSwapchainKHR>;

%template (VkVertexInputBindingDescriptionVector) std::vector<VkVertexInputBindingDescription>;

%template (VkImageSubresourceRangeVector) std::vector<VkImageSubresourceRange>;

%template (VkBindSparseInfoVector) std::vector< std::shared_ptr<VkBindSparseInfoRAII> >;

%template (VkDynamicStateVector) std::vector<VkDynamicState>;

%template (VkSparseMemoryBindVector) std::vector<VkSparseMemoryBind>;

#ifdef VK_KHR_incremental_present

%template (VkPresentRegionKHRVector) std::vector< std::shared_ptr<VkPresentRegionKHRRAII> >;

#endif

%template (VkDescriptorSetLayoutBindingVector) std::vector< std::shared_ptr<VkDescriptorSetLayoutBindingRAII> >;

%template (VkLayerPropertiesVector) std::vector<VkLayerProperties>;

%template (VkValidationCheckEXTVector) std::vector<VkValidationCheckEXT>;

#ifdef VK_KHR_bind_memory2

%template (VkBindImageMemoryInfoKHRVector) std::vector<VkBindImageMemoryInfoKHR>;

#endif

%template (VkPipelineVector) std::vector<VkPipeline>;

%template (VkWriteDescriptorSetVector) std::vector< std::shared_ptr<VkWriteDescriptorSetRAII> >;

#ifdef VK_KHR_get_physical_device_properties2

%template (VkSparseImageFormatProperties2KHRVector) std::vector<VkSparseImageFormatProperties2KHR>;

#endif

%template (VkSamplerVector) std::vector<VkSampler>;

%template (VkPushConstantRangeVector) std::vector<VkPushConstantRange>;

%template (VkDeviceSizeVector) std::vector<VkDeviceSize>;

#ifdef VK_KHR_get_physical_device_properties2

%template (VkQueueFamilyProperties2KHRVector) std::vector<VkQueueFamilyProperties2KHR>;

#endif

%template (VkDescriptorSetLayoutVector) std::vector<VkDescriptorSetLayout>;

#ifdef VK_KHR_display

%template (VkDisplayPlanePropertiesKHRVector) std::vector<VkDisplayPlanePropertiesKHR>;

#endif

%template (VkDescriptorImageInfoVector) std::vector<VkDescriptorImageInfo>;

#ifdef VK_NV_viewport_swizzle

%template (VkViewportSwizzleNVVector) std::vector<VkViewportSwizzleNV>;

#endif

%template (VkBufferImageCopyVector) std::vector<VkBufferImageCopy>;

%template (VkPresentModeKHRVector) std::vector<VkPresentModeKHR>;

#ifdef VK_KHR_get_surface_capabilities2

%template (VkSurfaceFormat2KHRVector) std::vector<VkSurfaceFormat2KHR>;

#endif

%template (VkDeviceQueueCreateInfoVector) std::vector< std::shared_ptr<VkDeviceQueueCreateInfoRAII> >;

%template (VkPipelineColorBlendAttachmentStateVector) std::vector<VkPipelineColorBlendAttachmentState>;

#ifdef VK_NVX_device_generated_commands

%template (VkIndirectCommandsLayoutTokenNVXVector) std::vector<VkIndirectCommandsLayoutTokenNVX>;

#endif

#ifdef VK_NV_clip_space_w_scaling

%template (VkViewportWScalingNVVector) std::vector<VkViewportWScalingNV>;

#endif

%template (VkAttachmentReferenceVector) std::vector<VkAttachmentReference>;

%template (VkSubpassDependencyVector) std::vector<VkSubpassDependency>;

%template (VkSwapchainCreateInfoKHRVector) std::vector< std::shared_ptr<VkSwapchainCreateInfoKHRRAII> >;

%template (VkGraphicsPipelineCreateInfoVector) std::vector< std::shared_ptr<VkGraphicsPipelineCreateInfoRAII> >;

%template (VkCopyDescriptorSetVector) std::vector<VkCopyDescriptorSet>;

%template (VkClearRectVector) std::vector<VkClearRect>;

%template (VkImageMemoryBarrierVector) std::vector<VkImageMemoryBarrier>;

%template (VkDescriptorBufferInfoVector) std::vector<VkDescriptorBufferInfo>;

%template (VkComputePipelineCreateInfoVector) std::vector<VkComputePipelineCreateInfo>;

%template (floatVector) std::vector<float>;

%template (VkSubpassDescriptionVector) std::vector< std::shared_ptr<VkSubpassDescriptionRAII> >;

%template (VkMappedMemoryRangeVector) std::vector<VkMappedMemoryRange>;

%template (VkBufferCopyVector) std::vector<VkBufferCopy>;

%template (VkVertexInputAttributeDescriptionVector) std::vector<VkVertexInputAttributeDescription>;

#ifdef VK_KHR_display

%template (VkDisplayPropertiesKHRVector) std::vector< std::shared_ptr<VkDisplayPropertiesKHRRAII> >;

#endif

%template (VkObjectEntryTypeNVXVector) std::vector<VkObjectEntryTypeNVX>;

%template (VkAttachmentDescriptionVector) std::vector<VkAttachmentDescription>;

#ifdef VK_EXT_sample_locations

%template (VkAttachmentSampleLocationsEXTVector) std::vector<VkAttachmentSampleLocationsEXT>;

#endif

%template (VkMemoryBarrierVector) std::vector<VkMemoryBarrier>;

%template (VkFenceVector) std::vector<VkFence>;

%template (VkResultVector) std::vector<VkResult>;

#ifdef VK_KHR_maintenance2

%template (VkInputAttachmentAspectReferenceKHRVector) std::vector<VkInputAttachmentAspectReferenceKHR>;

#endif

%template (VkClearValueVector) std::vector<VkClearValue>;

#ifdef VK_KHX_device_group_creation

%template (VkPhysicalDeviceGroupPropertiesKHXVector) std::vector<VkPhysicalDeviceGroupPropertiesKHX>;

#endif

#ifdef VK_EXT_sample_locations

%template (VkSubpassSampleLocationsEXTVector) std::vector<VkSubpassSampleLocationsEXT>;

#endif

#ifdef VK_NVX_device_generated_commands

%template (VkIndirectCommandsTokenNVXVector) std::vector<VkIndirectCommandsTokenNVX>;

#endif

%template (VkImageViewVector) std::vector<VkImageView>;

%template (VkImageVector) std::vector<VkImage>;

%template (VkPhysicalDeviceVector) std::vector<VkPhysicalDevice>;

%template (VkSparseImageMemoryRequirementsVector) std::vector<VkSparseImageMemoryRequirements>;

%template (VkSparseImageMemoryBindVector) std::vector<VkSparseImageMemoryBind>;

%template (VkImageCopyVector) std::vector<VkImageCopy>;

%template (VkSubmitInfoVector) std::vector< std::shared_ptr<VkSubmitInfoRAII> >;

#ifdef VK_KHR_bind_memory2

%template (VkBindBufferMemoryInfoKHRVector) std::vector<VkBindBufferMemoryInfoKHR>;

#endif

%template (VkSemaphoreVector) std::vector<VkSemaphore>;

%template (VkSpecializationMapEntryVector) std::vector<VkSpecializationMapEntry>;

%template (VkFormatVector) std::vector<VkFormat>;

#ifdef VK_KHR_incremental_present

%template (VkRectLayerKHRVector) std::vector<VkRectLayerKHR>;

#endif

%template (VkSparseImageOpaqueMemoryBindInfoVector) std::vector< std::shared_ptr<VkSparseImageOpaqueMemoryBindInfoRAII> >;

%template (VkSurfaceFormatKHRVector) std::vector<VkSurfaceFormatKHR>;

%template (VkDisplayKHRVector) std::vector<VkDisplayKHR>;

%template (VkEventVector) std::vector<VkEvent>;

#ifdef VK_EXT_sample_locations

%template (VkSampleLocationEXTVector) std::vector<VkSampleLocationEXT>;

#endif

%template (VkSparseImageFormatPropertiesVector) std::vector<VkSparseImageFormatProperties>;

#ifdef VK_GOOGLE_display_timing

%template (VkPresentTimeGOOGLEVector) std::vector<VkPresentTimeGOOGLE>;

#endif

%template (VkExtensionPropertiesVector) std::vector<VkExtensionProperties>;

%template (VkDeviceMemoryVector) std::vector<VkDeviceMemory>;

%template (uint8Vector) std::vector<uint8_t>;

%template (int32Vector) std::vector<int32_t>;

%template (VkRect2DVector) std::vector<VkRect2D>;

#ifdef VK_KHR_descriptor_update_template

%template (VkDescriptorUpdateTemplateEntryKHRVector) std::vector<VkDescriptorUpdateTemplateEntryKHR>;

#endif

%template (VkBufferMemoryBarrierVector) std::vector<VkBufferMemoryBarrier>;

%template (VkPipelineCacheVector) std::vector<VkPipelineCache>;

#ifdef VK_EXT_hdr_metadata

%template (VkHdrMetadataEXTVector) std::vector<VkHdrMetadataEXT>;

#endif

%template (VkSparseBufferMemoryBindInfoVector) std::vector< std::shared_ptr<VkSparseBufferMemoryBindInfoRAII> >;

%template (VkDescriptorPoolSizeVector) std::vector<VkDescriptorPoolSize>;

%template (VkImageResolveVector) std::vector<VkImageResolve>;

%template (VkBufferViewVector) std::vector<VkBufferView>;

%template (VkValidationCacheEXTVector) std::vector<VkValidationCacheEXT>;

%template (VkImageBlitVector) std::vector<VkImageBlit>;

#ifdef VK_GOOGLE_display_timing

%template (VkPastPresentationTimingGOOGLEVector) std::vector<VkPastPresentationTimingGOOGLE>;

#endif

#ifdef VK_KHR_display

%template (VkDisplayModePropertiesKHRVector) std::vector<VkDisplayModePropertiesKHR>;

#endif

%template (VkViewportVector) std::vector<VkViewport>;

%template (VkQueueFamilyPropertiesVector) std::vector<VkQueueFamilyProperties>;

#ifdef VK_KHR_get_memory_requirements2

%template (VkSparseImageMemoryRequirements2KHRVector) std::vector<VkSparseImageMemoryRequirements2KHR>;

#endif

%template (VkBufferVector) std::vector<VkBuffer>;

%template (VkSwapchainKHRHandleVector) std::vector< std::shared_ptr< VkSwapchainKHR_T > >;

%template (VkPipelineHandleVector) std::vector< std::shared_ptr< VkPipeline_T > >;

// Skipped commands that must be manually wrapped
//vkGetInstanceProcAddr
//vkGetDeviceProcAddr
//vkMapMemory
//vkAllocateDescriptorSets
//vkAllocateCommandBuffers
//vkCmdUpdateBuffer
//vkCmdPushConstants
//vkUpdateDescriptorSetWithTemplateKHR
//vkCmdPushDescriptorSetWithTemplateKHR
//vkRegisterObjectsNVX
// End content generated by genswigi.py
